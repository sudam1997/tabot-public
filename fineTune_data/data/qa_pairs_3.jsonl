{"query": "What is the objective of agile software development methods?", "response": "The objective of agile software development methods is to produce useful software quickly.", "context": "Agile software \ndevelopment\n3 \nObjectives\nThe objective of this chapter is to introduce you to agile software \ndevelopment methods. When you have read the chapter, you will:\n\u25a0 understand the rationale for agile software development methods, \nthe agile manifesto, and the differences between agile and \nplan-driven development;\n\u25a0 know about important agile development practices such as user \nstories, refactoring, pair programming and test-first development;\n\u25a0 understand the Scrum approach to agile project management;\n\u25a0 understand the issues of scaling agile development methods and \ncombining agile approaches with plan-driven approaches in the \ndevelopment of large software systems.\nContents\n3.1  Agile methods\n3.2  Agile development techniques\n3.3  Agile project management\n3.4  Scaling agile methods\n\n\nBusinesses now operate in a global, rapidly changing environment. They have to \nrespond to new opportunities and markets, changing economic conditions and the \nemergence of competing products and services. Software is part of almost all busi-\nness operations, so new software has to be developed quickly to take advantage of \nnew opportunities and to respond to competitive pressure. Rapid software develop-\nment and delivery is therefore the most critical requirement for most business systems. \nIn fact, businesses may be willing to trade off software quality and compromise on \nrequirements if they can deploy essential new software quickly.\nBecause these businesses are operating in a changing environment, it is practi-\ncally impossible to derive a complete set of stable software requirements. \nRequirements change because customers find it impossible to predict how a system \nwill affect working practices, how it will interact with other systems, and what user \noperations should be automated. It may only be after a system has been delivered \nand users gain experience with it that the real requirements become clear. Even then, \nexternal factors drive requirements change.\nPlan-driven software development processes that completely specify the require-\nments and then design, build, and test a system are not geared to rapid software devel-\nopment. As the requirements change or as requirements problems are discovered, the \nsystem design or implementation has to be reworked and retested. As a consequence, \na conventional waterfall or specification-based process is usually a lengthy one, and \nthe final software is delivered to the customer long after it was originally specified.\nFor some types of software, such as safety-critical control systems, where a com-\nplete analysis of the system is essential, this plan-driven approach is the right one. \nHowever, in a fast-moving business environment, it can cause real problems. By the \ntime the software is available for use, the original reason for its procurement may \nhave changed so radically that the software is effectively useless. Therefore, for \nbusiness systems in particular, development processes that focus on rapid software \ndevelopment and delivery are essential.\nThe need for rapid software development and processes that can handle changing \nrequirements has been recognized for many years (Larman and Basili 2003). \nHowever, faster software development really took off in the late 1990s with the \ndevelopment of the idea of \u201cagile methods\u201d such as Extreme Programming (Beck \n1999), Scrum (Schwaber and Beedle 2001), and DSDM (Stapleton 2003).\nRapid software development became known as agile development or agile meth-\nods. These agile methods are designed to produce useful software quickly. All of the \nagile methods that have been proposed share a number of common characteristics:\n1. The processes of specification, design and implementation are interleaved. \nThere is no detailed system specification, and design documentation is mini-\nmized or generated automatically by the programming environment used to \nimplement the system. The user requirements document is an outline definition \nof the most important characteristics of the system.\n2. The system is developed in a series of increments. End-users and other system \nstakeholders are involved in specifying and evaluating each increment. \nChapter 3 \u25a0 Agile software development  73 \n\n\n74  Chapter 3 \u25a0 Agile software development\nThey\u00a0may propose changes to the software and new requirements that should be \nimplemented in a later version of the system.\n3. Extensive tool support is used to support the development process. Tools that \nmay be used include automated testing tools, tools to support configuration man-\nagement, and system integration and tools to automate user interface production.\nAgile methods are incremental development methods in which the increments are \nsmall, and, typically, new releases of the system are created and made available to \n customers every two or three weeks. They involve customers in the development \n process to get rapid feedback on changing requirements. They minimize documentation \nby using informal communications rather than formal meetings with written documents.\nAgile approaches to software development consider design and implementation \nto be the central activities in the software process. They incorporate other activities, \nsuch as requirements elicitation and testing, into design and implementation. By \ncontrast, a plan-driven approach to software engineering identifies separate stages in \nthe software process with outputs associated with each stage. The outputs from one \nstage are used as a basis for planning the following process activity.\nFigure 3.1 shows the essential distinctions between plan-driven and agile approaches \nto system specification. In a plan-driven software development process, iteration \noccurs within activities, with formal documents used to communicate between stages \nof the process. For example, the requirements will evolve, and, ultimately, a require-\nments specification will be produced. This is then an input to the design and imple-\nmentation process. In an agile approach, iteration occurs across activities. Therefore, \nthe requirements and the design are developed together rather than separately.\nIn practice, as I explain in Section 3.4.1, plan-driven processes are often used along \nwith agile programming practices, and agile methods may incorporate some planned \nRequirements\nspecification\nRequirements\nengineering\nDesign and\nimplementation\nRequirements change\nrequests\nPlan-based development\nAgile development\nRequirements\nengineering\nDesign and\nimplementation\nFigure 3.1 Plan-driven \nand agile development"}
{"query": "What are the differences between agile and plan-driven development?", "response": "Agile and plan-driven development differ in several ways. \n\nFirstly, in agile development, the processes of specification, design, and implementation are interleaved, whereas in plan-driven development, these activities are typically carried out sequentially. Agile development does not rely on a detailed system specification and minimizes design documentation, while plan-driven development emphasizes detailed specifications and documentation.\n\nSecondly, agile development involves developing the system in a series of increments, with end-users and stakeholders involved in specifying and evaluating each increment. This allows for rapid feedback and the incorporation of changes and new requirements in later versions of the system. In contrast, plan-driven development follows a more linear approach, with outputs from one stage serving as the basis for planning the next stage.\n\nThirdly, agile development relies on extensive tool support to facilitate the development process, such as automated testing tools, configuration management tools, and tools for system integration and user interface production. Plan-driven development may also use tools, but they are not as central to the process as in agile development.\n\nOverall, agile development focuses on rapid software development and delivery, with an emphasis on flexibility, adaptability, and customer involvement. Plan-driven development, on the other hand, emphasizes detailed planning, documentation, and a more sequential approach to development.", "context": "Agile software \ndevelopment\n3 \nObjectives\nThe objective of this chapter is to introduce you to agile software \ndevelopment methods. When you have read the chapter, you will:\n\u25a0 understand the rationale for agile software development methods, \nthe agile manifesto, and the differences between agile and \nplan-driven development;\n\u25a0 know about important agile development practices such as user \nstories, refactoring, pair programming and test-first development;\n\u25a0 understand the Scrum approach to agile project management;\n\u25a0 understand the issues of scaling agile development methods and \ncombining agile approaches with plan-driven approaches in the \ndevelopment of large software systems.\nContents\n3.1  Agile methods\n3.2  Agile development techniques\n3.3  Agile project management\n3.4  Scaling agile methods\n\n\nBusinesses now operate in a global, rapidly changing environment. They have to \nrespond to new opportunities and markets, changing economic conditions and the \nemergence of competing products and services. Software is part of almost all busi-\nness operations, so new software has to be developed quickly to take advantage of \nnew opportunities and to respond to competitive pressure. Rapid software develop-\nment and delivery is therefore the most critical requirement for most business systems. \nIn fact, businesses may be willing to trade off software quality and compromise on \nrequirements if they can deploy essential new software quickly.\nBecause these businesses are operating in a changing environment, it is practi-\ncally impossible to derive a complete set of stable software requirements. \nRequirements change because customers find it impossible to predict how a system \nwill affect working practices, how it will interact with other systems, and what user \noperations should be automated. It may only be after a system has been delivered \nand users gain experience with it that the real requirements become clear. Even then, \nexternal factors drive requirements change.\nPlan-driven software development processes that completely specify the require-\nments and then design, build, and test a system are not geared to rapid software devel-\nopment. As the requirements change or as requirements problems are discovered, the \nsystem design or implementation has to be reworked and retested. As a consequence, \na conventional waterfall or specification-based process is usually a lengthy one, and \nthe final software is delivered to the customer long after it was originally specified.\nFor some types of software, such as safety-critical control systems, where a com-\nplete analysis of the system is essential, this plan-driven approach is the right one. \nHowever, in a fast-moving business environment, it can cause real problems. By the \ntime the software is available for use, the original reason for its procurement may \nhave changed so radically that the software is effectively useless. Therefore, for \nbusiness systems in particular, development processes that focus on rapid software \ndevelopment and delivery are essential.\nThe need for rapid software development and processes that can handle changing \nrequirements has been recognized for many years (Larman and Basili 2003). \nHowever, faster software development really took off in the late 1990s with the \ndevelopment of the idea of \u201cagile methods\u201d such as Extreme Programming (Beck \n1999), Scrum (Schwaber and Beedle 2001), and DSDM (Stapleton 2003).\nRapid software development became known as agile development or agile meth-\nods. These agile methods are designed to produce useful software quickly. All of the \nagile methods that have been proposed share a number of common characteristics:\n1. The processes of specification, design and implementation are interleaved. \nThere is no detailed system specification, and design documentation is mini-\nmized or generated automatically by the programming environment used to \nimplement the system. The user requirements document is an outline definition \nof the most important characteristics of the system.\n2. The system is developed in a series of increments. End-users and other system \nstakeholders are involved in specifying and evaluating each increment. \nChapter 3 \u25a0 Agile software development  73 \n\n\n74  Chapter 3 \u25a0 Agile software development\nThey\u00a0may propose changes to the software and new requirements that should be \nimplemented in a later version of the system.\n3. Extensive tool support is used to support the development process. Tools that \nmay be used include automated testing tools, tools to support configuration man-\nagement, and system integration and tools to automate user interface production.\nAgile methods are incremental development methods in which the increments are \nsmall, and, typically, new releases of the system are created and made available to \n customers every two or three weeks. They involve customers in the development \n process to get rapid feedback on changing requirements. They minimize documentation \nby using informal communications rather than formal meetings with written documents.\nAgile approaches to software development consider design and implementation \nto be the central activities in the software process. They incorporate other activities, \nsuch as requirements elicitation and testing, into design and implementation. By \ncontrast, a plan-driven approach to software engineering identifies separate stages in \nthe software process with outputs associated with each stage. The outputs from one \nstage are used as a basis for planning the following process activity.\nFigure 3.1 shows the essential distinctions between plan-driven and agile approaches \nto system specification. In a plan-driven software development process, iteration \noccurs within activities, with formal documents used to communicate between stages \nof the process. For example, the requirements will evolve, and, ultimately, a require-\nments specification will be produced. This is then an input to the design and imple-\nmentation process. In an agile approach, iteration occurs across activities. Therefore, \nthe requirements and the design are developed together rather than separately.\nIn practice, as I explain in Section 3.4.1, plan-driven processes are often used along \nwith agile programming practices, and agile methods may incorporate some planned \nRequirements\nspecification\nRequirements\nengineering\nDesign and\nimplementation\nRequirements change\nrequests\nPlan-based development\nAgile development\nRequirements\nengineering\nDesign and\nimplementation\nFigure 3.1 Plan-driven \nand agile development"}
{"query": "What are some important agile development practices?", "response": "Some important agile development practices include user stories, refactoring, pair programming, and test-first development.", "context": "Agile software \ndevelopment\n3 \nObjectives\nThe objective of this chapter is to introduce you to agile software \ndevelopment methods. When you have read the chapter, you will:\n\u25a0 understand the rationale for agile software development methods, \nthe agile manifesto, and the differences between agile and \nplan-driven development;\n\u25a0 know about important agile development practices such as user \nstories, refactoring, pair programming and test-first development;\n\u25a0 understand the Scrum approach to agile project management;\n\u25a0 understand the issues of scaling agile development methods and \ncombining agile approaches with plan-driven approaches in the \ndevelopment of large software systems.\nContents\n3.1  Agile methods\n3.2  Agile development techniques\n3.3  Agile project management\n3.4  Scaling agile methods\n\n\nBusinesses now operate in a global, rapidly changing environment. They have to \nrespond to new opportunities and markets, changing economic conditions and the \nemergence of competing products and services. Software is part of almost all busi-\nness operations, so new software has to be developed quickly to take advantage of \nnew opportunities and to respond to competitive pressure. Rapid software develop-\nment and delivery is therefore the most critical requirement for most business systems. \nIn fact, businesses may be willing to trade off software quality and compromise on \nrequirements if they can deploy essential new software quickly.\nBecause these businesses are operating in a changing environment, it is practi-\ncally impossible to derive a complete set of stable software requirements. \nRequirements change because customers find it impossible to predict how a system \nwill affect working practices, how it will interact with other systems, and what user \noperations should be automated. It may only be after a system has been delivered \nand users gain experience with it that the real requirements become clear. Even then, \nexternal factors drive requirements change.\nPlan-driven software development processes that completely specify the require-\nments and then design, build, and test a system are not geared to rapid software devel-\nopment. As the requirements change or as requirements problems are discovered, the \nsystem design or implementation has to be reworked and retested. As a consequence, \na conventional waterfall or specification-based process is usually a lengthy one, and \nthe final software is delivered to the customer long after it was originally specified.\nFor some types of software, such as safety-critical control systems, where a com-\nplete analysis of the system is essential, this plan-driven approach is the right one. \nHowever, in a fast-moving business environment, it can cause real problems. By the \ntime the software is available for use, the original reason for its procurement may \nhave changed so radically that the software is effectively useless. Therefore, for \nbusiness systems in particular, development processes that focus on rapid software \ndevelopment and delivery are essential.\nThe need for rapid software development and processes that can handle changing \nrequirements has been recognized for many years (Larman and Basili 2003). \nHowever, faster software development really took off in the late 1990s with the \ndevelopment of the idea of \u201cagile methods\u201d such as Extreme Programming (Beck \n1999), Scrum (Schwaber and Beedle 2001), and DSDM (Stapleton 2003).\nRapid software development became known as agile development or agile meth-\nods. These agile methods are designed to produce useful software quickly. All of the \nagile methods that have been proposed share a number of common characteristics:\n1. The processes of specification, design and implementation are interleaved. \nThere is no detailed system specification, and design documentation is mini-\nmized or generated automatically by the programming environment used to \nimplement the system. The user requirements document is an outline definition \nof the most important characteristics of the system.\n2. The system is developed in a series of increments. End-users and other system \nstakeholders are involved in specifying and evaluating each increment. \nChapter 3 \u25a0 Agile software development  73 \n\n\n74  Chapter 3 \u25a0 Agile software development\nThey\u00a0may propose changes to the software and new requirements that should be \nimplemented in a later version of the system.\n3. Extensive tool support is used to support the development process. Tools that \nmay be used include automated testing tools, tools to support configuration man-\nagement, and system integration and tools to automate user interface production.\nAgile methods are incremental development methods in which the increments are \nsmall, and, typically, new releases of the system are created and made available to \n customers every two or three weeks. They involve customers in the development \n process to get rapid feedback on changing requirements. They minimize documentation \nby using informal communications rather than formal meetings with written documents.\nAgile approaches to software development consider design and implementation \nto be the central activities in the software process. They incorporate other activities, \nsuch as requirements elicitation and testing, into design and implementation. By \ncontrast, a plan-driven approach to software engineering identifies separate stages in \nthe software process with outputs associated with each stage. The outputs from one \nstage are used as a basis for planning the following process activity.\nFigure 3.1 shows the essential distinctions between plan-driven and agile approaches \nto system specification. In a plan-driven software development process, iteration \noccurs within activities, with formal documents used to communicate between stages \nof the process. For example, the requirements will evolve, and, ultimately, a require-\nments specification will be produced. This is then an input to the design and imple-\nmentation process. In an agile approach, iteration occurs across activities. Therefore, \nthe requirements and the design are developed together rather than separately.\nIn practice, as I explain in Section 3.4.1, plan-driven processes are often used along \nwith agile programming practices, and agile methods may incorporate some planned \nRequirements\nspecification\nRequirements\nengineering\nDesign and\nimplementation\nRequirements change\nrequests\nPlan-based development\nAgile development\nRequirements\nengineering\nDesign and\nimplementation\nFigure 3.1 Plan-driven \nand agile development"}
{"query": "What is the Scrum approach to agile project management?", "response": "The Scrum approach to agile project management is a method that focuses on iterative and incremental development. It involves breaking down the project into small, manageable tasks called \"sprints\" that typically last for a few weeks. During each sprint, a cross-functional team works together to complete the tasks and deliver a potentially shippable product increment. The team holds daily stand-up meetings to discuss progress, address any issues, and plan for the next day's work. At the end of each sprint, there is a review and retrospective to evaluate the work done and make any necessary adjustments for future sprints. Scrum emphasizes collaboration, flexibility, and continuous improvement throughout the project.", "context": "Agile software \ndevelopment\n3 \nObjectives\nThe objective of this chapter is to introduce you to agile software \ndevelopment methods. When you have read the chapter, you will:\n\u25a0 understand the rationale for agile software development methods, \nthe agile manifesto, and the differences between agile and \nplan-driven development;\n\u25a0 know about important agile development practices such as user \nstories, refactoring, pair programming and test-first development;\n\u25a0 understand the Scrum approach to agile project management;\n\u25a0 understand the issues of scaling agile development methods and \ncombining agile approaches with plan-driven approaches in the \ndevelopment of large software systems.\nContents\n3.1  Agile methods\n3.2  Agile development techniques\n3.3  Agile project management\n3.4  Scaling agile methods\n\n\nBusinesses now operate in a global, rapidly changing environment. They have to \nrespond to new opportunities and markets, changing economic conditions and the \nemergence of competing products and services. Software is part of almost all busi-\nness operations, so new software has to be developed quickly to take advantage of \nnew opportunities and to respond to competitive pressure. Rapid software develop-\nment and delivery is therefore the most critical requirement for most business systems. \nIn fact, businesses may be willing to trade off software quality and compromise on \nrequirements if they can deploy essential new software quickly.\nBecause these businesses are operating in a changing environment, it is practi-\ncally impossible to derive a complete set of stable software requirements. \nRequirements change because customers find it impossible to predict how a system \nwill affect working practices, how it will interact with other systems, and what user \noperations should be automated. It may only be after a system has been delivered \nand users gain experience with it that the real requirements become clear. Even then, \nexternal factors drive requirements change.\nPlan-driven software development processes that completely specify the require-\nments and then design, build, and test a system are not geared to rapid software devel-\nopment. As the requirements change or as requirements problems are discovered, the \nsystem design or implementation has to be reworked and retested. As a consequence, \na conventional waterfall or specification-based process is usually a lengthy one, and \nthe final software is delivered to the customer long after it was originally specified.\nFor some types of software, such as safety-critical control systems, where a com-\nplete analysis of the system is essential, this plan-driven approach is the right one. \nHowever, in a fast-moving business environment, it can cause real problems. By the \ntime the software is available for use, the original reason for its procurement may \nhave changed so radically that the software is effectively useless. Therefore, for \nbusiness systems in particular, development processes that focus on rapid software \ndevelopment and delivery are essential.\nThe need for rapid software development and processes that can handle changing \nrequirements has been recognized for many years (Larman and Basili 2003). \nHowever, faster software development really took off in the late 1990s with the \ndevelopment of the idea of \u201cagile methods\u201d such as Extreme Programming (Beck \n1999), Scrum (Schwaber and Beedle 2001), and DSDM (Stapleton 2003).\nRapid software development became known as agile development or agile meth-\nods. These agile methods are designed to produce useful software quickly. All of the \nagile methods that have been proposed share a number of common characteristics:\n1. The processes of specification, design and implementation are interleaved. \nThere is no detailed system specification, and design documentation is mini-\nmized or generated automatically by the programming environment used to \nimplement the system. The user requirements document is an outline definition \nof the most important characteristics of the system.\n2. The system is developed in a series of increments. End-users and other system \nstakeholders are involved in specifying and evaluating each increment. \nChapter 3 \u25a0 Agile software development  73 \n\n\n74  Chapter 3 \u25a0 Agile software development\nThey\u00a0may propose changes to the software and new requirements that should be \nimplemented in a later version of the system.\n3. Extensive tool support is used to support the development process. Tools that \nmay be used include automated testing tools, tools to support configuration man-\nagement, and system integration and tools to automate user interface production.\nAgile methods are incremental development methods in which the increments are \nsmall, and, typically, new releases of the system are created and made available to \n customers every two or three weeks. They involve customers in the development \n process to get rapid feedback on changing requirements. They minimize documentation \nby using informal communications rather than formal meetings with written documents.\nAgile approaches to software development consider design and implementation \nto be the central activities in the software process. They incorporate other activities, \nsuch as requirements elicitation and testing, into design and implementation. By \ncontrast, a plan-driven approach to software engineering identifies separate stages in \nthe software process with outputs associated with each stage. The outputs from one \nstage are used as a basis for planning the following process activity.\nFigure 3.1 shows the essential distinctions between plan-driven and agile approaches \nto system specification. In a plan-driven software development process, iteration \noccurs within activities, with formal documents used to communicate between stages \nof the process. For example, the requirements will evolve, and, ultimately, a require-\nments specification will be produced. This is then an input to the design and imple-\nmentation process. In an agile approach, iteration occurs across activities. Therefore, \nthe requirements and the design are developed together rather than separately.\nIn practice, as I explain in Section 3.4.1, plan-driven processes are often used along \nwith agile programming practices, and agile methods may incorporate some planned \nRequirements\nspecification\nRequirements\nengineering\nDesign and\nimplementation\nRequirements change\nrequests\nPlan-based development\nAgile development\nRequirements\nengineering\nDesign and\nimplementation\nFigure 3.1 Plan-driven \nand agile development"}
{"query": "What are the issues of scaling agile development methods?", "response": "Scaling agile development methods can present several challenges. One of the main issues is ensuring effective coordination and communication among multiple teams working on different parts of a large software system. This becomes more complex as the number of teams and the size of the system increase. Another challenge is maintaining consistency and alignment across teams, especially when they are working on interdependent components. Additionally, scaling agile methods may require adapting or customizing certain practices and processes to fit the specific needs and context of the organization. This can involve addressing cultural barriers, integrating with existing plan-driven approaches, and establishing appropriate governance structures.", "context": "Agile software \ndevelopment\n3 \nObjectives\nThe objective of this chapter is to introduce you to agile software \ndevelopment methods. When you have read the chapter, you will:\n\u25a0 understand the rationale for agile software development methods, \nthe agile manifesto, and the differences between agile and \nplan-driven development;\n\u25a0 know about important agile development practices such as user \nstories, refactoring, pair programming and test-first development;\n\u25a0 understand the Scrum approach to agile project management;\n\u25a0 understand the issues of scaling agile development methods and \ncombining agile approaches with plan-driven approaches in the \ndevelopment of large software systems.\nContents\n3.1  Agile methods\n3.2  Agile development techniques\n3.3  Agile project management\n3.4  Scaling agile methods\n\n\nBusinesses now operate in a global, rapidly changing environment. They have to \nrespond to new opportunities and markets, changing economic conditions and the \nemergence of competing products and services. Software is part of almost all busi-\nness operations, so new software has to be developed quickly to take advantage of \nnew opportunities and to respond to competitive pressure. Rapid software develop-\nment and delivery is therefore the most critical requirement for most business systems. \nIn fact, businesses may be willing to trade off software quality and compromise on \nrequirements if they can deploy essential new software quickly.\nBecause these businesses are operating in a changing environment, it is practi-\ncally impossible to derive a complete set of stable software requirements. \nRequirements change because customers find it impossible to predict how a system \nwill affect working practices, how it will interact with other systems, and what user \noperations should be automated. It may only be after a system has been delivered \nand users gain experience with it that the real requirements become clear. Even then, \nexternal factors drive requirements change.\nPlan-driven software development processes that completely specify the require-\nments and then design, build, and test a system are not geared to rapid software devel-\nopment. As the requirements change or as requirements problems are discovered, the \nsystem design or implementation has to be reworked and retested. As a consequence, \na conventional waterfall or specification-based process is usually a lengthy one, and \nthe final software is delivered to the customer long after it was originally specified.\nFor some types of software, such as safety-critical control systems, where a com-\nplete analysis of the system is essential, this plan-driven approach is the right one. \nHowever, in a fast-moving business environment, it can cause real problems. By the \ntime the software is available for use, the original reason for its procurement may \nhave changed so radically that the software is effectively useless. Therefore, for \nbusiness systems in particular, development processes that focus on rapid software \ndevelopment and delivery are essential.\nThe need for rapid software development and processes that can handle changing \nrequirements has been recognized for many years (Larman and Basili 2003). \nHowever, faster software development really took off in the late 1990s with the \ndevelopment of the idea of \u201cagile methods\u201d such as Extreme Programming (Beck \n1999), Scrum (Schwaber and Beedle 2001), and DSDM (Stapleton 2003).\nRapid software development became known as agile development or agile meth-\nods. These agile methods are designed to produce useful software quickly. All of the \nagile methods that have been proposed share a number of common characteristics:\n1. The processes of specification, design and implementation are interleaved. \nThere is no detailed system specification, and design documentation is mini-\nmized or generated automatically by the programming environment used to \nimplement the system. The user requirements document is an outline definition \nof the most important characteristics of the system.\n2. The system is developed in a series of increments. End-users and other system \nstakeholders are involved in specifying and evaluating each increment. \nChapter 3 \u25a0 Agile software development  73 \n\n\n74  Chapter 3 \u25a0 Agile software development\nThey\u00a0may propose changes to the software and new requirements that should be \nimplemented in a later version of the system.\n3. Extensive tool support is used to support the development process. Tools that \nmay be used include automated testing tools, tools to support configuration man-\nagement, and system integration and tools to automate user interface production.\nAgile methods are incremental development methods in which the increments are \nsmall, and, typically, new releases of the system are created and made available to \n customers every two or three weeks. They involve customers in the development \n process to get rapid feedback on changing requirements. They minimize documentation \nby using informal communications rather than formal meetings with written documents.\nAgile approaches to software development consider design and implementation \nto be the central activities in the software process. They incorporate other activities, \nsuch as requirements elicitation and testing, into design and implementation. By \ncontrast, a plan-driven approach to software engineering identifies separate stages in \nthe software process with outputs associated with each stage. The outputs from one \nstage are used as a basis for planning the following process activity.\nFigure 3.1 shows the essential distinctions between plan-driven and agile approaches \nto system specification. In a plan-driven software development process, iteration \noccurs within activities, with formal documents used to communicate between stages \nof the process. For example, the requirements will evolve, and, ultimately, a require-\nments specification will be produced. This is then an input to the design and imple-\nmentation process. In an agile approach, iteration occurs across activities. Therefore, \nthe requirements and the design are developed together rather than separately.\nIn practice, as I explain in Section 3.4.1, plan-driven processes are often used along \nwith agile programming practices, and agile methods may incorporate some planned \nRequirements\nspecification\nRequirements\nengineering\nDesign and\nimplementation\nRequirements change\nrequests\nPlan-based development\nAgile development\nRequirements\nengineering\nDesign and\nimplementation\nFigure 3.1 Plan-driven \nand agile development"}
{"query": "Why is rapid software development critical for most business systems?", "response": "Rapid software development is critical for most business systems because businesses operate in a global, rapidly changing environment. They need to respond quickly to new opportunities, changing economic conditions, and the emergence of competing products and services. Rapid software development allows businesses to take advantage of new opportunities and respond to competitive pressure by quickly developing and delivering new software. In fact, businesses may be willing to compromise on software quality and requirements if it means they can deploy essential new software quickly.", "context": "Agile software \ndevelopment\n3 \nObjectives\nThe objective of this chapter is to introduce you to agile software \ndevelopment methods. When you have read the chapter, you will:\n\u25a0 understand the rationale for agile software development methods, \nthe agile manifesto, and the differences between agile and \nplan-driven development;\n\u25a0 know about important agile development practices such as user \nstories, refactoring, pair programming and test-first development;\n\u25a0 understand the Scrum approach to agile project management;\n\u25a0 understand the issues of scaling agile development methods and \ncombining agile approaches with plan-driven approaches in the \ndevelopment of large software systems.\nContents\n3.1  Agile methods\n3.2  Agile development techniques\n3.3  Agile project management\n3.4  Scaling agile methods\n\n\nBusinesses now operate in a global, rapidly changing environment. They have to \nrespond to new opportunities and markets, changing economic conditions and the \nemergence of competing products and services. Software is part of almost all busi-\nness operations, so new software has to be developed quickly to take advantage of \nnew opportunities and to respond to competitive pressure. Rapid software develop-\nment and delivery is therefore the most critical requirement for most business systems. \nIn fact, businesses may be willing to trade off software quality and compromise on \nrequirements if they can deploy essential new software quickly.\nBecause these businesses are operating in a changing environment, it is practi-\ncally impossible to derive a complete set of stable software requirements. \nRequirements change because customers find it impossible to predict how a system \nwill affect working practices, how it will interact with other systems, and what user \noperations should be automated. It may only be after a system has been delivered \nand users gain experience with it that the real requirements become clear. Even then, \nexternal factors drive requirements change.\nPlan-driven software development processes that completely specify the require-\nments and then design, build, and test a system are not geared to rapid software devel-\nopment. As the requirements change or as requirements problems are discovered, the \nsystem design or implementation has to be reworked and retested. As a consequence, \na conventional waterfall or specification-based process is usually a lengthy one, and \nthe final software is delivered to the customer long after it was originally specified.\nFor some types of software, such as safety-critical control systems, where a com-\nplete analysis of the system is essential, this plan-driven approach is the right one. \nHowever, in a fast-moving business environment, it can cause real problems. By the \ntime the software is available for use, the original reason for its procurement may \nhave changed so radically that the software is effectively useless. Therefore, for \nbusiness systems in particular, development processes that focus on rapid software \ndevelopment and delivery are essential.\nThe need for rapid software development and processes that can handle changing \nrequirements has been recognized for many years (Larman and Basili 2003). \nHowever, faster software development really took off in the late 1990s with the \ndevelopment of the idea of \u201cagile methods\u201d such as Extreme Programming (Beck \n1999), Scrum (Schwaber and Beedle 2001), and DSDM (Stapleton 2003).\nRapid software development became known as agile development or agile meth-\nods. These agile methods are designed to produce useful software quickly. All of the \nagile methods that have been proposed share a number of common characteristics:\n1. The processes of specification, design and implementation are interleaved. \nThere is no detailed system specification, and design documentation is mini-\nmized or generated automatically by the programming environment used to \nimplement the system. The user requirements document is an outline definition \nof the most important characteristics of the system.\n2. The system is developed in a series of increments. End-users and other system \nstakeholders are involved in specifying and evaluating each increment. \nChapter 3 \u25a0 Agile software development  73 \n\n\n74  Chapter 3 \u25a0 Agile software development\nThey\u00a0may propose changes to the software and new requirements that should be \nimplemented in a later version of the system.\n3. Extensive tool support is used to support the development process. Tools that \nmay be used include automated testing tools, tools to support configuration man-\nagement, and system integration and tools to automate user interface production.\nAgile methods are incremental development methods in which the increments are \nsmall, and, typically, new releases of the system are created and made available to \n customers every two or three weeks. They involve customers in the development \n process to get rapid feedback on changing requirements. They minimize documentation \nby using informal communications rather than formal meetings with written documents.\nAgile approaches to software development consider design and implementation \nto be the central activities in the software process. They incorporate other activities, \nsuch as requirements elicitation and testing, into design and implementation. By \ncontrast, a plan-driven approach to software engineering identifies separate stages in \nthe software process with outputs associated with each stage. The outputs from one \nstage are used as a basis for planning the following process activity.\nFigure 3.1 shows the essential distinctions between plan-driven and agile approaches \nto system specification. In a plan-driven software development process, iteration \noccurs within activities, with formal documents used to communicate between stages \nof the process. For example, the requirements will evolve, and, ultimately, a require-\nments specification will be produced. This is then an input to the design and imple-\nmentation process. In an agile approach, iteration occurs across activities. Therefore, \nthe requirements and the design are developed together rather than separately.\nIn practice, as I explain in Section 3.4.1, plan-driven processes are often used along \nwith agile programming practices, and agile methods may incorporate some planned \nRequirements\nspecification\nRequirements\nengineering\nDesign and\nimplementation\nRequirements change\nrequests\nPlan-based development\nAgile development\nRequirements\nengineering\nDesign and\nimplementation\nFigure 3.1 Plan-driven \nand agile development"}
{"query": "Why is it practically impossible to derive a complete set of stable software requirements in a changing environment?", "response": "In a changing environment, it is practically impossible to derive a complete set of stable software requirements because customers cannot predict how a system will affect working practices, how it will interact with other systems, and what user operations should be automated. Additionally, external factors can drive requirements change even after a system has been delivered and users gain experience with it. Therefore, the dynamic nature of the environment makes it challenging to establish a fixed and stable set of software requirements.", "context": "Agile software \ndevelopment\n3 \nObjectives\nThe objective of this chapter is to introduce you to agile software \ndevelopment methods. When you have read the chapter, you will:\n\u25a0 understand the rationale for agile software development methods, \nthe agile manifesto, and the differences between agile and \nplan-driven development;\n\u25a0 know about important agile development practices such as user \nstories, refactoring, pair programming and test-first development;\n\u25a0 understand the Scrum approach to agile project management;\n\u25a0 understand the issues of scaling agile development methods and \ncombining agile approaches with plan-driven approaches in the \ndevelopment of large software systems.\nContents\n3.1  Agile methods\n3.2  Agile development techniques\n3.3  Agile project management\n3.4  Scaling agile methods\n\n\nBusinesses now operate in a global, rapidly changing environment. They have to \nrespond to new opportunities and markets, changing economic conditions and the \nemergence of competing products and services. Software is part of almost all busi-\nness operations, so new software has to be developed quickly to take advantage of \nnew opportunities and to respond to competitive pressure. Rapid software develop-\nment and delivery is therefore the most critical requirement for most business systems. \nIn fact, businesses may be willing to trade off software quality and compromise on \nrequirements if they can deploy essential new software quickly.\nBecause these businesses are operating in a changing environment, it is practi-\ncally impossible to derive a complete set of stable software requirements. \nRequirements change because customers find it impossible to predict how a system \nwill affect working practices, how it will interact with other systems, and what user \noperations should be automated. It may only be after a system has been delivered \nand users gain experience with it that the real requirements become clear. Even then, \nexternal factors drive requirements change.\nPlan-driven software development processes that completely specify the require-\nments and then design, build, and test a system are not geared to rapid software devel-\nopment. As the requirements change or as requirements problems are discovered, the \nsystem design or implementation has to be reworked and retested. As a consequence, \na conventional waterfall or specification-based process is usually a lengthy one, and \nthe final software is delivered to the customer long after it was originally specified.\nFor some types of software, such as safety-critical control systems, where a com-\nplete analysis of the system is essential, this plan-driven approach is the right one. \nHowever, in a fast-moving business environment, it can cause real problems. By the \ntime the software is available for use, the original reason for its procurement may \nhave changed so radically that the software is effectively useless. Therefore, for \nbusiness systems in particular, development processes that focus on rapid software \ndevelopment and delivery are essential.\nThe need for rapid software development and processes that can handle changing \nrequirements has been recognized for many years (Larman and Basili 2003). \nHowever, faster software development really took off in the late 1990s with the \ndevelopment of the idea of \u201cagile methods\u201d such as Extreme Programming (Beck \n1999), Scrum (Schwaber and Beedle 2001), and DSDM (Stapleton 2003).\nRapid software development became known as agile development or agile meth-\nods. These agile methods are designed to produce useful software quickly. All of the \nagile methods that have been proposed share a number of common characteristics:\n1. The processes of specification, design and implementation are interleaved. \nThere is no detailed system specification, and design documentation is mini-\nmized or generated automatically by the programming environment used to \nimplement the system. The user requirements document is an outline definition \nof the most important characteristics of the system.\n2. The system is developed in a series of increments. End-users and other system \nstakeholders are involved in specifying and evaluating each increment. \nChapter 3 \u25a0 Agile software development  73 \n\n\n74  Chapter 3 \u25a0 Agile software development\nThey\u00a0may propose changes to the software and new requirements that should be \nimplemented in a later version of the system.\n3. Extensive tool support is used to support the development process. Tools that \nmay be used include automated testing tools, tools to support configuration man-\nagement, and system integration and tools to automate user interface production.\nAgile methods are incremental development methods in which the increments are \nsmall, and, typically, new releases of the system are created and made available to \n customers every two or three weeks. They involve customers in the development \n process to get rapid feedback on changing requirements. They minimize documentation \nby using informal communications rather than formal meetings with written documents.\nAgile approaches to software development consider design and implementation \nto be the central activities in the software process. They incorporate other activities, \nsuch as requirements elicitation and testing, into design and implementation. By \ncontrast, a plan-driven approach to software engineering identifies separate stages in \nthe software process with outputs associated with each stage. The outputs from one \nstage are used as a basis for planning the following process activity.\nFigure 3.1 shows the essential distinctions between plan-driven and agile approaches \nto system specification. In a plan-driven software development process, iteration \noccurs within activities, with formal documents used to communicate between stages \nof the process. For example, the requirements will evolve, and, ultimately, a require-\nments specification will be produced. This is then an input to the design and imple-\nmentation process. In an agile approach, iteration occurs across activities. Therefore, \nthe requirements and the design are developed together rather than separately.\nIn practice, as I explain in Section 3.4.1, plan-driven processes are often used along \nwith agile programming practices, and agile methods may incorporate some planned \nRequirements\nspecification\nRequirements\nengineering\nDesign and\nimplementation\nRequirements change\nrequests\nPlan-based development\nAgile development\nRequirements\nengineering\nDesign and\nimplementation\nFigure 3.1 Plan-driven \nand agile development"}
{"query": "Why are plan-driven software development processes not suitable for rapid software development?", "response": "Plan-driven software development processes are not suitable for rapid software development because they require a complete set of stable software requirements. However, in a rapidly changing business environment, it is practically impossible to derive such a complete set of requirements. As a result, when requirements change or problems are discovered, the system design and implementation have to be reworked and retested, leading to lengthy development cycles. This makes plan-driven processes unsuitable for rapid software development where the focus is on delivering software quickly to take advantage of new opportunities and respond to competitive pressure.", "context": "Agile software \ndevelopment\n3 \nObjectives\nThe objective of this chapter is to introduce you to agile software \ndevelopment methods. When you have read the chapter, you will:\n\u25a0 understand the rationale for agile software development methods, \nthe agile manifesto, and the differences between agile and \nplan-driven development;\n\u25a0 know about important agile development practices such as user \nstories, refactoring, pair programming and test-first development;\n\u25a0 understand the Scrum approach to agile project management;\n\u25a0 understand the issues of scaling agile development methods and \ncombining agile approaches with plan-driven approaches in the \ndevelopment of large software systems.\nContents\n3.1  Agile methods\n3.2  Agile development techniques\n3.3  Agile project management\n3.4  Scaling agile methods\n\n\nBusinesses now operate in a global, rapidly changing environment. They have to \nrespond to new opportunities and markets, changing economic conditions and the \nemergence of competing products and services. Software is part of almost all busi-\nness operations, so new software has to be developed quickly to take advantage of \nnew opportunities and to respond to competitive pressure. Rapid software develop-\nment and delivery is therefore the most critical requirement for most business systems. \nIn fact, businesses may be willing to trade off software quality and compromise on \nrequirements if they can deploy essential new software quickly.\nBecause these businesses are operating in a changing environment, it is practi-\ncally impossible to derive a complete set of stable software requirements. \nRequirements change because customers find it impossible to predict how a system \nwill affect working practices, how it will interact with other systems, and what user \noperations should be automated. It may only be after a system has been delivered \nand users gain experience with it that the real requirements become clear. Even then, \nexternal factors drive requirements change.\nPlan-driven software development processes that completely specify the require-\nments and then design, build, and test a system are not geared to rapid software devel-\nopment. As the requirements change or as requirements problems are discovered, the \nsystem design or implementation has to be reworked and retested. As a consequence, \na conventional waterfall or specification-based process is usually a lengthy one, and \nthe final software is delivered to the customer long after it was originally specified.\nFor some types of software, such as safety-critical control systems, where a com-\nplete analysis of the system is essential, this plan-driven approach is the right one. \nHowever, in a fast-moving business environment, it can cause real problems. By the \ntime the software is available for use, the original reason for its procurement may \nhave changed so radically that the software is effectively useless. Therefore, for \nbusiness systems in particular, development processes that focus on rapid software \ndevelopment and delivery are essential.\nThe need for rapid software development and processes that can handle changing \nrequirements has been recognized for many years (Larman and Basili 2003). \nHowever, faster software development really took off in the late 1990s with the \ndevelopment of the idea of \u201cagile methods\u201d such as Extreme Programming (Beck \n1999), Scrum (Schwaber and Beedle 2001), and DSDM (Stapleton 2003).\nRapid software development became known as agile development or agile meth-\nods. These agile methods are designed to produce useful software quickly. All of the \nagile methods that have been proposed share a number of common characteristics:\n1. The processes of specification, design and implementation are interleaved. \nThere is no detailed system specification, and design documentation is mini-\nmized or generated automatically by the programming environment used to \nimplement the system. The user requirements document is an outline definition \nof the most important characteristics of the system.\n2. The system is developed in a series of increments. End-users and other system \nstakeholders are involved in specifying and evaluating each increment. \nChapter 3 \u25a0 Agile software development  73 \n\n\n74  Chapter 3 \u25a0 Agile software development\nThey\u00a0may propose changes to the software and new requirements that should be \nimplemented in a later version of the system.\n3. Extensive tool support is used to support the development process. Tools that \nmay be used include automated testing tools, tools to support configuration man-\nagement, and system integration and tools to automate user interface production.\nAgile methods are incremental development methods in which the increments are \nsmall, and, typically, new releases of the system are created and made available to \n customers every two or three weeks. They involve customers in the development \n process to get rapid feedback on changing requirements. They minimize documentation \nby using informal communications rather than formal meetings with written documents.\nAgile approaches to software development consider design and implementation \nto be the central activities in the software process. They incorporate other activities, \nsuch as requirements elicitation and testing, into design and implementation. By \ncontrast, a plan-driven approach to software engineering identifies separate stages in \nthe software process with outputs associated with each stage. The outputs from one \nstage are used as a basis for planning the following process activity.\nFigure 3.1 shows the essential distinctions between plan-driven and agile approaches \nto system specification. In a plan-driven software development process, iteration \noccurs within activities, with formal documents used to communicate between stages \nof the process. For example, the requirements will evolve, and, ultimately, a require-\nments specification will be produced. This is then an input to the design and imple-\nmentation process. In an agile approach, iteration occurs across activities. Therefore, \nthe requirements and the design are developed together rather than separately.\nIn practice, as I explain in Section 3.4.1, plan-driven processes are often used along \nwith agile programming practices, and agile methods may incorporate some planned \nRequirements\nspecification\nRequirements\nengineering\nDesign and\nimplementation\nRequirements change\nrequests\nPlan-based development\nAgile development\nRequirements\nengineering\nDesign and\nimplementation\nFigure 3.1 Plan-driven \nand agile development"}
{"query": "What are the problems associated with plan-driven approach in a fast-moving business environment?", "response": "The plan-driven approach in a fast-moving business environment can cause real problems. By the time the software is available for use, the original reason for its procurement may have changed so radically that the software is effectively useless. This is because plan-driven processes completely specify the requirements and then design, build, and test a system. As the requirements change or as requirements problems are discovered, the system design or implementation has to be reworked and retested. As a consequence, a conventional waterfall or specification-based process is usually lengthy, and the final software is delivered to the customer long after it was originally specified. Therefore, in a fast-moving business environment, development processes that focus on rapid software development and delivery are essential.", "context": "Agile software \ndevelopment\n3 \nObjectives\nThe objective of this chapter is to introduce you to agile software \ndevelopment methods. When you have read the chapter, you will:\n\u25a0 understand the rationale for agile software development methods, \nthe agile manifesto, and the differences between agile and \nplan-driven development;\n\u25a0 know about important agile development practices such as user \nstories, refactoring, pair programming and test-first development;\n\u25a0 understand the Scrum approach to agile project management;\n\u25a0 understand the issues of scaling agile development methods and \ncombining agile approaches with plan-driven approaches in the \ndevelopment of large software systems.\nContents\n3.1  Agile methods\n3.2  Agile development techniques\n3.3  Agile project management\n3.4  Scaling agile methods\n\n\nBusinesses now operate in a global, rapidly changing environment. They have to \nrespond to new opportunities and markets, changing economic conditions and the \nemergence of competing products and services. Software is part of almost all busi-\nness operations, so new software has to be developed quickly to take advantage of \nnew opportunities and to respond to competitive pressure. Rapid software develop-\nment and delivery is therefore the most critical requirement for most business systems. \nIn fact, businesses may be willing to trade off software quality and compromise on \nrequirements if they can deploy essential new software quickly.\nBecause these businesses are operating in a changing environment, it is practi-\ncally impossible to derive a complete set of stable software requirements. \nRequirements change because customers find it impossible to predict how a system \nwill affect working practices, how it will interact with other systems, and what user \noperations should be automated. It may only be after a system has been delivered \nand users gain experience with it that the real requirements become clear. Even then, \nexternal factors drive requirements change.\nPlan-driven software development processes that completely specify the require-\nments and then design, build, and test a system are not geared to rapid software devel-\nopment. As the requirements change or as requirements problems are discovered, the \nsystem design or implementation has to be reworked and retested. As a consequence, \na conventional waterfall or specification-based process is usually a lengthy one, and \nthe final software is delivered to the customer long after it was originally specified.\nFor some types of software, such as safety-critical control systems, where a com-\nplete analysis of the system is essential, this plan-driven approach is the right one. \nHowever, in a fast-moving business environment, it can cause real problems. By the \ntime the software is available for use, the original reason for its procurement may \nhave changed so radically that the software is effectively useless. Therefore, for \nbusiness systems in particular, development processes that focus on rapid software \ndevelopment and delivery are essential.\nThe need for rapid software development and processes that can handle changing \nrequirements has been recognized for many years (Larman and Basili 2003). \nHowever, faster software development really took off in the late 1990s with the \ndevelopment of the idea of \u201cagile methods\u201d such as Extreme Programming (Beck \n1999), Scrum (Schwaber and Beedle 2001), and DSDM (Stapleton 2003).\nRapid software development became known as agile development or agile meth-\nods. These agile methods are designed to produce useful software quickly. All of the \nagile methods that have been proposed share a number of common characteristics:\n1. The processes of specification, design and implementation are interleaved. \nThere is no detailed system specification, and design documentation is mini-\nmized or generated automatically by the programming environment used to \nimplement the system. The user requirements document is an outline definition \nof the most important characteristics of the system.\n2. The system is developed in a series of increments. End-users and other system \nstakeholders are involved in specifying and evaluating each increment. \nChapter 3 \u25a0 Agile software development  73 \n\n\n74  Chapter 3 \u25a0 Agile software development\nThey\u00a0may propose changes to the software and new requirements that should be \nimplemented in a later version of the system.\n3. Extensive tool support is used to support the development process. Tools that \nmay be used include automated testing tools, tools to support configuration man-\nagement, and system integration and tools to automate user interface production.\nAgile methods are incremental development methods in which the increments are \nsmall, and, typically, new releases of the system are created and made available to \n customers every two or three weeks. They involve customers in the development \n process to get rapid feedback on changing requirements. They minimize documentation \nby using informal communications rather than formal meetings with written documents.\nAgile approaches to software development consider design and implementation \nto be the central activities in the software process. They incorporate other activities, \nsuch as requirements elicitation and testing, into design and implementation. By \ncontrast, a plan-driven approach to software engineering identifies separate stages in \nthe software process with outputs associated with each stage. The outputs from one \nstage are used as a basis for planning the following process activity.\nFigure 3.1 shows the essential distinctions between plan-driven and agile approaches \nto system specification. In a plan-driven software development process, iteration \noccurs within activities, with formal documents used to communicate between stages \nof the process. For example, the requirements will evolve, and, ultimately, a require-\nments specification will be produced. This is then an input to the design and imple-\nmentation process. In an agile approach, iteration occurs across activities. Therefore, \nthe requirements and the design are developed together rather than separately.\nIn practice, as I explain in Section 3.4.1, plan-driven processes are often used along \nwith agile programming practices, and agile methods may incorporate some planned \nRequirements\nspecification\nRequirements\nengineering\nDesign and\nimplementation\nRequirements change\nrequests\nPlan-based development\nAgile development\nRequirements\nengineering\nDesign and\nimplementation\nFigure 3.1 Plan-driven \nand agile development"}
{"query": "What are the common characteristics of agile methods?", "response": "The common characteristics of agile methods are:\n1. The processes of specification, design, and implementation are interleaved. There is no detailed system specification, and design documentation is minimized or generated automatically by the programming environment used to implement the system.\n2. The system is developed in a series of increments. End-users and other system stakeholders are involved in specifying and evaluating each increment. They may propose changes to the software and new requirements that should be implemented in a later version of the system.\n3. Extensive tool support is used to support the development process. Tools that may be used include automated testing tools, tools to support configuration management, system integration, and tools to automate user interface production.", "context": "Agile software \ndevelopment\n3 \nObjectives\nThe objective of this chapter is to introduce you to agile software \ndevelopment methods. When you have read the chapter, you will:\n\u25a0 understand the rationale for agile software development methods, \nthe agile manifesto, and the differences between agile and \nplan-driven development;\n\u25a0 know about important agile development practices such as user \nstories, refactoring, pair programming and test-first development;\n\u25a0 understand the Scrum approach to agile project management;\n\u25a0 understand the issues of scaling agile development methods and \ncombining agile approaches with plan-driven approaches in the \ndevelopment of large software systems.\nContents\n3.1  Agile methods\n3.2  Agile development techniques\n3.3  Agile project management\n3.4  Scaling agile methods\n\n\nBusinesses now operate in a global, rapidly changing environment. They have to \nrespond to new opportunities and markets, changing economic conditions and the \nemergence of competing products and services. Software is part of almost all busi-\nness operations, so new software has to be developed quickly to take advantage of \nnew opportunities and to respond to competitive pressure. Rapid software develop-\nment and delivery is therefore the most critical requirement for most business systems. \nIn fact, businesses may be willing to trade off software quality and compromise on \nrequirements if they can deploy essential new software quickly.\nBecause these businesses are operating in a changing environment, it is practi-\ncally impossible to derive a complete set of stable software requirements. \nRequirements change because customers find it impossible to predict how a system \nwill affect working practices, how it will interact with other systems, and what user \noperations should be automated. It may only be after a system has been delivered \nand users gain experience with it that the real requirements become clear. Even then, \nexternal factors drive requirements change.\nPlan-driven software development processes that completely specify the require-\nments and then design, build, and test a system are not geared to rapid software devel-\nopment. As the requirements change or as requirements problems are discovered, the \nsystem design or implementation has to be reworked and retested. As a consequence, \na conventional waterfall or specification-based process is usually a lengthy one, and \nthe final software is delivered to the customer long after it was originally specified.\nFor some types of software, such as safety-critical control systems, where a com-\nplete analysis of the system is essential, this plan-driven approach is the right one. \nHowever, in a fast-moving business environment, it can cause real problems. By the \ntime the software is available for use, the original reason for its procurement may \nhave changed so radically that the software is effectively useless. Therefore, for \nbusiness systems in particular, development processes that focus on rapid software \ndevelopment and delivery are essential.\nThe need for rapid software development and processes that can handle changing \nrequirements has been recognized for many years (Larman and Basili 2003). \nHowever, faster software development really took off in the late 1990s with the \ndevelopment of the idea of \u201cagile methods\u201d such as Extreme Programming (Beck \n1999), Scrum (Schwaber and Beedle 2001), and DSDM (Stapleton 2003).\nRapid software development became known as agile development or agile meth-\nods. These agile methods are designed to produce useful software quickly. All of the \nagile methods that have been proposed share a number of common characteristics:\n1. The processes of specification, design and implementation are interleaved. \nThere is no detailed system specification, and design documentation is mini-\nmized or generated automatically by the programming environment used to \nimplement the system. The user requirements document is an outline definition \nof the most important characteristics of the system.\n2. The system is developed in a series of increments. End-users and other system \nstakeholders are involved in specifying and evaluating each increment. \nChapter 3 \u25a0 Agile software development  73 \n\n\n74  Chapter 3 \u25a0 Agile software development\nThey\u00a0may propose changes to the software and new requirements that should be \nimplemented in a later version of the system.\n3. Extensive tool support is used to support the development process. Tools that \nmay be used include automated testing tools, tools to support configuration man-\nagement, and system integration and tools to automate user interface production.\nAgile methods are incremental development methods in which the increments are \nsmall, and, typically, new releases of the system are created and made available to \n customers every two or three weeks. They involve customers in the development \n process to get rapid feedback on changing requirements. They minimize documentation \nby using informal communications rather than formal meetings with written documents.\nAgile approaches to software development consider design and implementation \nto be the central activities in the software process. They incorporate other activities, \nsuch as requirements elicitation and testing, into design and implementation. By \ncontrast, a plan-driven approach to software engineering identifies separate stages in \nthe software process with outputs associated with each stage. The outputs from one \nstage are used as a basis for planning the following process activity.\nFigure 3.1 shows the essential distinctions between plan-driven and agile approaches \nto system specification. In a plan-driven software development process, iteration \noccurs within activities, with formal documents used to communicate between stages \nof the process. For example, the requirements will evolve, and, ultimately, a require-\nments specification will be produced. This is then an input to the design and imple-\nmentation process. In an agile approach, iteration occurs across activities. Therefore, \nthe requirements and the design are developed together rather than separately.\nIn practice, as I explain in Section 3.4.1, plan-driven processes are often used along \nwith agile programming practices, and agile methods may incorporate some planned \nRequirements\nspecification\nRequirements\nengineering\nDesign and\nimplementation\nRequirements change\nrequests\nPlan-based development\nAgile development\nRequirements\nengineering\nDesign and\nimplementation\nFigure 3.1 Plan-driven \nand agile development"}
{"query": "How is the system developed in agile methods?", "response": "The system is developed in agile methods through a series of increments. Each increment is developed and evaluated with the involvement of end-users and other stakeholders. They may propose changes and new requirements that can be implemented in later versions of the system. Agile methods focus on producing useful software quickly, with small increments and frequent releases to customers.", "context": "Agile software \ndevelopment\n3 \nObjectives\nThe objective of this chapter is to introduce you to agile software \ndevelopment methods. When you have read the chapter, you will:\n\u25a0 understand the rationale for agile software development methods, \nthe agile manifesto, and the differences between agile and \nplan-driven development;\n\u25a0 know about important agile development practices such as user \nstories, refactoring, pair programming and test-first development;\n\u25a0 understand the Scrum approach to agile project management;\n\u25a0 understand the issues of scaling agile development methods and \ncombining agile approaches with plan-driven approaches in the \ndevelopment of large software systems.\nContents\n3.1  Agile methods\n3.2  Agile development techniques\n3.3  Agile project management\n3.4  Scaling agile methods\n\n\nBusinesses now operate in a global, rapidly changing environment. They have to \nrespond to new opportunities and markets, changing economic conditions and the \nemergence of competing products and services. Software is part of almost all busi-\nness operations, so new software has to be developed quickly to take advantage of \nnew opportunities and to respond to competitive pressure. Rapid software develop-\nment and delivery is therefore the most critical requirement for most business systems. \nIn fact, businesses may be willing to trade off software quality and compromise on \nrequirements if they can deploy essential new software quickly.\nBecause these businesses are operating in a changing environment, it is practi-\ncally impossible to derive a complete set of stable software requirements. \nRequirements change because customers find it impossible to predict how a system \nwill affect working practices, how it will interact with other systems, and what user \noperations should be automated. It may only be after a system has been delivered \nand users gain experience with it that the real requirements become clear. Even then, \nexternal factors drive requirements change.\nPlan-driven software development processes that completely specify the require-\nments and then design, build, and test a system are not geared to rapid software devel-\nopment. As the requirements change or as requirements problems are discovered, the \nsystem design or implementation has to be reworked and retested. As a consequence, \na conventional waterfall or specification-based process is usually a lengthy one, and \nthe final software is delivered to the customer long after it was originally specified.\nFor some types of software, such as safety-critical control systems, where a com-\nplete analysis of the system is essential, this plan-driven approach is the right one. \nHowever, in a fast-moving business environment, it can cause real problems. By the \ntime the software is available for use, the original reason for its procurement may \nhave changed so radically that the software is effectively useless. Therefore, for \nbusiness systems in particular, development processes that focus on rapid software \ndevelopment and delivery are essential.\nThe need for rapid software development and processes that can handle changing \nrequirements has been recognized for many years (Larman and Basili 2003). \nHowever, faster software development really took off in the late 1990s with the \ndevelopment of the idea of \u201cagile methods\u201d such as Extreme Programming (Beck \n1999), Scrum (Schwaber and Beedle 2001), and DSDM (Stapleton 2003).\nRapid software development became known as agile development or agile meth-\nods. These agile methods are designed to produce useful software quickly. All of the \nagile methods that have been proposed share a number of common characteristics:\n1. The processes of specification, design and implementation are interleaved. \nThere is no detailed system specification, and design documentation is mini-\nmized or generated automatically by the programming environment used to \nimplement the system. The user requirements document is an outline definition \nof the most important characteristics of the system.\n2. The system is developed in a series of increments. End-users and other system \nstakeholders are involved in specifying and evaluating each increment. \nChapter 3 \u25a0 Agile software development  73 \n\n\n74  Chapter 3 \u25a0 Agile software development\nThey\u00a0may propose changes to the software and new requirements that should be \nimplemented in a later version of the system.\n3. Extensive tool support is used to support the development process. Tools that \nmay be used include automated testing tools, tools to support configuration man-\nagement, and system integration and tools to automate user interface production.\nAgile methods are incremental development methods in which the increments are \nsmall, and, typically, new releases of the system are created and made available to \n customers every two or three weeks. They involve customers in the development \n process to get rapid feedback on changing requirements. They minimize documentation \nby using informal communications rather than formal meetings with written documents.\nAgile approaches to software development consider design and implementation \nto be the central activities in the software process. They incorporate other activities, \nsuch as requirements elicitation and testing, into design and implementation. By \ncontrast, a plan-driven approach to software engineering identifies separate stages in \nthe software process with outputs associated with each stage. The outputs from one \nstage are used as a basis for planning the following process activity.\nFigure 3.1 shows the essential distinctions between plan-driven and agile approaches \nto system specification. In a plan-driven software development process, iteration \noccurs within activities, with formal documents used to communicate between stages \nof the process. For example, the requirements will evolve, and, ultimately, a require-\nments specification will be produced. This is then an input to the design and imple-\nmentation process. In an agile approach, iteration occurs across activities. Therefore, \nthe requirements and the design are developed together rather than separately.\nIn practice, as I explain in Section 3.4.1, plan-driven processes are often used along \nwith agile programming practices, and agile methods may incorporate some planned \nRequirements\nspecification\nRequirements\nengineering\nDesign and\nimplementation\nRequirements change\nrequests\nPlan-based development\nAgile development\nRequirements\nengineering\nDesign and\nimplementation\nFigure 3.1 Plan-driven \nand agile development"}
{"query": "What kind of tool support is used in the agile development process?", "response": "Agile methods make use of extensive tool support to facilitate the development process. These tools can include automated testing tools, configuration management tools, system integration tools, and tools to automate user interface production.", "context": "Agile software \ndevelopment\n3 \nObjectives\nThe objective of this chapter is to introduce you to agile software \ndevelopment methods. When you have read the chapter, you will:\n\u25a0 understand the rationale for agile software development methods, \nthe agile manifesto, and the differences between agile and \nplan-driven development;\n\u25a0 know about important agile development practices such as user \nstories, refactoring, pair programming and test-first development;\n\u25a0 understand the Scrum approach to agile project management;\n\u25a0 understand the issues of scaling agile development methods and \ncombining agile approaches with plan-driven approaches in the \ndevelopment of large software systems.\nContents\n3.1  Agile methods\n3.2  Agile development techniques\n3.3  Agile project management\n3.4  Scaling agile methods\n\n\nBusinesses now operate in a global, rapidly changing environment. They have to \nrespond to new opportunities and markets, changing economic conditions and the \nemergence of competing products and services. Software is part of almost all busi-\nness operations, so new software has to be developed quickly to take advantage of \nnew opportunities and to respond to competitive pressure. Rapid software develop-\nment and delivery is therefore the most critical requirement for most business systems. \nIn fact, businesses may be willing to trade off software quality and compromise on \nrequirements if they can deploy essential new software quickly.\nBecause these businesses are operating in a changing environment, it is practi-\ncally impossible to derive a complete set of stable software requirements. \nRequirements change because customers find it impossible to predict how a system \nwill affect working practices, how it will interact with other systems, and what user \noperations should be automated. It may only be after a system has been delivered \nand users gain experience with it that the real requirements become clear. Even then, \nexternal factors drive requirements change.\nPlan-driven software development processes that completely specify the require-\nments and then design, build, and test a system are not geared to rapid software devel-\nopment. As the requirements change or as requirements problems are discovered, the \nsystem design or implementation has to be reworked and retested. As a consequence, \na conventional waterfall or specification-based process is usually a lengthy one, and \nthe final software is delivered to the customer long after it was originally specified.\nFor some types of software, such as safety-critical control systems, where a com-\nplete analysis of the system is essential, this plan-driven approach is the right one. \nHowever, in a fast-moving business environment, it can cause real problems. By the \ntime the software is available for use, the original reason for its procurement may \nhave changed so radically that the software is effectively useless. Therefore, for \nbusiness systems in particular, development processes that focus on rapid software \ndevelopment and delivery are essential.\nThe need for rapid software development and processes that can handle changing \nrequirements has been recognized for many years (Larman and Basili 2003). \nHowever, faster software development really took off in the late 1990s with the \ndevelopment of the idea of \u201cagile methods\u201d such as Extreme Programming (Beck \n1999), Scrum (Schwaber and Beedle 2001), and DSDM (Stapleton 2003).\nRapid software development became known as agile development or agile meth-\nods. These agile methods are designed to produce useful software quickly. All of the \nagile methods that have been proposed share a number of common characteristics:\n1. The processes of specification, design and implementation are interleaved. \nThere is no detailed system specification, and design documentation is mini-\nmized or generated automatically by the programming environment used to \nimplement the system. The user requirements document is an outline definition \nof the most important characteristics of the system.\n2. The system is developed in a series of increments. End-users and other system \nstakeholders are involved in specifying and evaluating each increment. \nChapter 3 \u25a0 Agile software development  73 \n\n\n74  Chapter 3 \u25a0 Agile software development\nThey\u00a0may propose changes to the software and new requirements that should be \nimplemented in a later version of the system.\n3. Extensive tool support is used to support the development process. Tools that \nmay be used include automated testing tools, tools to support configuration man-\nagement, and system integration and tools to automate user interface production.\nAgile methods are incremental development methods in which the increments are \nsmall, and, typically, new releases of the system are created and made available to \n customers every two or three weeks. They involve customers in the development \n process to get rapid feedback on changing requirements. They minimize documentation \nby using informal communications rather than formal meetings with written documents.\nAgile approaches to software development consider design and implementation \nto be the central activities in the software process. They incorporate other activities, \nsuch as requirements elicitation and testing, into design and implementation. By \ncontrast, a plan-driven approach to software engineering identifies separate stages in \nthe software process with outputs associated with each stage. The outputs from one \nstage are used as a basis for planning the following process activity.\nFigure 3.1 shows the essential distinctions between plan-driven and agile approaches \nto system specification. In a plan-driven software development process, iteration \noccurs within activities, with formal documents used to communicate between stages \nof the process. For example, the requirements will evolve, and, ultimately, a require-\nments specification will be produced. This is then an input to the design and imple-\nmentation process. In an agile approach, iteration occurs across activities. Therefore, \nthe requirements and the design are developed together rather than separately.\nIn practice, as I explain in Section 3.4.1, plan-driven processes are often used along \nwith agile programming practices, and agile methods may incorporate some planned \nRequirements\nspecification\nRequirements\nengineering\nDesign and\nimplementation\nRequirements change\nrequests\nPlan-based development\nAgile development\nRequirements\nengineering\nDesign and\nimplementation\nFigure 3.1 Plan-driven \nand agile development"}
{"query": "How often are new releases of the system created in agile methods?", "response": "New releases of the system are typically created and made available to customers every two or three weeks in agile methods.", "context": "Agile software \ndevelopment\n3 \nObjectives\nThe objective of this chapter is to introduce you to agile software \ndevelopment methods. When you have read the chapter, you will:\n\u25a0 understand the rationale for agile software development methods, \nthe agile manifesto, and the differences between agile and \nplan-driven development;\n\u25a0 know about important agile development practices such as user \nstories, refactoring, pair programming and test-first development;\n\u25a0 understand the Scrum approach to agile project management;\n\u25a0 understand the issues of scaling agile development methods and \ncombining agile approaches with plan-driven approaches in the \ndevelopment of large software systems.\nContents\n3.1  Agile methods\n3.2  Agile development techniques\n3.3  Agile project management\n3.4  Scaling agile methods\n\n\nBusinesses now operate in a global, rapidly changing environment. They have to \nrespond to new opportunities and markets, changing economic conditions and the \nemergence of competing products and services. Software is part of almost all busi-\nness operations, so new software has to be developed quickly to take advantage of \nnew opportunities and to respond to competitive pressure. Rapid software develop-\nment and delivery is therefore the most critical requirement for most business systems. \nIn fact, businesses may be willing to trade off software quality and compromise on \nrequirements if they can deploy essential new software quickly.\nBecause these businesses are operating in a changing environment, it is practi-\ncally impossible to derive a complete set of stable software requirements. \nRequirements change because customers find it impossible to predict how a system \nwill affect working practices, how it will interact with other systems, and what user \noperations should be automated. It may only be after a system has been delivered \nand users gain experience with it that the real requirements become clear. Even then, \nexternal factors drive requirements change.\nPlan-driven software development processes that completely specify the require-\nments and then design, build, and test a system are not geared to rapid software devel-\nopment. As the requirements change or as requirements problems are discovered, the \nsystem design or implementation has to be reworked and retested. As a consequence, \na conventional waterfall or specification-based process is usually a lengthy one, and \nthe final software is delivered to the customer long after it was originally specified.\nFor some types of software, such as safety-critical control systems, where a com-\nplete analysis of the system is essential, this plan-driven approach is the right one. \nHowever, in a fast-moving business environment, it can cause real problems. By the \ntime the software is available for use, the original reason for its procurement may \nhave changed so radically that the software is effectively useless. Therefore, for \nbusiness systems in particular, development processes that focus on rapid software \ndevelopment and delivery are essential.\nThe need for rapid software development and processes that can handle changing \nrequirements has been recognized for many years (Larman and Basili 2003). \nHowever, faster software development really took off in the late 1990s with the \ndevelopment of the idea of \u201cagile methods\u201d such as Extreme Programming (Beck \n1999), Scrum (Schwaber and Beedle 2001), and DSDM (Stapleton 2003).\nRapid software development became known as agile development or agile meth-\nods. These agile methods are designed to produce useful software quickly. All of the \nagile methods that have been proposed share a number of common characteristics:\n1. The processes of specification, design and implementation are interleaved. \nThere is no detailed system specification, and design documentation is mini-\nmized or generated automatically by the programming environment used to \nimplement the system. The user requirements document is an outline definition \nof the most important characteristics of the system.\n2. The system is developed in a series of increments. End-users and other system \nstakeholders are involved in specifying and evaluating each increment. \nChapter 3 \u25a0 Agile software development  73 \n\n\n74  Chapter 3 \u25a0 Agile software development\nThey\u00a0may propose changes to the software and new requirements that should be \nimplemented in a later version of the system.\n3. Extensive tool support is used to support the development process. Tools that \nmay be used include automated testing tools, tools to support configuration man-\nagement, and system integration and tools to automate user interface production.\nAgile methods are incremental development methods in which the increments are \nsmall, and, typically, new releases of the system are created and made available to \n customers every two or three weeks. They involve customers in the development \n process to get rapid feedback on changing requirements. They minimize documentation \nby using informal communications rather than formal meetings with written documents.\nAgile approaches to software development consider design and implementation \nto be the central activities in the software process. They incorporate other activities, \nsuch as requirements elicitation and testing, into design and implementation. By \ncontrast, a plan-driven approach to software engineering identifies separate stages in \nthe software process with outputs associated with each stage. The outputs from one \nstage are used as a basis for planning the following process activity.\nFigure 3.1 shows the essential distinctions between plan-driven and agile approaches \nto system specification. In a plan-driven software development process, iteration \noccurs within activities, with formal documents used to communicate between stages \nof the process. For example, the requirements will evolve, and, ultimately, a require-\nments specification will be produced. This is then an input to the design and imple-\nmentation process. In an agile approach, iteration occurs across activities. Therefore, \nthe requirements and the design are developed together rather than separately.\nIn practice, as I explain in Section 3.4.1, plan-driven processes are often used along \nwith agile programming practices, and agile methods may incorporate some planned \nRequirements\nspecification\nRequirements\nengineering\nDesign and\nimplementation\nRequirements change\nrequests\nPlan-based development\nAgile development\nRequirements\nengineering\nDesign and\nimplementation\nFigure 3.1 Plan-driven \nand agile development"}
{"query": "How do agile approaches incorporate requirements elicitation and testing into design and implementation?", "response": "Agile approaches incorporate requirements elicitation and testing into design and implementation by considering them as integral parts of the software development process. In agile methods, requirements elicitation and testing are not treated as separate activities, but rather as activities that are intertwined with design and implementation. This means that requirements are continuously refined and updated throughout the development process, and testing is performed concurrently with the development of the software. This iterative and incremental approach allows for rapid feedback and adaptation to changing requirements, ensuring that the final product meets the needs of the stakeholders.", "context": "Agile software \ndevelopment\n3 \nObjectives\nThe objective of this chapter is to introduce you to agile software \ndevelopment methods. When you have read the chapter, you will:\n\u25a0 understand the rationale for agile software development methods, \nthe agile manifesto, and the differences between agile and \nplan-driven development;\n\u25a0 know about important agile development practices such as user \nstories, refactoring, pair programming and test-first development;\n\u25a0 understand the Scrum approach to agile project management;\n\u25a0 understand the issues of scaling agile development methods and \ncombining agile approaches with plan-driven approaches in the \ndevelopment of large software systems.\nContents\n3.1  Agile methods\n3.2  Agile development techniques\n3.3  Agile project management\n3.4  Scaling agile methods\n\n\nBusinesses now operate in a global, rapidly changing environment. They have to \nrespond to new opportunities and markets, changing economic conditions and the \nemergence of competing products and services. Software is part of almost all busi-\nness operations, so new software has to be developed quickly to take advantage of \nnew opportunities and to respond to competitive pressure. Rapid software develop-\nment and delivery is therefore the most critical requirement for most business systems. \nIn fact, businesses may be willing to trade off software quality and compromise on \nrequirements if they can deploy essential new software quickly.\nBecause these businesses are operating in a changing environment, it is practi-\ncally impossible to derive a complete set of stable software requirements. \nRequirements change because customers find it impossible to predict how a system \nwill affect working practices, how it will interact with other systems, and what user \noperations should be automated. It may only be after a system has been delivered \nand users gain experience with it that the real requirements become clear. Even then, \nexternal factors drive requirements change.\nPlan-driven software development processes that completely specify the require-\nments and then design, build, and test a system are not geared to rapid software devel-\nopment. As the requirements change or as requirements problems are discovered, the \nsystem design or implementation has to be reworked and retested. As a consequence, \na conventional waterfall or specification-based process is usually a lengthy one, and \nthe final software is delivered to the customer long after it was originally specified.\nFor some types of software, such as safety-critical control systems, where a com-\nplete analysis of the system is essential, this plan-driven approach is the right one. \nHowever, in a fast-moving business environment, it can cause real problems. By the \ntime the software is available for use, the original reason for its procurement may \nhave changed so radically that the software is effectively useless. Therefore, for \nbusiness systems in particular, development processes that focus on rapid software \ndevelopment and delivery are essential.\nThe need for rapid software development and processes that can handle changing \nrequirements has been recognized for many years (Larman and Basili 2003). \nHowever, faster software development really took off in the late 1990s with the \ndevelopment of the idea of \u201cagile methods\u201d such as Extreme Programming (Beck \n1999), Scrum (Schwaber and Beedle 2001), and DSDM (Stapleton 2003).\nRapid software development became known as agile development or agile meth-\nods. These agile methods are designed to produce useful software quickly. All of the \nagile methods that have been proposed share a number of common characteristics:\n1. The processes of specification, design and implementation are interleaved. \nThere is no detailed system specification, and design documentation is mini-\nmized or generated automatically by the programming environment used to \nimplement the system. The user requirements document is an outline definition \nof the most important characteristics of the system.\n2. The system is developed in a series of increments. End-users and other system \nstakeholders are involved in specifying and evaluating each increment. \nChapter 3 \u25a0 Agile software development  73 \n\n\n74  Chapter 3 \u25a0 Agile software development\nThey\u00a0may propose changes to the software and new requirements that should be \nimplemented in a later version of the system.\n3. Extensive tool support is used to support the development process. Tools that \nmay be used include automated testing tools, tools to support configuration man-\nagement, and system integration and tools to automate user interface production.\nAgile methods are incremental development methods in which the increments are \nsmall, and, typically, new releases of the system are created and made available to \n customers every two or three weeks. They involve customers in the development \n process to get rapid feedback on changing requirements. They minimize documentation \nby using informal communications rather than formal meetings with written documents.\nAgile approaches to software development consider design and implementation \nto be the central activities in the software process. They incorporate other activities, \nsuch as requirements elicitation and testing, into design and implementation. By \ncontrast, a plan-driven approach to software engineering identifies separate stages in \nthe software process with outputs associated with each stage. The outputs from one \nstage are used as a basis for planning the following process activity.\nFigure 3.1 shows the essential distinctions between plan-driven and agile approaches \nto system specification. In a plan-driven software development process, iteration \noccurs within activities, with formal documents used to communicate between stages \nof the process. For example, the requirements will evolve, and, ultimately, a require-\nments specification will be produced. This is then an input to the design and imple-\nmentation process. In an agile approach, iteration occurs across activities. Therefore, \nthe requirements and the design are developed together rather than separately.\nIn practice, as I explain in Section 3.4.1, plan-driven processes are often used along \nwith agile programming practices, and agile methods may incorporate some planned \nRequirements\nspecification\nRequirements\nengineering\nDesign and\nimplementation\nRequirements change\nrequests\nPlan-based development\nAgile development\nRequirements\nengineering\nDesign and\nimplementation\nFigure 3.1 Plan-driven \nand agile development"}
{"query": "What are the essential distinctions between plan-driven and agile approaches to system specification?", "response": "Plan-driven approaches to system specification involve a sequential process where iteration occurs within activities. Formal documents are used to communicate between stages of the process, such as requirements specification being produced as an input to the design and implementation process. On the other hand, agile approaches to system specification involve iteration across activities. Requirements and design are developed together rather than separately. Agile methods focus on incremental development, involving customers in the development process to get rapid feedback on changing requirements. They also minimize documentation and use informal communications instead of formal meetings with written documents.", "context": "Agile software \ndevelopment\n3 \nObjectives\nThe objective of this chapter is to introduce you to agile software \ndevelopment methods. When you have read the chapter, you will:\n\u25a0 understand the rationale for agile software development methods, \nthe agile manifesto, and the differences between agile and \nplan-driven development;\n\u25a0 know about important agile development practices such as user \nstories, refactoring, pair programming and test-first development;\n\u25a0 understand the Scrum approach to agile project management;\n\u25a0 understand the issues of scaling agile development methods and \ncombining agile approaches with plan-driven approaches in the \ndevelopment of large software systems.\nContents\n3.1  Agile methods\n3.2  Agile development techniques\n3.3  Agile project management\n3.4  Scaling agile methods\n\n\nBusinesses now operate in a global, rapidly changing environment. They have to \nrespond to new opportunities and markets, changing economic conditions and the \nemergence of competing products and services. Software is part of almost all busi-\nness operations, so new software has to be developed quickly to take advantage of \nnew opportunities and to respond to competitive pressure. Rapid software develop-\nment and delivery is therefore the most critical requirement for most business systems. \nIn fact, businesses may be willing to trade off software quality and compromise on \nrequirements if they can deploy essential new software quickly.\nBecause these businesses are operating in a changing environment, it is practi-\ncally impossible to derive a complete set of stable software requirements. \nRequirements change because customers find it impossible to predict how a system \nwill affect working practices, how it will interact with other systems, and what user \noperations should be automated. It may only be after a system has been delivered \nand users gain experience with it that the real requirements become clear. Even then, \nexternal factors drive requirements change.\nPlan-driven software development processes that completely specify the require-\nments and then design, build, and test a system are not geared to rapid software devel-\nopment. As the requirements change or as requirements problems are discovered, the \nsystem design or implementation has to be reworked and retested. As a consequence, \na conventional waterfall or specification-based process is usually a lengthy one, and \nthe final software is delivered to the customer long after it was originally specified.\nFor some types of software, such as safety-critical control systems, where a com-\nplete analysis of the system is essential, this plan-driven approach is the right one. \nHowever, in a fast-moving business environment, it can cause real problems. By the \ntime the software is available for use, the original reason for its procurement may \nhave changed so radically that the software is effectively useless. Therefore, for \nbusiness systems in particular, development processes that focus on rapid software \ndevelopment and delivery are essential.\nThe need for rapid software development and processes that can handle changing \nrequirements has been recognized for many years (Larman and Basili 2003). \nHowever, faster software development really took off in the late 1990s with the \ndevelopment of the idea of \u201cagile methods\u201d such as Extreme Programming (Beck \n1999), Scrum (Schwaber and Beedle 2001), and DSDM (Stapleton 2003).\nRapid software development became known as agile development or agile meth-\nods. These agile methods are designed to produce useful software quickly. All of the \nagile methods that have been proposed share a number of common characteristics:\n1. The processes of specification, design and implementation are interleaved. \nThere is no detailed system specification, and design documentation is mini-\nmized or generated automatically by the programming environment used to \nimplement the system. The user requirements document is an outline definition \nof the most important characteristics of the system.\n2. The system is developed in a series of increments. End-users and other system \nstakeholders are involved in specifying and evaluating each increment. \nChapter 3 \u25a0 Agile software development  73 \n\n\n74  Chapter 3 \u25a0 Agile software development\nThey\u00a0may propose changes to the software and new requirements that should be \nimplemented in a later version of the system.\n3. Extensive tool support is used to support the development process. Tools that \nmay be used include automated testing tools, tools to support configuration man-\nagement, and system integration and tools to automate user interface production.\nAgile methods are incremental development methods in which the increments are \nsmall, and, typically, new releases of the system are created and made available to \n customers every two or three weeks. They involve customers in the development \n process to get rapid feedback on changing requirements. They minimize documentation \nby using informal communications rather than formal meetings with written documents.\nAgile approaches to software development consider design and implementation \nto be the central activities in the software process. They incorporate other activities, \nsuch as requirements elicitation and testing, into design and implementation. By \ncontrast, a plan-driven approach to software engineering identifies separate stages in \nthe software process with outputs associated with each stage. The outputs from one \nstage are used as a basis for planning the following process activity.\nFigure 3.1 shows the essential distinctions between plan-driven and agile approaches \nto system specification. In a plan-driven software development process, iteration \noccurs within activities, with formal documents used to communicate between stages \nof the process. For example, the requirements will evolve, and, ultimately, a require-\nments specification will be produced. This is then an input to the design and imple-\nmentation process. In an agile approach, iteration occurs across activities. Therefore, \nthe requirements and the design are developed together rather than separately.\nIn practice, as I explain in Section 3.4.1, plan-driven processes are often used along \nwith agile programming practices, and agile methods may incorporate some planned \nRequirements\nspecification\nRequirements\nengineering\nDesign and\nimplementation\nRequirements change\nrequests\nPlan-based development\nAgile development\nRequirements\nengineering\nDesign and\nimplementation\nFigure 3.1 Plan-driven \nand agile development"}
{"query": "How does iteration occur in a plan-driven software development process?", "response": "In a plan-driven software development process, iteration occurs within activities. This means that there are formal documents used to communicate between stages of the process. For example, the requirements will evolve, and ultimately a requirements specification will be produced. This specification then becomes an input to the design and implementation process.", "context": "Agile software \ndevelopment\n3 \nObjectives\nThe objective of this chapter is to introduce you to agile software \ndevelopment methods. When you have read the chapter, you will:\n\u25a0 understand the rationale for agile software development methods, \nthe agile manifesto, and the differences between agile and \nplan-driven development;\n\u25a0 know about important agile development practices such as user \nstories, refactoring, pair programming and test-first development;\n\u25a0 understand the Scrum approach to agile project management;\n\u25a0 understand the issues of scaling agile development methods and \ncombining agile approaches with plan-driven approaches in the \ndevelopment of large software systems.\nContents\n3.1  Agile methods\n3.2  Agile development techniques\n3.3  Agile project management\n3.4  Scaling agile methods\n\n\nBusinesses now operate in a global, rapidly changing environment. They have to \nrespond to new opportunities and markets, changing economic conditions and the \nemergence of competing products and services. Software is part of almost all busi-\nness operations, so new software has to be developed quickly to take advantage of \nnew opportunities and to respond to competitive pressure. Rapid software develop-\nment and delivery is therefore the most critical requirement for most business systems. \nIn fact, businesses may be willing to trade off software quality and compromise on \nrequirements if they can deploy essential new software quickly.\nBecause these businesses are operating in a changing environment, it is practi-\ncally impossible to derive a complete set of stable software requirements. \nRequirements change because customers find it impossible to predict how a system \nwill affect working practices, how it will interact with other systems, and what user \noperations should be automated. It may only be after a system has been delivered \nand users gain experience with it that the real requirements become clear. Even then, \nexternal factors drive requirements change.\nPlan-driven software development processes that completely specify the require-\nments and then design, build, and test a system are not geared to rapid software devel-\nopment. As the requirements change or as requirements problems are discovered, the \nsystem design or implementation has to be reworked and retested. As a consequence, \na conventional waterfall or specification-based process is usually a lengthy one, and \nthe final software is delivered to the customer long after it was originally specified.\nFor some types of software, such as safety-critical control systems, where a com-\nplete analysis of the system is essential, this plan-driven approach is the right one. \nHowever, in a fast-moving business environment, it can cause real problems. By the \ntime the software is available for use, the original reason for its procurement may \nhave changed so radically that the software is effectively useless. Therefore, for \nbusiness systems in particular, development processes that focus on rapid software \ndevelopment and delivery are essential.\nThe need for rapid software development and processes that can handle changing \nrequirements has been recognized for many years (Larman and Basili 2003). \nHowever, faster software development really took off in the late 1990s with the \ndevelopment of the idea of \u201cagile methods\u201d such as Extreme Programming (Beck \n1999), Scrum (Schwaber and Beedle 2001), and DSDM (Stapleton 2003).\nRapid software development became known as agile development or agile meth-\nods. These agile methods are designed to produce useful software quickly. All of the \nagile methods that have been proposed share a number of common characteristics:\n1. The processes of specification, design and implementation are interleaved. \nThere is no detailed system specification, and design documentation is mini-\nmized or generated automatically by the programming environment used to \nimplement the system. The user requirements document is an outline definition \nof the most important characteristics of the system.\n2. The system is developed in a series of increments. End-users and other system \nstakeholders are involved in specifying and evaluating each increment. \nChapter 3 \u25a0 Agile software development  73 \n\n\n74  Chapter 3 \u25a0 Agile software development\nThey\u00a0may propose changes to the software and new requirements that should be \nimplemented in a later version of the system.\n3. Extensive tool support is used to support the development process. Tools that \nmay be used include automated testing tools, tools to support configuration man-\nagement, and system integration and tools to automate user interface production.\nAgile methods are incremental development methods in which the increments are \nsmall, and, typically, new releases of the system are created and made available to \n customers every two or three weeks. They involve customers in the development \n process to get rapid feedback on changing requirements. They minimize documentation \nby using informal communications rather than formal meetings with written documents.\nAgile approaches to software development consider design and implementation \nto be the central activities in the software process. They incorporate other activities, \nsuch as requirements elicitation and testing, into design and implementation. By \ncontrast, a plan-driven approach to software engineering identifies separate stages in \nthe software process with outputs associated with each stage. The outputs from one \nstage are used as a basis for planning the following process activity.\nFigure 3.1 shows the essential distinctions between plan-driven and agile approaches \nto system specification. In a plan-driven software development process, iteration \noccurs within activities, with formal documents used to communicate between stages \nof the process. For example, the requirements will evolve, and, ultimately, a require-\nments specification will be produced. This is then an input to the design and imple-\nmentation process. In an agile approach, iteration occurs across activities. Therefore, \nthe requirements and the design are developed together rather than separately.\nIn practice, as I explain in Section 3.4.1, plan-driven processes are often used along \nwith agile programming practices, and agile methods may incorporate some planned \nRequirements\nspecification\nRequirements\nengineering\nDesign and\nimplementation\nRequirements change\nrequests\nPlan-based development\nAgile development\nRequirements\nengineering\nDesign and\nimplementation\nFigure 3.1 Plan-driven \nand agile development"}
{"query": "How does iteration occur in an agile approach?", "response": "In an agile approach, iteration occurs across activities. This means that the requirements and the design are developed together rather than separately.", "context": "Agile software \ndevelopment\n3 \nObjectives\nThe objective of this chapter is to introduce you to agile software \ndevelopment methods. When you have read the chapter, you will:\n\u25a0 understand the rationale for agile software development methods, \nthe agile manifesto, and the differences between agile and \nplan-driven development;\n\u25a0 know about important agile development practices such as user \nstories, refactoring, pair programming and test-first development;\n\u25a0 understand the Scrum approach to agile project management;\n\u25a0 understand the issues of scaling agile development methods and \ncombining agile approaches with plan-driven approaches in the \ndevelopment of large software systems.\nContents\n3.1  Agile methods\n3.2  Agile development techniques\n3.3  Agile project management\n3.4  Scaling agile methods\n\n\nBusinesses now operate in a global, rapidly changing environment. They have to \nrespond to new opportunities and markets, changing economic conditions and the \nemergence of competing products and services. Software is part of almost all busi-\nness operations, so new software has to be developed quickly to take advantage of \nnew opportunities and to respond to competitive pressure. Rapid software develop-\nment and delivery is therefore the most critical requirement for most business systems. \nIn fact, businesses may be willing to trade off software quality and compromise on \nrequirements if they can deploy essential new software quickly.\nBecause these businesses are operating in a changing environment, it is practi-\ncally impossible to derive a complete set of stable software requirements. \nRequirements change because customers find it impossible to predict how a system \nwill affect working practices, how it will interact with other systems, and what user \noperations should be automated. It may only be after a system has been delivered \nand users gain experience with it that the real requirements become clear. Even then, \nexternal factors drive requirements change.\nPlan-driven software development processes that completely specify the require-\nments and then design, build, and test a system are not geared to rapid software devel-\nopment. As the requirements change or as requirements problems are discovered, the \nsystem design or implementation has to be reworked and retested. As a consequence, \na conventional waterfall or specification-based process is usually a lengthy one, and \nthe final software is delivered to the customer long after it was originally specified.\nFor some types of software, such as safety-critical control systems, where a com-\nplete analysis of the system is essential, this plan-driven approach is the right one. \nHowever, in a fast-moving business environment, it can cause real problems. By the \ntime the software is available for use, the original reason for its procurement may \nhave changed so radically that the software is effectively useless. Therefore, for \nbusiness systems in particular, development processes that focus on rapid software \ndevelopment and delivery are essential.\nThe need for rapid software development and processes that can handle changing \nrequirements has been recognized for many years (Larman and Basili 2003). \nHowever, faster software development really took off in the late 1990s with the \ndevelopment of the idea of \u201cagile methods\u201d such as Extreme Programming (Beck \n1999), Scrum (Schwaber and Beedle 2001), and DSDM (Stapleton 2003).\nRapid software development became known as agile development or agile meth-\nods. These agile methods are designed to produce useful software quickly. All of the \nagile methods that have been proposed share a number of common characteristics:\n1. The processes of specification, design and implementation are interleaved. \nThere is no detailed system specification, and design documentation is mini-\nmized or generated automatically by the programming environment used to \nimplement the system. The user requirements document is an outline definition \nof the most important characteristics of the system.\n2. The system is developed in a series of increments. End-users and other system \nstakeholders are involved in specifying and evaluating each increment. \nChapter 3 \u25a0 Agile software development  73 \n\n\n74  Chapter 3 \u25a0 Agile software development\nThey\u00a0may propose changes to the software and new requirements that should be \nimplemented in a later version of the system.\n3. Extensive tool support is used to support the development process. Tools that \nmay be used include automated testing tools, tools to support configuration man-\nagement, and system integration and tools to automate user interface production.\nAgile methods are incremental development methods in which the increments are \nsmall, and, typically, new releases of the system are created and made available to \n customers every two or three weeks. They involve customers in the development \n process to get rapid feedback on changing requirements. They minimize documentation \nby using informal communications rather than formal meetings with written documents.\nAgile approaches to software development consider design and implementation \nto be the central activities in the software process. They incorporate other activities, \nsuch as requirements elicitation and testing, into design and implementation. By \ncontrast, a plan-driven approach to software engineering identifies separate stages in \nthe software process with outputs associated with each stage. The outputs from one \nstage are used as a basis for planning the following process activity.\nFigure 3.1 shows the essential distinctions between plan-driven and agile approaches \nto system specification. In a plan-driven software development process, iteration \noccurs within activities, with formal documents used to communicate between stages \nof the process. For example, the requirements will evolve, and, ultimately, a require-\nments specification will be produced. This is then an input to the design and imple-\nmentation process. In an agile approach, iteration occurs across activities. Therefore, \nthe requirements and the design are developed together rather than separately.\nIn practice, as I explain in Section 3.4.1, plan-driven processes are often used along \nwith agile programming practices, and agile methods may incorporate some planned \nRequirements\nspecification\nRequirements\nengineering\nDesign and\nimplementation\nRequirements change\nrequests\nPlan-based development\nAgile development\nRequirements\nengineering\nDesign and\nimplementation\nFigure 3.1 Plan-driven \nand agile development"}
{"query": "How are the requirements and the design developed in an agile approach?", "response": "In an agile approach, the requirements and the design are developed together rather than separately.", "context": "Agile software \ndevelopment\n3 \nObjectives\nThe objective of this chapter is to introduce you to agile software \ndevelopment methods. When you have read the chapter, you will:\n\u25a0 understand the rationale for agile software development methods, \nthe agile manifesto, and the differences between agile and \nplan-driven development;\n\u25a0 know about important agile development practices such as user \nstories, refactoring, pair programming and test-first development;\n\u25a0 understand the Scrum approach to agile project management;\n\u25a0 understand the issues of scaling agile development methods and \ncombining agile approaches with plan-driven approaches in the \ndevelopment of large software systems.\nContents\n3.1  Agile methods\n3.2  Agile development techniques\n3.3  Agile project management\n3.4  Scaling agile methods\n\n\nBusinesses now operate in a global, rapidly changing environment. They have to \nrespond to new opportunities and markets, changing economic conditions and the \nemergence of competing products and services. Software is part of almost all busi-\nness operations, so new software has to be developed quickly to take advantage of \nnew opportunities and to respond to competitive pressure. Rapid software develop-\nment and delivery is therefore the most critical requirement for most business systems. \nIn fact, businesses may be willing to trade off software quality and compromise on \nrequirements if they can deploy essential new software quickly.\nBecause these businesses are operating in a changing environment, it is practi-\ncally impossible to derive a complete set of stable software requirements. \nRequirements change because customers find it impossible to predict how a system \nwill affect working practices, how it will interact with other systems, and what user \noperations should be automated. It may only be after a system has been delivered \nand users gain experience with it that the real requirements become clear. Even then, \nexternal factors drive requirements change.\nPlan-driven software development processes that completely specify the require-\nments and then design, build, and test a system are not geared to rapid software devel-\nopment. As the requirements change or as requirements problems are discovered, the \nsystem design or implementation has to be reworked and retested. As a consequence, \na conventional waterfall or specification-based process is usually a lengthy one, and \nthe final software is delivered to the customer long after it was originally specified.\nFor some types of software, such as safety-critical control systems, where a com-\nplete analysis of the system is essential, this plan-driven approach is the right one. \nHowever, in a fast-moving business environment, it can cause real problems. By the \ntime the software is available for use, the original reason for its procurement may \nhave changed so radically that the software is effectively useless. Therefore, for \nbusiness systems in particular, development processes that focus on rapid software \ndevelopment and delivery are essential.\nThe need for rapid software development and processes that can handle changing \nrequirements has been recognized for many years (Larman and Basili 2003). \nHowever, faster software development really took off in the late 1990s with the \ndevelopment of the idea of \u201cagile methods\u201d such as Extreme Programming (Beck \n1999), Scrum (Schwaber and Beedle 2001), and DSDM (Stapleton 2003).\nRapid software development became known as agile development or agile meth-\nods. These agile methods are designed to produce useful software quickly. All of the \nagile methods that have been proposed share a number of common characteristics:\n1. The processes of specification, design and implementation are interleaved. \nThere is no detailed system specification, and design documentation is mini-\nmized or generated automatically by the programming environment used to \nimplement the system. The user requirements document is an outline definition \nof the most important characteristics of the system.\n2. The system is developed in a series of increments. End-users and other system \nstakeholders are involved in specifying and evaluating each increment. \nChapter 3 \u25a0 Agile software development  73 \n\n\n74  Chapter 3 \u25a0 Agile software development\nThey\u00a0may propose changes to the software and new requirements that should be \nimplemented in a later version of the system.\n3. Extensive tool support is used to support the development process. Tools that \nmay be used include automated testing tools, tools to support configuration man-\nagement, and system integration and tools to automate user interface production.\nAgile methods are incremental development methods in which the increments are \nsmall, and, typically, new releases of the system are created and made available to \n customers every two or three weeks. They involve customers in the development \n process to get rapid feedback on changing requirements. They minimize documentation \nby using informal communications rather than formal meetings with written documents.\nAgile approaches to software development consider design and implementation \nto be the central activities in the software process. They incorporate other activities, \nsuch as requirements elicitation and testing, into design and implementation. By \ncontrast, a plan-driven approach to software engineering identifies separate stages in \nthe software process with outputs associated with each stage. The outputs from one \nstage are used as a basis for planning the following process activity.\nFigure 3.1 shows the essential distinctions between plan-driven and agile approaches \nto system specification. In a plan-driven software development process, iteration \noccurs within activities, with formal documents used to communicate between stages \nof the process. For example, the requirements will evolve, and, ultimately, a require-\nments specification will be produced. This is then an input to the design and imple-\nmentation process. In an agile approach, iteration occurs across activities. Therefore, \nthe requirements and the design are developed together rather than separately.\nIn practice, as I explain in Section 3.4.1, plan-driven processes are often used along \nwith agile programming practices, and agile methods may incorporate some planned \nRequirements\nspecification\nRequirements\nengineering\nDesign and\nimplementation\nRequirements change\nrequests\nPlan-based development\nAgile development\nRequirements\nengineering\nDesign and\nimplementation\nFigure 3.1 Plan-driven \nand agile development"}
{"query": "How are plan-driven processes used along with agile programming practices?", "response": "Agile programming practices can be used in conjunction with plan-driven processes. This means that while the overall development process may follow a plan-driven approach, certain agile practices can be incorporated into specific stages or activities. For example, agile methods may be used to gather and incorporate feedback from end-users and stakeholders during the development process. Additionally, agile practices such as user stories, refactoring, pair programming, and test-first development can be utilized within the plan-driven framework to enhance the development process.", "context": "Agile software \ndevelopment\n3 \nObjectives\nThe objective of this chapter is to introduce you to agile software \ndevelopment methods. When you have read the chapter, you will:\n\u25a0 understand the rationale for agile software development methods, \nthe agile manifesto, and the differences between agile and \nplan-driven development;\n\u25a0 know about important agile development practices such as user \nstories, refactoring, pair programming and test-first development;\n\u25a0 understand the Scrum approach to agile project management;\n\u25a0 understand the issues of scaling agile development methods and \ncombining agile approaches with plan-driven approaches in the \ndevelopment of large software systems.\nContents\n3.1  Agile methods\n3.2  Agile development techniques\n3.3  Agile project management\n3.4  Scaling agile methods\n\n\nBusinesses now operate in a global, rapidly changing environment. They have to \nrespond to new opportunities and markets, changing economic conditions and the \nemergence of competing products and services. Software is part of almost all busi-\nness operations, so new software has to be developed quickly to take advantage of \nnew opportunities and to respond to competitive pressure. Rapid software develop-\nment and delivery is therefore the most critical requirement for most business systems. \nIn fact, businesses may be willing to trade off software quality and compromise on \nrequirements if they can deploy essential new software quickly.\nBecause these businesses are operating in a changing environment, it is practi-\ncally impossible to derive a complete set of stable software requirements. \nRequirements change because customers find it impossible to predict how a system \nwill affect working practices, how it will interact with other systems, and what user \noperations should be automated. It may only be after a system has been delivered \nand users gain experience with it that the real requirements become clear. Even then, \nexternal factors drive requirements change.\nPlan-driven software development processes that completely specify the require-\nments and then design, build, and test a system are not geared to rapid software devel-\nopment. As the requirements change or as requirements problems are discovered, the \nsystem design or implementation has to be reworked and retested. As a consequence, \na conventional waterfall or specification-based process is usually a lengthy one, and \nthe final software is delivered to the customer long after it was originally specified.\nFor some types of software, such as safety-critical control systems, where a com-\nplete analysis of the system is essential, this plan-driven approach is the right one. \nHowever, in a fast-moving business environment, it can cause real problems. By the \ntime the software is available for use, the original reason for its procurement may \nhave changed so radically that the software is effectively useless. Therefore, for \nbusiness systems in particular, development processes that focus on rapid software \ndevelopment and delivery are essential.\nThe need for rapid software development and processes that can handle changing \nrequirements has been recognized for many years (Larman and Basili 2003). \nHowever, faster software development really took off in the late 1990s with the \ndevelopment of the idea of \u201cagile methods\u201d such as Extreme Programming (Beck \n1999), Scrum (Schwaber and Beedle 2001), and DSDM (Stapleton 2003).\nRapid software development became known as agile development or agile meth-\nods. These agile methods are designed to produce useful software quickly. All of the \nagile methods that have been proposed share a number of common characteristics:\n1. The processes of specification, design and implementation are interleaved. \nThere is no detailed system specification, and design documentation is mini-\nmized or generated automatically by the programming environment used to \nimplement the system. The user requirements document is an outline definition \nof the most important characteristics of the system.\n2. The system is developed in a series of increments. End-users and other system \nstakeholders are involved in specifying and evaluating each increment. \nChapter 3 \u25a0 Agile software development  73 \n\n\n74  Chapter 3 \u25a0 Agile software development\nThey\u00a0may propose changes to the software and new requirements that should be \nimplemented in a later version of the system.\n3. Extensive tool support is used to support the development process. Tools that \nmay be used include automated testing tools, tools to support configuration man-\nagement, and system integration and tools to automate user interface production.\nAgile methods are incremental development methods in which the increments are \nsmall, and, typically, new releases of the system are created and made available to \n customers every two or three weeks. They involve customers in the development \n process to get rapid feedback on changing requirements. They minimize documentation \nby using informal communications rather than formal meetings with written documents.\nAgile approaches to software development consider design and implementation \nto be the central activities in the software process. They incorporate other activities, \nsuch as requirements elicitation and testing, into design and implementation. By \ncontrast, a plan-driven approach to software engineering identifies separate stages in \nthe software process with outputs associated with each stage. The outputs from one \nstage are used as a basis for planning the following process activity.\nFigure 3.1 shows the essential distinctions between plan-driven and agile approaches \nto system specification. In a plan-driven software development process, iteration \noccurs within activities, with formal documents used to communicate between stages \nof the process. For example, the requirements will evolve, and, ultimately, a require-\nments specification will be produced. This is then an input to the design and imple-\nmentation process. In an agile approach, iteration occurs across activities. Therefore, \nthe requirements and the design are developed together rather than separately.\nIn practice, as I explain in Section 3.4.1, plan-driven processes are often used along \nwith agile programming practices, and agile methods may incorporate some planned \nRequirements\nspecification\nRequirements\nengineering\nDesign and\nimplementation\nRequirements change\nrequests\nPlan-based development\nAgile development\nRequirements\nengineering\nDesign and\nimplementation\nFigure 3.1 Plan-driven \nand agile development"}
{"query": "How do agile methods incorporate some planned activities?", "response": "Agile methods incorporate some planned activities by using plan-driven processes alongside agile programming practices. This means that while agile methods prioritize rapid software development and delivery, they also recognize the need for certain planned activities such as requirements engineering and design and implementation. Agile methods may incorporate some planned activities to ensure that the development process is efficient and effective.", "context": "Agile software \ndevelopment\n3 \nObjectives\nThe objective of this chapter is to introduce you to agile software \ndevelopment methods. When you have read the chapter, you will:\n\u25a0 understand the rationale for agile software development methods, \nthe agile manifesto, and the differences between agile and \nplan-driven development;\n\u25a0 know about important agile development practices such as user \nstories, refactoring, pair programming and test-first development;\n\u25a0 understand the Scrum approach to agile project management;\n\u25a0 understand the issues of scaling agile development methods and \ncombining agile approaches with plan-driven approaches in the \ndevelopment of large software systems.\nContents\n3.1  Agile methods\n3.2  Agile development techniques\n3.3  Agile project management\n3.4  Scaling agile methods\n\n\nBusinesses now operate in a global, rapidly changing environment. They have to \nrespond to new opportunities and markets, changing economic conditions and the \nemergence of competing products and services. Software is part of almost all busi-\nness operations, so new software has to be developed quickly to take advantage of \nnew opportunities and to respond to competitive pressure. Rapid software develop-\nment and delivery is therefore the most critical requirement for most business systems. \nIn fact, businesses may be willing to trade off software quality and compromise on \nrequirements if they can deploy essential new software quickly.\nBecause these businesses are operating in a changing environment, it is practi-\ncally impossible to derive a complete set of stable software requirements. \nRequirements change because customers find it impossible to predict how a system \nwill affect working practices, how it will interact with other systems, and what user \noperations should be automated. It may only be after a system has been delivered \nand users gain experience with it that the real requirements become clear. Even then, \nexternal factors drive requirements change.\nPlan-driven software development processes that completely specify the require-\nments and then design, build, and test a system are not geared to rapid software devel-\nopment. As the requirements change or as requirements problems are discovered, the \nsystem design or implementation has to be reworked and retested. As a consequence, \na conventional waterfall or specification-based process is usually a lengthy one, and \nthe final software is delivered to the customer long after it was originally specified.\nFor some types of software, such as safety-critical control systems, where a com-\nplete analysis of the system is essential, this plan-driven approach is the right one. \nHowever, in a fast-moving business environment, it can cause real problems. By the \ntime the software is available for use, the original reason for its procurement may \nhave changed so radically that the software is effectively useless. Therefore, for \nbusiness systems in particular, development processes that focus on rapid software \ndevelopment and delivery are essential.\nThe need for rapid software development and processes that can handle changing \nrequirements has been recognized for many years (Larman and Basili 2003). \nHowever, faster software development really took off in the late 1990s with the \ndevelopment of the idea of \u201cagile methods\u201d such as Extreme Programming (Beck \n1999), Scrum (Schwaber and Beedle 2001), and DSDM (Stapleton 2003).\nRapid software development became known as agile development or agile meth-\nods. These agile methods are designed to produce useful software quickly. All of the \nagile methods that have been proposed share a number of common characteristics:\n1. The processes of specification, design and implementation are interleaved. \nThere is no detailed system specification, and design documentation is mini-\nmized or generated automatically by the programming environment used to \nimplement the system. The user requirements document is an outline definition \nof the most important characteristics of the system.\n2. The system is developed in a series of increments. End-users and other system \nstakeholders are involved in specifying and evaluating each increment. \nChapter 3 \u25a0 Agile software development  73 \n\n\n74  Chapter 3 \u25a0 Agile software development\nThey\u00a0may propose changes to the software and new requirements that should be \nimplemented in a later version of the system.\n3. Extensive tool support is used to support the development process. Tools that \nmay be used include automated testing tools, tools to support configuration man-\nagement, and system integration and tools to automate user interface production.\nAgile methods are incremental development methods in which the increments are \nsmall, and, typically, new releases of the system are created and made available to \n customers every two or three weeks. They involve customers in the development \n process to get rapid feedback on changing requirements. They minimize documentation \nby using informal communications rather than formal meetings with written documents.\nAgile approaches to software development consider design and implementation \nto be the central activities in the software process. They incorporate other activities, \nsuch as requirements elicitation and testing, into design and implementation. By \ncontrast, a plan-driven approach to software engineering identifies separate stages in \nthe software process with outputs associated with each stage. The outputs from one \nstage are used as a basis for planning the following process activity.\nFigure 3.1 shows the essential distinctions between plan-driven and agile approaches \nto system specification. In a plan-driven software development process, iteration \noccurs within activities, with formal documents used to communicate between stages \nof the process. For example, the requirements will evolve, and, ultimately, a require-\nments specification will be produced. This is then an input to the design and imple-\nmentation process. In an agile approach, iteration occurs across activities. Therefore, \nthe requirements and the design are developed together rather than separately.\nIn practice, as I explain in Section 3.4.1, plan-driven processes are often used along \nwith agile programming practices, and agile methods may incorporate some planned \nRequirements\nspecification\nRequirements\nengineering\nDesign and\nimplementation\nRequirements change\nrequests\nPlan-based development\nAgile development\nRequirements\nengineering\nDesign and\nimplementation\nFigure 3.1 Plan-driven \nand agile development"}
{"query": "How do businesses respond to new opportunities and markets, changing economic conditions and the emergence of competing products and services?", "response": "Businesses respond to new opportunities and markets, changing economic conditions, and the emergence of competing products and services by developing new software quickly. Rapid software development and delivery are considered the most critical requirement for most business systems. Businesses may be willing to compromise on software quality and requirements in order to deploy essential new software quickly.", "context": "Agile software \ndevelopment\n3 \nObjectives\nThe objective of this chapter is to introduce you to agile software \ndevelopment methods. When you have read the chapter, you will:\n\u25a0 understand the rationale for agile software development methods, \nthe agile manifesto, and the differences between agile and \nplan-driven development;\n\u25a0 know about important agile development practices such as user \nstories, refactoring, pair programming and test-first development;\n\u25a0 understand the Scrum approach to agile project management;\n\u25a0 understand the issues of scaling agile development methods and \ncombining agile approaches with plan-driven approaches in the \ndevelopment of large software systems.\nContents\n3.1  Agile methods\n3.2  Agile development techniques\n3.3  Agile project management\n3.4  Scaling agile methods\n\n\nBusinesses now operate in a global, rapidly changing environment. They have to \nrespond to new opportunities and markets, changing economic conditions and the \nemergence of competing products and services. Software is part of almost all busi-\nness operations, so new software has to be developed quickly to take advantage of \nnew opportunities and to respond to competitive pressure. Rapid software develop-\nment and delivery is therefore the most critical requirement for most business systems. \nIn fact, businesses may be willing to trade off software quality and compromise on \nrequirements if they can deploy essential new software quickly.\nBecause these businesses are operating in a changing environment, it is practi-\ncally impossible to derive a complete set of stable software requirements. \nRequirements change because customers find it impossible to predict how a system \nwill affect working practices, how it will interact with other systems, and what user \noperations should be automated. It may only be after a system has been delivered \nand users gain experience with it that the real requirements become clear. Even then, \nexternal factors drive requirements change.\nPlan-driven software development processes that completely specify the require-\nments and then design, build, and test a system are not geared to rapid software devel-\nopment. As the requirements change or as requirements problems are discovered, the \nsystem design or implementation has to be reworked and retested. As a consequence, \na conventional waterfall or specification-based process is usually a lengthy one, and \nthe final software is delivered to the customer long after it was originally specified.\nFor some types of software, such as safety-critical control systems, where a com-\nplete analysis of the system is essential, this plan-driven approach is the right one. \nHowever, in a fast-moving business environment, it can cause real problems. By the \ntime the software is available for use, the original reason for its procurement may \nhave changed so radically that the software is effectively useless. Therefore, for \nbusiness systems in particular, development processes that focus on rapid software \ndevelopment and delivery are essential.\nThe need for rapid software development and processes that can handle changing \nrequirements has been recognized for many years (Larman and Basili 2003). \nHowever, faster software development really took off in the late 1990s with the \ndevelopment of the idea of \u201cagile methods\u201d such as Extreme Programming (Beck \n1999), Scrum (Schwaber and Beedle 2001), and DSDM (Stapleton 2003).\nRapid software development became known as agile development or agile meth-\nods. These agile methods are designed to produce useful software quickly. All of the \nagile methods that have been proposed share a number of common characteristics:\n1. The processes of specification, design and implementation are interleaved. \nThere is no detailed system specification, and design documentation is mini-\nmized or generated automatically by the programming environment used to \nimplement the system. The user requirements document is an outline definition \nof the most important characteristics of the system.\n2. The system is developed in a series of increments. End-users and other system \nstakeholders are involved in specifying and evaluating each increment. \nChapter 3 \u25a0 Agile software development  73 \n\n\n74  Chapter 3 \u25a0 Agile software development\nThey\u00a0may propose changes to the software and new requirements that should be \nimplemented in a later version of the system.\n3. Extensive tool support is used to support the development process. Tools that \nmay be used include automated testing tools, tools to support configuration man-\nagement, and system integration and tools to automate user interface production.\nAgile methods are incremental development methods in which the increments are \nsmall, and, typically, new releases of the system are created and made available to \n customers every two or three weeks. They involve customers in the development \n process to get rapid feedback on changing requirements. They minimize documentation \nby using informal communications rather than formal meetings with written documents.\nAgile approaches to software development consider design and implementation \nto be the central activities in the software process. They incorporate other activities, \nsuch as requirements elicitation and testing, into design and implementation. By \ncontrast, a plan-driven approach to software engineering identifies separate stages in \nthe software process with outputs associated with each stage. The outputs from one \nstage are used as a basis for planning the following process activity.\nFigure 3.1 shows the essential distinctions between plan-driven and agile approaches \nto system specification. In a plan-driven software development process, iteration \noccurs within activities, with formal documents used to communicate between stages \nof the process. For example, the requirements will evolve, and, ultimately, a require-\nments specification will be produced. This is then an input to the design and imple-\nmentation process. In an agile approach, iteration occurs across activities. Therefore, \nthe requirements and the design are developed together rather than separately.\nIn practice, as I explain in Section 3.4.1, plan-driven processes are often used along \nwith agile programming practices, and agile methods may incorporate some planned \nRequirements\nspecification\nRequirements\nengineering\nDesign and\nimplementation\nRequirements change\nrequests\nPlan-based development\nAgile development\nRequirements\nengineering\nDesign and\nimplementation\nFigure 3.1 Plan-driven \nand agile development"}
{"query": "Why might businesses be willing to trade off software quality and compromise on requirements?", "response": "Businesses might be willing to trade off software quality and compromise on requirements because their main priority is rapid software development and delivery. In a rapidly changing environment, businesses need to respond quickly to new opportunities and competitive pressure. They may prioritize deploying essential new software quickly over ensuring high software quality or fully meeting all requirements. This trade-off allows them to take advantage of new opportunities and stay competitive in the market.", "context": "Agile software \ndevelopment\n3 \nObjectives\nThe objective of this chapter is to introduce you to agile software \ndevelopment methods. When you have read the chapter, you will:\n\u25a0 understand the rationale for agile software development methods, \nthe agile manifesto, and the differences between agile and \nplan-driven development;\n\u25a0 know about important agile development practices such as user \nstories, refactoring, pair programming and test-first development;\n\u25a0 understand the Scrum approach to agile project management;\n\u25a0 understand the issues of scaling agile development methods and \ncombining agile approaches with plan-driven approaches in the \ndevelopment of large software systems.\nContents\n3.1  Agile methods\n3.2  Agile development techniques\n3.3  Agile project management\n3.4  Scaling agile methods\n\n\nBusinesses now operate in a global, rapidly changing environment. They have to \nrespond to new opportunities and markets, changing economic conditions and the \nemergence of competing products and services. Software is part of almost all busi-\nness operations, so new software has to be developed quickly to take advantage of \nnew opportunities and to respond to competitive pressure. Rapid software develop-\nment and delivery is therefore the most critical requirement for most business systems. \nIn fact, businesses may be willing to trade off software quality and compromise on \nrequirements if they can deploy essential new software quickly.\nBecause these businesses are operating in a changing environment, it is practi-\ncally impossible to derive a complete set of stable software requirements. \nRequirements change because customers find it impossible to predict how a system \nwill affect working practices, how it will interact with other systems, and what user \noperations should be automated. It may only be after a system has been delivered \nand users gain experience with it that the real requirements become clear. Even then, \nexternal factors drive requirements change.\nPlan-driven software development processes that completely specify the require-\nments and then design, build, and test a system are not geared to rapid software devel-\nopment. As the requirements change or as requirements problems are discovered, the \nsystem design or implementation has to be reworked and retested. As a consequence, \na conventional waterfall or specification-based process is usually a lengthy one, and \nthe final software is delivered to the customer long after it was originally specified.\nFor some types of software, such as safety-critical control systems, where a com-\nplete analysis of the system is essential, this plan-driven approach is the right one. \nHowever, in a fast-moving business environment, it can cause real problems. By the \ntime the software is available for use, the original reason for its procurement may \nhave changed so radically that the software is effectively useless. Therefore, for \nbusiness systems in particular, development processes that focus on rapid software \ndevelopment and delivery are essential.\nThe need for rapid software development and processes that can handle changing \nrequirements has been recognized for many years (Larman and Basili 2003). \nHowever, faster software development really took off in the late 1990s with the \ndevelopment of the idea of \u201cagile methods\u201d such as Extreme Programming (Beck \n1999), Scrum (Schwaber and Beedle 2001), and DSDM (Stapleton 2003).\nRapid software development became known as agile development or agile meth-\nods. These agile methods are designed to produce useful software quickly. All of the \nagile methods that have been proposed share a number of common characteristics:\n1. The processes of specification, design and implementation are interleaved. \nThere is no detailed system specification, and design documentation is mini-\nmized or generated automatically by the programming environment used to \nimplement the system. The user requirements document is an outline definition \nof the most important characteristics of the system.\n2. The system is developed in a series of increments. End-users and other system \nstakeholders are involved in specifying and evaluating each increment. \nChapter 3 \u25a0 Agile software development  73 \n\n\n74  Chapter 3 \u25a0 Agile software development\nThey\u00a0may propose changes to the software and new requirements that should be \nimplemented in a later version of the system.\n3. Extensive tool support is used to support the development process. Tools that \nmay be used include automated testing tools, tools to support configuration man-\nagement, and system integration and tools to automate user interface production.\nAgile methods are incremental development methods in which the increments are \nsmall, and, typically, new releases of the system are created and made available to \n customers every two or three weeks. They involve customers in the development \n process to get rapid feedback on changing requirements. They minimize documentation \nby using informal communications rather than formal meetings with written documents.\nAgile approaches to software development consider design and implementation \nto be the central activities in the software process. They incorporate other activities, \nsuch as requirements elicitation and testing, into design and implementation. By \ncontrast, a plan-driven approach to software engineering identifies separate stages in \nthe software process with outputs associated with each stage. The outputs from one \nstage are used as a basis for planning the following process activity.\nFigure 3.1 shows the essential distinctions between plan-driven and agile approaches \nto system specification. In a plan-driven software development process, iteration \noccurs within activities, with formal documents used to communicate between stages \nof the process. For example, the requirements will evolve, and, ultimately, a require-\nments specification will be produced. This is then an input to the design and imple-\nmentation process. In an agile approach, iteration occurs across activities. Therefore, \nthe requirements and the design are developed together rather than separately.\nIn practice, as I explain in Section 3.4.1, plan-driven processes are often used along \nwith agile programming practices, and agile methods may incorporate some planned \nRequirements\nspecification\nRequirements\nengineering\nDesign and\nimplementation\nRequirements change\nrequests\nPlan-based development\nAgile development\nRequirements\nengineering\nDesign and\nimplementation\nFigure 3.1 Plan-driven \nand agile development"}
{"query": "What are the consequences of a conventional waterfall or specification-based process?", "response": "The consequences of a conventional waterfall or specification-based process are that it is usually lengthy and the final software is delivered to the customer long after it was originally specified. This can be problematic in a fast-moving business environment, as by the time the software is available for use, the original reason for its procurement may have changed so radically that the software is effectively useless. Therefore, for business systems in particular, development processes that focus on rapid software development and delivery are essential.", "context": "Agile software \ndevelopment\n3 \nObjectives\nThe objective of this chapter is to introduce you to agile software \ndevelopment methods. When you have read the chapter, you will:\n\u25a0 understand the rationale for agile software development methods, \nthe agile manifesto, and the differences between agile and \nplan-driven development;\n\u25a0 know about important agile development practices such as user \nstories, refactoring, pair programming and test-first development;\n\u25a0 understand the Scrum approach to agile project management;\n\u25a0 understand the issues of scaling agile development methods and \ncombining agile approaches with plan-driven approaches in the \ndevelopment of large software systems.\nContents\n3.1  Agile methods\n3.2  Agile development techniques\n3.3  Agile project management\n3.4  Scaling agile methods\n\n\nBusinesses now operate in a global, rapidly changing environment. They have to \nrespond to new opportunities and markets, changing economic conditions and the \nemergence of competing products and services. Software is part of almost all busi-\nness operations, so new software has to be developed quickly to take advantage of \nnew opportunities and to respond to competitive pressure. Rapid software develop-\nment and delivery is therefore the most critical requirement for most business systems. \nIn fact, businesses may be willing to trade off software quality and compromise on \nrequirements if they can deploy essential new software quickly.\nBecause these businesses are operating in a changing environment, it is practi-\ncally impossible to derive a complete set of stable software requirements. \nRequirements change because customers find it impossible to predict how a system \nwill affect working practices, how it will interact with other systems, and what user \noperations should be automated. It may only be after a system has been delivered \nand users gain experience with it that the real requirements become clear. Even then, \nexternal factors drive requirements change.\nPlan-driven software development processes that completely specify the require-\nments and then design, build, and test a system are not geared to rapid software devel-\nopment. As the requirements change or as requirements problems are discovered, the \nsystem design or implementation has to be reworked and retested. As a consequence, \na conventional waterfall or specification-based process is usually a lengthy one, and \nthe final software is delivered to the customer long after it was originally specified.\nFor some types of software, such as safety-critical control systems, where a com-\nplete analysis of the system is essential, this plan-driven approach is the right one. \nHowever, in a fast-moving business environment, it can cause real problems. By the \ntime the software is available for use, the original reason for its procurement may \nhave changed so radically that the software is effectively useless. Therefore, for \nbusiness systems in particular, development processes that focus on rapid software \ndevelopment and delivery are essential.\nThe need for rapid software development and processes that can handle changing \nrequirements has been recognized for many years (Larman and Basili 2003). \nHowever, faster software development really took off in the late 1990s with the \ndevelopment of the idea of \u201cagile methods\u201d such as Extreme Programming (Beck \n1999), Scrum (Schwaber and Beedle 2001), and DSDM (Stapleton 2003).\nRapid software development became known as agile development or agile meth-\nods. These agile methods are designed to produce useful software quickly. All of the \nagile methods that have been proposed share a number of common characteristics:\n1. The processes of specification, design and implementation are interleaved. \nThere is no detailed system specification, and design documentation is mini-\nmized or generated automatically by the programming environment used to \nimplement the system. The user requirements document is an outline definition \nof the most important characteristics of the system.\n2. The system is developed in a series of increments. End-users and other system \nstakeholders are involved in specifying and evaluating each increment. \nChapter 3 \u25a0 Agile software development  73 \n\n\n74  Chapter 3 \u25a0 Agile software development\nThey\u00a0may propose changes to the software and new requirements that should be \nimplemented in a later version of the system.\n3. Extensive tool support is used to support the development process. Tools that \nmay be used include automated testing tools, tools to support configuration man-\nagement, and system integration and tools to automate user interface production.\nAgile methods are incremental development methods in which the increments are \nsmall, and, typically, new releases of the system are created and made available to \n customers every two or three weeks. They involve customers in the development \n process to get rapid feedback on changing requirements. They minimize documentation \nby using informal communications rather than formal meetings with written documents.\nAgile approaches to software development consider design and implementation \nto be the central activities in the software process. They incorporate other activities, \nsuch as requirements elicitation and testing, into design and implementation. By \ncontrast, a plan-driven approach to software engineering identifies separate stages in \nthe software process with outputs associated with each stage. The outputs from one \nstage are used as a basis for planning the following process activity.\nFigure 3.1 shows the essential distinctions between plan-driven and agile approaches \nto system specification. In a plan-driven software development process, iteration \noccurs within activities, with formal documents used to communicate between stages \nof the process. For example, the requirements will evolve, and, ultimately, a require-\nments specification will be produced. This is then an input to the design and imple-\nmentation process. In an agile approach, iteration occurs across activities. Therefore, \nthe requirements and the design are developed together rather than separately.\nIn practice, as I explain in Section 3.4.1, plan-driven processes are often used along \nwith agile programming practices, and agile methods may incorporate some planned \nRequirements\nspecification\nRequirements\nengineering\nDesign and\nimplementation\nRequirements change\nrequests\nPlan-based development\nAgile development\nRequirements\nengineering\nDesign and\nimplementation\nFigure 3.1 Plan-driven \nand agile development"}
{"query": "When did the idea of \u201cagile methods\u201d such as Extreme Programming, Scrum, and DSDM develop?", "response": "The idea of \"agile methods\" such as Extreme Programming, Scrum, and DSDM developed in the late 1990s.", "context": "Agile software \ndevelopment\n3 \nObjectives\nThe objective of this chapter is to introduce you to agile software \ndevelopment methods. When you have read the chapter, you will:\n\u25a0 understand the rationale for agile software development methods, \nthe agile manifesto, and the differences between agile and \nplan-driven development;\n\u25a0 know about important agile development practices such as user \nstories, refactoring, pair programming and test-first development;\n\u25a0 understand the Scrum approach to agile project management;\n\u25a0 understand the issues of scaling agile development methods and \ncombining agile approaches with plan-driven approaches in the \ndevelopment of large software systems.\nContents\n3.1  Agile methods\n3.2  Agile development techniques\n3.3  Agile project management\n3.4  Scaling agile methods\n\n\nBusinesses now operate in a global, rapidly changing environment. They have to \nrespond to new opportunities and markets, changing economic conditions and the \nemergence of competing products and services. Software is part of almost all busi-\nness operations, so new software has to be developed quickly to take advantage of \nnew opportunities and to respond to competitive pressure. Rapid software develop-\nment and delivery is therefore the most critical requirement for most business systems. \nIn fact, businesses may be willing to trade off software quality and compromise on \nrequirements if they can deploy essential new software quickly.\nBecause these businesses are operating in a changing environment, it is practi-\ncally impossible to derive a complete set of stable software requirements. \nRequirements change because customers find it impossible to predict how a system \nwill affect working practices, how it will interact with other systems, and what user \noperations should be automated. It may only be after a system has been delivered \nand users gain experience with it that the real requirements become clear. Even then, \nexternal factors drive requirements change.\nPlan-driven software development processes that completely specify the require-\nments and then design, build, and test a system are not geared to rapid software devel-\nopment. As the requirements change or as requirements problems are discovered, the \nsystem design or implementation has to be reworked and retested. As a consequence, \na conventional waterfall or specification-based process is usually a lengthy one, and \nthe final software is delivered to the customer long after it was originally specified.\nFor some types of software, such as safety-critical control systems, where a com-\nplete analysis of the system is essential, this plan-driven approach is the right one. \nHowever, in a fast-moving business environment, it can cause real problems. By the \ntime the software is available for use, the original reason for its procurement may \nhave changed so radically that the software is effectively useless. Therefore, for \nbusiness systems in particular, development processes that focus on rapid software \ndevelopment and delivery are essential.\nThe need for rapid software development and processes that can handle changing \nrequirements has been recognized for many years (Larman and Basili 2003). \nHowever, faster software development really took off in the late 1990s with the \ndevelopment of the idea of \u201cagile methods\u201d such as Extreme Programming (Beck \n1999), Scrum (Schwaber and Beedle 2001), and DSDM (Stapleton 2003).\nRapid software development became known as agile development or agile meth-\nods. These agile methods are designed to produce useful software quickly. All of the \nagile methods that have been proposed share a number of common characteristics:\n1. The processes of specification, design and implementation are interleaved. \nThere is no detailed system specification, and design documentation is mini-\nmized or generated automatically by the programming environment used to \nimplement the system. The user requirements document is an outline definition \nof the most important characteristics of the system.\n2. The system is developed in a series of increments. End-users and other system \nstakeholders are involved in specifying and evaluating each increment. \nChapter 3 \u25a0 Agile software development  73 \n\n\n74  Chapter 3 \u25a0 Agile software development\nThey\u00a0may propose changes to the software and new requirements that should be \nimplemented in a later version of the system.\n3. Extensive tool support is used to support the development process. Tools that \nmay be used include automated testing tools, tools to support configuration man-\nagement, and system integration and tools to automate user interface production.\nAgile methods are incremental development methods in which the increments are \nsmall, and, typically, new releases of the system are created and made available to \n customers every two or three weeks. They involve customers in the development \n process to get rapid feedback on changing requirements. They minimize documentation \nby using informal communications rather than formal meetings with written documents.\nAgile approaches to software development consider design and implementation \nto be the central activities in the software process. They incorporate other activities, \nsuch as requirements elicitation and testing, into design and implementation. By \ncontrast, a plan-driven approach to software engineering identifies separate stages in \nthe software process with outputs associated with each stage. The outputs from one \nstage are used as a basis for planning the following process activity.\nFigure 3.1 shows the essential distinctions between plan-driven and agile approaches \nto system specification. In a plan-driven software development process, iteration \noccurs within activities, with formal documents used to communicate between stages \nof the process. For example, the requirements will evolve, and, ultimately, a require-\nments specification will be produced. This is then an input to the design and imple-\nmentation process. In an agile approach, iteration occurs across activities. Therefore, \nthe requirements and the design are developed together rather than separately.\nIn practice, as I explain in Section 3.4.1, plan-driven processes are often used along \nwith agile programming practices, and agile methods may incorporate some planned \nRequirements\nspecification\nRequirements\nengineering\nDesign and\nimplementation\nRequirements change\nrequests\nPlan-based development\nAgile development\nRequirements\nengineering\nDesign and\nimplementation\nFigure 3.1 Plan-driven \nand agile development"}
{"query": "How do agile methods handle changing requirements?", "response": "Agile methods handle changing requirements by involving end-users and other stakeholders in the development process. They develop the system in a series of increments, allowing for feedback and proposed changes from users. Agile methods also prioritize rapid software development and delivery, minimizing documentation and using informal communication to gather requirements. Additionally, extensive tool support is used to automate processes such as testing and configuration management.", "context": "Agile software \ndevelopment\n3 \nObjectives\nThe objective of this chapter is to introduce you to agile software \ndevelopment methods. When you have read the chapter, you will:\n\u25a0 understand the rationale for agile software development methods, \nthe agile manifesto, and the differences between agile and \nplan-driven development;\n\u25a0 know about important agile development practices such as user \nstories, refactoring, pair programming and test-first development;\n\u25a0 understand the Scrum approach to agile project management;\n\u25a0 understand the issues of scaling agile development methods and \ncombining agile approaches with plan-driven approaches in the \ndevelopment of large software systems.\nContents\n3.1  Agile methods\n3.2  Agile development techniques\n3.3  Agile project management\n3.4  Scaling agile methods\n\n\nBusinesses now operate in a global, rapidly changing environment. They have to \nrespond to new opportunities and markets, changing economic conditions and the \nemergence of competing products and services. Software is part of almost all busi-\nness operations, so new software has to be developed quickly to take advantage of \nnew opportunities and to respond to competitive pressure. Rapid software develop-\nment and delivery is therefore the most critical requirement for most business systems. \nIn fact, businesses may be willing to trade off software quality and compromise on \nrequirements if they can deploy essential new software quickly.\nBecause these businesses are operating in a changing environment, it is practi-\ncally impossible to derive a complete set of stable software requirements. \nRequirements change because customers find it impossible to predict how a system \nwill affect working practices, how it will interact with other systems, and what user \noperations should be automated. It may only be after a system has been delivered \nand users gain experience with it that the real requirements become clear. Even then, \nexternal factors drive requirements change.\nPlan-driven software development processes that completely specify the require-\nments and then design, build, and test a system are not geared to rapid software devel-\nopment. As the requirements change or as requirements problems are discovered, the \nsystem design or implementation has to be reworked and retested. As a consequence, \na conventional waterfall or specification-based process is usually a lengthy one, and \nthe final software is delivered to the customer long after it was originally specified.\nFor some types of software, such as safety-critical control systems, where a com-\nplete analysis of the system is essential, this plan-driven approach is the right one. \nHowever, in a fast-moving business environment, it can cause real problems. By the \ntime the software is available for use, the original reason for its procurement may \nhave changed so radically that the software is effectively useless. Therefore, for \nbusiness systems in particular, development processes that focus on rapid software \ndevelopment and delivery are essential.\nThe need for rapid software development and processes that can handle changing \nrequirements has been recognized for many years (Larman and Basili 2003). \nHowever, faster software development really took off in the late 1990s with the \ndevelopment of the idea of \u201cagile methods\u201d such as Extreme Programming (Beck \n1999), Scrum (Schwaber and Beedle 2001), and DSDM (Stapleton 2003).\nRapid software development became known as agile development or agile meth-\nods. These agile methods are designed to produce useful software quickly. All of the \nagile methods that have been proposed share a number of common characteristics:\n1. The processes of specification, design and implementation are interleaved. \nThere is no detailed system specification, and design documentation is mini-\nmized or generated automatically by the programming environment used to \nimplement the system. The user requirements document is an outline definition \nof the most important characteristics of the system.\n2. The system is developed in a series of increments. End-users and other system \nstakeholders are involved in specifying and evaluating each increment. \nChapter 3 \u25a0 Agile software development  73 \n\n\n74  Chapter 3 \u25a0 Agile software development\nThey\u00a0may propose changes to the software and new requirements that should be \nimplemented in a later version of the system.\n3. Extensive tool support is used to support the development process. Tools that \nmay be used include automated testing tools, tools to support configuration man-\nagement, and system integration and tools to automate user interface production.\nAgile methods are incremental development methods in which the increments are \nsmall, and, typically, new releases of the system are created and made available to \n customers every two or three weeks. They involve customers in the development \n process to get rapid feedback on changing requirements. They minimize documentation \nby using informal communications rather than formal meetings with written documents.\nAgile approaches to software development consider design and implementation \nto be the central activities in the software process. They incorporate other activities, \nsuch as requirements elicitation and testing, into design and implementation. By \ncontrast, a plan-driven approach to software engineering identifies separate stages in \nthe software process with outputs associated with each stage. The outputs from one \nstage are used as a basis for planning the following process activity.\nFigure 3.1 shows the essential distinctions between plan-driven and agile approaches \nto system specification. In a plan-driven software development process, iteration \noccurs within activities, with formal documents used to communicate between stages \nof the process. For example, the requirements will evolve, and, ultimately, a require-\nments specification will be produced. This is then an input to the design and imple-\nmentation process. In an agile approach, iteration occurs across activities. Therefore, \nthe requirements and the design are developed together rather than separately.\nIn practice, as I explain in Section 3.4.1, plan-driven processes are often used along \nwith agile programming practices, and agile methods may incorporate some planned \nRequirements\nspecification\nRequirements\nengineering\nDesign and\nimplementation\nRequirements change\nrequests\nPlan-based development\nAgile development\nRequirements\nengineering\nDesign and\nimplementation\nFigure 3.1 Plan-driven \nand agile development"}
{"query": "What is the role of end-users and other system stakeholders in agile methods?", "response": "End-users and other system stakeholders play a crucial role in agile methods. They are actively involved in specifying and evaluating each increment of the system. They have the opportunity to propose changes to the software and new requirements that should be implemented in future versions of the system. This involvement of end-users and stakeholders allows for rapid feedback on changing requirements and ensures that the software meets their needs effectively.", "context": "Agile software \ndevelopment\n3 \nObjectives\nThe objective of this chapter is to introduce you to agile software \ndevelopment methods. When you have read the chapter, you will:\n\u25a0 understand the rationale for agile software development methods, \nthe agile manifesto, and the differences between agile and \nplan-driven development;\n\u25a0 know about important agile development practices such as user \nstories, refactoring, pair programming and test-first development;\n\u25a0 understand the Scrum approach to agile project management;\n\u25a0 understand the issues of scaling agile development methods and \ncombining agile approaches with plan-driven approaches in the \ndevelopment of large software systems.\nContents\n3.1  Agile methods\n3.2  Agile development techniques\n3.3  Agile project management\n3.4  Scaling agile methods\n\n\nBusinesses now operate in a global, rapidly changing environment. They have to \nrespond to new opportunities and markets, changing economic conditions and the \nemergence of competing products and services. Software is part of almost all busi-\nness operations, so new software has to be developed quickly to take advantage of \nnew opportunities and to respond to competitive pressure. Rapid software develop-\nment and delivery is therefore the most critical requirement for most business systems. \nIn fact, businesses may be willing to trade off software quality and compromise on \nrequirements if they can deploy essential new software quickly.\nBecause these businesses are operating in a changing environment, it is practi-\ncally impossible to derive a complete set of stable software requirements. \nRequirements change because customers find it impossible to predict how a system \nwill affect working practices, how it will interact with other systems, and what user \noperations should be automated. It may only be after a system has been delivered \nand users gain experience with it that the real requirements become clear. Even then, \nexternal factors drive requirements change.\nPlan-driven software development processes that completely specify the require-\nments and then design, build, and test a system are not geared to rapid software devel-\nopment. As the requirements change or as requirements problems are discovered, the \nsystem design or implementation has to be reworked and retested. As a consequence, \na conventional waterfall or specification-based process is usually a lengthy one, and \nthe final software is delivered to the customer long after it was originally specified.\nFor some types of software, such as safety-critical control systems, where a com-\nplete analysis of the system is essential, this plan-driven approach is the right one. \nHowever, in a fast-moving business environment, it can cause real problems. By the \ntime the software is available for use, the original reason for its procurement may \nhave changed so radically that the software is effectively useless. Therefore, for \nbusiness systems in particular, development processes that focus on rapid software \ndevelopment and delivery are essential.\nThe need for rapid software development and processes that can handle changing \nrequirements has been recognized for many years (Larman and Basili 2003). \nHowever, faster software development really took off in the late 1990s with the \ndevelopment of the idea of \u201cagile methods\u201d such as Extreme Programming (Beck \n1999), Scrum (Schwaber and Beedle 2001), and DSDM (Stapleton 2003).\nRapid software development became known as agile development or agile meth-\nods. These agile methods are designed to produce useful software quickly. All of the \nagile methods that have been proposed share a number of common characteristics:\n1. The processes of specification, design and implementation are interleaved. \nThere is no detailed system specification, and design documentation is mini-\nmized or generated automatically by the programming environment used to \nimplement the system. The user requirements document is an outline definition \nof the most important characteristics of the system.\n2. The system is developed in a series of increments. End-users and other system \nstakeholders are involved in specifying and evaluating each increment. \nChapter 3 \u25a0 Agile software development  73 \n\n\n74  Chapter 3 \u25a0 Agile software development\nThey\u00a0may propose changes to the software and new requirements that should be \nimplemented in a later version of the system.\n3. Extensive tool support is used to support the development process. Tools that \nmay be used include automated testing tools, tools to support configuration man-\nagement, and system integration and tools to automate user interface production.\nAgile methods are incremental development methods in which the increments are \nsmall, and, typically, new releases of the system are created and made available to \n customers every two or three weeks. They involve customers in the development \n process to get rapid feedback on changing requirements. They minimize documentation \nby using informal communications rather than formal meetings with written documents.\nAgile approaches to software development consider design and implementation \nto be the central activities in the software process. They incorporate other activities, \nsuch as requirements elicitation and testing, into design and implementation. By \ncontrast, a plan-driven approach to software engineering identifies separate stages in \nthe software process with outputs associated with each stage. The outputs from one \nstage are used as a basis for planning the following process activity.\nFigure 3.1 shows the essential distinctions between plan-driven and agile approaches \nto system specification. In a plan-driven software development process, iteration \noccurs within activities, with formal documents used to communicate between stages \nof the process. For example, the requirements will evolve, and, ultimately, a require-\nments specification will be produced. This is then an input to the design and imple-\nmentation process. In an agile approach, iteration occurs across activities. Therefore, \nthe requirements and the design are developed together rather than separately.\nIn practice, as I explain in Section 3.4.1, plan-driven processes are often used along \nwith agile programming practices, and agile methods may incorporate some planned \nRequirements\nspecification\nRequirements\nengineering\nDesign and\nimplementation\nRequirements change\nrequests\nPlan-based development\nAgile development\nRequirements\nengineering\nDesign and\nimplementation\nFigure 3.1 Plan-driven \nand agile development"}
{"query": "How do agile methods minimize documentation?", "response": "Agile methods minimize documentation by using informal communications rather than formal meetings with written documents. They consider design and implementation to be the central activities in the software process and incorporate other activities, such as requirements elicitation and testing, into design and implementation. This approach reduces the need for extensive documentation and promotes rapid feedback and collaboration with customers.", "context": "Agile software \ndevelopment\n3 \nObjectives\nThe objective of this chapter is to introduce you to agile software \ndevelopment methods. When you have read the chapter, you will:\n\u25a0 understand the rationale for agile software development methods, \nthe agile manifesto, and the differences between agile and \nplan-driven development;\n\u25a0 know about important agile development practices such as user \nstories, refactoring, pair programming and test-first development;\n\u25a0 understand the Scrum approach to agile project management;\n\u25a0 understand the issues of scaling agile development methods and \ncombining agile approaches with plan-driven approaches in the \ndevelopment of large software systems.\nContents\n3.1  Agile methods\n3.2  Agile development techniques\n3.3  Agile project management\n3.4  Scaling agile methods\n\n\nBusinesses now operate in a global, rapidly changing environment. They have to \nrespond to new opportunities and markets, changing economic conditions and the \nemergence of competing products and services. Software is part of almost all busi-\nness operations, so new software has to be developed quickly to take advantage of \nnew opportunities and to respond to competitive pressure. Rapid software develop-\nment and delivery is therefore the most critical requirement for most business systems. \nIn fact, businesses may be willing to trade off software quality and compromise on \nrequirements if they can deploy essential new software quickly.\nBecause these businesses are operating in a changing environment, it is practi-\ncally impossible to derive a complete set of stable software requirements. \nRequirements change because customers find it impossible to predict how a system \nwill affect working practices, how it will interact with other systems, and what user \noperations should be automated. It may only be after a system has been delivered \nand users gain experience with it that the real requirements become clear. Even then, \nexternal factors drive requirements change.\nPlan-driven software development processes that completely specify the require-\nments and then design, build, and test a system are not geared to rapid software devel-\nopment. As the requirements change or as requirements problems are discovered, the \nsystem design or implementation has to be reworked and retested. As a consequence, \na conventional waterfall or specification-based process is usually a lengthy one, and \nthe final software is delivered to the customer long after it was originally specified.\nFor some types of software, such as safety-critical control systems, where a com-\nplete analysis of the system is essential, this plan-driven approach is the right one. \nHowever, in a fast-moving business environment, it can cause real problems. By the \ntime the software is available for use, the original reason for its procurement may \nhave changed so radically that the software is effectively useless. Therefore, for \nbusiness systems in particular, development processes that focus on rapid software \ndevelopment and delivery are essential.\nThe need for rapid software development and processes that can handle changing \nrequirements has been recognized for many years (Larman and Basili 2003). \nHowever, faster software development really took off in the late 1990s with the \ndevelopment of the idea of \u201cagile methods\u201d such as Extreme Programming (Beck \n1999), Scrum (Schwaber and Beedle 2001), and DSDM (Stapleton 2003).\nRapid software development became known as agile development or agile meth-\nods. These agile methods are designed to produce useful software quickly. All of the \nagile methods that have been proposed share a number of common characteristics:\n1. The processes of specification, design and implementation are interleaved. \nThere is no detailed system specification, and design documentation is mini-\nmized or generated automatically by the programming environment used to \nimplement the system. The user requirements document is an outline definition \nof the most important characteristics of the system.\n2. The system is developed in a series of increments. End-users and other system \nstakeholders are involved in specifying and evaluating each increment. \nChapter 3 \u25a0 Agile software development  73 \n\n\n74  Chapter 3 \u25a0 Agile software development\nThey\u00a0may propose changes to the software and new requirements that should be \nimplemented in a later version of the system.\n3. Extensive tool support is used to support the development process. Tools that \nmay be used include automated testing tools, tools to support configuration man-\nagement, and system integration and tools to automate user interface production.\nAgile methods are incremental development methods in which the increments are \nsmall, and, typically, new releases of the system are created and made available to \n customers every two or three weeks. They involve customers in the development \n process to get rapid feedback on changing requirements. They minimize documentation \nby using informal communications rather than formal meetings with written documents.\nAgile approaches to software development consider design and implementation \nto be the central activities in the software process. They incorporate other activities, \nsuch as requirements elicitation and testing, into design and implementation. By \ncontrast, a plan-driven approach to software engineering identifies separate stages in \nthe software process with outputs associated with each stage. The outputs from one \nstage are used as a basis for planning the following process activity.\nFigure 3.1 shows the essential distinctions between plan-driven and agile approaches \nto system specification. In a plan-driven software development process, iteration \noccurs within activities, with formal documents used to communicate between stages \nof the process. For example, the requirements will evolve, and, ultimately, a require-\nments specification will be produced. This is then an input to the design and imple-\nmentation process. In an agile approach, iteration occurs across activities. Therefore, \nthe requirements and the design are developed together rather than separately.\nIn practice, as I explain in Section 3.4.1, plan-driven processes are often used along \nwith agile programming practices, and agile methods may incorporate some planned \nRequirements\nspecification\nRequirements\nengineering\nDesign and\nimplementation\nRequirements change\nrequests\nPlan-based development\nAgile development\nRequirements\nengineering\nDesign and\nimplementation\nFigure 3.1 Plan-driven \nand agile development"}
{"query": "What are the central activities in the agile software development process?", "response": "The central activities in the agile software development process are design and implementation.", "context": "Agile software \ndevelopment\n3 \nObjectives\nThe objective of this chapter is to introduce you to agile software \ndevelopment methods. When you have read the chapter, you will:\n\u25a0 understand the rationale for agile software development methods, \nthe agile manifesto, and the differences between agile and \nplan-driven development;\n\u25a0 know about important agile development practices such as user \nstories, refactoring, pair programming and test-first development;\n\u25a0 understand the Scrum approach to agile project management;\n\u25a0 understand the issues of scaling agile development methods and \ncombining agile approaches with plan-driven approaches in the \ndevelopment of large software systems.\nContents\n3.1  Agile methods\n3.2  Agile development techniques\n3.3  Agile project management\n3.4  Scaling agile methods\n\n\nBusinesses now operate in a global, rapidly changing environment. They have to \nrespond to new opportunities and markets, changing economic conditions and the \nemergence of competing products and services. Software is part of almost all busi-\nness operations, so new software has to be developed quickly to take advantage of \nnew opportunities and to respond to competitive pressure. Rapid software develop-\nment and delivery is therefore the most critical requirement for most business systems. \nIn fact, businesses may be willing to trade off software quality and compromise on \nrequirements if they can deploy essential new software quickly.\nBecause these businesses are operating in a changing environment, it is practi-\ncally impossible to derive a complete set of stable software requirements. \nRequirements change because customers find it impossible to predict how a system \nwill affect working practices, how it will interact with other systems, and what user \noperations should be automated. It may only be after a system has been delivered \nand users gain experience with it that the real requirements become clear. Even then, \nexternal factors drive requirements change.\nPlan-driven software development processes that completely specify the require-\nments and then design, build, and test a system are not geared to rapid software devel-\nopment. As the requirements change or as requirements problems are discovered, the \nsystem design or implementation has to be reworked and retested. As a consequence, \na conventional waterfall or specification-based process is usually a lengthy one, and \nthe final software is delivered to the customer long after it was originally specified.\nFor some types of software, such as safety-critical control systems, where a com-\nplete analysis of the system is essential, this plan-driven approach is the right one. \nHowever, in a fast-moving business environment, it can cause real problems. By the \ntime the software is available for use, the original reason for its procurement may \nhave changed so radically that the software is effectively useless. Therefore, for \nbusiness systems in particular, development processes that focus on rapid software \ndevelopment and delivery are essential.\nThe need for rapid software development and processes that can handle changing \nrequirements has been recognized for many years (Larman and Basili 2003). \nHowever, faster software development really took off in the late 1990s with the \ndevelopment of the idea of \u201cagile methods\u201d such as Extreme Programming (Beck \n1999), Scrum (Schwaber and Beedle 2001), and DSDM (Stapleton 2003).\nRapid software development became known as agile development or agile meth-\nods. These agile methods are designed to produce useful software quickly. All of the \nagile methods that have been proposed share a number of common characteristics:\n1. The processes of specification, design and implementation are interleaved. \nThere is no detailed system specification, and design documentation is mini-\nmized or generated automatically by the programming environment used to \nimplement the system. The user requirements document is an outline definition \nof the most important characteristics of the system.\n2. The system is developed in a series of increments. End-users and other system \nstakeholders are involved in specifying and evaluating each increment. \nChapter 3 \u25a0 Agile software development  73 \n\n\n74  Chapter 3 \u25a0 Agile software development\nThey\u00a0may propose changes to the software and new requirements that should be \nimplemented in a later version of the system.\n3. Extensive tool support is used to support the development process. Tools that \nmay be used include automated testing tools, tools to support configuration man-\nagement, and system integration and tools to automate user interface production.\nAgile methods are incremental development methods in which the increments are \nsmall, and, typically, new releases of the system are created and made available to \n customers every two or three weeks. They involve customers in the development \n process to get rapid feedback on changing requirements. They minimize documentation \nby using informal communications rather than formal meetings with written documents.\nAgile approaches to software development consider design and implementation \nto be the central activities in the software process. They incorporate other activities, \nsuch as requirements elicitation and testing, into design and implementation. By \ncontrast, a plan-driven approach to software engineering identifies separate stages in \nthe software process with outputs associated with each stage. The outputs from one \nstage are used as a basis for planning the following process activity.\nFigure 3.1 shows the essential distinctions between plan-driven and agile approaches \nto system specification. In a plan-driven software development process, iteration \noccurs within activities, with formal documents used to communicate between stages \nof the process. For example, the requirements will evolve, and, ultimately, a require-\nments specification will be produced. This is then an input to the design and imple-\nmentation process. In an agile approach, iteration occurs across activities. Therefore, \nthe requirements and the design are developed together rather than separately.\nIn practice, as I explain in Section 3.4.1, plan-driven processes are often used along \nwith agile programming practices, and agile methods may incorporate some planned \nRequirements\nspecification\nRequirements\nengineering\nDesign and\nimplementation\nRequirements change\nrequests\nPlan-based development\nAgile development\nRequirements\nengineering\nDesign and\nimplementation\nFigure 3.1 Plan-driven \nand agile development"}
{"query": "How are the outputs from one stage used as a basis for planning the following process activity in a plan-driven approach?", "response": "In a plan-driven approach, the outputs from one stage are used as a basis for planning the following process activity. This means that the requirements specification, which evolves throughout the process, serves as an input for the design and implementation process. The formal documents produced in each stage of the process are used to communicate and guide the subsequent activities. This sequential approach ensures that each stage builds upon the outputs of the previous stage, allowing for a more structured and controlled development process.", "context": "Agile software \ndevelopment\n3 \nObjectives\nThe objective of this chapter is to introduce you to agile software \ndevelopment methods. When you have read the chapter, you will:\n\u25a0 understand the rationale for agile software development methods, \nthe agile manifesto, and the differences between agile and \nplan-driven development;\n\u25a0 know about important agile development practices such as user \nstories, refactoring, pair programming and test-first development;\n\u25a0 understand the Scrum approach to agile project management;\n\u25a0 understand the issues of scaling agile development methods and \ncombining agile approaches with plan-driven approaches in the \ndevelopment of large software systems.\nContents\n3.1  Agile methods\n3.2  Agile development techniques\n3.3  Agile project management\n3.4  Scaling agile methods\n\n\nBusinesses now operate in a global, rapidly changing environment. They have to \nrespond to new opportunities and markets, changing economic conditions and the \nemergence of competing products and services. Software is part of almost all busi-\nness operations, so new software has to be developed quickly to take advantage of \nnew opportunities and to respond to competitive pressure. Rapid software develop-\nment and delivery is therefore the most critical requirement for most business systems. \nIn fact, businesses may be willing to trade off software quality and compromise on \nrequirements if they can deploy essential new software quickly.\nBecause these businesses are operating in a changing environment, it is practi-\ncally impossible to derive a complete set of stable software requirements. \nRequirements change because customers find it impossible to predict how a system \nwill affect working practices, how it will interact with other systems, and what user \noperations should be automated. It may only be after a system has been delivered \nand users gain experience with it that the real requirements become clear. Even then, \nexternal factors drive requirements change.\nPlan-driven software development processes that completely specify the require-\nments and then design, build, and test a system are not geared to rapid software devel-\nopment. As the requirements change or as requirements problems are discovered, the \nsystem design or implementation has to be reworked and retested. As a consequence, \na conventional waterfall or specification-based process is usually a lengthy one, and \nthe final software is delivered to the customer long after it was originally specified.\nFor some types of software, such as safety-critical control systems, where a com-\nplete analysis of the system is essential, this plan-driven approach is the right one. \nHowever, in a fast-moving business environment, it can cause real problems. By the \ntime the software is available for use, the original reason for its procurement may \nhave changed so radically that the software is effectively useless. Therefore, for \nbusiness systems in particular, development processes that focus on rapid software \ndevelopment and delivery are essential.\nThe need for rapid software development and processes that can handle changing \nrequirements has been recognized for many years (Larman and Basili 2003). \nHowever, faster software development really took off in the late 1990s with the \ndevelopment of the idea of \u201cagile methods\u201d such as Extreme Programming (Beck \n1999), Scrum (Schwaber and Beedle 2001), and DSDM (Stapleton 2003).\nRapid software development became known as agile development or agile meth-\nods. These agile methods are designed to produce useful software quickly. All of the \nagile methods that have been proposed share a number of common characteristics:\n1. The processes of specification, design and implementation are interleaved. \nThere is no detailed system specification, and design documentation is mini-\nmized or generated automatically by the programming environment used to \nimplement the system. The user requirements document is an outline definition \nof the most important characteristics of the system.\n2. The system is developed in a series of increments. End-users and other system \nstakeholders are involved in specifying and evaluating each increment. \nChapter 3 \u25a0 Agile software development  73 \n\n\n74  Chapter 3 \u25a0 Agile software development\nThey\u00a0may propose changes to the software and new requirements that should be \nimplemented in a later version of the system.\n3. Extensive tool support is used to support the development process. Tools that \nmay be used include automated testing tools, tools to support configuration man-\nagement, and system integration and tools to automate user interface production.\nAgile methods are incremental development methods in which the increments are \nsmall, and, typically, new releases of the system are created and made available to \n customers every two or three weeks. They involve customers in the development \n process to get rapid feedback on changing requirements. They minimize documentation \nby using informal communications rather than formal meetings with written documents.\nAgile approaches to software development consider design and implementation \nto be the central activities in the software process. They incorporate other activities, \nsuch as requirements elicitation and testing, into design and implementation. By \ncontrast, a plan-driven approach to software engineering identifies separate stages in \nthe software process with outputs associated with each stage. The outputs from one \nstage are used as a basis for planning the following process activity.\nFigure 3.1 shows the essential distinctions between plan-driven and agile approaches \nto system specification. In a plan-driven software development process, iteration \noccurs within activities, with formal documents used to communicate between stages \nof the process. For example, the requirements will evolve, and, ultimately, a require-\nments specification will be produced. This is then an input to the design and imple-\nmentation process. In an agile approach, iteration occurs across activities. Therefore, \nthe requirements and the design are developed together rather than separately.\nIn practice, as I explain in Section 3.4.1, plan-driven processes are often used along \nwith agile programming practices, and agile methods may incorporate some planned \nRequirements\nspecification\nRequirements\nengineering\nDesign and\nimplementation\nRequirements change\nrequests\nPlan-based development\nAgile development\nRequirements\nengineering\nDesign and\nimplementation\nFigure 3.1 Plan-driven \nand agile development"}
{"query": "How are the requirements specification and design and implementation related in plan-driven and agile development?", "response": "In plan-driven development, the requirements specification is produced as a separate stage in the software process, and it serves as an input to the design and implementation process. This means that the requirements are first specified, and then the design and implementation are based on those requirements.\n\nOn the other hand, in agile development, the requirements and the design are developed together rather than separately. There is no detailed system specification, and the design documentation is minimized or generated automatically. The user requirements document in agile development is an outline definition of the most important characteristics of the system.\n\nSo, in plan-driven development, the requirements specification is a separate stage that precedes the design and implementation, while in agile development, the requirements and the design are developed concurrently.", "context": "Agile software \ndevelopment\n3 \nObjectives\nThe objective of this chapter is to introduce you to agile software \ndevelopment methods. When you have read the chapter, you will:\n\u25a0 understand the rationale for agile software development methods, \nthe agile manifesto, and the differences between agile and \nplan-driven development;\n\u25a0 know about important agile development practices such as user \nstories, refactoring, pair programming and test-first development;\n\u25a0 understand the Scrum approach to agile project management;\n\u25a0 understand the issues of scaling agile development methods and \ncombining agile approaches with plan-driven approaches in the \ndevelopment of large software systems.\nContents\n3.1  Agile methods\n3.2  Agile development techniques\n3.3  Agile project management\n3.4  Scaling agile methods\n\n\nBusinesses now operate in a global, rapidly changing environment. They have to \nrespond to new opportunities and markets, changing economic conditions and the \nemergence of competing products and services. Software is part of almost all busi-\nness operations, so new software has to be developed quickly to take advantage of \nnew opportunities and to respond to competitive pressure. Rapid software develop-\nment and delivery is therefore the most critical requirement for most business systems. \nIn fact, businesses may be willing to trade off software quality and compromise on \nrequirements if they can deploy essential new software quickly.\nBecause these businesses are operating in a changing environment, it is practi-\ncally impossible to derive a complete set of stable software requirements. \nRequirements change because customers find it impossible to predict how a system \nwill affect working practices, how it will interact with other systems, and what user \noperations should be automated. It may only be after a system has been delivered \nand users gain experience with it that the real requirements become clear. Even then, \nexternal factors drive requirements change.\nPlan-driven software development processes that completely specify the require-\nments and then design, build, and test a system are not geared to rapid software devel-\nopment. As the requirements change or as requirements problems are discovered, the \nsystem design or implementation has to be reworked and retested. As a consequence, \na conventional waterfall or specification-based process is usually a lengthy one, and \nthe final software is delivered to the customer long after it was originally specified.\nFor some types of software, such as safety-critical control systems, where a com-\nplete analysis of the system is essential, this plan-driven approach is the right one. \nHowever, in a fast-moving business environment, it can cause real problems. By the \ntime the software is available for use, the original reason for its procurement may \nhave changed so radically that the software is effectively useless. Therefore, for \nbusiness systems in particular, development processes that focus on rapid software \ndevelopment and delivery are essential.\nThe need for rapid software development and processes that can handle changing \nrequirements has been recognized for many years (Larman and Basili 2003). \nHowever, faster software development really took off in the late 1990s with the \ndevelopment of the idea of \u201cagile methods\u201d such as Extreme Programming (Beck \n1999), Scrum (Schwaber and Beedle 2001), and DSDM (Stapleton 2003).\nRapid software development became known as agile development or agile meth-\nods. These agile methods are designed to produce useful software quickly. All of the \nagile methods that have been proposed share a number of common characteristics:\n1. The processes of specification, design and implementation are interleaved. \nThere is no detailed system specification, and design documentation is mini-\nmized or generated automatically by the programming environment used to \nimplement the system. The user requirements document is an outline definition \nof the most important characteristics of the system.\n2. The system is developed in a series of increments. End-users and other system \nstakeholders are involved in specifying and evaluating each increment. \nChapter 3 \u25a0 Agile software development  73 \n\n\n74  Chapter 3 \u25a0 Agile software development\nThey\u00a0may propose changes to the software and new requirements that should be \nimplemented in a later version of the system.\n3. Extensive tool support is used to support the development process. Tools that \nmay be used include automated testing tools, tools to support configuration man-\nagement, and system integration and tools to automate user interface production.\nAgile methods are incremental development methods in which the increments are \nsmall, and, typically, new releases of the system are created and made available to \n customers every two or three weeks. They involve customers in the development \n process to get rapid feedback on changing requirements. They minimize documentation \nby using informal communications rather than formal meetings with written documents.\nAgile approaches to software development consider design and implementation \nto be the central activities in the software process. They incorporate other activities, \nsuch as requirements elicitation and testing, into design and implementation. By \ncontrast, a plan-driven approach to software engineering identifies separate stages in \nthe software process with outputs associated with each stage. The outputs from one \nstage are used as a basis for planning the following process activity.\nFigure 3.1 shows the essential distinctions between plan-driven and agile approaches \nto system specification. In a plan-driven software development process, iteration \noccurs within activities, with formal documents used to communicate between stages \nof the process. For example, the requirements will evolve, and, ultimately, a require-\nments specification will be produced. This is then an input to the design and imple-\nmentation process. In an agile approach, iteration occurs across activities. Therefore, \nthe requirements and the design are developed together rather than separately.\nIn practice, as I explain in Section 3.4.1, plan-driven processes are often used along \nwith agile programming practices, and agile methods may incorporate some planned \nRequirements\nspecification\nRequirements\nengineering\nDesign and\nimplementation\nRequirements change\nrequests\nPlan-based development\nAgile development\nRequirements\nengineering\nDesign and\nimplementation\nFigure 3.1 Plan-driven \nand agile development"}
{"query": "What is the plan-driven approach in software development?", "response": "The plan-driven approach in software development is a heavyweight approach that involves careful project planning, formalized quality assurance, use of analysis and design methods supported by software tools, and controlled and rigorous software development processes. It is typically used for large, long-lived software systems developed by large teams working for different companies. This approach involves significant overhead in planning, designing, and documenting the system, which is justified when multiple development teams need to be coordinated, the system is critical, and many different people will be involved in maintaining the software over its lifetime.", "context": "3.1 \u25a0 Agile methods  75\nactivities apart from programming and testing. It is perfectly feasible, in a plan-driven \nprocess, to allocate requirements and plan the design and development phase as a \nseries of increments. An agile process is not inevitably code-focused, and it may \n produce some design documentation. Agile developers may decide that an iteration \nshould not produce new code but rather should produce system models and documentation.\n \n3.1 Agile methods\nIn the 1980s and early 1990s, there was a widespread view that the best way to \nachieve better software was through careful project planning, formalized quality \nassurance, use of analysis and design methods supported by software tools, and con-\ntrolled and rigorous software development processes. This view came from the soft-\nware engineering community that was responsible for developing large, long-lived \nsoftware systems such as aerospace and government systems.\nThis plan-driven approach was developed for software developed by large teams, \nworking for different companies. Teams were often geographically dispersed and \nworked on the software for long periods of time. An example of this type of software \nis the control systems for a modern aircraft, which might take up to 10 years from \ninitial specification to deployment. Plan-driven approaches involve a significant \noverhead in planning, designing, and documenting the system. This overhead is jus-\ntified when the work of multiple development teams has to be coordinated, when the \nsystem is a critical system, and when many different people will be involved in \nmaintaining the software over its lifetime.\nHowever, when this heavyweight, plan-driven development approach is applied \nto small and medium-sized business systems, the overhead involved is so large that \nit dominates the software development process. More time is spent on how the sys-\ntem should be developed than on program development and testing. As the system \nrequirements change, rework is essential and, in principle at least, the specification \nand design have to change with the program.\nDissatisfaction with these heavyweight approaches to software engineering \nled to the development of agile methods in the late 1990s. These methods allowed \nthe development team to focus on the software itself rather than on its design and \ndocumentation. They are best suited to application development where the sys-\ntem requirements usually change rapidly during the development process. They \nare intended to deliver working software quickly to customers, who can then pro-\npose new and changed requirements to be included in later iterations of the sys-\ntem. They aim to cut down on process bureaucracy by avoiding work that has \ndubious long-term value and eliminating documentation that will probably never \nbe used.\nThe philosophy behind agile methods is reflected in the agile manifesto (http://\nagilemanifesto.org) issued by the leading developers of these methods. This mani-\nfesto states:\n\n\n76  Chapter 3 \u25a0 Agile software development\nWe are uncovering better ways of developing software by doing it and helping \nothers do it. Through this work we have come to value:\nIndividuals and interactions over processes and tools \nWorking software over comprehensive documentation \nCustomer collaboration over contract negotiation \nResponding to change over following a plan\nThat is, while there is value in the items on the right, we value the items on the \nleft more\u2020.\nAll agile methods suggest that software should be developed and delivered incre-\nmentally. These methods are based on different agile processes but they share a set \nof principles, based on the agile manifesto, and so they have much in common. I \nhave listed these principles in Figure 3.2.\nAgile methods have been particularly successful for two kinds of system  development.\n1. Product development where a software company is developing a small or \nmedium-sized product for sale. Virtually all software products and apps are now \ndeveloped using an agile approach.\n2. \nCustom system development within an organization, where there is a clear com-\nmitment from the customer to become involved in the development process and \nwhere there are few external stakeholders and regulations that affect the software.\nAgile methods work well in these situations because it is possible to have con-\ntinuous communications between the product manager or system customer and the \ndevelopment team. The software itself is a stand-alone system rather than tightly \nintegrated with other systems being developed at the same time. Consequently, there \nis no need to coordinate parallel development streams. Small and medium-sized \nPrinciple\nDescription\nCustomer involvement\nCustomers should be closely involved throughout the development process. \nTheir role is provide and prioritize new system requirements and to evaluate \nthe iterations of the system.\nEmbrace change\nExpect the system requirements to change, and so design the system to \naccommodate these changes.\nIncremental delivery\nThe software is developed in increments, with the customer specifying the \nrequirements to be included in each increment.\nMaintain simplicity\nFocus on simplicity in both the software being developed and in the \ndevelopment process. Wherever possible, actively work to eliminate \ncomplexity from the system.\nPeople, not process\nThe skills of the development team should be recognized and exploited. \nTeam members should be left to develop their own ways of working without \nprescriptive processes.\nFigure 3.2 The \nprinciples of agile \nmethods\n\u2020http://agilemanifesto.org/"}
{"query": "What kind of software systems were the plan-driven approach developed for?", "response": "The plan-driven approach was developed for software systems developed by large teams, working for different companies. These teams were often geographically dispersed and worked on the software for long periods of time. Examples of this type of software include control systems for modern aircraft, which can take up to 10 years from initial specification to deployment.", "context": "3.1 \u25a0 Agile methods  75\nactivities apart from programming and testing. It is perfectly feasible, in a plan-driven \nprocess, to allocate requirements and plan the design and development phase as a \nseries of increments. An agile process is not inevitably code-focused, and it may \n produce some design documentation. Agile developers may decide that an iteration \nshould not produce new code but rather should produce system models and documentation.\n \n3.1 Agile methods\nIn the 1980s and early 1990s, there was a widespread view that the best way to \nachieve better software was through careful project planning, formalized quality \nassurance, use of analysis and design methods supported by software tools, and con-\ntrolled and rigorous software development processes. This view came from the soft-\nware engineering community that was responsible for developing large, long-lived \nsoftware systems such as aerospace and government systems.\nThis plan-driven approach was developed for software developed by large teams, \nworking for different companies. Teams were often geographically dispersed and \nworked on the software for long periods of time. An example of this type of software \nis the control systems for a modern aircraft, which might take up to 10 years from \ninitial specification to deployment. Plan-driven approaches involve a significant \noverhead in planning, designing, and documenting the system. This overhead is jus-\ntified when the work of multiple development teams has to be coordinated, when the \nsystem is a critical system, and when many different people will be involved in \nmaintaining the software over its lifetime.\nHowever, when this heavyweight, plan-driven development approach is applied \nto small and medium-sized business systems, the overhead involved is so large that \nit dominates the software development process. More time is spent on how the sys-\ntem should be developed than on program development and testing. As the system \nrequirements change, rework is essential and, in principle at least, the specification \nand design have to change with the program.\nDissatisfaction with these heavyweight approaches to software engineering \nled to the development of agile methods in the late 1990s. These methods allowed \nthe development team to focus on the software itself rather than on its design and \ndocumentation. They are best suited to application development where the sys-\ntem requirements usually change rapidly during the development process. They \nare intended to deliver working software quickly to customers, who can then pro-\npose new and changed requirements to be included in later iterations of the sys-\ntem. They aim to cut down on process bureaucracy by avoiding work that has \ndubious long-term value and eliminating documentation that will probably never \nbe used.\nThe philosophy behind agile methods is reflected in the agile manifesto (http://\nagilemanifesto.org) issued by the leading developers of these methods. This mani-\nfesto states:\n\n\n76  Chapter 3 \u25a0 Agile software development\nWe are uncovering better ways of developing software by doing it and helping \nothers do it. Through this work we have come to value:\nIndividuals and interactions over processes and tools \nWorking software over comprehensive documentation \nCustomer collaboration over contract negotiation \nResponding to change over following a plan\nThat is, while there is value in the items on the right, we value the items on the \nleft more\u2020.\nAll agile methods suggest that software should be developed and delivered incre-\nmentally. These methods are based on different agile processes but they share a set \nof principles, based on the agile manifesto, and so they have much in common. I \nhave listed these principles in Figure 3.2.\nAgile methods have been particularly successful for two kinds of system  development.\n1. Product development where a software company is developing a small or \nmedium-sized product for sale. Virtually all software products and apps are now \ndeveloped using an agile approach.\n2. \nCustom system development within an organization, where there is a clear com-\nmitment from the customer to become involved in the development process and \nwhere there are few external stakeholders and regulations that affect the software.\nAgile methods work well in these situations because it is possible to have con-\ntinuous communications between the product manager or system customer and the \ndevelopment team. The software itself is a stand-alone system rather than tightly \nintegrated with other systems being developed at the same time. Consequently, there \nis no need to coordinate parallel development streams. Small and medium-sized \nPrinciple\nDescription\nCustomer involvement\nCustomers should be closely involved throughout the development process. \nTheir role is provide and prioritize new system requirements and to evaluate \nthe iterations of the system.\nEmbrace change\nExpect the system requirements to change, and so design the system to \naccommodate these changes.\nIncremental delivery\nThe software is developed in increments, with the customer specifying the \nrequirements to be included in each increment.\nMaintain simplicity\nFocus on simplicity in both the software being developed and in the \ndevelopment process. Wherever possible, actively work to eliminate \ncomplexity from the system.\nPeople, not process\nThe skills of the development team should be recognized and exploited. \nTeam members should be left to develop their own ways of working without \nprescriptive processes.\nFigure 3.2 The \nprinciples of agile \nmethods\n\u2020http://agilemanifesto.org/"}
{"query": "What are some of the drawbacks of applying the plan-driven approach to small and medium-sized business systems?", "response": "The overhead involved in the plan-driven approach is so large that it dominates the software development process for small and medium-sized business systems. More time is spent on how the system should be developed than on actual program development and testing. Additionally, as the system requirements change, rework is essential, and the specification and design have to change with the program.", "context": "3.1 \u25a0 Agile methods  75\nactivities apart from programming and testing. It is perfectly feasible, in a plan-driven \nprocess, to allocate requirements and plan the design and development phase as a \nseries of increments. An agile process is not inevitably code-focused, and it may \n produce some design documentation. Agile developers may decide that an iteration \nshould not produce new code but rather should produce system models and documentation.\n \n3.1 Agile methods\nIn the 1980s and early 1990s, there was a widespread view that the best way to \nachieve better software was through careful project planning, formalized quality \nassurance, use of analysis and design methods supported by software tools, and con-\ntrolled and rigorous software development processes. This view came from the soft-\nware engineering community that was responsible for developing large, long-lived \nsoftware systems such as aerospace and government systems.\nThis plan-driven approach was developed for software developed by large teams, \nworking for different companies. Teams were often geographically dispersed and \nworked on the software for long periods of time. An example of this type of software \nis the control systems for a modern aircraft, which might take up to 10 years from \ninitial specification to deployment. Plan-driven approaches involve a significant \noverhead in planning, designing, and documenting the system. This overhead is jus-\ntified when the work of multiple development teams has to be coordinated, when the \nsystem is a critical system, and when many different people will be involved in \nmaintaining the software over its lifetime.\nHowever, when this heavyweight, plan-driven development approach is applied \nto small and medium-sized business systems, the overhead involved is so large that \nit dominates the software development process. More time is spent on how the sys-\ntem should be developed than on program development and testing. As the system \nrequirements change, rework is essential and, in principle at least, the specification \nand design have to change with the program.\nDissatisfaction with these heavyweight approaches to software engineering \nled to the development of agile methods in the late 1990s. These methods allowed \nthe development team to focus on the software itself rather than on its design and \ndocumentation. They are best suited to application development where the sys-\ntem requirements usually change rapidly during the development process. They \nare intended to deliver working software quickly to customers, who can then pro-\npose new and changed requirements to be included in later iterations of the sys-\ntem. They aim to cut down on process bureaucracy by avoiding work that has \ndubious long-term value and eliminating documentation that will probably never \nbe used.\nThe philosophy behind agile methods is reflected in the agile manifesto (http://\nagilemanifesto.org) issued by the leading developers of these methods. This mani-\nfesto states:\n\n\n76  Chapter 3 \u25a0 Agile software development\nWe are uncovering better ways of developing software by doing it and helping \nothers do it. Through this work we have come to value:\nIndividuals and interactions over processes and tools \nWorking software over comprehensive documentation \nCustomer collaboration over contract negotiation \nResponding to change over following a plan\nThat is, while there is value in the items on the right, we value the items on the \nleft more\u2020.\nAll agile methods suggest that software should be developed and delivered incre-\nmentally. These methods are based on different agile processes but they share a set \nof principles, based on the agile manifesto, and so they have much in common. I \nhave listed these principles in Figure 3.2.\nAgile methods have been particularly successful for two kinds of system  development.\n1. Product development where a software company is developing a small or \nmedium-sized product for sale. Virtually all software products and apps are now \ndeveloped using an agile approach.\n2. \nCustom system development within an organization, where there is a clear com-\nmitment from the customer to become involved in the development process and \nwhere there are few external stakeholders and regulations that affect the software.\nAgile methods work well in these situations because it is possible to have con-\ntinuous communications between the product manager or system customer and the \ndevelopment team. The software itself is a stand-alone system rather than tightly \nintegrated with other systems being developed at the same time. Consequently, there \nis no need to coordinate parallel development streams. Small and medium-sized \nPrinciple\nDescription\nCustomer involvement\nCustomers should be closely involved throughout the development process. \nTheir role is provide and prioritize new system requirements and to evaluate \nthe iterations of the system.\nEmbrace change\nExpect the system requirements to change, and so design the system to \naccommodate these changes.\nIncremental delivery\nThe software is developed in increments, with the customer specifying the \nrequirements to be included in each increment.\nMaintain simplicity\nFocus on simplicity in both the software being developed and in the \ndevelopment process. Wherever possible, actively work to eliminate \ncomplexity from the system.\nPeople, not process\nThe skills of the development team should be recognized and exploited. \nTeam members should be left to develop their own ways of working without \nprescriptive processes.\nFigure 3.2 The \nprinciples of agile \nmethods\n\u2020http://agilemanifesto.org/"}
{"query": "What led to the development of agile methods in software development?", "response": "Dissatisfaction with heavyweight approaches to software engineering led to the development of agile methods in software development. These methods allowed the development team to focus on the software itself rather than on its design and documentation. They were developed as a response to the overhead involved in plan-driven development approaches, which dominated the software development process for small and medium-sized business systems. Agile methods aimed to deliver working software quickly to customers and cut down on process bureaucracy by avoiding work with dubious long-term value and eliminating unnecessary documentation.", "context": "3.1 \u25a0 Agile methods  75\nactivities apart from programming and testing. It is perfectly feasible, in a plan-driven \nprocess, to allocate requirements and plan the design and development phase as a \nseries of increments. An agile process is not inevitably code-focused, and it may \n produce some design documentation. Agile developers may decide that an iteration \nshould not produce new code but rather should produce system models and documentation.\n \n3.1 Agile methods\nIn the 1980s and early 1990s, there was a widespread view that the best way to \nachieve better software was through careful project planning, formalized quality \nassurance, use of analysis and design methods supported by software tools, and con-\ntrolled and rigorous software development processes. This view came from the soft-\nware engineering community that was responsible for developing large, long-lived \nsoftware systems such as aerospace and government systems.\nThis plan-driven approach was developed for software developed by large teams, \nworking for different companies. Teams were often geographically dispersed and \nworked on the software for long periods of time. An example of this type of software \nis the control systems for a modern aircraft, which might take up to 10 years from \ninitial specification to deployment. Plan-driven approaches involve a significant \noverhead in planning, designing, and documenting the system. This overhead is jus-\ntified when the work of multiple development teams has to be coordinated, when the \nsystem is a critical system, and when many different people will be involved in \nmaintaining the software over its lifetime.\nHowever, when this heavyweight, plan-driven development approach is applied \nto small and medium-sized business systems, the overhead involved is so large that \nit dominates the software development process. More time is spent on how the sys-\ntem should be developed than on program development and testing. As the system \nrequirements change, rework is essential and, in principle at least, the specification \nand design have to change with the program.\nDissatisfaction with these heavyweight approaches to software engineering \nled to the development of agile methods in the late 1990s. These methods allowed \nthe development team to focus on the software itself rather than on its design and \ndocumentation. They are best suited to application development where the sys-\ntem requirements usually change rapidly during the development process. They \nare intended to deliver working software quickly to customers, who can then pro-\npose new and changed requirements to be included in later iterations of the sys-\ntem. They aim to cut down on process bureaucracy by avoiding work that has \ndubious long-term value and eliminating documentation that will probably never \nbe used.\nThe philosophy behind agile methods is reflected in the agile manifesto (http://\nagilemanifesto.org) issued by the leading developers of these methods. This mani-\nfesto states:\n\n\n76  Chapter 3 \u25a0 Agile software development\nWe are uncovering better ways of developing software by doing it and helping \nothers do it. Through this work we have come to value:\nIndividuals and interactions over processes and tools \nWorking software over comprehensive documentation \nCustomer collaboration over contract negotiation \nResponding to change over following a plan\nThat is, while there is value in the items on the right, we value the items on the \nleft more\u2020.\nAll agile methods suggest that software should be developed and delivered incre-\nmentally. These methods are based on different agile processes but they share a set \nof principles, based on the agile manifesto, and so they have much in common. I \nhave listed these principles in Figure 3.2.\nAgile methods have been particularly successful for two kinds of system  development.\n1. Product development where a software company is developing a small or \nmedium-sized product for sale. Virtually all software products and apps are now \ndeveloped using an agile approach.\n2. \nCustom system development within an organization, where there is a clear com-\nmitment from the customer to become involved in the development process and \nwhere there are few external stakeholders and regulations that affect the software.\nAgile methods work well in these situations because it is possible to have con-\ntinuous communications between the product manager or system customer and the \ndevelopment team. The software itself is a stand-alone system rather than tightly \nintegrated with other systems being developed at the same time. Consequently, there \nis no need to coordinate parallel development streams. Small and medium-sized \nPrinciple\nDescription\nCustomer involvement\nCustomers should be closely involved throughout the development process. \nTheir role is provide and prioritize new system requirements and to evaluate \nthe iterations of the system.\nEmbrace change\nExpect the system requirements to change, and so design the system to \naccommodate these changes.\nIncremental delivery\nThe software is developed in increments, with the customer specifying the \nrequirements to be included in each increment.\nMaintain simplicity\nFocus on simplicity in both the software being developed and in the \ndevelopment process. Wherever possible, actively work to eliminate \ncomplexity from the system.\nPeople, not process\nThe skills of the development team should be recognized and exploited. \nTeam members should be left to develop their own ways of working without \nprescriptive processes.\nFigure 3.2 The \nprinciples of agile \nmethods\n\u2020http://agilemanifesto.org/"}
{"query": "What is the main focus of the development team when using agile methods?", "response": "The main focus of the development team when using agile methods is on the software itself rather than on its design and documentation.", "context": "3.1 \u25a0 Agile methods  75\nactivities apart from programming and testing. It is perfectly feasible, in a plan-driven \nprocess, to allocate requirements and plan the design and development phase as a \nseries of increments. An agile process is not inevitably code-focused, and it may \n produce some design documentation. Agile developers may decide that an iteration \nshould not produce new code but rather should produce system models and documentation.\n \n3.1 Agile methods\nIn the 1980s and early 1990s, there was a widespread view that the best way to \nachieve better software was through careful project planning, formalized quality \nassurance, use of analysis and design methods supported by software tools, and con-\ntrolled and rigorous software development processes. This view came from the soft-\nware engineering community that was responsible for developing large, long-lived \nsoftware systems such as aerospace and government systems.\nThis plan-driven approach was developed for software developed by large teams, \nworking for different companies. Teams were often geographically dispersed and \nworked on the software for long periods of time. An example of this type of software \nis the control systems for a modern aircraft, which might take up to 10 years from \ninitial specification to deployment. Plan-driven approaches involve a significant \noverhead in planning, designing, and documenting the system. This overhead is jus-\ntified when the work of multiple development teams has to be coordinated, when the \nsystem is a critical system, and when many different people will be involved in \nmaintaining the software over its lifetime.\nHowever, when this heavyweight, plan-driven development approach is applied \nto small and medium-sized business systems, the overhead involved is so large that \nit dominates the software development process. More time is spent on how the sys-\ntem should be developed than on program development and testing. As the system \nrequirements change, rework is essential and, in principle at least, the specification \nand design have to change with the program.\nDissatisfaction with these heavyweight approaches to software engineering \nled to the development of agile methods in the late 1990s. These methods allowed \nthe development team to focus on the software itself rather than on its design and \ndocumentation. They are best suited to application development where the sys-\ntem requirements usually change rapidly during the development process. They \nare intended to deliver working software quickly to customers, who can then pro-\npose new and changed requirements to be included in later iterations of the sys-\ntem. They aim to cut down on process bureaucracy by avoiding work that has \ndubious long-term value and eliminating documentation that will probably never \nbe used.\nThe philosophy behind agile methods is reflected in the agile manifesto (http://\nagilemanifesto.org) issued by the leading developers of these methods. This mani-\nfesto states:\n\n\n76  Chapter 3 \u25a0 Agile software development\nWe are uncovering better ways of developing software by doing it and helping \nothers do it. Through this work we have come to value:\nIndividuals and interactions over processes and tools \nWorking software over comprehensive documentation \nCustomer collaboration over contract negotiation \nResponding to change over following a plan\nThat is, while there is value in the items on the right, we value the items on the \nleft more\u2020.\nAll agile methods suggest that software should be developed and delivered incre-\nmentally. These methods are based on different agile processes but they share a set \nof principles, based on the agile manifesto, and so they have much in common. I \nhave listed these principles in Figure 3.2.\nAgile methods have been particularly successful for two kinds of system  development.\n1. Product development where a software company is developing a small or \nmedium-sized product for sale. Virtually all software products and apps are now \ndeveloped using an agile approach.\n2. \nCustom system development within an organization, where there is a clear com-\nmitment from the customer to become involved in the development process and \nwhere there are few external stakeholders and regulations that affect the software.\nAgile methods work well in these situations because it is possible to have con-\ntinuous communications between the product manager or system customer and the \ndevelopment team. The software itself is a stand-alone system rather than tightly \nintegrated with other systems being developed at the same time. Consequently, there \nis no need to coordinate parallel development streams. Small and medium-sized \nPrinciple\nDescription\nCustomer involvement\nCustomers should be closely involved throughout the development process. \nTheir role is provide and prioritize new system requirements and to evaluate \nthe iterations of the system.\nEmbrace change\nExpect the system requirements to change, and so design the system to \naccommodate these changes.\nIncremental delivery\nThe software is developed in increments, with the customer specifying the \nrequirements to be included in each increment.\nMaintain simplicity\nFocus on simplicity in both the software being developed and in the \ndevelopment process. Wherever possible, actively work to eliminate \ncomplexity from the system.\nPeople, not process\nThe skills of the development team should be recognized and exploited. \nTeam members should be left to develop their own ways of working without \nprescriptive processes.\nFigure 3.2 The \nprinciples of agile \nmethods\n\u2020http://agilemanifesto.org/"}
{"query": "What are the benefits of using agile methods in application development?", "response": "Agile methods in application development offer several benefits. Firstly, they allow the development team to focus on the software itself rather than spending excessive time on design and documentation. This enables the team to deliver working software quickly to customers. Secondly, agile methods are well-suited for application development where system requirements tend to change rapidly during the development process. By embracing change, agile methods enable the development team to accommodate these changes effectively. Additionally, agile methods aim to cut down on process bureaucracy and eliminate documentation that is unlikely to be used, thus reducing unnecessary overhead. Finally, agile methods promote customer collaboration, allowing for continuous communication between the product manager or system customer and the development team. This involvement of customers throughout the development process helps in providing and prioritizing new system requirements and evaluating the iterations of the system.", "context": "3.1 \u25a0 Agile methods  75\nactivities apart from programming and testing. It is perfectly feasible, in a plan-driven \nprocess, to allocate requirements and plan the design and development phase as a \nseries of increments. An agile process is not inevitably code-focused, and it may \n produce some design documentation. Agile developers may decide that an iteration \nshould not produce new code but rather should produce system models and documentation.\n \n3.1 Agile methods\nIn the 1980s and early 1990s, there was a widespread view that the best way to \nachieve better software was through careful project planning, formalized quality \nassurance, use of analysis and design methods supported by software tools, and con-\ntrolled and rigorous software development processes. This view came from the soft-\nware engineering community that was responsible for developing large, long-lived \nsoftware systems such as aerospace and government systems.\nThis plan-driven approach was developed for software developed by large teams, \nworking for different companies. Teams were often geographically dispersed and \nworked on the software for long periods of time. An example of this type of software \nis the control systems for a modern aircraft, which might take up to 10 years from \ninitial specification to deployment. Plan-driven approaches involve a significant \noverhead in planning, designing, and documenting the system. This overhead is jus-\ntified when the work of multiple development teams has to be coordinated, when the \nsystem is a critical system, and when many different people will be involved in \nmaintaining the software over its lifetime.\nHowever, when this heavyweight, plan-driven development approach is applied \nto small and medium-sized business systems, the overhead involved is so large that \nit dominates the software development process. More time is spent on how the sys-\ntem should be developed than on program development and testing. As the system \nrequirements change, rework is essential and, in principle at least, the specification \nand design have to change with the program.\nDissatisfaction with these heavyweight approaches to software engineering \nled to the development of agile methods in the late 1990s. These methods allowed \nthe development team to focus on the software itself rather than on its design and \ndocumentation. They are best suited to application development where the sys-\ntem requirements usually change rapidly during the development process. They \nare intended to deliver working software quickly to customers, who can then pro-\npose new and changed requirements to be included in later iterations of the sys-\ntem. They aim to cut down on process bureaucracy by avoiding work that has \ndubious long-term value and eliminating documentation that will probably never \nbe used.\nThe philosophy behind agile methods is reflected in the agile manifesto (http://\nagilemanifesto.org) issued by the leading developers of these methods. This mani-\nfesto states:\n\n\n76  Chapter 3 \u25a0 Agile software development\nWe are uncovering better ways of developing software by doing it and helping \nothers do it. Through this work we have come to value:\nIndividuals and interactions over processes and tools \nWorking software over comprehensive documentation \nCustomer collaboration over contract negotiation \nResponding to change over following a plan\nThat is, while there is value in the items on the right, we value the items on the \nleft more\u2020.\nAll agile methods suggest that software should be developed and delivered incre-\nmentally. These methods are based on different agile processes but they share a set \nof principles, based on the agile manifesto, and so they have much in common. I \nhave listed these principles in Figure 3.2.\nAgile methods have been particularly successful for two kinds of system  development.\n1. Product development where a software company is developing a small or \nmedium-sized product for sale. Virtually all software products and apps are now \ndeveloped using an agile approach.\n2. \nCustom system development within an organization, where there is a clear com-\nmitment from the customer to become involved in the development process and \nwhere there are few external stakeholders and regulations that affect the software.\nAgile methods work well in these situations because it is possible to have con-\ntinuous communications between the product manager or system customer and the \ndevelopment team. The software itself is a stand-alone system rather than tightly \nintegrated with other systems being developed at the same time. Consequently, there \nis no need to coordinate parallel development streams. Small and medium-sized \nPrinciple\nDescription\nCustomer involvement\nCustomers should be closely involved throughout the development process. \nTheir role is provide and prioritize new system requirements and to evaluate \nthe iterations of the system.\nEmbrace change\nExpect the system requirements to change, and so design the system to \naccommodate these changes.\nIncremental delivery\nThe software is developed in increments, with the customer specifying the \nrequirements to be included in each increment.\nMaintain simplicity\nFocus on simplicity in both the software being developed and in the \ndevelopment process. Wherever possible, actively work to eliminate \ncomplexity from the system.\nPeople, not process\nThe skills of the development team should be recognized and exploited. \nTeam members should be left to develop their own ways of working without \nprescriptive processes.\nFigure 3.2 The \nprinciples of agile \nmethods\n\u2020http://agilemanifesto.org/"}
{"query": "What is the agile manifesto and what does it state?", "response": "The agile manifesto is a document issued by the leading developers of agile methods. It states that while there is value in processes and tools, comprehensive documentation, contract negotiation, and following a plan, the manifesto values individuals and interactions, working software, customer collaboration, and responding to change more. In other words, it emphasizes the importance of focusing on people and their interactions, delivering working software, collaborating with customers, and being adaptable to change.", "context": "3.1 \u25a0 Agile methods  75\nactivities apart from programming and testing. It is perfectly feasible, in a plan-driven \nprocess, to allocate requirements and plan the design and development phase as a \nseries of increments. An agile process is not inevitably code-focused, and it may \n produce some design documentation. Agile developers may decide that an iteration \nshould not produce new code but rather should produce system models and documentation.\n \n3.1 Agile methods\nIn the 1980s and early 1990s, there was a widespread view that the best way to \nachieve better software was through careful project planning, formalized quality \nassurance, use of analysis and design methods supported by software tools, and con-\ntrolled and rigorous software development processes. This view came from the soft-\nware engineering community that was responsible for developing large, long-lived \nsoftware systems such as aerospace and government systems.\nThis plan-driven approach was developed for software developed by large teams, \nworking for different companies. Teams were often geographically dispersed and \nworked on the software for long periods of time. An example of this type of software \nis the control systems for a modern aircraft, which might take up to 10 years from \ninitial specification to deployment. Plan-driven approaches involve a significant \noverhead in planning, designing, and documenting the system. This overhead is jus-\ntified when the work of multiple development teams has to be coordinated, when the \nsystem is a critical system, and when many different people will be involved in \nmaintaining the software over its lifetime.\nHowever, when this heavyweight, plan-driven development approach is applied \nto small and medium-sized business systems, the overhead involved is so large that \nit dominates the software development process. More time is spent on how the sys-\ntem should be developed than on program development and testing. As the system \nrequirements change, rework is essential and, in principle at least, the specification \nand design have to change with the program.\nDissatisfaction with these heavyweight approaches to software engineering \nled to the development of agile methods in the late 1990s. These methods allowed \nthe development team to focus on the software itself rather than on its design and \ndocumentation. They are best suited to application development where the sys-\ntem requirements usually change rapidly during the development process. They \nare intended to deliver working software quickly to customers, who can then pro-\npose new and changed requirements to be included in later iterations of the sys-\ntem. They aim to cut down on process bureaucracy by avoiding work that has \ndubious long-term value and eliminating documentation that will probably never \nbe used.\nThe philosophy behind agile methods is reflected in the agile manifesto (http://\nagilemanifesto.org) issued by the leading developers of these methods. This mani-\nfesto states:\n\n\n76  Chapter 3 \u25a0 Agile software development\nWe are uncovering better ways of developing software by doing it and helping \nothers do it. Through this work we have come to value:\nIndividuals and interactions over processes and tools \nWorking software over comprehensive documentation \nCustomer collaboration over contract negotiation \nResponding to change over following a plan\nThat is, while there is value in the items on the right, we value the items on the \nleft more\u2020.\nAll agile methods suggest that software should be developed and delivered incre-\nmentally. These methods are based on different agile processes but they share a set \nof principles, based on the agile manifesto, and so they have much in common. I \nhave listed these principles in Figure 3.2.\nAgile methods have been particularly successful for two kinds of system  development.\n1. Product development where a software company is developing a small or \nmedium-sized product for sale. Virtually all software products and apps are now \ndeveloped using an agile approach.\n2. \nCustom system development within an organization, where there is a clear com-\nmitment from the customer to become involved in the development process and \nwhere there are few external stakeholders and regulations that affect the software.\nAgile methods work well in these situations because it is possible to have con-\ntinuous communications between the product manager or system customer and the \ndevelopment team. The software itself is a stand-alone system rather than tightly \nintegrated with other systems being developed at the same time. Consequently, there \nis no need to coordinate parallel development streams. Small and medium-sized \nPrinciple\nDescription\nCustomer involvement\nCustomers should be closely involved throughout the development process. \nTheir role is provide and prioritize new system requirements and to evaluate \nthe iterations of the system.\nEmbrace change\nExpect the system requirements to change, and so design the system to \naccommodate these changes.\nIncremental delivery\nThe software is developed in increments, with the customer specifying the \nrequirements to be included in each increment.\nMaintain simplicity\nFocus on simplicity in both the software being developed and in the \ndevelopment process. Wherever possible, actively work to eliminate \ncomplexity from the system.\nPeople, not process\nThe skills of the development team should be recognized and exploited. \nTeam members should be left to develop their own ways of working without \nprescriptive processes.\nFigure 3.2 The \nprinciples of agile \nmethods\n\u2020http://agilemanifesto.org/"}
{"query": "How is software developed and delivered according to agile methods?", "response": "Software is developed and delivered incrementally according to agile methods. Agile methods emphasize continuous communication and collaboration between the development team and the customer. The software is developed in increments, with the customer specifying the requirements to be included in each increment. This allows for flexibility and the ability to accommodate changes in the system requirements. Agile methods also prioritize working software over comprehensive documentation, focusing on simplicity and eliminating complexity from the system. The skills of the development team are recognized and exploited, allowing team members to develop their own ways of working without prescriptive processes.", "context": "3.1 \u25a0 Agile methods  75\nactivities apart from programming and testing. It is perfectly feasible, in a plan-driven \nprocess, to allocate requirements and plan the design and development phase as a \nseries of increments. An agile process is not inevitably code-focused, and it may \n produce some design documentation. Agile developers may decide that an iteration \nshould not produce new code but rather should produce system models and documentation.\n \n3.1 Agile methods\nIn the 1980s and early 1990s, there was a widespread view that the best way to \nachieve better software was through careful project planning, formalized quality \nassurance, use of analysis and design methods supported by software tools, and con-\ntrolled and rigorous software development processes. This view came from the soft-\nware engineering community that was responsible for developing large, long-lived \nsoftware systems such as aerospace and government systems.\nThis plan-driven approach was developed for software developed by large teams, \nworking for different companies. Teams were often geographically dispersed and \nworked on the software for long periods of time. An example of this type of software \nis the control systems for a modern aircraft, which might take up to 10 years from \ninitial specification to deployment. Plan-driven approaches involve a significant \noverhead in planning, designing, and documenting the system. This overhead is jus-\ntified when the work of multiple development teams has to be coordinated, when the \nsystem is a critical system, and when many different people will be involved in \nmaintaining the software over its lifetime.\nHowever, when this heavyweight, plan-driven development approach is applied \nto small and medium-sized business systems, the overhead involved is so large that \nit dominates the software development process. More time is spent on how the sys-\ntem should be developed than on program development and testing. As the system \nrequirements change, rework is essential and, in principle at least, the specification \nand design have to change with the program.\nDissatisfaction with these heavyweight approaches to software engineering \nled to the development of agile methods in the late 1990s. These methods allowed \nthe development team to focus on the software itself rather than on its design and \ndocumentation. They are best suited to application development where the sys-\ntem requirements usually change rapidly during the development process. They \nare intended to deliver working software quickly to customers, who can then pro-\npose new and changed requirements to be included in later iterations of the sys-\ntem. They aim to cut down on process bureaucracy by avoiding work that has \ndubious long-term value and eliminating documentation that will probably never \nbe used.\nThe philosophy behind agile methods is reflected in the agile manifesto (http://\nagilemanifesto.org) issued by the leading developers of these methods. This mani-\nfesto states:\n\n\n76  Chapter 3 \u25a0 Agile software development\nWe are uncovering better ways of developing software by doing it and helping \nothers do it. Through this work we have come to value:\nIndividuals and interactions over processes and tools \nWorking software over comprehensive documentation \nCustomer collaboration over contract negotiation \nResponding to change over following a plan\nThat is, while there is value in the items on the right, we value the items on the \nleft more\u2020.\nAll agile methods suggest that software should be developed and delivered incre-\nmentally. These methods are based on different agile processes but they share a set \nof principles, based on the agile manifesto, and so they have much in common. I \nhave listed these principles in Figure 3.2.\nAgile methods have been particularly successful for two kinds of system  development.\n1. Product development where a software company is developing a small or \nmedium-sized product for sale. Virtually all software products and apps are now \ndeveloped using an agile approach.\n2. \nCustom system development within an organization, where there is a clear com-\nmitment from the customer to become involved in the development process and \nwhere there are few external stakeholders and regulations that affect the software.\nAgile methods work well in these situations because it is possible to have con-\ntinuous communications between the product manager or system customer and the \ndevelopment team. The software itself is a stand-alone system rather than tightly \nintegrated with other systems being developed at the same time. Consequently, there \nis no need to coordinate parallel development streams. Small and medium-sized \nPrinciple\nDescription\nCustomer involvement\nCustomers should be closely involved throughout the development process. \nTheir role is provide and prioritize new system requirements and to evaluate \nthe iterations of the system.\nEmbrace change\nExpect the system requirements to change, and so design the system to \naccommodate these changes.\nIncremental delivery\nThe software is developed in increments, with the customer specifying the \nrequirements to be included in each increment.\nMaintain simplicity\nFocus on simplicity in both the software being developed and in the \ndevelopment process. Wherever possible, actively work to eliminate \ncomplexity from the system.\nPeople, not process\nThe skills of the development team should be recognized and exploited. \nTeam members should be left to develop their own ways of working without \nprescriptive processes.\nFigure 3.2 The \nprinciples of agile \nmethods\n\u2020http://agilemanifesto.org/"}
{"query": "What are some of the principles of agile methods?", "response": "Some of the principles of agile methods include customer involvement, embracing change, incremental delivery, maintaining simplicity, and focusing on people rather than processes.", "context": "3.1 \u25a0 Agile methods  75\nactivities apart from programming and testing. It is perfectly feasible, in a plan-driven \nprocess, to allocate requirements and plan the design and development phase as a \nseries of increments. An agile process is not inevitably code-focused, and it may \n produce some design documentation. Agile developers may decide that an iteration \nshould not produce new code but rather should produce system models and documentation.\n \n3.1 Agile methods\nIn the 1980s and early 1990s, there was a widespread view that the best way to \nachieve better software was through careful project planning, formalized quality \nassurance, use of analysis and design methods supported by software tools, and con-\ntrolled and rigorous software development processes. This view came from the soft-\nware engineering community that was responsible for developing large, long-lived \nsoftware systems such as aerospace and government systems.\nThis plan-driven approach was developed for software developed by large teams, \nworking for different companies. Teams were often geographically dispersed and \nworked on the software for long periods of time. An example of this type of software \nis the control systems for a modern aircraft, which might take up to 10 years from \ninitial specification to deployment. Plan-driven approaches involve a significant \noverhead in planning, designing, and documenting the system. This overhead is jus-\ntified when the work of multiple development teams has to be coordinated, when the \nsystem is a critical system, and when many different people will be involved in \nmaintaining the software over its lifetime.\nHowever, when this heavyweight, plan-driven development approach is applied \nto small and medium-sized business systems, the overhead involved is so large that \nit dominates the software development process. More time is spent on how the sys-\ntem should be developed than on program development and testing. As the system \nrequirements change, rework is essential and, in principle at least, the specification \nand design have to change with the program.\nDissatisfaction with these heavyweight approaches to software engineering \nled to the development of agile methods in the late 1990s. These methods allowed \nthe development team to focus on the software itself rather than on its design and \ndocumentation. They are best suited to application development where the sys-\ntem requirements usually change rapidly during the development process. They \nare intended to deliver working software quickly to customers, who can then pro-\npose new and changed requirements to be included in later iterations of the sys-\ntem. They aim to cut down on process bureaucracy by avoiding work that has \ndubious long-term value and eliminating documentation that will probably never \nbe used.\nThe philosophy behind agile methods is reflected in the agile manifesto (http://\nagilemanifesto.org) issued by the leading developers of these methods. This mani-\nfesto states:\n\n\n76  Chapter 3 \u25a0 Agile software development\nWe are uncovering better ways of developing software by doing it and helping \nothers do it. Through this work we have come to value:\nIndividuals and interactions over processes and tools \nWorking software over comprehensive documentation \nCustomer collaboration over contract negotiation \nResponding to change over following a plan\nThat is, while there is value in the items on the right, we value the items on the \nleft more\u2020.\nAll agile methods suggest that software should be developed and delivered incre-\nmentally. These methods are based on different agile processes but they share a set \nof principles, based on the agile manifesto, and so they have much in common. I \nhave listed these principles in Figure 3.2.\nAgile methods have been particularly successful for two kinds of system  development.\n1. Product development where a software company is developing a small or \nmedium-sized product for sale. Virtually all software products and apps are now \ndeveloped using an agile approach.\n2. \nCustom system development within an organization, where there is a clear com-\nmitment from the customer to become involved in the development process and \nwhere there are few external stakeholders and regulations that affect the software.\nAgile methods work well in these situations because it is possible to have con-\ntinuous communications between the product manager or system customer and the \ndevelopment team. The software itself is a stand-alone system rather than tightly \nintegrated with other systems being developed at the same time. Consequently, there \nis no need to coordinate parallel development streams. Small and medium-sized \nPrinciple\nDescription\nCustomer involvement\nCustomers should be closely involved throughout the development process. \nTheir role is provide and prioritize new system requirements and to evaluate \nthe iterations of the system.\nEmbrace change\nExpect the system requirements to change, and so design the system to \naccommodate these changes.\nIncremental delivery\nThe software is developed in increments, with the customer specifying the \nrequirements to be included in each increment.\nMaintain simplicity\nFocus on simplicity in both the software being developed and in the \ndevelopment process. Wherever possible, actively work to eliminate \ncomplexity from the system.\nPeople, not process\nThe skills of the development team should be recognized and exploited. \nTeam members should be left to develop their own ways of working without \nprescriptive processes.\nFigure 3.2 The \nprinciples of agile \nmethods\n\u2020http://agilemanifesto.org/"}
{"query": "In what kind of system development have agile methods been particularly successful?", "response": "Agile methods have been particularly successful in two kinds of system development: product development where a software company is developing a small or medium-sized product for sale, and custom system development within an organization where there is a clear commitment from the customer to become involved in the development process and where there are few external stakeholders and regulations that affect the software.", "context": "3.1 \u25a0 Agile methods  75\nactivities apart from programming and testing. It is perfectly feasible, in a plan-driven \nprocess, to allocate requirements and plan the design and development phase as a \nseries of increments. An agile process is not inevitably code-focused, and it may \n produce some design documentation. Agile developers may decide that an iteration \nshould not produce new code but rather should produce system models and documentation.\n \n3.1 Agile methods\nIn the 1980s and early 1990s, there was a widespread view that the best way to \nachieve better software was through careful project planning, formalized quality \nassurance, use of analysis and design methods supported by software tools, and con-\ntrolled and rigorous software development processes. This view came from the soft-\nware engineering community that was responsible for developing large, long-lived \nsoftware systems such as aerospace and government systems.\nThis plan-driven approach was developed for software developed by large teams, \nworking for different companies. Teams were often geographically dispersed and \nworked on the software for long periods of time. An example of this type of software \nis the control systems for a modern aircraft, which might take up to 10 years from \ninitial specification to deployment. Plan-driven approaches involve a significant \noverhead in planning, designing, and documenting the system. This overhead is jus-\ntified when the work of multiple development teams has to be coordinated, when the \nsystem is a critical system, and when many different people will be involved in \nmaintaining the software over its lifetime.\nHowever, when this heavyweight, plan-driven development approach is applied \nto small and medium-sized business systems, the overhead involved is so large that \nit dominates the software development process. More time is spent on how the sys-\ntem should be developed than on program development and testing. As the system \nrequirements change, rework is essential and, in principle at least, the specification \nand design have to change with the program.\nDissatisfaction with these heavyweight approaches to software engineering \nled to the development of agile methods in the late 1990s. These methods allowed \nthe development team to focus on the software itself rather than on its design and \ndocumentation. They are best suited to application development where the sys-\ntem requirements usually change rapidly during the development process. They \nare intended to deliver working software quickly to customers, who can then pro-\npose new and changed requirements to be included in later iterations of the sys-\ntem. They aim to cut down on process bureaucracy by avoiding work that has \ndubious long-term value and eliminating documentation that will probably never \nbe used.\nThe philosophy behind agile methods is reflected in the agile manifesto (http://\nagilemanifesto.org) issued by the leading developers of these methods. This mani-\nfesto states:\n\n\n76  Chapter 3 \u25a0 Agile software development\nWe are uncovering better ways of developing software by doing it and helping \nothers do it. Through this work we have come to value:\nIndividuals and interactions over processes and tools \nWorking software over comprehensive documentation \nCustomer collaboration over contract negotiation \nResponding to change over following a plan\nThat is, while there is value in the items on the right, we value the items on the \nleft more\u2020.\nAll agile methods suggest that software should be developed and delivered incre-\nmentally. These methods are based on different agile processes but they share a set \nof principles, based on the agile manifesto, and so they have much in common. I \nhave listed these principles in Figure 3.2.\nAgile methods have been particularly successful for two kinds of system  development.\n1. Product development where a software company is developing a small or \nmedium-sized product for sale. Virtually all software products and apps are now \ndeveloped using an agile approach.\n2. \nCustom system development within an organization, where there is a clear com-\nmitment from the customer to become involved in the development process and \nwhere there are few external stakeholders and regulations that affect the software.\nAgile methods work well in these situations because it is possible to have con-\ntinuous communications between the product manager or system customer and the \ndevelopment team. The software itself is a stand-alone system rather than tightly \nintegrated with other systems being developed at the same time. Consequently, there \nis no need to coordinate parallel development streams. Small and medium-sized \nPrinciple\nDescription\nCustomer involvement\nCustomers should be closely involved throughout the development process. \nTheir role is provide and prioritize new system requirements and to evaluate \nthe iterations of the system.\nEmbrace change\nExpect the system requirements to change, and so design the system to \naccommodate these changes.\nIncremental delivery\nThe software is developed in increments, with the customer specifying the \nrequirements to be included in each increment.\nMaintain simplicity\nFocus on simplicity in both the software being developed and in the \ndevelopment process. Wherever possible, actively work to eliminate \ncomplexity from the system.\nPeople, not process\nThe skills of the development team should be recognized and exploited. \nTeam members should be left to develop their own ways of working without \nprescriptive processes.\nFigure 3.2 The \nprinciples of agile \nmethods\n\u2020http://agilemanifesto.org/"}
{"query": "Why do agile methods work well in product development and custom system development within an organization?", "response": "Agile methods work well in product development and custom system development within an organization because they allow for continuous communication between the product manager or system customer and the development team. This close involvement of the customer throughout the development process enables them to provide and prioritize new system requirements and evaluate the iterations of the system. Additionally, agile methods embrace change and expect the system requirements to change, allowing for flexibility in accommodating these changes. The incremental delivery approach of agile methods also allows for the software to be developed in increments, with the customer specifying the requirements to be included in each increment. This iterative and collaborative approach helps to ensure that the final product meets the needs and expectations of the customer.", "context": "3.1 \u25a0 Agile methods  75\nactivities apart from programming and testing. It is perfectly feasible, in a plan-driven \nprocess, to allocate requirements and plan the design and development phase as a \nseries of increments. An agile process is not inevitably code-focused, and it may \n produce some design documentation. Agile developers may decide that an iteration \nshould not produce new code but rather should produce system models and documentation.\n \n3.1 Agile methods\nIn the 1980s and early 1990s, there was a widespread view that the best way to \nachieve better software was through careful project planning, formalized quality \nassurance, use of analysis and design methods supported by software tools, and con-\ntrolled and rigorous software development processes. This view came from the soft-\nware engineering community that was responsible for developing large, long-lived \nsoftware systems such as aerospace and government systems.\nThis plan-driven approach was developed for software developed by large teams, \nworking for different companies. Teams were often geographically dispersed and \nworked on the software for long periods of time. An example of this type of software \nis the control systems for a modern aircraft, which might take up to 10 years from \ninitial specification to deployment. Plan-driven approaches involve a significant \noverhead in planning, designing, and documenting the system. This overhead is jus-\ntified when the work of multiple development teams has to be coordinated, when the \nsystem is a critical system, and when many different people will be involved in \nmaintaining the software over its lifetime.\nHowever, when this heavyweight, plan-driven development approach is applied \nto small and medium-sized business systems, the overhead involved is so large that \nit dominates the software development process. More time is spent on how the sys-\ntem should be developed than on program development and testing. As the system \nrequirements change, rework is essential and, in principle at least, the specification \nand design have to change with the program.\nDissatisfaction with these heavyweight approaches to software engineering \nled to the development of agile methods in the late 1990s. These methods allowed \nthe development team to focus on the software itself rather than on its design and \ndocumentation. They are best suited to application development where the sys-\ntem requirements usually change rapidly during the development process. They \nare intended to deliver working software quickly to customers, who can then pro-\npose new and changed requirements to be included in later iterations of the sys-\ntem. They aim to cut down on process bureaucracy by avoiding work that has \ndubious long-term value and eliminating documentation that will probably never \nbe used.\nThe philosophy behind agile methods is reflected in the agile manifesto (http://\nagilemanifesto.org) issued by the leading developers of these methods. This mani-\nfesto states:\n\n\n76  Chapter 3 \u25a0 Agile software development\nWe are uncovering better ways of developing software by doing it and helping \nothers do it. Through this work we have come to value:\nIndividuals and interactions over processes and tools \nWorking software over comprehensive documentation \nCustomer collaboration over contract negotiation \nResponding to change over following a plan\nThat is, while there is value in the items on the right, we value the items on the \nleft more\u2020.\nAll agile methods suggest that software should be developed and delivered incre-\nmentally. These methods are based on different agile processes but they share a set \nof principles, based on the agile manifesto, and so they have much in common. I \nhave listed these principles in Figure 3.2.\nAgile methods have been particularly successful for two kinds of system  development.\n1. Product development where a software company is developing a small or \nmedium-sized product for sale. Virtually all software products and apps are now \ndeveloped using an agile approach.\n2. \nCustom system development within an organization, where there is a clear com-\nmitment from the customer to become involved in the development process and \nwhere there are few external stakeholders and regulations that affect the software.\nAgile methods work well in these situations because it is possible to have con-\ntinuous communications between the product manager or system customer and the \ndevelopment team. The software itself is a stand-alone system rather than tightly \nintegrated with other systems being developed at the same time. Consequently, there \nis no need to coordinate parallel development streams. Small and medium-sized \nPrinciple\nDescription\nCustomer involvement\nCustomers should be closely involved throughout the development process. \nTheir role is provide and prioritize new system requirements and to evaluate \nthe iterations of the system.\nEmbrace change\nExpect the system requirements to change, and so design the system to \naccommodate these changes.\nIncremental delivery\nThe software is developed in increments, with the customer specifying the \nrequirements to be included in each increment.\nMaintain simplicity\nFocus on simplicity in both the software being developed and in the \ndevelopment process. Wherever possible, actively work to eliminate \ncomplexity from the system.\nPeople, not process\nThe skills of the development team should be recognized and exploited. \nTeam members should be left to develop their own ways of working without \nprescriptive processes.\nFigure 3.2 The \nprinciples of agile \nmethods\n\u2020http://agilemanifesto.org/"}
{"query": "What is the role of the customer in the development process according to the principles of agile methods?", "response": "The role of the customer in the development process, according to the principles of agile methods, is to be closely involved throughout the development process. They are responsible for providing and prioritizing new system requirements and evaluating the iterations of the system.", "context": "3.1 \u25a0 Agile methods  75\nactivities apart from programming and testing. It is perfectly feasible, in a plan-driven \nprocess, to allocate requirements and plan the design and development phase as a \nseries of increments. An agile process is not inevitably code-focused, and it may \n produce some design documentation. Agile developers may decide that an iteration \nshould not produce new code but rather should produce system models and documentation.\n \n3.1 Agile methods\nIn the 1980s and early 1990s, there was a widespread view that the best way to \nachieve better software was through careful project planning, formalized quality \nassurance, use of analysis and design methods supported by software tools, and con-\ntrolled and rigorous software development processes. This view came from the soft-\nware engineering community that was responsible for developing large, long-lived \nsoftware systems such as aerospace and government systems.\nThis plan-driven approach was developed for software developed by large teams, \nworking for different companies. Teams were often geographically dispersed and \nworked on the software for long periods of time. An example of this type of software \nis the control systems for a modern aircraft, which might take up to 10 years from \ninitial specification to deployment. Plan-driven approaches involve a significant \noverhead in planning, designing, and documenting the system. This overhead is jus-\ntified when the work of multiple development teams has to be coordinated, when the \nsystem is a critical system, and when many different people will be involved in \nmaintaining the software over its lifetime.\nHowever, when this heavyweight, plan-driven development approach is applied \nto small and medium-sized business systems, the overhead involved is so large that \nit dominates the software development process. More time is spent on how the sys-\ntem should be developed than on program development and testing. As the system \nrequirements change, rework is essential and, in principle at least, the specification \nand design have to change with the program.\nDissatisfaction with these heavyweight approaches to software engineering \nled to the development of agile methods in the late 1990s. These methods allowed \nthe development team to focus on the software itself rather than on its design and \ndocumentation. They are best suited to application development where the sys-\ntem requirements usually change rapidly during the development process. They \nare intended to deliver working software quickly to customers, who can then pro-\npose new and changed requirements to be included in later iterations of the sys-\ntem. They aim to cut down on process bureaucracy by avoiding work that has \ndubious long-term value and eliminating documentation that will probably never \nbe used.\nThe philosophy behind agile methods is reflected in the agile manifesto (http://\nagilemanifesto.org) issued by the leading developers of these methods. This mani-\nfesto states:\n\n\n76  Chapter 3 \u25a0 Agile software development\nWe are uncovering better ways of developing software by doing it and helping \nothers do it. Through this work we have come to value:\nIndividuals and interactions over processes and tools \nWorking software over comprehensive documentation \nCustomer collaboration over contract negotiation \nResponding to change over following a plan\nThat is, while there is value in the items on the right, we value the items on the \nleft more\u2020.\nAll agile methods suggest that software should be developed and delivered incre-\nmentally. These methods are based on different agile processes but they share a set \nof principles, based on the agile manifesto, and so they have much in common. I \nhave listed these principles in Figure 3.2.\nAgile methods have been particularly successful for two kinds of system  development.\n1. Product development where a software company is developing a small or \nmedium-sized product for sale. Virtually all software products and apps are now \ndeveloped using an agile approach.\n2. \nCustom system development within an organization, where there is a clear com-\nmitment from the customer to become involved in the development process and \nwhere there are few external stakeholders and regulations that affect the software.\nAgile methods work well in these situations because it is possible to have con-\ntinuous communications between the product manager or system customer and the \ndevelopment team. The software itself is a stand-alone system rather than tightly \nintegrated with other systems being developed at the same time. Consequently, there \nis no need to coordinate parallel development streams. Small and medium-sized \nPrinciple\nDescription\nCustomer involvement\nCustomers should be closely involved throughout the development process. \nTheir role is provide and prioritize new system requirements and to evaluate \nthe iterations of the system.\nEmbrace change\nExpect the system requirements to change, and so design the system to \naccommodate these changes.\nIncremental delivery\nThe software is developed in increments, with the customer specifying the \nrequirements to be included in each increment.\nMaintain simplicity\nFocus on simplicity in both the software being developed and in the \ndevelopment process. Wherever possible, actively work to eliminate \ncomplexity from the system.\nPeople, not process\nThe skills of the development team should be recognized and exploited. \nTeam members should be left to develop their own ways of working without \nprescriptive processes.\nFigure 3.2 The \nprinciples of agile \nmethods\n\u2020http://agilemanifesto.org/"}
{"query": "How does the principle of embracing change apply in agile methods?", "response": "The principle of embracing change in agile methods means that the development team expects the system requirements to change and designs the system to accommodate these changes. In other words, agile methods recognize that requirements are likely to evolve throughout the development process, and instead of resisting or trying to prevent changes, they embrace them as a natural part of the software development lifecycle. This allows for flexibility and adaptability, enabling the team to respond to new or modified requirements and incorporate them into the system as needed.", "context": "3.1 \u25a0 Agile methods  75\nactivities apart from programming and testing. It is perfectly feasible, in a plan-driven \nprocess, to allocate requirements and plan the design and development phase as a \nseries of increments. An agile process is not inevitably code-focused, and it may \n produce some design documentation. Agile developers may decide that an iteration \nshould not produce new code but rather should produce system models and documentation.\n \n3.1 Agile methods\nIn the 1980s and early 1990s, there was a widespread view that the best way to \nachieve better software was through careful project planning, formalized quality \nassurance, use of analysis and design methods supported by software tools, and con-\ntrolled and rigorous software development processes. This view came from the soft-\nware engineering community that was responsible for developing large, long-lived \nsoftware systems such as aerospace and government systems.\nThis plan-driven approach was developed for software developed by large teams, \nworking for different companies. Teams were often geographically dispersed and \nworked on the software for long periods of time. An example of this type of software \nis the control systems for a modern aircraft, which might take up to 10 years from \ninitial specification to deployment. Plan-driven approaches involve a significant \noverhead in planning, designing, and documenting the system. This overhead is jus-\ntified when the work of multiple development teams has to be coordinated, when the \nsystem is a critical system, and when many different people will be involved in \nmaintaining the software over its lifetime.\nHowever, when this heavyweight, plan-driven development approach is applied \nto small and medium-sized business systems, the overhead involved is so large that \nit dominates the software development process. More time is spent on how the sys-\ntem should be developed than on program development and testing. As the system \nrequirements change, rework is essential and, in principle at least, the specification \nand design have to change with the program.\nDissatisfaction with these heavyweight approaches to software engineering \nled to the development of agile methods in the late 1990s. These methods allowed \nthe development team to focus on the software itself rather than on its design and \ndocumentation. They are best suited to application development where the sys-\ntem requirements usually change rapidly during the development process. They \nare intended to deliver working software quickly to customers, who can then pro-\npose new and changed requirements to be included in later iterations of the sys-\ntem. They aim to cut down on process bureaucracy by avoiding work that has \ndubious long-term value and eliminating documentation that will probably never \nbe used.\nThe philosophy behind agile methods is reflected in the agile manifesto (http://\nagilemanifesto.org) issued by the leading developers of these methods. This mani-\nfesto states:\n\n\n76  Chapter 3 \u25a0 Agile software development\nWe are uncovering better ways of developing software by doing it and helping \nothers do it. Through this work we have come to value:\nIndividuals and interactions over processes and tools \nWorking software over comprehensive documentation \nCustomer collaboration over contract negotiation \nResponding to change over following a plan\nThat is, while there is value in the items on the right, we value the items on the \nleft more\u2020.\nAll agile methods suggest that software should be developed and delivered incre-\nmentally. These methods are based on different agile processes but they share a set \nof principles, based on the agile manifesto, and so they have much in common. I \nhave listed these principles in Figure 3.2.\nAgile methods have been particularly successful for two kinds of system  development.\n1. Product development where a software company is developing a small or \nmedium-sized product for sale. Virtually all software products and apps are now \ndeveloped using an agile approach.\n2. \nCustom system development within an organization, where there is a clear com-\nmitment from the customer to become involved in the development process and \nwhere there are few external stakeholders and regulations that affect the software.\nAgile methods work well in these situations because it is possible to have con-\ntinuous communications between the product manager or system customer and the \ndevelopment team. The software itself is a stand-alone system rather than tightly \nintegrated with other systems being developed at the same time. Consequently, there \nis no need to coordinate parallel development streams. Small and medium-sized \nPrinciple\nDescription\nCustomer involvement\nCustomers should be closely involved throughout the development process. \nTheir role is provide and prioritize new system requirements and to evaluate \nthe iterations of the system.\nEmbrace change\nExpect the system requirements to change, and so design the system to \naccommodate these changes.\nIncremental delivery\nThe software is developed in increments, with the customer specifying the \nrequirements to be included in each increment.\nMaintain simplicity\nFocus on simplicity in both the software being developed and in the \ndevelopment process. Wherever possible, actively work to eliminate \ncomplexity from the system.\nPeople, not process\nThe skills of the development team should be recognized and exploited. \nTeam members should be left to develop their own ways of working without \nprescriptive processes.\nFigure 3.2 The \nprinciples of agile \nmethods\n\u2020http://agilemanifesto.org/"}
{"query": "What is meant by incremental delivery in the context of agile methods?", "response": "Agile methods emphasize incremental delivery, which means that the software is developed and delivered in small increments or iterations. Each increment includes a set of requirements specified by the customer. This approach allows for continuous feedback and collaboration between the development team and the customer. It also enables the customer to prioritize and evaluate each increment, ensuring that the software meets their evolving needs. By delivering working software in increments, agile methods aim to provide value to the customer early and frequently throughout the development process.", "context": "3.1 \u25a0 Agile methods  75\nactivities apart from programming and testing. It is perfectly feasible, in a plan-driven \nprocess, to allocate requirements and plan the design and development phase as a \nseries of increments. An agile process is not inevitably code-focused, and it may \n produce some design documentation. Agile developers may decide that an iteration \nshould not produce new code but rather should produce system models and documentation.\n \n3.1 Agile methods\nIn the 1980s and early 1990s, there was a widespread view that the best way to \nachieve better software was through careful project planning, formalized quality \nassurance, use of analysis and design methods supported by software tools, and con-\ntrolled and rigorous software development processes. This view came from the soft-\nware engineering community that was responsible for developing large, long-lived \nsoftware systems such as aerospace and government systems.\nThis plan-driven approach was developed for software developed by large teams, \nworking for different companies. Teams were often geographically dispersed and \nworked on the software for long periods of time. An example of this type of software \nis the control systems for a modern aircraft, which might take up to 10 years from \ninitial specification to deployment. Plan-driven approaches involve a significant \noverhead in planning, designing, and documenting the system. This overhead is jus-\ntified when the work of multiple development teams has to be coordinated, when the \nsystem is a critical system, and when many different people will be involved in \nmaintaining the software over its lifetime.\nHowever, when this heavyweight, plan-driven development approach is applied \nto small and medium-sized business systems, the overhead involved is so large that \nit dominates the software development process. More time is spent on how the sys-\ntem should be developed than on program development and testing. As the system \nrequirements change, rework is essential and, in principle at least, the specification \nand design have to change with the program.\nDissatisfaction with these heavyweight approaches to software engineering \nled to the development of agile methods in the late 1990s. These methods allowed \nthe development team to focus on the software itself rather than on its design and \ndocumentation. They are best suited to application development where the sys-\ntem requirements usually change rapidly during the development process. They \nare intended to deliver working software quickly to customers, who can then pro-\npose new and changed requirements to be included in later iterations of the sys-\ntem. They aim to cut down on process bureaucracy by avoiding work that has \ndubious long-term value and eliminating documentation that will probably never \nbe used.\nThe philosophy behind agile methods is reflected in the agile manifesto (http://\nagilemanifesto.org) issued by the leading developers of these methods. This mani-\nfesto states:\n\n\n76  Chapter 3 \u25a0 Agile software development\nWe are uncovering better ways of developing software by doing it and helping \nothers do it. Through this work we have come to value:\nIndividuals and interactions over processes and tools \nWorking software over comprehensive documentation \nCustomer collaboration over contract negotiation \nResponding to change over following a plan\nThat is, while there is value in the items on the right, we value the items on the \nleft more\u2020.\nAll agile methods suggest that software should be developed and delivered incre-\nmentally. These methods are based on different agile processes but they share a set \nof principles, based on the agile manifesto, and so they have much in common. I \nhave listed these principles in Figure 3.2.\nAgile methods have been particularly successful for two kinds of system  development.\n1. Product development where a software company is developing a small or \nmedium-sized product for sale. Virtually all software products and apps are now \ndeveloped using an agile approach.\n2. \nCustom system development within an organization, where there is a clear com-\nmitment from the customer to become involved in the development process and \nwhere there are few external stakeholders and regulations that affect the software.\nAgile methods work well in these situations because it is possible to have con-\ntinuous communications between the product manager or system customer and the \ndevelopment team. The software itself is a stand-alone system rather than tightly \nintegrated with other systems being developed at the same time. Consequently, there \nis no need to coordinate parallel development streams. Small and medium-sized \nPrinciple\nDescription\nCustomer involvement\nCustomers should be closely involved throughout the development process. \nTheir role is provide and prioritize new system requirements and to evaluate \nthe iterations of the system.\nEmbrace change\nExpect the system requirements to change, and so design the system to \naccommodate these changes.\nIncremental delivery\nThe software is developed in increments, with the customer specifying the \nrequirements to be included in each increment.\nMaintain simplicity\nFocus on simplicity in both the software being developed and in the \ndevelopment process. Wherever possible, actively work to eliminate \ncomplexity from the system.\nPeople, not process\nThe skills of the development team should be recognized and exploited. \nTeam members should be left to develop their own ways of working without \nprescriptive processes.\nFigure 3.2 The \nprinciples of agile \nmethods\n\u2020http://agilemanifesto.org/"}
{"query": "How is simplicity maintained in both the software being developed and in the development process according to the principles of agile methods?", "response": "The principles of agile methods emphasize maintaining simplicity in both the software being developed and in the development process. This means that the focus is on keeping the software and the development process as simple as possible. Agile methods encourage actively working to eliminate complexity from the system. Additionally, the skills of the development team are recognized and exploited, allowing team members to develop their own ways of working without being bound by prescriptive processes. By embracing simplicity and allowing flexibility in the development process, agile methods aim to streamline the software development process and deliver value quickly.", "context": "3.1 \u25a0 Agile methods  75\nactivities apart from programming and testing. It is perfectly feasible, in a plan-driven \nprocess, to allocate requirements and plan the design and development phase as a \nseries of increments. An agile process is not inevitably code-focused, and it may \n produce some design documentation. Agile developers may decide that an iteration \nshould not produce new code but rather should produce system models and documentation.\n \n3.1 Agile methods\nIn the 1980s and early 1990s, there was a widespread view that the best way to \nachieve better software was through careful project planning, formalized quality \nassurance, use of analysis and design methods supported by software tools, and con-\ntrolled and rigorous software development processes. This view came from the soft-\nware engineering community that was responsible for developing large, long-lived \nsoftware systems such as aerospace and government systems.\nThis plan-driven approach was developed for software developed by large teams, \nworking for different companies. Teams were often geographically dispersed and \nworked on the software for long periods of time. An example of this type of software \nis the control systems for a modern aircraft, which might take up to 10 years from \ninitial specification to deployment. Plan-driven approaches involve a significant \noverhead in planning, designing, and documenting the system. This overhead is jus-\ntified when the work of multiple development teams has to be coordinated, when the \nsystem is a critical system, and when many different people will be involved in \nmaintaining the software over its lifetime.\nHowever, when this heavyweight, plan-driven development approach is applied \nto small and medium-sized business systems, the overhead involved is so large that \nit dominates the software development process. More time is spent on how the sys-\ntem should be developed than on program development and testing. As the system \nrequirements change, rework is essential and, in principle at least, the specification \nand design have to change with the program.\nDissatisfaction with these heavyweight approaches to software engineering \nled to the development of agile methods in the late 1990s. These methods allowed \nthe development team to focus on the software itself rather than on its design and \ndocumentation. They are best suited to application development where the sys-\ntem requirements usually change rapidly during the development process. They \nare intended to deliver working software quickly to customers, who can then pro-\npose new and changed requirements to be included in later iterations of the sys-\ntem. They aim to cut down on process bureaucracy by avoiding work that has \ndubious long-term value and eliminating documentation that will probably never \nbe used.\nThe philosophy behind agile methods is reflected in the agile manifesto (http://\nagilemanifesto.org) issued by the leading developers of these methods. This mani-\nfesto states:\n\n\n76  Chapter 3 \u25a0 Agile software development\nWe are uncovering better ways of developing software by doing it and helping \nothers do it. Through this work we have come to value:\nIndividuals and interactions over processes and tools \nWorking software over comprehensive documentation \nCustomer collaboration over contract negotiation \nResponding to change over following a plan\nThat is, while there is value in the items on the right, we value the items on the \nleft more\u2020.\nAll agile methods suggest that software should be developed and delivered incre-\nmentally. These methods are based on different agile processes but they share a set \nof principles, based on the agile manifesto, and so they have much in common. I \nhave listed these principles in Figure 3.2.\nAgile methods have been particularly successful for two kinds of system  development.\n1. Product development where a software company is developing a small or \nmedium-sized product for sale. Virtually all software products and apps are now \ndeveloped using an agile approach.\n2. \nCustom system development within an organization, where there is a clear com-\nmitment from the customer to become involved in the development process and \nwhere there are few external stakeholders and regulations that affect the software.\nAgile methods work well in these situations because it is possible to have con-\ntinuous communications between the product manager or system customer and the \ndevelopment team. The software itself is a stand-alone system rather than tightly \nintegrated with other systems being developed at the same time. Consequently, there \nis no need to coordinate parallel development streams. Small and medium-sized \nPrinciple\nDescription\nCustomer involvement\nCustomers should be closely involved throughout the development process. \nTheir role is provide and prioritize new system requirements and to evaluate \nthe iterations of the system.\nEmbrace change\nExpect the system requirements to change, and so design the system to \naccommodate these changes.\nIncremental delivery\nThe software is developed in increments, with the customer specifying the \nrequirements to be included in each increment.\nMaintain simplicity\nFocus on simplicity in both the software being developed and in the \ndevelopment process. Wherever possible, actively work to eliminate \ncomplexity from the system.\nPeople, not process\nThe skills of the development team should be recognized and exploited. \nTeam members should be left to develop their own ways of working without \nprescriptive processes.\nFigure 3.2 The \nprinciples of agile \nmethods\n\u2020http://agilemanifesto.org/"}
{"query": "What is the principle of \"people, not process\" in agile methods?", "response": "The principle of \"people, not process\" in agile methods emphasizes the importance of recognizing and utilizing the skills of the development team. It suggests that team members should be given the freedom to develop their own ways of working without being bound by prescriptive processes. This principle values the expertise and autonomy of individuals in the development team, allowing them to find the most effective and efficient ways to deliver the software.", "context": "3.1 \u25a0 Agile methods  75\nactivities apart from programming and testing. It is perfectly feasible, in a plan-driven \nprocess, to allocate requirements and plan the design and development phase as a \nseries of increments. An agile process is not inevitably code-focused, and it may \n produce some design documentation. Agile developers may decide that an iteration \nshould not produce new code but rather should produce system models and documentation.\n \n3.1 Agile methods\nIn the 1980s and early 1990s, there was a widespread view that the best way to \nachieve better software was through careful project planning, formalized quality \nassurance, use of analysis and design methods supported by software tools, and con-\ntrolled and rigorous software development processes. This view came from the soft-\nware engineering community that was responsible for developing large, long-lived \nsoftware systems such as aerospace and government systems.\nThis plan-driven approach was developed for software developed by large teams, \nworking for different companies. Teams were often geographically dispersed and \nworked on the software for long periods of time. An example of this type of software \nis the control systems for a modern aircraft, which might take up to 10 years from \ninitial specification to deployment. Plan-driven approaches involve a significant \noverhead in planning, designing, and documenting the system. This overhead is jus-\ntified when the work of multiple development teams has to be coordinated, when the \nsystem is a critical system, and when many different people will be involved in \nmaintaining the software over its lifetime.\nHowever, when this heavyweight, plan-driven development approach is applied \nto small and medium-sized business systems, the overhead involved is so large that \nit dominates the software development process. More time is spent on how the sys-\ntem should be developed than on program development and testing. As the system \nrequirements change, rework is essential and, in principle at least, the specification \nand design have to change with the program.\nDissatisfaction with these heavyweight approaches to software engineering \nled to the development of agile methods in the late 1990s. These methods allowed \nthe development team to focus on the software itself rather than on its design and \ndocumentation. They are best suited to application development where the sys-\ntem requirements usually change rapidly during the development process. They \nare intended to deliver working software quickly to customers, who can then pro-\npose new and changed requirements to be included in later iterations of the sys-\ntem. They aim to cut down on process bureaucracy by avoiding work that has \ndubious long-term value and eliminating documentation that will probably never \nbe used.\nThe philosophy behind agile methods is reflected in the agile manifesto (http://\nagilemanifesto.org) issued by the leading developers of these methods. This mani-\nfesto states:\n\n\n76  Chapter 3 \u25a0 Agile software development\nWe are uncovering better ways of developing software by doing it and helping \nothers do it. Through this work we have come to value:\nIndividuals and interactions over processes and tools \nWorking software over comprehensive documentation \nCustomer collaboration over contract negotiation \nResponding to change over following a plan\nThat is, while there is value in the items on the right, we value the items on the \nleft more\u2020.\nAll agile methods suggest that software should be developed and delivered incre-\nmentally. These methods are based on different agile processes but they share a set \nof principles, based on the agile manifesto, and so they have much in common. I \nhave listed these principles in Figure 3.2.\nAgile methods have been particularly successful for two kinds of system  development.\n1. Product development where a software company is developing a small or \nmedium-sized product for sale. Virtually all software products and apps are now \ndeveloped using an agile approach.\n2. \nCustom system development within an organization, where there is a clear com-\nmitment from the customer to become involved in the development process and \nwhere there are few external stakeholders and regulations that affect the software.\nAgile methods work well in these situations because it is possible to have con-\ntinuous communications between the product manager or system customer and the \ndevelopment team. The software itself is a stand-alone system rather than tightly \nintegrated with other systems being developed at the same time. Consequently, there \nis no need to coordinate parallel development streams. Small and medium-sized \nPrinciple\nDescription\nCustomer involvement\nCustomers should be closely involved throughout the development process. \nTheir role is provide and prioritize new system requirements and to evaluate \nthe iterations of the system.\nEmbrace change\nExpect the system requirements to change, and so design the system to \naccommodate these changes.\nIncremental delivery\nThe software is developed in increments, with the customer specifying the \nrequirements to be included in each increment.\nMaintain simplicity\nFocus on simplicity in both the software being developed and in the \ndevelopment process. Wherever possible, actively work to eliminate \ncomplexity from the system.\nPeople, not process\nThe skills of the development team should be recognized and exploited. \nTeam members should be left to develop their own ways of working without \nprescriptive processes.\nFigure 3.2 The \nprinciples of agile \nmethods\n\u2020http://agilemanifesto.org/"}
{"query": "What is the significance of the agile manifesto in the development of agile methods?", "response": "The agile manifesto is significant in the development of agile methods because it reflects the philosophy and values behind these methods. It emphasizes the importance of individuals and interactions, working software, customer collaboration, and responding to change. The manifesto highlights the shift in focus from processes and tools to the actual development of software. It serves as a guiding principle for agile methods and helps shape their approach to software development.", "context": "3.1 \u25a0 Agile methods  75\nactivities apart from programming and testing. It is perfectly feasible, in a plan-driven \nprocess, to allocate requirements and plan the design and development phase as a \nseries of increments. An agile process is not inevitably code-focused, and it may \n produce some design documentation. Agile developers may decide that an iteration \nshould not produce new code but rather should produce system models and documentation.\n \n3.1 Agile methods\nIn the 1980s and early 1990s, there was a widespread view that the best way to \nachieve better software was through careful project planning, formalized quality \nassurance, use of analysis and design methods supported by software tools, and con-\ntrolled and rigorous software development processes. This view came from the soft-\nware engineering community that was responsible for developing large, long-lived \nsoftware systems such as aerospace and government systems.\nThis plan-driven approach was developed for software developed by large teams, \nworking for different companies. Teams were often geographically dispersed and \nworked on the software for long periods of time. An example of this type of software \nis the control systems for a modern aircraft, which might take up to 10 years from \ninitial specification to deployment. Plan-driven approaches involve a significant \noverhead in planning, designing, and documenting the system. This overhead is jus-\ntified when the work of multiple development teams has to be coordinated, when the \nsystem is a critical system, and when many different people will be involved in \nmaintaining the software over its lifetime.\nHowever, when this heavyweight, plan-driven development approach is applied \nto small and medium-sized business systems, the overhead involved is so large that \nit dominates the software development process. More time is spent on how the sys-\ntem should be developed than on program development and testing. As the system \nrequirements change, rework is essential and, in principle at least, the specification \nand design have to change with the program.\nDissatisfaction with these heavyweight approaches to software engineering \nled to the development of agile methods in the late 1990s. These methods allowed \nthe development team to focus on the software itself rather than on its design and \ndocumentation. They are best suited to application development where the sys-\ntem requirements usually change rapidly during the development process. They \nare intended to deliver working software quickly to customers, who can then pro-\npose new and changed requirements to be included in later iterations of the sys-\ntem. They aim to cut down on process bureaucracy by avoiding work that has \ndubious long-term value and eliminating documentation that will probably never \nbe used.\nThe philosophy behind agile methods is reflected in the agile manifesto (http://\nagilemanifesto.org) issued by the leading developers of these methods. This mani-\nfesto states:\n\n\n76  Chapter 3 \u25a0 Agile software development\nWe are uncovering better ways of developing software by doing it and helping \nothers do it. Through this work we have come to value:\nIndividuals and interactions over processes and tools \nWorking software over comprehensive documentation \nCustomer collaboration over contract negotiation \nResponding to change over following a plan\nThat is, while there is value in the items on the right, we value the items on the \nleft more\u2020.\nAll agile methods suggest that software should be developed and delivered incre-\nmentally. These methods are based on different agile processes but they share a set \nof principles, based on the agile manifesto, and so they have much in common. I \nhave listed these principles in Figure 3.2.\nAgile methods have been particularly successful for two kinds of system  development.\n1. Product development where a software company is developing a small or \nmedium-sized product for sale. Virtually all software products and apps are now \ndeveloped using an agile approach.\n2. \nCustom system development within an organization, where there is a clear com-\nmitment from the customer to become involved in the development process and \nwhere there are few external stakeholders and regulations that affect the software.\nAgile methods work well in these situations because it is possible to have con-\ntinuous communications between the product manager or system customer and the \ndevelopment team. The software itself is a stand-alone system rather than tightly \nintegrated with other systems being developed at the same time. Consequently, there \nis no need to coordinate parallel development streams. Small and medium-sized \nPrinciple\nDescription\nCustomer involvement\nCustomers should be closely involved throughout the development process. \nTheir role is provide and prioritize new system requirements and to evaluate \nthe iterations of the system.\nEmbrace change\nExpect the system requirements to change, and so design the system to \naccommodate these changes.\nIncremental delivery\nThe software is developed in increments, with the customer specifying the \nrequirements to be included in each increment.\nMaintain simplicity\nFocus on simplicity in both the software being developed and in the \ndevelopment process. Wherever possible, actively work to eliminate \ncomplexity from the system.\nPeople, not process\nThe skills of the development team should be recognized and exploited. \nTeam members should be left to develop their own ways of working without \nprescriptive processes.\nFigure 3.2 The \nprinciples of agile \nmethods\n\u2020http://agilemanifesto.org/"}
{"query": "How does the plan-driven approach differ from agile methods in software development?", "response": "The plan-driven approach in software development involves careful project planning, formalized quality assurance, analysis and design methods, and controlled and rigorous development processes. It is typically used for large, long-lived software systems developed by large teams working for different companies. This approach involves significant overhead in planning, designing, and documenting the system. It is justified when multiple development teams need to be coordinated, the system is critical, and many people will be involved in maintaining the software over its lifetime.\n\nOn the other hand, agile methods in software development focus on the software itself rather than its design and documentation. These methods are best suited for application development where system requirements change rapidly. Agile methods aim to deliver working software quickly to customers, who can then propose new and changed requirements to be included in later iterations of the system. They cut down on process bureaucracy and eliminate documentation that is unlikely to be used. Agile methods emphasize individuals and interactions, working software, customer collaboration, and responding to change over processes and tools, comprehensive documentation, contract negotiation, and following a plan.", "context": "3.1 \u25a0 Agile methods  75\nactivities apart from programming and testing. It is perfectly feasible, in a plan-driven \nprocess, to allocate requirements and plan the design and development phase as a \nseries of increments. An agile process is not inevitably code-focused, and it may \n produce some design documentation. Agile developers may decide that an iteration \nshould not produce new code but rather should produce system models and documentation.\n \n3.1 Agile methods\nIn the 1980s and early 1990s, there was a widespread view that the best way to \nachieve better software was through careful project planning, formalized quality \nassurance, use of analysis and design methods supported by software tools, and con-\ntrolled and rigorous software development processes. This view came from the soft-\nware engineering community that was responsible for developing large, long-lived \nsoftware systems such as aerospace and government systems.\nThis plan-driven approach was developed for software developed by large teams, \nworking for different companies. Teams were often geographically dispersed and \nworked on the software for long periods of time. An example of this type of software \nis the control systems for a modern aircraft, which might take up to 10 years from \ninitial specification to deployment. Plan-driven approaches involve a significant \noverhead in planning, designing, and documenting the system. This overhead is jus-\ntified when the work of multiple development teams has to be coordinated, when the \nsystem is a critical system, and when many different people will be involved in \nmaintaining the software over its lifetime.\nHowever, when this heavyweight, plan-driven development approach is applied \nto small and medium-sized business systems, the overhead involved is so large that \nit dominates the software development process. More time is spent on how the sys-\ntem should be developed than on program development and testing. As the system \nrequirements change, rework is essential and, in principle at least, the specification \nand design have to change with the program.\nDissatisfaction with these heavyweight approaches to software engineering \nled to the development of agile methods in the late 1990s. These methods allowed \nthe development team to focus on the software itself rather than on its design and \ndocumentation. They are best suited to application development where the sys-\ntem requirements usually change rapidly during the development process. They \nare intended to deliver working software quickly to customers, who can then pro-\npose new and changed requirements to be included in later iterations of the sys-\ntem. They aim to cut down on process bureaucracy by avoiding work that has \ndubious long-term value and eliminating documentation that will probably never \nbe used.\nThe philosophy behind agile methods is reflected in the agile manifesto (http://\nagilemanifesto.org) issued by the leading developers of these methods. This mani-\nfesto states:\n\n\n76  Chapter 3 \u25a0 Agile software development\nWe are uncovering better ways of developing software by doing it and helping \nothers do it. Through this work we have come to value:\nIndividuals and interactions over processes and tools \nWorking software over comprehensive documentation \nCustomer collaboration over contract negotiation \nResponding to change over following a plan\nThat is, while there is value in the items on the right, we value the items on the \nleft more\u2020.\nAll agile methods suggest that software should be developed and delivered incre-\nmentally. These methods are based on different agile processes but they share a set \nof principles, based on the agile manifesto, and so they have much in common. I \nhave listed these principles in Figure 3.2.\nAgile methods have been particularly successful for two kinds of system  development.\n1. Product development where a software company is developing a small or \nmedium-sized product for sale. Virtually all software products and apps are now \ndeveloped using an agile approach.\n2. \nCustom system development within an organization, where there is a clear com-\nmitment from the customer to become involved in the development process and \nwhere there are few external stakeholders and regulations that affect the software.\nAgile methods work well in these situations because it is possible to have con-\ntinuous communications between the product manager or system customer and the \ndevelopment team. The software itself is a stand-alone system rather than tightly \nintegrated with other systems being developed at the same time. Consequently, there \nis no need to coordinate parallel development streams. Small and medium-sized \nPrinciple\nDescription\nCustomer involvement\nCustomers should be closely involved throughout the development process. \nTheir role is provide and prioritize new system requirements and to evaluate \nthe iterations of the system.\nEmbrace change\nExpect the system requirements to change, and so design the system to \naccommodate these changes.\nIncremental delivery\nThe software is developed in increments, with the customer specifying the \nrequirements to be included in each increment.\nMaintain simplicity\nFocus on simplicity in both the software being developed and in the \ndevelopment process. Wherever possible, actively work to eliminate \ncomplexity from the system.\nPeople, not process\nThe skills of the development team should be recognized and exploited. \nTeam members should be left to develop their own ways of working without \nprescriptive processes.\nFigure 3.2 The \nprinciples of agile \nmethods\n\u2020http://agilemanifesto.org/"}
{"query": "Why is the overhead involved in the plan-driven approach considered justified in certain situations?", "response": "The overhead involved in the plan-driven approach is considered justified in certain situations because it helps in coordinating the work of multiple development teams, especially when they are geographically dispersed and working on the software for long periods of time. Additionally, it is beneficial for critical systems and when many different people will be involved in maintaining the software over its lifetime.", "context": "3.1 \u25a0 Agile methods  75\nactivities apart from programming and testing. It is perfectly feasible, in a plan-driven \nprocess, to allocate requirements and plan the design and development phase as a \nseries of increments. An agile process is not inevitably code-focused, and it may \n produce some design documentation. Agile developers may decide that an iteration \nshould not produce new code but rather should produce system models and documentation.\n \n3.1 Agile methods\nIn the 1980s and early 1990s, there was a widespread view that the best way to \nachieve better software was through careful project planning, formalized quality \nassurance, use of analysis and design methods supported by software tools, and con-\ntrolled and rigorous software development processes. This view came from the soft-\nware engineering community that was responsible for developing large, long-lived \nsoftware systems such as aerospace and government systems.\nThis plan-driven approach was developed for software developed by large teams, \nworking for different companies. Teams were often geographically dispersed and \nworked on the software for long periods of time. An example of this type of software \nis the control systems for a modern aircraft, which might take up to 10 years from \ninitial specification to deployment. Plan-driven approaches involve a significant \noverhead in planning, designing, and documenting the system. This overhead is jus-\ntified when the work of multiple development teams has to be coordinated, when the \nsystem is a critical system, and when many different people will be involved in \nmaintaining the software over its lifetime.\nHowever, when this heavyweight, plan-driven development approach is applied \nto small and medium-sized business systems, the overhead involved is so large that \nit dominates the software development process. More time is spent on how the sys-\ntem should be developed than on program development and testing. As the system \nrequirements change, rework is essential and, in principle at least, the specification \nand design have to change with the program.\nDissatisfaction with these heavyweight approaches to software engineering \nled to the development of agile methods in the late 1990s. These methods allowed \nthe development team to focus on the software itself rather than on its design and \ndocumentation. They are best suited to application development where the sys-\ntem requirements usually change rapidly during the development process. They \nare intended to deliver working software quickly to customers, who can then pro-\npose new and changed requirements to be included in later iterations of the sys-\ntem. They aim to cut down on process bureaucracy by avoiding work that has \ndubious long-term value and eliminating documentation that will probably never \nbe used.\nThe philosophy behind agile methods is reflected in the agile manifesto (http://\nagilemanifesto.org) issued by the leading developers of these methods. This mani-\nfesto states:\n\n\n76  Chapter 3 \u25a0 Agile software development\nWe are uncovering better ways of developing software by doing it and helping \nothers do it. Through this work we have come to value:\nIndividuals and interactions over processes and tools \nWorking software over comprehensive documentation \nCustomer collaboration over contract negotiation \nResponding to change over following a plan\nThat is, while there is value in the items on the right, we value the items on the \nleft more\u2020.\nAll agile methods suggest that software should be developed and delivered incre-\nmentally. These methods are based on different agile processes but they share a set \nof principles, based on the agile manifesto, and so they have much in common. I \nhave listed these principles in Figure 3.2.\nAgile methods have been particularly successful for two kinds of system  development.\n1. Product development where a software company is developing a small or \nmedium-sized product for sale. Virtually all software products and apps are now \ndeveloped using an agile approach.\n2. \nCustom system development within an organization, where there is a clear com-\nmitment from the customer to become involved in the development process and \nwhere there are few external stakeholders and regulations that affect the software.\nAgile methods work well in these situations because it is possible to have con-\ntinuous communications between the product manager or system customer and the \ndevelopment team. The software itself is a stand-alone system rather than tightly \nintegrated with other systems being developed at the same time. Consequently, there \nis no need to coordinate parallel development streams. Small and medium-sized \nPrinciple\nDescription\nCustomer involvement\nCustomers should be closely involved throughout the development process. \nTheir role is provide and prioritize new system requirements and to evaluate \nthe iterations of the system.\nEmbrace change\nExpect the system requirements to change, and so design the system to \naccommodate these changes.\nIncremental delivery\nThe software is developed in increments, with the customer specifying the \nrequirements to be included in each increment.\nMaintain simplicity\nFocus on simplicity in both the software being developed and in the \ndevelopment process. Wherever possible, actively work to eliminate \ncomplexity from the system.\nPeople, not process\nThe skills of the development team should be recognized and exploited. \nTeam members should be left to develop their own ways of working without \nprescriptive processes.\nFigure 3.2 The \nprinciples of agile \nmethods\n\u2020http://agilemanifesto.org/"}
{"query": "What is the role of the customer in the agile methods of software development?", "response": "The role of the customer in agile methods of software development is to be closely involved throughout the development process. They are responsible for providing and prioritizing new system requirements and evaluating the iterations of the system. The customer's involvement is crucial in ensuring that the software meets their needs and that any changes in requirements are accommodated.", "context": "3.1 \u25a0 Agile methods  75\nactivities apart from programming and testing. It is perfectly feasible, in a plan-driven \nprocess, to allocate requirements and plan the design and development phase as a \nseries of increments. An agile process is not inevitably code-focused, and it may \n produce some design documentation. Agile developers may decide that an iteration \nshould not produce new code but rather should produce system models and documentation.\n \n3.1 Agile methods\nIn the 1980s and early 1990s, there was a widespread view that the best way to \nachieve better software was through careful project planning, formalized quality \nassurance, use of analysis and design methods supported by software tools, and con-\ntrolled and rigorous software development processes. This view came from the soft-\nware engineering community that was responsible for developing large, long-lived \nsoftware systems such as aerospace and government systems.\nThis plan-driven approach was developed for software developed by large teams, \nworking for different companies. Teams were often geographically dispersed and \nworked on the software for long periods of time. An example of this type of software \nis the control systems for a modern aircraft, which might take up to 10 years from \ninitial specification to deployment. Plan-driven approaches involve a significant \noverhead in planning, designing, and documenting the system. This overhead is jus-\ntified when the work of multiple development teams has to be coordinated, when the \nsystem is a critical system, and when many different people will be involved in \nmaintaining the software over its lifetime.\nHowever, when this heavyweight, plan-driven development approach is applied \nto small and medium-sized business systems, the overhead involved is so large that \nit dominates the software development process. More time is spent on how the sys-\ntem should be developed than on program development and testing. As the system \nrequirements change, rework is essential and, in principle at least, the specification \nand design have to change with the program.\nDissatisfaction with these heavyweight approaches to software engineering \nled to the development of agile methods in the late 1990s. These methods allowed \nthe development team to focus on the software itself rather than on its design and \ndocumentation. They are best suited to application development where the sys-\ntem requirements usually change rapidly during the development process. They \nare intended to deliver working software quickly to customers, who can then pro-\npose new and changed requirements to be included in later iterations of the sys-\ntem. They aim to cut down on process bureaucracy by avoiding work that has \ndubious long-term value and eliminating documentation that will probably never \nbe used.\nThe philosophy behind agile methods is reflected in the agile manifesto (http://\nagilemanifesto.org) issued by the leading developers of these methods. This mani-\nfesto states:\n\n\n76  Chapter 3 \u25a0 Agile software development\nWe are uncovering better ways of developing software by doing it and helping \nothers do it. Through this work we have come to value:\nIndividuals and interactions over processes and tools \nWorking software over comprehensive documentation \nCustomer collaboration over contract negotiation \nResponding to change over following a plan\nThat is, while there is value in the items on the right, we value the items on the \nleft more\u2020.\nAll agile methods suggest that software should be developed and delivered incre-\nmentally. These methods are based on different agile processes but they share a set \nof principles, based on the agile manifesto, and so they have much in common. I \nhave listed these principles in Figure 3.2.\nAgile methods have been particularly successful for two kinds of system  development.\n1. Product development where a software company is developing a small or \nmedium-sized product for sale. Virtually all software products and apps are now \ndeveloped using an agile approach.\n2. \nCustom system development within an organization, where there is a clear com-\nmitment from the customer to become involved in the development process and \nwhere there are few external stakeholders and regulations that affect the software.\nAgile methods work well in these situations because it is possible to have con-\ntinuous communications between the product manager or system customer and the \ndevelopment team. The software itself is a stand-alone system rather than tightly \nintegrated with other systems being developed at the same time. Consequently, there \nis no need to coordinate parallel development streams. Small and medium-sized \nPrinciple\nDescription\nCustomer involvement\nCustomers should be closely involved throughout the development process. \nTheir role is provide and prioritize new system requirements and to evaluate \nthe iterations of the system.\nEmbrace change\nExpect the system requirements to change, and so design the system to \naccommodate these changes.\nIncremental delivery\nThe software is developed in increments, with the customer specifying the \nrequirements to be included in each increment.\nMaintain simplicity\nFocus on simplicity in both the software being developed and in the \ndevelopment process. Wherever possible, actively work to eliminate \ncomplexity from the system.\nPeople, not process\nThe skills of the development team should be recognized and exploited. \nTeam members should be left to develop their own ways of working without \nprescriptive processes.\nFigure 3.2 The \nprinciples of agile \nmethods\n\u2020http://agilemanifesto.org/"}
{"query": "How do agile methods accommodate changing system requirements?", "response": "Agile methods accommodate changing system requirements by expecting and embracing the fact that requirements will change throughout the development process. The software is developed in increments, and the customer is actively involved in specifying the requirements for each increment. This allows for flexibility and the ability to adapt to changing needs. Additionally, agile methods prioritize simplicity and maintain a focus on delivering working software quickly, which allows for easier adjustments and iterations based on changing requirements.", "context": "3.1 \u25a0 Agile methods  75\nactivities apart from programming and testing. It is perfectly feasible, in a plan-driven \nprocess, to allocate requirements and plan the design and development phase as a \nseries of increments. An agile process is not inevitably code-focused, and it may \n produce some design documentation. Agile developers may decide that an iteration \nshould not produce new code but rather should produce system models and documentation.\n \n3.1 Agile methods\nIn the 1980s and early 1990s, there was a widespread view that the best way to \nachieve better software was through careful project planning, formalized quality \nassurance, use of analysis and design methods supported by software tools, and con-\ntrolled and rigorous software development processes. This view came from the soft-\nware engineering community that was responsible for developing large, long-lived \nsoftware systems such as aerospace and government systems.\nThis plan-driven approach was developed for software developed by large teams, \nworking for different companies. Teams were often geographically dispersed and \nworked on the software for long periods of time. An example of this type of software \nis the control systems for a modern aircraft, which might take up to 10 years from \ninitial specification to deployment. Plan-driven approaches involve a significant \noverhead in planning, designing, and documenting the system. This overhead is jus-\ntified when the work of multiple development teams has to be coordinated, when the \nsystem is a critical system, and when many different people will be involved in \nmaintaining the software over its lifetime.\nHowever, when this heavyweight, plan-driven development approach is applied \nto small and medium-sized business systems, the overhead involved is so large that \nit dominates the software development process. More time is spent on how the sys-\ntem should be developed than on program development and testing. As the system \nrequirements change, rework is essential and, in principle at least, the specification \nand design have to change with the program.\nDissatisfaction with these heavyweight approaches to software engineering \nled to the development of agile methods in the late 1990s. These methods allowed \nthe development team to focus on the software itself rather than on its design and \ndocumentation. They are best suited to application development where the sys-\ntem requirements usually change rapidly during the development process. They \nare intended to deliver working software quickly to customers, who can then pro-\npose new and changed requirements to be included in later iterations of the sys-\ntem. They aim to cut down on process bureaucracy by avoiding work that has \ndubious long-term value and eliminating documentation that will probably never \nbe used.\nThe philosophy behind agile methods is reflected in the agile manifesto (http://\nagilemanifesto.org) issued by the leading developers of these methods. This mani-\nfesto states:\n\n\n76  Chapter 3 \u25a0 Agile software development\nWe are uncovering better ways of developing software by doing it and helping \nothers do it. Through this work we have come to value:\nIndividuals and interactions over processes and tools \nWorking software over comprehensive documentation \nCustomer collaboration over contract negotiation \nResponding to change over following a plan\nThat is, while there is value in the items on the right, we value the items on the \nleft more\u2020.\nAll agile methods suggest that software should be developed and delivered incre-\nmentally. These methods are based on different agile processes but they share a set \nof principles, based on the agile manifesto, and so they have much in common. I \nhave listed these principles in Figure 3.2.\nAgile methods have been particularly successful for two kinds of system  development.\n1. Product development where a software company is developing a small or \nmedium-sized product for sale. Virtually all software products and apps are now \ndeveloped using an agile approach.\n2. \nCustom system development within an organization, where there is a clear com-\nmitment from the customer to become involved in the development process and \nwhere there are few external stakeholders and regulations that affect the software.\nAgile methods work well in these situations because it is possible to have con-\ntinuous communications between the product manager or system customer and the \ndevelopment team. The software itself is a stand-alone system rather than tightly \nintegrated with other systems being developed at the same time. Consequently, there \nis no need to coordinate parallel development streams. Small and medium-sized \nPrinciple\nDescription\nCustomer involvement\nCustomers should be closely involved throughout the development process. \nTheir role is provide and prioritize new system requirements and to evaluate \nthe iterations of the system.\nEmbrace change\nExpect the system requirements to change, and so design the system to \naccommodate these changes.\nIncremental delivery\nThe software is developed in increments, with the customer specifying the \nrequirements to be included in each increment.\nMaintain simplicity\nFocus on simplicity in both the software being developed and in the \ndevelopment process. Wherever possible, actively work to eliminate \ncomplexity from the system.\nPeople, not process\nThe skills of the development team should be recognized and exploited. \nTeam members should be left to develop their own ways of working without \nprescriptive processes.\nFigure 3.2 The \nprinciples of agile \nmethods\n\u2020http://agilemanifesto.org/"}
{"query": "What is the significance of customer collaboration in agile methods?", "response": "Customer collaboration is significant in agile methods because it prioritizes the involvement of customers throughout the development process. This allows customers to provide and prioritize new system requirements and evaluate the iterations of the system. By actively involving customers, agile methods ensure that the developed software meets their needs and expectations. This collaboration helps in adapting to changing requirements and delivering a product that aligns with customer expectations.", "context": "3.1 \u25a0 Agile methods  75\nactivities apart from programming and testing. It is perfectly feasible, in a plan-driven \nprocess, to allocate requirements and plan the design and development phase as a \nseries of increments. An agile process is not inevitably code-focused, and it may \n produce some design documentation. Agile developers may decide that an iteration \nshould not produce new code but rather should produce system models and documentation.\n \n3.1 Agile methods\nIn the 1980s and early 1990s, there was a widespread view that the best way to \nachieve better software was through careful project planning, formalized quality \nassurance, use of analysis and design methods supported by software tools, and con-\ntrolled and rigorous software development processes. This view came from the soft-\nware engineering community that was responsible for developing large, long-lived \nsoftware systems such as aerospace and government systems.\nThis plan-driven approach was developed for software developed by large teams, \nworking for different companies. Teams were often geographically dispersed and \nworked on the software for long periods of time. An example of this type of software \nis the control systems for a modern aircraft, which might take up to 10 years from \ninitial specification to deployment. Plan-driven approaches involve a significant \noverhead in planning, designing, and documenting the system. This overhead is jus-\ntified when the work of multiple development teams has to be coordinated, when the \nsystem is a critical system, and when many different people will be involved in \nmaintaining the software over its lifetime.\nHowever, when this heavyweight, plan-driven development approach is applied \nto small and medium-sized business systems, the overhead involved is so large that \nit dominates the software development process. More time is spent on how the sys-\ntem should be developed than on program development and testing. As the system \nrequirements change, rework is essential and, in principle at least, the specification \nand design have to change with the program.\nDissatisfaction with these heavyweight approaches to software engineering \nled to the development of agile methods in the late 1990s. These methods allowed \nthe development team to focus on the software itself rather than on its design and \ndocumentation. They are best suited to application development where the sys-\ntem requirements usually change rapidly during the development process. They \nare intended to deliver working software quickly to customers, who can then pro-\npose new and changed requirements to be included in later iterations of the sys-\ntem. They aim to cut down on process bureaucracy by avoiding work that has \ndubious long-term value and eliminating documentation that will probably never \nbe used.\nThe philosophy behind agile methods is reflected in the agile manifesto (http://\nagilemanifesto.org) issued by the leading developers of these methods. This mani-\nfesto states:\n\n\n76  Chapter 3 \u25a0 Agile software development\nWe are uncovering better ways of developing software by doing it and helping \nothers do it. Through this work we have come to value:\nIndividuals and interactions over processes and tools \nWorking software over comprehensive documentation \nCustomer collaboration over contract negotiation \nResponding to change over following a plan\nThat is, while there is value in the items on the right, we value the items on the \nleft more\u2020.\nAll agile methods suggest that software should be developed and delivered incre-\nmentally. These methods are based on different agile processes but they share a set \nof principles, based on the agile manifesto, and so they have much in common. I \nhave listed these principles in Figure 3.2.\nAgile methods have been particularly successful for two kinds of system  development.\n1. Product development where a software company is developing a small or \nmedium-sized product for sale. Virtually all software products and apps are now \ndeveloped using an agile approach.\n2. \nCustom system development within an organization, where there is a clear com-\nmitment from the customer to become involved in the development process and \nwhere there are few external stakeholders and regulations that affect the software.\nAgile methods work well in these situations because it is possible to have con-\ntinuous communications between the product manager or system customer and the \ndevelopment team. The software itself is a stand-alone system rather than tightly \nintegrated with other systems being developed at the same time. Consequently, there \nis no need to coordinate parallel development streams. Small and medium-sized \nPrinciple\nDescription\nCustomer involvement\nCustomers should be closely involved throughout the development process. \nTheir role is provide and prioritize new system requirements and to evaluate \nthe iterations of the system.\nEmbrace change\nExpect the system requirements to change, and so design the system to \naccommodate these changes.\nIncremental delivery\nThe software is developed in increments, with the customer specifying the \nrequirements to be included in each increment.\nMaintain simplicity\nFocus on simplicity in both the software being developed and in the \ndevelopment process. Wherever possible, actively work to eliminate \ncomplexity from the system.\nPeople, not process\nThe skills of the development team should be recognized and exploited. \nTeam members should be left to develop their own ways of working without \nprescriptive processes.\nFigure 3.2 The \nprinciples of agile \nmethods\n\u2020http://agilemanifesto.org/"}
{"query": "How do agile methods respond to change compared to the plan-driven approach?", "response": "Agile methods respond to change by embracing it and designing the system to accommodate changes. In contrast, the plan-driven approach typically involves significant overhead in planning, designing, and documenting the system. While the plan-driven approach may be justified for large, long-lived software systems, it can be impractical for small and medium-sized business systems. Agile methods prioritize working software over comprehensive documentation and aim to cut down on process bureaucracy. They allow for rapid changes in system requirements during the development process and deliver working software quickly to customers.", "context": "3.1 \u25a0 Agile methods  75\nactivities apart from programming and testing. It is perfectly feasible, in a plan-driven \nprocess, to allocate requirements and plan the design and development phase as a \nseries of increments. An agile process is not inevitably code-focused, and it may \n produce some design documentation. Agile developers may decide that an iteration \nshould not produce new code but rather should produce system models and documentation.\n \n3.1 Agile methods\nIn the 1980s and early 1990s, there was a widespread view that the best way to \nachieve better software was through careful project planning, formalized quality \nassurance, use of analysis and design methods supported by software tools, and con-\ntrolled and rigorous software development processes. This view came from the soft-\nware engineering community that was responsible for developing large, long-lived \nsoftware systems such as aerospace and government systems.\nThis plan-driven approach was developed for software developed by large teams, \nworking for different companies. Teams were often geographically dispersed and \nworked on the software for long periods of time. An example of this type of software \nis the control systems for a modern aircraft, which might take up to 10 years from \ninitial specification to deployment. Plan-driven approaches involve a significant \noverhead in planning, designing, and documenting the system. This overhead is jus-\ntified when the work of multiple development teams has to be coordinated, when the \nsystem is a critical system, and when many different people will be involved in \nmaintaining the software over its lifetime.\nHowever, when this heavyweight, plan-driven development approach is applied \nto small and medium-sized business systems, the overhead involved is so large that \nit dominates the software development process. More time is spent on how the sys-\ntem should be developed than on program development and testing. As the system \nrequirements change, rework is essential and, in principle at least, the specification \nand design have to change with the program.\nDissatisfaction with these heavyweight approaches to software engineering \nled to the development of agile methods in the late 1990s. These methods allowed \nthe development team to focus on the software itself rather than on its design and \ndocumentation. They are best suited to application development where the sys-\ntem requirements usually change rapidly during the development process. They \nare intended to deliver working software quickly to customers, who can then pro-\npose new and changed requirements to be included in later iterations of the sys-\ntem. They aim to cut down on process bureaucracy by avoiding work that has \ndubious long-term value and eliminating documentation that will probably never \nbe used.\nThe philosophy behind agile methods is reflected in the agile manifesto (http://\nagilemanifesto.org) issued by the leading developers of these methods. This mani-\nfesto states:\n\n\n76  Chapter 3 \u25a0 Agile software development\nWe are uncovering better ways of developing software by doing it and helping \nothers do it. Through this work we have come to value:\nIndividuals and interactions over processes and tools \nWorking software over comprehensive documentation \nCustomer collaboration over contract negotiation \nResponding to change over following a plan\nThat is, while there is value in the items on the right, we value the items on the \nleft more\u2020.\nAll agile methods suggest that software should be developed and delivered incre-\nmentally. These methods are based on different agile processes but they share a set \nof principles, based on the agile manifesto, and so they have much in common. I \nhave listed these principles in Figure 3.2.\nAgile methods have been particularly successful for two kinds of system  development.\n1. Product development where a software company is developing a small or \nmedium-sized product for sale. Virtually all software products and apps are now \ndeveloped using an agile approach.\n2. \nCustom system development within an organization, where there is a clear com-\nmitment from the customer to become involved in the development process and \nwhere there are few external stakeholders and regulations that affect the software.\nAgile methods work well in these situations because it is possible to have con-\ntinuous communications between the product manager or system customer and the \ndevelopment team. The software itself is a stand-alone system rather than tightly \nintegrated with other systems being developed at the same time. Consequently, there \nis no need to coordinate parallel development streams. Small and medium-sized \nPrinciple\nDescription\nCustomer involvement\nCustomers should be closely involved throughout the development process. \nTheir role is provide and prioritize new system requirements and to evaluate \nthe iterations of the system.\nEmbrace change\nExpect the system requirements to change, and so design the system to \naccommodate these changes.\nIncremental delivery\nThe software is developed in increments, with the customer specifying the \nrequirements to be included in each increment.\nMaintain simplicity\nFocus on simplicity in both the software being developed and in the \ndevelopment process. Wherever possible, actively work to eliminate \ncomplexity from the system.\nPeople, not process\nThe skills of the development team should be recognized and exploited. \nTeam members should be left to develop their own ways of working without \nprescriptive processes.\nFigure 3.2 The \nprinciples of agile \nmethods\n\u2020http://agilemanifesto.org/"}
{"query": "What is the importance of individuals and interactions in agile methods?", "response": "The importance of individuals and interactions in agile methods is emphasized over processes and tools. Agile methods value the collaboration and communication between team members and stakeholders. This means that the focus is on the people involved in the development process and their ability to work together effectively. By prioritizing individuals and interactions, agile methods aim to foster a collaborative and flexible approach to software development.", "context": "3.1 \u25a0 Agile methods  75\nactivities apart from programming and testing. It is perfectly feasible, in a plan-driven \nprocess, to allocate requirements and plan the design and development phase as a \nseries of increments. An agile process is not inevitably code-focused, and it may \n produce some design documentation. Agile developers may decide that an iteration \nshould not produce new code but rather should produce system models and documentation.\n \n3.1 Agile methods\nIn the 1980s and early 1990s, there was a widespread view that the best way to \nachieve better software was through careful project planning, formalized quality \nassurance, use of analysis and design methods supported by software tools, and con-\ntrolled and rigorous software development processes. This view came from the soft-\nware engineering community that was responsible for developing large, long-lived \nsoftware systems such as aerospace and government systems.\nThis plan-driven approach was developed for software developed by large teams, \nworking for different companies. Teams were often geographically dispersed and \nworked on the software for long periods of time. An example of this type of software \nis the control systems for a modern aircraft, which might take up to 10 years from \ninitial specification to deployment. Plan-driven approaches involve a significant \noverhead in planning, designing, and documenting the system. This overhead is jus-\ntified when the work of multiple development teams has to be coordinated, when the \nsystem is a critical system, and when many different people will be involved in \nmaintaining the software over its lifetime.\nHowever, when this heavyweight, plan-driven development approach is applied \nto small and medium-sized business systems, the overhead involved is so large that \nit dominates the software development process. More time is spent on how the sys-\ntem should be developed than on program development and testing. As the system \nrequirements change, rework is essential and, in principle at least, the specification \nand design have to change with the program.\nDissatisfaction with these heavyweight approaches to software engineering \nled to the development of agile methods in the late 1990s. These methods allowed \nthe development team to focus on the software itself rather than on its design and \ndocumentation. They are best suited to application development where the sys-\ntem requirements usually change rapidly during the development process. They \nare intended to deliver working software quickly to customers, who can then pro-\npose new and changed requirements to be included in later iterations of the sys-\ntem. They aim to cut down on process bureaucracy by avoiding work that has \ndubious long-term value and eliminating documentation that will probably never \nbe used.\nThe philosophy behind agile methods is reflected in the agile manifesto (http://\nagilemanifesto.org) issued by the leading developers of these methods. This mani-\nfesto states:\n\n\n76  Chapter 3 \u25a0 Agile software development\nWe are uncovering better ways of developing software by doing it and helping \nothers do it. Through this work we have come to value:\nIndividuals and interactions over processes and tools \nWorking software over comprehensive documentation \nCustomer collaboration over contract negotiation \nResponding to change over following a plan\nThat is, while there is value in the items on the right, we value the items on the \nleft more\u2020.\nAll agile methods suggest that software should be developed and delivered incre-\nmentally. These methods are based on different agile processes but they share a set \nof principles, based on the agile manifesto, and so they have much in common. I \nhave listed these principles in Figure 3.2.\nAgile methods have been particularly successful for two kinds of system  development.\n1. Product development where a software company is developing a small or \nmedium-sized product for sale. Virtually all software products and apps are now \ndeveloped using an agile approach.\n2. \nCustom system development within an organization, where there is a clear com-\nmitment from the customer to become involved in the development process and \nwhere there are few external stakeholders and regulations that affect the software.\nAgile methods work well in these situations because it is possible to have con-\ntinuous communications between the product manager or system customer and the \ndevelopment team. The software itself is a stand-alone system rather than tightly \nintegrated with other systems being developed at the same time. Consequently, there \nis no need to coordinate parallel development streams. Small and medium-sized \nPrinciple\nDescription\nCustomer involvement\nCustomers should be closely involved throughout the development process. \nTheir role is provide and prioritize new system requirements and to evaluate \nthe iterations of the system.\nEmbrace change\nExpect the system requirements to change, and so design the system to \naccommodate these changes.\nIncremental delivery\nThe software is developed in increments, with the customer specifying the \nrequirements to be included in each increment.\nMaintain simplicity\nFocus on simplicity in both the software being developed and in the \ndevelopment process. Wherever possible, actively work to eliminate \ncomplexity from the system.\nPeople, not process\nThe skills of the development team should be recognized and exploited. \nTeam members should be left to develop their own ways of working without \nprescriptive processes.\nFigure 3.2 The \nprinciples of agile \nmethods\n\u2020http://agilemanifesto.org/"}
{"query": "How does the principle of maintaining simplicity benefit the software development process in agile methods?", "response": "The principle of maintaining simplicity in agile methods benefits the software development process by focusing on simplicity in both the software being developed and in the development process itself. By actively working to eliminate complexity from the system, agile developers can create software that is easier to understand, maintain, and modify. This simplification helps to reduce the risk of errors and makes it easier for the development team to collaborate and work efficiently. Additionally, by prioritizing simplicity, agile methods allow developers to adapt and respond to changes in requirements more easily, as complex systems tend to be more rigid and resistant to change. Overall, maintaining simplicity in agile methods promotes a more streamlined and flexible software development process.", "context": "3.1 \u25a0 Agile methods  75\nactivities apart from programming and testing. It is perfectly feasible, in a plan-driven \nprocess, to allocate requirements and plan the design and development phase as a \nseries of increments. An agile process is not inevitably code-focused, and it may \n produce some design documentation. Agile developers may decide that an iteration \nshould not produce new code but rather should produce system models and documentation.\n \n3.1 Agile methods\nIn the 1980s and early 1990s, there was a widespread view that the best way to \nachieve better software was through careful project planning, formalized quality \nassurance, use of analysis and design methods supported by software tools, and con-\ntrolled and rigorous software development processes. This view came from the soft-\nware engineering community that was responsible for developing large, long-lived \nsoftware systems such as aerospace and government systems.\nThis plan-driven approach was developed for software developed by large teams, \nworking for different companies. Teams were often geographically dispersed and \nworked on the software for long periods of time. An example of this type of software \nis the control systems for a modern aircraft, which might take up to 10 years from \ninitial specification to deployment. Plan-driven approaches involve a significant \noverhead in planning, designing, and documenting the system. This overhead is jus-\ntified when the work of multiple development teams has to be coordinated, when the \nsystem is a critical system, and when many different people will be involved in \nmaintaining the software over its lifetime.\nHowever, when this heavyweight, plan-driven development approach is applied \nto small and medium-sized business systems, the overhead involved is so large that \nit dominates the software development process. More time is spent on how the sys-\ntem should be developed than on program development and testing. As the system \nrequirements change, rework is essential and, in principle at least, the specification \nand design have to change with the program.\nDissatisfaction with these heavyweight approaches to software engineering \nled to the development of agile methods in the late 1990s. These methods allowed \nthe development team to focus on the software itself rather than on its design and \ndocumentation. They are best suited to application development where the sys-\ntem requirements usually change rapidly during the development process. They \nare intended to deliver working software quickly to customers, who can then pro-\npose new and changed requirements to be included in later iterations of the sys-\ntem. They aim to cut down on process bureaucracy by avoiding work that has \ndubious long-term value and eliminating documentation that will probably never \nbe used.\nThe philosophy behind agile methods is reflected in the agile manifesto (http://\nagilemanifesto.org) issued by the leading developers of these methods. This mani-\nfesto states:\n\n\n76  Chapter 3 \u25a0 Agile software development\nWe are uncovering better ways of developing software by doing it and helping \nothers do it. Through this work we have come to value:\nIndividuals and interactions over processes and tools \nWorking software over comprehensive documentation \nCustomer collaboration over contract negotiation \nResponding to change over following a plan\nThat is, while there is value in the items on the right, we value the items on the \nleft more\u2020.\nAll agile methods suggest that software should be developed and delivered incre-\nmentally. These methods are based on different agile processes but they share a set \nof principles, based on the agile manifesto, and so they have much in common. I \nhave listed these principles in Figure 3.2.\nAgile methods have been particularly successful for two kinds of system  development.\n1. Product development where a software company is developing a small or \nmedium-sized product for sale. Virtually all software products and apps are now \ndeveloped using an agile approach.\n2. \nCustom system development within an organization, where there is a clear com-\nmitment from the customer to become involved in the development process and \nwhere there are few external stakeholders and regulations that affect the software.\nAgile methods work well in these situations because it is possible to have con-\ntinuous communications between the product manager or system customer and the \ndevelopment team. The software itself is a stand-alone system rather than tightly \nintegrated with other systems being developed at the same time. Consequently, there \nis no need to coordinate parallel development streams. Small and medium-sized \nPrinciple\nDescription\nCustomer involvement\nCustomers should be closely involved throughout the development process. \nTheir role is provide and prioritize new system requirements and to evaluate \nthe iterations of the system.\nEmbrace change\nExpect the system requirements to change, and so design the system to \naccommodate these changes.\nIncremental delivery\nThe software is developed in increments, with the customer specifying the \nrequirements to be included in each increment.\nMaintain simplicity\nFocus on simplicity in both the software being developed and in the \ndevelopment process. Wherever possible, actively work to eliminate \ncomplexity from the system.\nPeople, not process\nThe skills of the development team should be recognized and exploited. \nTeam members should be left to develop their own ways of working without \nprescriptive processes.\nFigure 3.2 The \nprinciples of agile \nmethods\n\u2020http://agilemanifesto.org/"}
{"query": "How does the principle of \"people, not process\" benefit the development team in agile methods?", "response": "The principle of \"people, not process\" in agile methods benefits the development team by recognizing and exploiting the skills of the team members. It allows the team members to develop their own ways of working without being bound by prescriptive processes. This empowers the team to take ownership of their work and encourages creativity and innovation. By focusing on the capabilities and expertise of the individuals, agile methods promote a collaborative and self-organizing team environment, which can lead to higher productivity and job satisfaction.", "context": "3.1 \u25a0 Agile methods  75\nactivities apart from programming and testing. It is perfectly feasible, in a plan-driven \nprocess, to allocate requirements and plan the design and development phase as a \nseries of increments. An agile process is not inevitably code-focused, and it may \n produce some design documentation. Agile developers may decide that an iteration \nshould not produce new code but rather should produce system models and documentation.\n \n3.1 Agile methods\nIn the 1980s and early 1990s, there was a widespread view that the best way to \nachieve better software was through careful project planning, formalized quality \nassurance, use of analysis and design methods supported by software tools, and con-\ntrolled and rigorous software development processes. This view came from the soft-\nware engineering community that was responsible for developing large, long-lived \nsoftware systems such as aerospace and government systems.\nThis plan-driven approach was developed for software developed by large teams, \nworking for different companies. Teams were often geographically dispersed and \nworked on the software for long periods of time. An example of this type of software \nis the control systems for a modern aircraft, which might take up to 10 years from \ninitial specification to deployment. Plan-driven approaches involve a significant \noverhead in planning, designing, and documenting the system. This overhead is jus-\ntified when the work of multiple development teams has to be coordinated, when the \nsystem is a critical system, and when many different people will be involved in \nmaintaining the software over its lifetime.\nHowever, when this heavyweight, plan-driven development approach is applied \nto small and medium-sized business systems, the overhead involved is so large that \nit dominates the software development process. More time is spent on how the sys-\ntem should be developed than on program development and testing. As the system \nrequirements change, rework is essential and, in principle at least, the specification \nand design have to change with the program.\nDissatisfaction with these heavyweight approaches to software engineering \nled to the development of agile methods in the late 1990s. These methods allowed \nthe development team to focus on the software itself rather than on its design and \ndocumentation. They are best suited to application development where the sys-\ntem requirements usually change rapidly during the development process. They \nare intended to deliver working software quickly to customers, who can then pro-\npose new and changed requirements to be included in later iterations of the sys-\ntem. They aim to cut down on process bureaucracy by avoiding work that has \ndubious long-term value and eliminating documentation that will probably never \nbe used.\nThe philosophy behind agile methods is reflected in the agile manifesto (http://\nagilemanifesto.org) issued by the leading developers of these methods. This mani-\nfesto states:\n\n\n76  Chapter 3 \u25a0 Agile software development\nWe are uncovering better ways of developing software by doing it and helping \nothers do it. Through this work we have come to value:\nIndividuals and interactions over processes and tools \nWorking software over comprehensive documentation \nCustomer collaboration over contract negotiation \nResponding to change over following a plan\nThat is, while there is value in the items on the right, we value the items on the \nleft more\u2020.\nAll agile methods suggest that software should be developed and delivered incre-\nmentally. These methods are based on different agile processes but they share a set \nof principles, based on the agile manifesto, and so they have much in common. I \nhave listed these principles in Figure 3.2.\nAgile methods have been particularly successful for two kinds of system  development.\n1. Product development where a software company is developing a small or \nmedium-sized product for sale. Virtually all software products and apps are now \ndeveloped using an agile approach.\n2. \nCustom system development within an organization, where there is a clear com-\nmitment from the customer to become involved in the development process and \nwhere there are few external stakeholders and regulations that affect the software.\nAgile methods work well in these situations because it is possible to have con-\ntinuous communications between the product manager or system customer and the \ndevelopment team. The software itself is a stand-alone system rather than tightly \nintegrated with other systems being developed at the same time. Consequently, there \nis no need to coordinate parallel development streams. Small and medium-sized \nPrinciple\nDescription\nCustomer involvement\nCustomers should be closely involved throughout the development process. \nTheir role is provide and prioritize new system requirements and to evaluate \nthe iterations of the system.\nEmbrace change\nExpect the system requirements to change, and so design the system to \naccommodate these changes.\nIncremental delivery\nThe software is developed in increments, with the customer specifying the \nrequirements to be included in each increment.\nMaintain simplicity\nFocus on simplicity in both the software being developed and in the \ndevelopment process. Wherever possible, actively work to eliminate \ncomplexity from the system.\nPeople, not process\nThe skills of the development team should be recognized and exploited. \nTeam members should be left to develop their own ways of working without \nprescriptive processes.\nFigure 3.2 The \nprinciples of agile \nmethods\n\u2020http://agilemanifesto.org/"}
{"query": "What are the key values stated in the agile manifesto?", "response": "The key values stated in the agile manifesto are:\n1. Individuals and interactions over processes and tools\n2. Working software over comprehensive documentation\n3. Customer collaboration over contract negotiation\n4. Responding to change over following a plan", "context": "3.1 \u25a0 Agile methods  75\nactivities apart from programming and testing. It is perfectly feasible, in a plan-driven \nprocess, to allocate requirements and plan the design and development phase as a \nseries of increments. An agile process is not inevitably code-focused, and it may \n produce some design documentation. Agile developers may decide that an iteration \nshould not produce new code but rather should produce system models and documentation.\n \n3.1 Agile methods\nIn the 1980s and early 1990s, there was a widespread view that the best way to \nachieve better software was through careful project planning, formalized quality \nassurance, use of analysis and design methods supported by software tools, and con-\ntrolled and rigorous software development processes. This view came from the soft-\nware engineering community that was responsible for developing large, long-lived \nsoftware systems such as aerospace and government systems.\nThis plan-driven approach was developed for software developed by large teams, \nworking for different companies. Teams were often geographically dispersed and \nworked on the software for long periods of time. An example of this type of software \nis the control systems for a modern aircraft, which might take up to 10 years from \ninitial specification to deployment. Plan-driven approaches involve a significant \noverhead in planning, designing, and documenting the system. This overhead is jus-\ntified when the work of multiple development teams has to be coordinated, when the \nsystem is a critical system, and when many different people will be involved in \nmaintaining the software over its lifetime.\nHowever, when this heavyweight, plan-driven development approach is applied \nto small and medium-sized business systems, the overhead involved is so large that \nit dominates the software development process. More time is spent on how the sys-\ntem should be developed than on program development and testing. As the system \nrequirements change, rework is essential and, in principle at least, the specification \nand design have to change with the program.\nDissatisfaction with these heavyweight approaches to software engineering \nled to the development of agile methods in the late 1990s. These methods allowed \nthe development team to focus on the software itself rather than on its design and \ndocumentation. They are best suited to application development where the sys-\ntem requirements usually change rapidly during the development process. They \nare intended to deliver working software quickly to customers, who can then pro-\npose new and changed requirements to be included in later iterations of the sys-\ntem. They aim to cut down on process bureaucracy by avoiding work that has \ndubious long-term value and eliminating documentation that will probably never \nbe used.\nThe philosophy behind agile methods is reflected in the agile manifesto (http://\nagilemanifesto.org) issued by the leading developers of these methods. This mani-\nfesto states:\n\n\n76  Chapter 3 \u25a0 Agile software development\nWe are uncovering better ways of developing software by doing it and helping \nothers do it. Through this work we have come to value:\nIndividuals and interactions over processes and tools \nWorking software over comprehensive documentation \nCustomer collaboration over contract negotiation \nResponding to change over following a plan\nThat is, while there is value in the items on the right, we value the items on the \nleft more\u2020.\nAll agile methods suggest that software should be developed and delivered incre-\nmentally. These methods are based on different agile processes but they share a set \nof principles, based on the agile manifesto, and so they have much in common. I \nhave listed these principles in Figure 3.2.\nAgile methods have been particularly successful for two kinds of system  development.\n1. Product development where a software company is developing a small or \nmedium-sized product for sale. Virtually all software products and apps are now \ndeveloped using an agile approach.\n2. \nCustom system development within an organization, where there is a clear com-\nmitment from the customer to become involved in the development process and \nwhere there are few external stakeholders and regulations that affect the software.\nAgile methods work well in these situations because it is possible to have con-\ntinuous communications between the product manager or system customer and the \ndevelopment team. The software itself is a stand-alone system rather than tightly \nintegrated with other systems being developed at the same time. Consequently, there \nis no need to coordinate parallel development streams. Small and medium-sized \nPrinciple\nDescription\nCustomer involvement\nCustomers should be closely involved throughout the development process. \nTheir role is provide and prioritize new system requirements and to evaluate \nthe iterations of the system.\nEmbrace change\nExpect the system requirements to change, and so design the system to \naccommodate these changes.\nIncremental delivery\nThe software is developed in increments, with the customer specifying the \nrequirements to be included in each increment.\nMaintain simplicity\nFocus on simplicity in both the software being developed and in the \ndevelopment process. Wherever possible, actively work to eliminate \ncomplexity from the system.\nPeople, not process\nThe skills of the development team should be recognized and exploited. \nTeam members should be left to develop their own ways of working without \nprescriptive processes.\nFigure 3.2 The \nprinciples of agile \nmethods\n\u2020http://agilemanifesto.org/"}
{"query": "How does the agile approach to software development differ from traditional methods?", "response": "The agile approach to software development differs from traditional methods in several ways. \n\nFirstly, agile methods prioritize individuals and interactions over processes and tools. This means that the focus is on the people involved in the development process and their collaboration, rather than relying heavily on formalized processes and tools.\n\nSecondly, agile methods emphasize working software over comprehensive documentation. Instead of spending a significant amount of time on planning, designing, and documenting the system, agile developers prioritize actually developing and delivering working software.\n\nThirdly, agile methods promote customer collaboration over contract negotiation. Agile teams actively involve customers throughout the development process, allowing them to provide and prioritize new system requirements and evaluate the iterations of the system. This collaborative approach ensures that the software meets the needs and expectations of the customers.\n\nLastly, agile methods prioritize responding to change over following a plan. Agile developers expect that the system requirements will change over time, and they design the system to accommodate these changes. This flexibility allows for continuous adaptation and improvement throughout the development process.\n\nOverall, the agile approach to software development focuses on delivering working software quickly, involving customers in the development process, and embracing change, while traditional methods often involve more planning, documentation, and adherence to a fixed plan.", "context": "3.1 \u25a0 Agile methods  75\nactivities apart from programming and testing. It is perfectly feasible, in a plan-driven \nprocess, to allocate requirements and plan the design and development phase as a \nseries of increments. An agile process is not inevitably code-focused, and it may \n produce some design documentation. Agile developers may decide that an iteration \nshould not produce new code but rather should produce system models and documentation.\n \n3.1 Agile methods\nIn the 1980s and early 1990s, there was a widespread view that the best way to \nachieve better software was through careful project planning, formalized quality \nassurance, use of analysis and design methods supported by software tools, and con-\ntrolled and rigorous software development processes. This view came from the soft-\nware engineering community that was responsible for developing large, long-lived \nsoftware systems such as aerospace and government systems.\nThis plan-driven approach was developed for software developed by large teams, \nworking for different companies. Teams were often geographically dispersed and \nworked on the software for long periods of time. An example of this type of software \nis the control systems for a modern aircraft, which might take up to 10 years from \ninitial specification to deployment. Plan-driven approaches involve a significant \noverhead in planning, designing, and documenting the system. This overhead is jus-\ntified when the work of multiple development teams has to be coordinated, when the \nsystem is a critical system, and when many different people will be involved in \nmaintaining the software over its lifetime.\nHowever, when this heavyweight, plan-driven development approach is applied \nto small and medium-sized business systems, the overhead involved is so large that \nit dominates the software development process. More time is spent on how the sys-\ntem should be developed than on program development and testing. As the system \nrequirements change, rework is essential and, in principle at least, the specification \nand design have to change with the program.\nDissatisfaction with these heavyweight approaches to software engineering \nled to the development of agile methods in the late 1990s. These methods allowed \nthe development team to focus on the software itself rather than on its design and \ndocumentation. They are best suited to application development where the sys-\ntem requirements usually change rapidly during the development process. They \nare intended to deliver working software quickly to customers, who can then pro-\npose new and changed requirements to be included in later iterations of the sys-\ntem. They aim to cut down on process bureaucracy by avoiding work that has \ndubious long-term value and eliminating documentation that will probably never \nbe used.\nThe philosophy behind agile methods is reflected in the agile manifesto (http://\nagilemanifesto.org) issued by the leading developers of these methods. This mani-\nfesto states:\n\n\n76  Chapter 3 \u25a0 Agile software development\nWe are uncovering better ways of developing software by doing it and helping \nothers do it. Through this work we have come to value:\nIndividuals and interactions over processes and tools \nWorking software over comprehensive documentation \nCustomer collaboration over contract negotiation \nResponding to change over following a plan\nThat is, while there is value in the items on the right, we value the items on the \nleft more\u2020.\nAll agile methods suggest that software should be developed and delivered incre-\nmentally. These methods are based on different agile processes but they share a set \nof principles, based on the agile manifesto, and so they have much in common. I \nhave listed these principles in Figure 3.2.\nAgile methods have been particularly successful for two kinds of system  development.\n1. Product development where a software company is developing a small or \nmedium-sized product for sale. Virtually all software products and apps are now \ndeveloped using an agile approach.\n2. \nCustom system development within an organization, where there is a clear com-\nmitment from the customer to become involved in the development process and \nwhere there are few external stakeholders and regulations that affect the software.\nAgile methods work well in these situations because it is possible to have con-\ntinuous communications between the product manager or system customer and the \ndevelopment team. The software itself is a stand-alone system rather than tightly \nintegrated with other systems being developed at the same time. Consequently, there \nis no need to coordinate parallel development streams. Small and medium-sized \nPrinciple\nDescription\nCustomer involvement\nCustomers should be closely involved throughout the development process. \nTheir role is provide and prioritize new system requirements and to evaluate \nthe iterations of the system.\nEmbrace change\nExpect the system requirements to change, and so design the system to \naccommodate these changes.\nIncremental delivery\nThe software is developed in increments, with the customer specifying the \nrequirements to be included in each increment.\nMaintain simplicity\nFocus on simplicity in both the software being developed and in the \ndevelopment process. Wherever possible, actively work to eliminate \ncomplexity from the system.\nPeople, not process\nThe skills of the development team should be recognized and exploited. \nTeam members should be left to develop their own ways of working without \nprescriptive processes.\nFigure 3.2 The \nprinciples of agile \nmethods\n\u2020http://agilemanifesto.org/"}
{"query": "What are some of the common principles shared by different agile processes?", "response": "Some of the common principles shared by different agile processes include customer involvement, embracing change, incremental delivery, maintaining simplicity, and focusing on people rather than processes.", "context": "3.1 \u25a0 Agile methods  75\nactivities apart from programming and testing. It is perfectly feasible, in a plan-driven \nprocess, to allocate requirements and plan the design and development phase as a \nseries of increments. An agile process is not inevitably code-focused, and it may \n produce some design documentation. Agile developers may decide that an iteration \nshould not produce new code but rather should produce system models and documentation.\n \n3.1 Agile methods\nIn the 1980s and early 1990s, there was a widespread view that the best way to \nachieve better software was through careful project planning, formalized quality \nassurance, use of analysis and design methods supported by software tools, and con-\ntrolled and rigorous software development processes. This view came from the soft-\nware engineering community that was responsible for developing large, long-lived \nsoftware systems such as aerospace and government systems.\nThis plan-driven approach was developed for software developed by large teams, \nworking for different companies. Teams were often geographically dispersed and \nworked on the software for long periods of time. An example of this type of software \nis the control systems for a modern aircraft, which might take up to 10 years from \ninitial specification to deployment. Plan-driven approaches involve a significant \noverhead in planning, designing, and documenting the system. This overhead is jus-\ntified when the work of multiple development teams has to be coordinated, when the \nsystem is a critical system, and when many different people will be involved in \nmaintaining the software over its lifetime.\nHowever, when this heavyweight, plan-driven development approach is applied \nto small and medium-sized business systems, the overhead involved is so large that \nit dominates the software development process. More time is spent on how the sys-\ntem should be developed than on program development and testing. As the system \nrequirements change, rework is essential and, in principle at least, the specification \nand design have to change with the program.\nDissatisfaction with these heavyweight approaches to software engineering \nled to the development of agile methods in the late 1990s. These methods allowed \nthe development team to focus on the software itself rather than on its design and \ndocumentation. They are best suited to application development where the sys-\ntem requirements usually change rapidly during the development process. They \nare intended to deliver working software quickly to customers, who can then pro-\npose new and changed requirements to be included in later iterations of the sys-\ntem. They aim to cut down on process bureaucracy by avoiding work that has \ndubious long-term value and eliminating documentation that will probably never \nbe used.\nThe philosophy behind agile methods is reflected in the agile manifesto (http://\nagilemanifesto.org) issued by the leading developers of these methods. This mani-\nfesto states:\n\n\n76  Chapter 3 \u25a0 Agile software development\nWe are uncovering better ways of developing software by doing it and helping \nothers do it. Through this work we have come to value:\nIndividuals and interactions over processes and tools \nWorking software over comprehensive documentation \nCustomer collaboration over contract negotiation \nResponding to change over following a plan\nThat is, while there is value in the items on the right, we value the items on the \nleft more\u2020.\nAll agile methods suggest that software should be developed and delivered incre-\nmentally. These methods are based on different agile processes but they share a set \nof principles, based on the agile manifesto, and so they have much in common. I \nhave listed these principles in Figure 3.2.\nAgile methods have been particularly successful for two kinds of system  development.\n1. Product development where a software company is developing a small or \nmedium-sized product for sale. Virtually all software products and apps are now \ndeveloped using an agile approach.\n2. \nCustom system development within an organization, where there is a clear com-\nmitment from the customer to become involved in the development process and \nwhere there are few external stakeholders and regulations that affect the software.\nAgile methods work well in these situations because it is possible to have con-\ntinuous communications between the product manager or system customer and the \ndevelopment team. The software itself is a stand-alone system rather than tightly \nintegrated with other systems being developed at the same time. Consequently, there \nis no need to coordinate parallel development streams. Small and medium-sized \nPrinciple\nDescription\nCustomer involvement\nCustomers should be closely involved throughout the development process. \nTheir role is provide and prioritize new system requirements and to evaluate \nthe iterations of the system.\nEmbrace change\nExpect the system requirements to change, and so design the system to \naccommodate these changes.\nIncremental delivery\nThe software is developed in increments, with the customer specifying the \nrequirements to be included in each increment.\nMaintain simplicity\nFocus on simplicity in both the software being developed and in the \ndevelopment process. Wherever possible, actively work to eliminate \ncomplexity from the system.\nPeople, not process\nThe skills of the development team should be recognized and exploited. \nTeam members should be left to develop their own ways of working without \nprescriptive processes.\nFigure 3.2 The \nprinciples of agile \nmethods\n\u2020http://agilemanifesto.org/"}
{"query": "Why are agile methods particularly successful in product development and custom system development within an organization?", "response": "Agile methods are particularly successful in product development and custom system development within an organization because they allow for continuous communication between the product manager or system customer and the development team. This close involvement of the customer throughout the development process enables them to provide and prioritize new system requirements and evaluate the iterations of the system. Additionally, agile methods embrace change and expect the system requirements to change, allowing for flexibility in accommodating these changes. Furthermore, the incremental delivery approach of agile methods, where the software is developed in increments with the customer specifying the requirements for each increment, allows for quicker delivery of working software to customers. Finally, agile methods focus on simplicity and recognize and exploit the skills of the development team, allowing team members to develop their own ways of working without prescriptive processes.", "context": "3.1 \u25a0 Agile methods  75\nactivities apart from programming and testing. It is perfectly feasible, in a plan-driven \nprocess, to allocate requirements and plan the design and development phase as a \nseries of increments. An agile process is not inevitably code-focused, and it may \n produce some design documentation. Agile developers may decide that an iteration \nshould not produce new code but rather should produce system models and documentation.\n \n3.1 Agile methods\nIn the 1980s and early 1990s, there was a widespread view that the best way to \nachieve better software was through careful project planning, formalized quality \nassurance, use of analysis and design methods supported by software tools, and con-\ntrolled and rigorous software development processes. This view came from the soft-\nware engineering community that was responsible for developing large, long-lived \nsoftware systems such as aerospace and government systems.\nThis plan-driven approach was developed for software developed by large teams, \nworking for different companies. Teams were often geographically dispersed and \nworked on the software for long periods of time. An example of this type of software \nis the control systems for a modern aircraft, which might take up to 10 years from \ninitial specification to deployment. Plan-driven approaches involve a significant \noverhead in planning, designing, and documenting the system. This overhead is jus-\ntified when the work of multiple development teams has to be coordinated, when the \nsystem is a critical system, and when many different people will be involved in \nmaintaining the software over its lifetime.\nHowever, when this heavyweight, plan-driven development approach is applied \nto small and medium-sized business systems, the overhead involved is so large that \nit dominates the software development process. More time is spent on how the sys-\ntem should be developed than on program development and testing. As the system \nrequirements change, rework is essential and, in principle at least, the specification \nand design have to change with the program.\nDissatisfaction with these heavyweight approaches to software engineering \nled to the development of agile methods in the late 1990s. These methods allowed \nthe development team to focus on the software itself rather than on its design and \ndocumentation. They are best suited to application development where the sys-\ntem requirements usually change rapidly during the development process. They \nare intended to deliver working software quickly to customers, who can then pro-\npose new and changed requirements to be included in later iterations of the sys-\ntem. They aim to cut down on process bureaucracy by avoiding work that has \ndubious long-term value and eliminating documentation that will probably never \nbe used.\nThe philosophy behind agile methods is reflected in the agile manifesto (http://\nagilemanifesto.org) issued by the leading developers of these methods. This mani-\nfesto states:\n\n\n76  Chapter 3 \u25a0 Agile software development\nWe are uncovering better ways of developing software by doing it and helping \nothers do it. Through this work we have come to value:\nIndividuals and interactions over processes and tools \nWorking software over comprehensive documentation \nCustomer collaboration over contract negotiation \nResponding to change over following a plan\nThat is, while there is value in the items on the right, we value the items on the \nleft more\u2020.\nAll agile methods suggest that software should be developed and delivered incre-\nmentally. These methods are based on different agile processes but they share a set \nof principles, based on the agile manifesto, and so they have much in common. I \nhave listed these principles in Figure 3.2.\nAgile methods have been particularly successful for two kinds of system  development.\n1. Product development where a software company is developing a small or \nmedium-sized product for sale. Virtually all software products and apps are now \ndeveloped using an agile approach.\n2. \nCustom system development within an organization, where there is a clear com-\nmitment from the customer to become involved in the development process and \nwhere there are few external stakeholders and regulations that affect the software.\nAgile methods work well in these situations because it is possible to have con-\ntinuous communications between the product manager or system customer and the \ndevelopment team. The software itself is a stand-alone system rather than tightly \nintegrated with other systems being developed at the same time. Consequently, there \nis no need to coordinate parallel development streams. Small and medium-sized \nPrinciple\nDescription\nCustomer involvement\nCustomers should be closely involved throughout the development process. \nTheir role is provide and prioritize new system requirements and to evaluate \nthe iterations of the system.\nEmbrace change\nExpect the system requirements to change, and so design the system to \naccommodate these changes.\nIncremental delivery\nThe software is developed in increments, with the customer specifying the \nrequirements to be included in each increment.\nMaintain simplicity\nFocus on simplicity in both the software being developed and in the \ndevelopment process. Wherever possible, actively work to eliminate \ncomplexity from the system.\nPeople, not process\nThe skills of the development team should be recognized and exploited. \nTeam members should be left to develop their own ways of working without \nprescriptive processes.\nFigure 3.2 The \nprinciples of agile \nmethods\n\u2020http://agilemanifesto.org/"}
{"query": "What is the concept of Agile development techniques?", "response": "Agile development techniques are a set of practices and principles that aim to improve the software development process. These techniques emphasize flexibility, collaboration, and iterative development. One of the key concepts in agile development is the idea of delivering software in small, frequent releases, allowing for continuous feedback and adaptation. Agile development also promotes customer involvement throughout the development process, with the customer representative playing an active role in defining requirements and acceptance testing. Other important concepts in agile development include pair programming, collective ownership of code, continuous integration, and test-driven development. Overall, agile development techniques prioritize people and interactions over processes and tools, and focus on delivering high-quality software that meets customer needs.", "context": "3.2  \u25a0 Agile development techniques  77\n systems can be developed by co-located teams, so informal communications among \nteam members work well.\n \n3.2  Agile development techniques\nThe ideas underlying agile methods were developed around the same time by a number \nof different people in the 1990s. However, perhaps the most significant approach to \nchanging software development culture was the development of Extreme Programming \n(XP). The name was coined by Kent Beck (Beck 1998) because the approach was \ndeveloped by pushing recognized good practice, such as iterative development, to \n\u201cextreme\u201d levels. For example, in XP, several new versions of a system may be devel-\noped by different programmers, integrated, and tested in a day. Figure 3.3 illustrates \nthe XP process to produce an increment of the system that is being developed.\nIn XP, requirements are expressed as scenarios (called user stories), which are \nimplemented directly as a series of tasks. Programmers work in pairs and develop \ntests for each task before writing the code. All tests must be successfully executed \nwhen new code is integrated into the system. There is a short time gap between \nreleases of the system.\nExtreme programming was controversial as it introduced a number of agile prac-\ntices that were quite different from the development practice of that time. These prac-\ntices are summarized in Figure 3.4 and reflect the principles of the agile manifesto:\n1. \nIncremental development is supported through small, frequent releases of the sys-\ntem. Requirements are based on simple customer stories or scenarios that are used \nas a basis for deciding what functionality should be included in a system increment.\n2. Customer involvement is supported through the continuous engagement of the \ncustomer in the development team. The customer representative takes part in \nthe development and is responsible for defining acceptance tests for the system.\n3. People, not process, are supported through pair programming, collective owner-\nship of the system code, and a sustainable development process that does not \ninvolve excessively long working hours.\nBreak down\nstories to tasks\nSelect user\nstories for this\nrelease\nPlan release\nRelease\nsoftware\nEvaluate\nsystem\nDevelop/integrate/\ntest software\nFigure 3.3 The XP \nrelease cycle\n\n\n78  Chapter 3 \u25a0 Agile software development\nPrinciple or practice\nDescription\nCollective ownership\nThe pairs of developers work on all areas of the system, so that no islands of \nexpertise develop and all the developers take responsibility for all of the code. \nAnyone can change anything.\nContinuous \nintegration\nAs soon as the work on a task is complete, it is integrated into the whole \nsystem. After any such integration, all the unit tests in the system must pass.\nIncremental planning\nRequirements are recorded on \u201cstory cards,\u201d and the stories to be included in \na\u00a0release are determined by the time available and their relative priority. The \ndevelopers break these stories into development \u201ctasks.\u201d See Figures 3.5 \nand\u00a03.6.\nOn-site customer\nA representative of the end-user of the system (the Customer) should be \navailable full time for the use of the XP team. In an extreme programming \nprocess, the customer is a member of the development team and is \nresponsible for bringing system requirements to the team for implementation.\nPair programming\nDevelopers work in pairs, checking each other's work and providing the \nsupport to always do a good job.\nRefactoring\nAll developers are expected to refactor the code continuously as soon as \npotential code improvements are found. This keeps the code simple and \nmaintainable.\nSimple design\nEnough design is carried out to meet the current requirements and no more.\nSmall releases\nThe minimal useful set of functionality that provides business value is \ndeveloped first. Releases of the system are frequent and incrementally add \nfunctionality to the first release.\nSustainable pace\nLarge amounts of overtime are not considered acceptable, as the net effect is \noften to reduce code quality and medium-term productivity.\nTest first \ndevelopment\nAn automated unit test framework is used to write tests for a new piece of \nfunctionality before that functionality itself is implemented.\nFigure 3.4 Extreme \nprogramming practices 4. Change is embraced through regular system releases to customers, test-first \ndevelopment, refactoring to avoid code degeneration, and continuous integra-\ntion of new functionality.\n5. Maintaining simplicity is supported by constant refactoring that improves code \nquality and by using simple designs that do not unnecessarily anticipate future \nchanges to the system.\nIn practice, the application of Extreme Programming as originally proposed has \nproved to be more difficult than anticipated. It cannot be readily integrated with the \nmanagement practices and culture of most businesses. Therefore, companies adopt-\ning agile methods pick and choose those XP practices that are most appropriate for \ntheir way of working. Sometimes these are incorporated into their own development \nprocesses but, more commonly, they are used in conjunction with a management-\nfocused agile method such as Scrum (Rubin 2013)."}
{"query": "Who coined the term Extreme Programming (XP) and why?", "response": "Kent Beck coined the term Extreme Programming (XP). The term was coined because the approach of XP involved pushing recognized good practices, such as iterative development, to \"extreme\" levels.", "context": "3.2  \u25a0 Agile development techniques  77\n systems can be developed by co-located teams, so informal communications among \nteam members work well.\n \n3.2  Agile development techniques\nThe ideas underlying agile methods were developed around the same time by a number \nof different people in the 1990s. However, perhaps the most significant approach to \nchanging software development culture was the development of Extreme Programming \n(XP). The name was coined by Kent Beck (Beck 1998) because the approach was \ndeveloped by pushing recognized good practice, such as iterative development, to \n\u201cextreme\u201d levels. For example, in XP, several new versions of a system may be devel-\noped by different programmers, integrated, and tested in a day. Figure 3.3 illustrates \nthe XP process to produce an increment of the system that is being developed.\nIn XP, requirements are expressed as scenarios (called user stories), which are \nimplemented directly as a series of tasks. Programmers work in pairs and develop \ntests for each task before writing the code. All tests must be successfully executed \nwhen new code is integrated into the system. There is a short time gap between \nreleases of the system.\nExtreme programming was controversial as it introduced a number of agile prac-\ntices that were quite different from the development practice of that time. These prac-\ntices are summarized in Figure 3.4 and reflect the principles of the agile manifesto:\n1. \nIncremental development is supported through small, frequent releases of the sys-\ntem. Requirements are based on simple customer stories or scenarios that are used \nas a basis for deciding what functionality should be included in a system increment.\n2. Customer involvement is supported through the continuous engagement of the \ncustomer in the development team. The customer representative takes part in \nthe development and is responsible for defining acceptance tests for the system.\n3. People, not process, are supported through pair programming, collective owner-\nship of the system code, and a sustainable development process that does not \ninvolve excessively long working hours.\nBreak down\nstories to tasks\nSelect user\nstories for this\nrelease\nPlan release\nRelease\nsoftware\nEvaluate\nsystem\nDevelop/integrate/\ntest software\nFigure 3.3 The XP \nrelease cycle\n\n\n78  Chapter 3 \u25a0 Agile software development\nPrinciple or practice\nDescription\nCollective ownership\nThe pairs of developers work on all areas of the system, so that no islands of \nexpertise develop and all the developers take responsibility for all of the code. \nAnyone can change anything.\nContinuous \nintegration\nAs soon as the work on a task is complete, it is integrated into the whole \nsystem. After any such integration, all the unit tests in the system must pass.\nIncremental planning\nRequirements are recorded on \u201cstory cards,\u201d and the stories to be included in \na\u00a0release are determined by the time available and their relative priority. The \ndevelopers break these stories into development \u201ctasks.\u201d See Figures 3.5 \nand\u00a03.6.\nOn-site customer\nA representative of the end-user of the system (the Customer) should be \navailable full time for the use of the XP team. In an extreme programming \nprocess, the customer is a member of the development team and is \nresponsible for bringing system requirements to the team for implementation.\nPair programming\nDevelopers work in pairs, checking each other's work and providing the \nsupport to always do a good job.\nRefactoring\nAll developers are expected to refactor the code continuously as soon as \npotential code improvements are found. This keeps the code simple and \nmaintainable.\nSimple design\nEnough design is carried out to meet the current requirements and no more.\nSmall releases\nThe minimal useful set of functionality that provides business value is \ndeveloped first. Releases of the system are frequent and incrementally add \nfunctionality to the first release.\nSustainable pace\nLarge amounts of overtime are not considered acceptable, as the net effect is \noften to reduce code quality and medium-term productivity.\nTest first \ndevelopment\nAn automated unit test framework is used to write tests for a new piece of \nfunctionality before that functionality itself is implemented.\nFigure 3.4 Extreme \nprogramming practices 4. Change is embraced through regular system releases to customers, test-first \ndevelopment, refactoring to avoid code degeneration, and continuous integra-\ntion of new functionality.\n5. Maintaining simplicity is supported by constant refactoring that improves code \nquality and by using simple designs that do not unnecessarily anticipate future \nchanges to the system.\nIn practice, the application of Extreme Programming as originally proposed has \nproved to be more difficult than anticipated. It cannot be readily integrated with the \nmanagement practices and culture of most businesses. Therefore, companies adopt-\ning agile methods pick and choose those XP practices that are most appropriate for \ntheir way of working. Sometimes these are incorporated into their own development \nprocesses but, more commonly, they are used in conjunction with a management-\nfocused agile method such as Scrum (Rubin 2013)."}
{"query": "How does Extreme Programming (XP) approach software development?", "response": "Extreme Programming (XP) approach software development by pushing recognized good practice, such as iterative development, to \"extreme\" levels. It involves developing several new versions of a system by different programmers, integrating and testing them in a day. Requirements are expressed as scenarios called user stories, which are implemented directly as a series of tasks. Programmers work in pairs and develop tests for each task before writing the code. All tests must be successfully executed when new code is integrated into the system. XP also emphasizes incremental development, customer involvement, collective ownership of the code, continuous integration, and sustainable development practices.", "context": "3.2  \u25a0 Agile development techniques  77\n systems can be developed by co-located teams, so informal communications among \nteam members work well.\n \n3.2  Agile development techniques\nThe ideas underlying agile methods were developed around the same time by a number \nof different people in the 1990s. However, perhaps the most significant approach to \nchanging software development culture was the development of Extreme Programming \n(XP). The name was coined by Kent Beck (Beck 1998) because the approach was \ndeveloped by pushing recognized good practice, such as iterative development, to \n\u201cextreme\u201d levels. For example, in XP, several new versions of a system may be devel-\noped by different programmers, integrated, and tested in a day. Figure 3.3 illustrates \nthe XP process to produce an increment of the system that is being developed.\nIn XP, requirements are expressed as scenarios (called user stories), which are \nimplemented directly as a series of tasks. Programmers work in pairs and develop \ntests for each task before writing the code. All tests must be successfully executed \nwhen new code is integrated into the system. There is a short time gap between \nreleases of the system.\nExtreme programming was controversial as it introduced a number of agile prac-\ntices that were quite different from the development practice of that time. These prac-\ntices are summarized in Figure 3.4 and reflect the principles of the agile manifesto:\n1. \nIncremental development is supported through small, frequent releases of the sys-\ntem. Requirements are based on simple customer stories or scenarios that are used \nas a basis for deciding what functionality should be included in a system increment.\n2. Customer involvement is supported through the continuous engagement of the \ncustomer in the development team. The customer representative takes part in \nthe development and is responsible for defining acceptance tests for the system.\n3. People, not process, are supported through pair programming, collective owner-\nship of the system code, and a sustainable development process that does not \ninvolve excessively long working hours.\nBreak down\nstories to tasks\nSelect user\nstories for this\nrelease\nPlan release\nRelease\nsoftware\nEvaluate\nsystem\nDevelop/integrate/\ntest software\nFigure 3.3 The XP \nrelease cycle\n\n\n78  Chapter 3 \u25a0 Agile software development\nPrinciple or practice\nDescription\nCollective ownership\nThe pairs of developers work on all areas of the system, so that no islands of \nexpertise develop and all the developers take responsibility for all of the code. \nAnyone can change anything.\nContinuous \nintegration\nAs soon as the work on a task is complete, it is integrated into the whole \nsystem. After any such integration, all the unit tests in the system must pass.\nIncremental planning\nRequirements are recorded on \u201cstory cards,\u201d and the stories to be included in \na\u00a0release are determined by the time available and their relative priority. The \ndevelopers break these stories into development \u201ctasks.\u201d See Figures 3.5 \nand\u00a03.6.\nOn-site customer\nA representative of the end-user of the system (the Customer) should be \navailable full time for the use of the XP team. In an extreme programming \nprocess, the customer is a member of the development team and is \nresponsible for bringing system requirements to the team for implementation.\nPair programming\nDevelopers work in pairs, checking each other's work and providing the \nsupport to always do a good job.\nRefactoring\nAll developers are expected to refactor the code continuously as soon as \npotential code improvements are found. This keeps the code simple and \nmaintainable.\nSimple design\nEnough design is carried out to meet the current requirements and no more.\nSmall releases\nThe minimal useful set of functionality that provides business value is \ndeveloped first. Releases of the system are frequent and incrementally add \nfunctionality to the first release.\nSustainable pace\nLarge amounts of overtime are not considered acceptable, as the net effect is \noften to reduce code quality and medium-term productivity.\nTest first \ndevelopment\nAn automated unit test framework is used to write tests for a new piece of \nfunctionality before that functionality itself is implemented.\nFigure 3.4 Extreme \nprogramming practices 4. Change is embraced through regular system releases to customers, test-first \ndevelopment, refactoring to avoid code degeneration, and continuous integra-\ntion of new functionality.\n5. Maintaining simplicity is supported by constant refactoring that improves code \nquality and by using simple designs that do not unnecessarily anticipate future \nchanges to the system.\nIn practice, the application of Extreme Programming as originally proposed has \nproved to be more difficult than anticipated. It cannot be readily integrated with the \nmanagement practices and culture of most businesses. Therefore, companies adopt-\ning agile methods pick and choose those XP practices that are most appropriate for \ntheir way of working. Sometimes these are incorporated into their own development \nprocesses but, more commonly, they are used in conjunction with a management-\nfocused agile method such as Scrum (Rubin 2013)."}
{"query": "What are user stories in the context of Extreme Programming (XP)?", "response": "User stories in the context of Extreme Programming (XP) are scenarios that express requirements. They are implemented directly as a series of tasks and serve as a basis for deciding what functionality should be included in a system increment.", "context": "3.2  \u25a0 Agile development techniques  77\n systems can be developed by co-located teams, so informal communications among \nteam members work well.\n \n3.2  Agile development techniques\nThe ideas underlying agile methods were developed around the same time by a number \nof different people in the 1990s. However, perhaps the most significant approach to \nchanging software development culture was the development of Extreme Programming \n(XP). The name was coined by Kent Beck (Beck 1998) because the approach was \ndeveloped by pushing recognized good practice, such as iterative development, to \n\u201cextreme\u201d levels. For example, in XP, several new versions of a system may be devel-\noped by different programmers, integrated, and tested in a day. Figure 3.3 illustrates \nthe XP process to produce an increment of the system that is being developed.\nIn XP, requirements are expressed as scenarios (called user stories), which are \nimplemented directly as a series of tasks. Programmers work in pairs and develop \ntests for each task before writing the code. All tests must be successfully executed \nwhen new code is integrated into the system. There is a short time gap between \nreleases of the system.\nExtreme programming was controversial as it introduced a number of agile prac-\ntices that were quite different from the development practice of that time. These prac-\ntices are summarized in Figure 3.4 and reflect the principles of the agile manifesto:\n1. \nIncremental development is supported through small, frequent releases of the sys-\ntem. Requirements are based on simple customer stories or scenarios that are used \nas a basis for deciding what functionality should be included in a system increment.\n2. Customer involvement is supported through the continuous engagement of the \ncustomer in the development team. The customer representative takes part in \nthe development and is responsible for defining acceptance tests for the system.\n3. People, not process, are supported through pair programming, collective owner-\nship of the system code, and a sustainable development process that does not \ninvolve excessively long working hours.\nBreak down\nstories to tasks\nSelect user\nstories for this\nrelease\nPlan release\nRelease\nsoftware\nEvaluate\nsystem\nDevelop/integrate/\ntest software\nFigure 3.3 The XP \nrelease cycle\n\n\n78  Chapter 3 \u25a0 Agile software development\nPrinciple or practice\nDescription\nCollective ownership\nThe pairs of developers work on all areas of the system, so that no islands of \nexpertise develop and all the developers take responsibility for all of the code. \nAnyone can change anything.\nContinuous \nintegration\nAs soon as the work on a task is complete, it is integrated into the whole \nsystem. After any such integration, all the unit tests in the system must pass.\nIncremental planning\nRequirements are recorded on \u201cstory cards,\u201d and the stories to be included in \na\u00a0release are determined by the time available and their relative priority. The \ndevelopers break these stories into development \u201ctasks.\u201d See Figures 3.5 \nand\u00a03.6.\nOn-site customer\nA representative of the end-user of the system (the Customer) should be \navailable full time for the use of the XP team. In an extreme programming \nprocess, the customer is a member of the development team and is \nresponsible for bringing system requirements to the team for implementation.\nPair programming\nDevelopers work in pairs, checking each other's work and providing the \nsupport to always do a good job.\nRefactoring\nAll developers are expected to refactor the code continuously as soon as \npotential code improvements are found. This keeps the code simple and \nmaintainable.\nSimple design\nEnough design is carried out to meet the current requirements and no more.\nSmall releases\nThe minimal useful set of functionality that provides business value is \ndeveloped first. Releases of the system are frequent and incrementally add \nfunctionality to the first release.\nSustainable pace\nLarge amounts of overtime are not considered acceptable, as the net effect is \noften to reduce code quality and medium-term productivity.\nTest first \ndevelopment\nAn automated unit test framework is used to write tests for a new piece of \nfunctionality before that functionality itself is implemented.\nFigure 3.4 Extreme \nprogramming practices 4. Change is embraced through regular system releases to customers, test-first \ndevelopment, refactoring to avoid code degeneration, and continuous integra-\ntion of new functionality.\n5. Maintaining simplicity is supported by constant refactoring that improves code \nquality and by using simple designs that do not unnecessarily anticipate future \nchanges to the system.\nIn practice, the application of Extreme Programming as originally proposed has \nproved to be more difficult than anticipated. It cannot be readily integrated with the \nmanagement practices and culture of most businesses. Therefore, companies adopt-\ning agile methods pick and choose those XP practices that are most appropriate for \ntheir way of working. Sometimes these are incorporated into their own development \nprocesses but, more commonly, they are used in conjunction with a management-\nfocused agile method such as Scrum (Rubin 2013)."}
{"query": "How are tasks developed in Extreme Programming (XP)?", "response": "Tasks in Extreme Programming (XP) are developed by breaking down user stories into smaller, manageable units. Programmers work in pairs and develop tests for each task before writing the code. This approach ensures that all tests are successfully executed when new code is integrated into the system.", "context": "3.2  \u25a0 Agile development techniques  77\n systems can be developed by co-located teams, so informal communications among \nteam members work well.\n \n3.2  Agile development techniques\nThe ideas underlying agile methods were developed around the same time by a number \nof different people in the 1990s. However, perhaps the most significant approach to \nchanging software development culture was the development of Extreme Programming \n(XP). The name was coined by Kent Beck (Beck 1998) because the approach was \ndeveloped by pushing recognized good practice, such as iterative development, to \n\u201cextreme\u201d levels. For example, in XP, several new versions of a system may be devel-\noped by different programmers, integrated, and tested in a day. Figure 3.3 illustrates \nthe XP process to produce an increment of the system that is being developed.\nIn XP, requirements are expressed as scenarios (called user stories), which are \nimplemented directly as a series of tasks. Programmers work in pairs and develop \ntests for each task before writing the code. All tests must be successfully executed \nwhen new code is integrated into the system. There is a short time gap between \nreleases of the system.\nExtreme programming was controversial as it introduced a number of agile prac-\ntices that were quite different from the development practice of that time. These prac-\ntices are summarized in Figure 3.4 and reflect the principles of the agile manifesto:\n1. \nIncremental development is supported through small, frequent releases of the sys-\ntem. Requirements are based on simple customer stories or scenarios that are used \nas a basis for deciding what functionality should be included in a system increment.\n2. Customer involvement is supported through the continuous engagement of the \ncustomer in the development team. The customer representative takes part in \nthe development and is responsible for defining acceptance tests for the system.\n3. People, not process, are supported through pair programming, collective owner-\nship of the system code, and a sustainable development process that does not \ninvolve excessively long working hours.\nBreak down\nstories to tasks\nSelect user\nstories for this\nrelease\nPlan release\nRelease\nsoftware\nEvaluate\nsystem\nDevelop/integrate/\ntest software\nFigure 3.3 The XP \nrelease cycle\n\n\n78  Chapter 3 \u25a0 Agile software development\nPrinciple or practice\nDescription\nCollective ownership\nThe pairs of developers work on all areas of the system, so that no islands of \nexpertise develop and all the developers take responsibility for all of the code. \nAnyone can change anything.\nContinuous \nintegration\nAs soon as the work on a task is complete, it is integrated into the whole \nsystem. After any such integration, all the unit tests in the system must pass.\nIncremental planning\nRequirements are recorded on \u201cstory cards,\u201d and the stories to be included in \na\u00a0release are determined by the time available and their relative priority. The \ndevelopers break these stories into development \u201ctasks.\u201d See Figures 3.5 \nand\u00a03.6.\nOn-site customer\nA representative of the end-user of the system (the Customer) should be \navailable full time for the use of the XP team. In an extreme programming \nprocess, the customer is a member of the development team and is \nresponsible for bringing system requirements to the team for implementation.\nPair programming\nDevelopers work in pairs, checking each other's work and providing the \nsupport to always do a good job.\nRefactoring\nAll developers are expected to refactor the code continuously as soon as \npotential code improvements are found. This keeps the code simple and \nmaintainable.\nSimple design\nEnough design is carried out to meet the current requirements and no more.\nSmall releases\nThe minimal useful set of functionality that provides business value is \ndeveloped first. Releases of the system are frequent and incrementally add \nfunctionality to the first release.\nSustainable pace\nLarge amounts of overtime are not considered acceptable, as the net effect is \noften to reduce code quality and medium-term productivity.\nTest first \ndevelopment\nAn automated unit test framework is used to write tests for a new piece of \nfunctionality before that functionality itself is implemented.\nFigure 3.4 Extreme \nprogramming practices 4. Change is embraced through regular system releases to customers, test-first \ndevelopment, refactoring to avoid code degeneration, and continuous integra-\ntion of new functionality.\n5. Maintaining simplicity is supported by constant refactoring that improves code \nquality and by using simple designs that do not unnecessarily anticipate future \nchanges to the system.\nIn practice, the application of Extreme Programming as originally proposed has \nproved to be more difficult than anticipated. It cannot be readily integrated with the \nmanagement practices and culture of most businesses. Therefore, companies adopt-\ning agile methods pick and choose those XP practices that are most appropriate for \ntheir way of working. Sometimes these are incorporated into their own development \nprocesses but, more commonly, they are used in conjunction with a management-\nfocused agile method such as Scrum (Rubin 2013)."}
{"query": "What is the role of testing in Extreme Programming (XP)?", "response": "Testing plays a crucial role in Extreme Programming (XP). In XP, programmers work in pairs and develop tests for each task before writing the code. All tests must be successfully executed when new code is integrated into the system. This approach, known as test-first development, ensures that the code meets the desired functionality and maintains code quality. Additionally, continuous integration is practiced in XP, where as soon as the work on a task is complete, it is integrated into the whole system and all the unit tests in the system must pass. This ensures that any changes made to the code do not introduce any errors or regressions.", "context": "3.2  \u25a0 Agile development techniques  77\n systems can be developed by co-located teams, so informal communications among \nteam members work well.\n \n3.2  Agile development techniques\nThe ideas underlying agile methods were developed around the same time by a number \nof different people in the 1990s. However, perhaps the most significant approach to \nchanging software development culture was the development of Extreme Programming \n(XP). The name was coined by Kent Beck (Beck 1998) because the approach was \ndeveloped by pushing recognized good practice, such as iterative development, to \n\u201cextreme\u201d levels. For example, in XP, several new versions of a system may be devel-\noped by different programmers, integrated, and tested in a day. Figure 3.3 illustrates \nthe XP process to produce an increment of the system that is being developed.\nIn XP, requirements are expressed as scenarios (called user stories), which are \nimplemented directly as a series of tasks. Programmers work in pairs and develop \ntests for each task before writing the code. All tests must be successfully executed \nwhen new code is integrated into the system. There is a short time gap between \nreleases of the system.\nExtreme programming was controversial as it introduced a number of agile prac-\ntices that were quite different from the development practice of that time. These prac-\ntices are summarized in Figure 3.4 and reflect the principles of the agile manifesto:\n1. \nIncremental development is supported through small, frequent releases of the sys-\ntem. Requirements are based on simple customer stories or scenarios that are used \nas a basis for deciding what functionality should be included in a system increment.\n2. Customer involvement is supported through the continuous engagement of the \ncustomer in the development team. The customer representative takes part in \nthe development and is responsible for defining acceptance tests for the system.\n3. People, not process, are supported through pair programming, collective owner-\nship of the system code, and a sustainable development process that does not \ninvolve excessively long working hours.\nBreak down\nstories to tasks\nSelect user\nstories for this\nrelease\nPlan release\nRelease\nsoftware\nEvaluate\nsystem\nDevelop/integrate/\ntest software\nFigure 3.3 The XP \nrelease cycle\n\n\n78  Chapter 3 \u25a0 Agile software development\nPrinciple or practice\nDescription\nCollective ownership\nThe pairs of developers work on all areas of the system, so that no islands of \nexpertise develop and all the developers take responsibility for all of the code. \nAnyone can change anything.\nContinuous \nintegration\nAs soon as the work on a task is complete, it is integrated into the whole \nsystem. After any such integration, all the unit tests in the system must pass.\nIncremental planning\nRequirements are recorded on \u201cstory cards,\u201d and the stories to be included in \na\u00a0release are determined by the time available and their relative priority. The \ndevelopers break these stories into development \u201ctasks.\u201d See Figures 3.5 \nand\u00a03.6.\nOn-site customer\nA representative of the end-user of the system (the Customer) should be \navailable full time for the use of the XP team. In an extreme programming \nprocess, the customer is a member of the development team and is \nresponsible for bringing system requirements to the team for implementation.\nPair programming\nDevelopers work in pairs, checking each other's work and providing the \nsupport to always do a good job.\nRefactoring\nAll developers are expected to refactor the code continuously as soon as \npotential code improvements are found. This keeps the code simple and \nmaintainable.\nSimple design\nEnough design is carried out to meet the current requirements and no more.\nSmall releases\nThe minimal useful set of functionality that provides business value is \ndeveloped first. Releases of the system are frequent and incrementally add \nfunctionality to the first release.\nSustainable pace\nLarge amounts of overtime are not considered acceptable, as the net effect is \noften to reduce code quality and medium-term productivity.\nTest first \ndevelopment\nAn automated unit test framework is used to write tests for a new piece of \nfunctionality before that functionality itself is implemented.\nFigure 3.4 Extreme \nprogramming practices 4. Change is embraced through regular system releases to customers, test-first \ndevelopment, refactoring to avoid code degeneration, and continuous integra-\ntion of new functionality.\n5. Maintaining simplicity is supported by constant refactoring that improves code \nquality and by using simple designs that do not unnecessarily anticipate future \nchanges to the system.\nIn practice, the application of Extreme Programming as originally proposed has \nproved to be more difficult than anticipated. It cannot be readily integrated with the \nmanagement practices and culture of most businesses. Therefore, companies adopt-\ning agile methods pick and choose those XP practices that are most appropriate for \ntheir way of working. Sometimes these are incorporated into their own development \nprocesses but, more commonly, they are used in conjunction with a management-\nfocused agile method such as Scrum (Rubin 2013)."}
{"query": "What are some of the agile practices introduced by Extreme Programming (XP)?", "response": "Some of the agile practices introduced by Extreme Programming (XP) include incremental development through small, frequent releases of the system, customer involvement through continuous engagement of the customer in the development team, pair programming where developers work in pairs and check each other's work, continuous integration where completed tasks are integrated into the whole system and all unit tests must pass, refactoring to continuously improve code quality, and test-first development where tests are written for new functionality before implementation.", "context": "3.2  \u25a0 Agile development techniques  77\n systems can be developed by co-located teams, so informal communications among \nteam members work well.\n \n3.2  Agile development techniques\nThe ideas underlying agile methods were developed around the same time by a number \nof different people in the 1990s. However, perhaps the most significant approach to \nchanging software development culture was the development of Extreme Programming \n(XP). The name was coined by Kent Beck (Beck 1998) because the approach was \ndeveloped by pushing recognized good practice, such as iterative development, to \n\u201cextreme\u201d levels. For example, in XP, several new versions of a system may be devel-\noped by different programmers, integrated, and tested in a day. Figure 3.3 illustrates \nthe XP process to produce an increment of the system that is being developed.\nIn XP, requirements are expressed as scenarios (called user stories), which are \nimplemented directly as a series of tasks. Programmers work in pairs and develop \ntests for each task before writing the code. All tests must be successfully executed \nwhen new code is integrated into the system. There is a short time gap between \nreleases of the system.\nExtreme programming was controversial as it introduced a number of agile prac-\ntices that were quite different from the development practice of that time. These prac-\ntices are summarized in Figure 3.4 and reflect the principles of the agile manifesto:\n1. \nIncremental development is supported through small, frequent releases of the sys-\ntem. Requirements are based on simple customer stories or scenarios that are used \nas a basis for deciding what functionality should be included in a system increment.\n2. Customer involvement is supported through the continuous engagement of the \ncustomer in the development team. The customer representative takes part in \nthe development and is responsible for defining acceptance tests for the system.\n3. People, not process, are supported through pair programming, collective owner-\nship of the system code, and a sustainable development process that does not \ninvolve excessively long working hours.\nBreak down\nstories to tasks\nSelect user\nstories for this\nrelease\nPlan release\nRelease\nsoftware\nEvaluate\nsystem\nDevelop/integrate/\ntest software\nFigure 3.3 The XP \nrelease cycle\n\n\n78  Chapter 3 \u25a0 Agile software development\nPrinciple or practice\nDescription\nCollective ownership\nThe pairs of developers work on all areas of the system, so that no islands of \nexpertise develop and all the developers take responsibility for all of the code. \nAnyone can change anything.\nContinuous \nintegration\nAs soon as the work on a task is complete, it is integrated into the whole \nsystem. After any such integration, all the unit tests in the system must pass.\nIncremental planning\nRequirements are recorded on \u201cstory cards,\u201d and the stories to be included in \na\u00a0release are determined by the time available and their relative priority. The \ndevelopers break these stories into development \u201ctasks.\u201d See Figures 3.5 \nand\u00a03.6.\nOn-site customer\nA representative of the end-user of the system (the Customer) should be \navailable full time for the use of the XP team. In an extreme programming \nprocess, the customer is a member of the development team and is \nresponsible for bringing system requirements to the team for implementation.\nPair programming\nDevelopers work in pairs, checking each other's work and providing the \nsupport to always do a good job.\nRefactoring\nAll developers are expected to refactor the code continuously as soon as \npotential code improvements are found. This keeps the code simple and \nmaintainable.\nSimple design\nEnough design is carried out to meet the current requirements and no more.\nSmall releases\nThe minimal useful set of functionality that provides business value is \ndeveloped first. Releases of the system are frequent and incrementally add \nfunctionality to the first release.\nSustainable pace\nLarge amounts of overtime are not considered acceptable, as the net effect is \noften to reduce code quality and medium-term productivity.\nTest first \ndevelopment\nAn automated unit test framework is used to write tests for a new piece of \nfunctionality before that functionality itself is implemented.\nFigure 3.4 Extreme \nprogramming practices 4. Change is embraced through regular system releases to customers, test-first \ndevelopment, refactoring to avoid code degeneration, and continuous integra-\ntion of new functionality.\n5. Maintaining simplicity is supported by constant refactoring that improves code \nquality and by using simple designs that do not unnecessarily anticipate future \nchanges to the system.\nIn practice, the application of Extreme Programming as originally proposed has \nproved to be more difficult than anticipated. It cannot be readily integrated with the \nmanagement practices and culture of most businesses. Therefore, companies adopt-\ning agile methods pick and choose those XP practices that are most appropriate for \ntheir way of working. Sometimes these are incorporated into their own development \nprocesses but, more commonly, they are used in conjunction with a management-\nfocused agile method such as Scrum (Rubin 2013)."}
{"query": "How does Extreme Programming (XP) support incremental development?", "response": "Extreme Programming (XP) supports incremental development through small, frequent releases of the system. Requirements are based on simple customer stories or scenarios, which are used to decide what functionality should be included in a system increment. This allows for the development of the minimal useful set of functionality that provides business value first, with subsequent releases incrementally adding more functionality.", "context": "3.2  \u25a0 Agile development techniques  77\n systems can be developed by co-located teams, so informal communications among \nteam members work well.\n \n3.2  Agile development techniques\nThe ideas underlying agile methods were developed around the same time by a number \nof different people in the 1990s. However, perhaps the most significant approach to \nchanging software development culture was the development of Extreme Programming \n(XP). The name was coined by Kent Beck (Beck 1998) because the approach was \ndeveloped by pushing recognized good practice, such as iterative development, to \n\u201cextreme\u201d levels. For example, in XP, several new versions of a system may be devel-\noped by different programmers, integrated, and tested in a day. Figure 3.3 illustrates \nthe XP process to produce an increment of the system that is being developed.\nIn XP, requirements are expressed as scenarios (called user stories), which are \nimplemented directly as a series of tasks. Programmers work in pairs and develop \ntests for each task before writing the code. All tests must be successfully executed \nwhen new code is integrated into the system. There is a short time gap between \nreleases of the system.\nExtreme programming was controversial as it introduced a number of agile prac-\ntices that were quite different from the development practice of that time. These prac-\ntices are summarized in Figure 3.4 and reflect the principles of the agile manifesto:\n1. \nIncremental development is supported through small, frequent releases of the sys-\ntem. Requirements are based on simple customer stories or scenarios that are used \nas a basis for deciding what functionality should be included in a system increment.\n2. Customer involvement is supported through the continuous engagement of the \ncustomer in the development team. The customer representative takes part in \nthe development and is responsible for defining acceptance tests for the system.\n3. People, not process, are supported through pair programming, collective owner-\nship of the system code, and a sustainable development process that does not \ninvolve excessively long working hours.\nBreak down\nstories to tasks\nSelect user\nstories for this\nrelease\nPlan release\nRelease\nsoftware\nEvaluate\nsystem\nDevelop/integrate/\ntest software\nFigure 3.3 The XP \nrelease cycle\n\n\n78  Chapter 3 \u25a0 Agile software development\nPrinciple or practice\nDescription\nCollective ownership\nThe pairs of developers work on all areas of the system, so that no islands of \nexpertise develop and all the developers take responsibility for all of the code. \nAnyone can change anything.\nContinuous \nintegration\nAs soon as the work on a task is complete, it is integrated into the whole \nsystem. After any such integration, all the unit tests in the system must pass.\nIncremental planning\nRequirements are recorded on \u201cstory cards,\u201d and the stories to be included in \na\u00a0release are determined by the time available and their relative priority. The \ndevelopers break these stories into development \u201ctasks.\u201d See Figures 3.5 \nand\u00a03.6.\nOn-site customer\nA representative of the end-user of the system (the Customer) should be \navailable full time for the use of the XP team. In an extreme programming \nprocess, the customer is a member of the development team and is \nresponsible for bringing system requirements to the team for implementation.\nPair programming\nDevelopers work in pairs, checking each other's work and providing the \nsupport to always do a good job.\nRefactoring\nAll developers are expected to refactor the code continuously as soon as \npotential code improvements are found. This keeps the code simple and \nmaintainable.\nSimple design\nEnough design is carried out to meet the current requirements and no more.\nSmall releases\nThe minimal useful set of functionality that provides business value is \ndeveloped first. Releases of the system are frequent and incrementally add \nfunctionality to the first release.\nSustainable pace\nLarge amounts of overtime are not considered acceptable, as the net effect is \noften to reduce code quality and medium-term productivity.\nTest first \ndevelopment\nAn automated unit test framework is used to write tests for a new piece of \nfunctionality before that functionality itself is implemented.\nFigure 3.4 Extreme \nprogramming practices 4. Change is embraced through regular system releases to customers, test-first \ndevelopment, refactoring to avoid code degeneration, and continuous integra-\ntion of new functionality.\n5. Maintaining simplicity is supported by constant refactoring that improves code \nquality and by using simple designs that do not unnecessarily anticipate future \nchanges to the system.\nIn practice, the application of Extreme Programming as originally proposed has \nproved to be more difficult than anticipated. It cannot be readily integrated with the \nmanagement practices and culture of most businesses. Therefore, companies adopt-\ning agile methods pick and choose those XP practices that are most appropriate for \ntheir way of working. Sometimes these are incorporated into their own development \nprocesses but, more commonly, they are used in conjunction with a management-\nfocused agile method such as Scrum (Rubin 2013)."}
{"query": "How does Extreme Programming (XP) involve customer involvement?", "response": "Extreme Programming (XP) involves customer involvement through the continuous engagement of the customer in the development team. In XP, a customer representative takes part in the development process and is responsible for defining acceptance tests for the system. This ensures that the customer's requirements and expectations are understood and met throughout the development process.", "context": "3.2  \u25a0 Agile development techniques  77\n systems can be developed by co-located teams, so informal communications among \nteam members work well.\n \n3.2  Agile development techniques\nThe ideas underlying agile methods were developed around the same time by a number \nof different people in the 1990s. However, perhaps the most significant approach to \nchanging software development culture was the development of Extreme Programming \n(XP). The name was coined by Kent Beck (Beck 1998) because the approach was \ndeveloped by pushing recognized good practice, such as iterative development, to \n\u201cextreme\u201d levels. For example, in XP, several new versions of a system may be devel-\noped by different programmers, integrated, and tested in a day. Figure 3.3 illustrates \nthe XP process to produce an increment of the system that is being developed.\nIn XP, requirements are expressed as scenarios (called user stories), which are \nimplemented directly as a series of tasks. Programmers work in pairs and develop \ntests for each task before writing the code. All tests must be successfully executed \nwhen new code is integrated into the system. There is a short time gap between \nreleases of the system.\nExtreme programming was controversial as it introduced a number of agile prac-\ntices that were quite different from the development practice of that time. These prac-\ntices are summarized in Figure 3.4 and reflect the principles of the agile manifesto:\n1. \nIncremental development is supported through small, frequent releases of the sys-\ntem. Requirements are based on simple customer stories or scenarios that are used \nas a basis for deciding what functionality should be included in a system increment.\n2. Customer involvement is supported through the continuous engagement of the \ncustomer in the development team. The customer representative takes part in \nthe development and is responsible for defining acceptance tests for the system.\n3. People, not process, are supported through pair programming, collective owner-\nship of the system code, and a sustainable development process that does not \ninvolve excessively long working hours.\nBreak down\nstories to tasks\nSelect user\nstories for this\nrelease\nPlan release\nRelease\nsoftware\nEvaluate\nsystem\nDevelop/integrate/\ntest software\nFigure 3.3 The XP \nrelease cycle\n\n\n78  Chapter 3 \u25a0 Agile software development\nPrinciple or practice\nDescription\nCollective ownership\nThe pairs of developers work on all areas of the system, so that no islands of \nexpertise develop and all the developers take responsibility for all of the code. \nAnyone can change anything.\nContinuous \nintegration\nAs soon as the work on a task is complete, it is integrated into the whole \nsystem. After any such integration, all the unit tests in the system must pass.\nIncremental planning\nRequirements are recorded on \u201cstory cards,\u201d and the stories to be included in \na\u00a0release are determined by the time available and their relative priority. The \ndevelopers break these stories into development \u201ctasks.\u201d See Figures 3.5 \nand\u00a03.6.\nOn-site customer\nA representative of the end-user of the system (the Customer) should be \navailable full time for the use of the XP team. In an extreme programming \nprocess, the customer is a member of the development team and is \nresponsible for bringing system requirements to the team for implementation.\nPair programming\nDevelopers work in pairs, checking each other's work and providing the \nsupport to always do a good job.\nRefactoring\nAll developers are expected to refactor the code continuously as soon as \npotential code improvements are found. This keeps the code simple and \nmaintainable.\nSimple design\nEnough design is carried out to meet the current requirements and no more.\nSmall releases\nThe minimal useful set of functionality that provides business value is \ndeveloped first. Releases of the system are frequent and incrementally add \nfunctionality to the first release.\nSustainable pace\nLarge amounts of overtime are not considered acceptable, as the net effect is \noften to reduce code quality and medium-term productivity.\nTest first \ndevelopment\nAn automated unit test framework is used to write tests for a new piece of \nfunctionality before that functionality itself is implemented.\nFigure 3.4 Extreme \nprogramming practices 4. Change is embraced through regular system releases to customers, test-first \ndevelopment, refactoring to avoid code degeneration, and continuous integra-\ntion of new functionality.\n5. Maintaining simplicity is supported by constant refactoring that improves code \nquality and by using simple designs that do not unnecessarily anticipate future \nchanges to the system.\nIn practice, the application of Extreme Programming as originally proposed has \nproved to be more difficult than anticipated. It cannot be readily integrated with the \nmanagement practices and culture of most businesses. Therefore, companies adopt-\ning agile methods pick and choose those XP practices that are most appropriate for \ntheir way of working. Sometimes these are incorporated into their own development \nprocesses but, more commonly, they are used in conjunction with a management-\nfocused agile method such as Scrum (Rubin 2013)."}
{"query": "How does Extreme Programming (XP) prioritize people over process?", "response": "Extreme Programming (XP) prioritizes people over process by promoting practices that emphasize the importance of individuals and their collaboration. For example, XP encourages pair programming, where developers work in pairs and support each other to produce high-quality code. This practice ensures that knowledge is shared among team members and prevents the development of isolated areas of expertise. XP also promotes collective ownership of the system code, where all developers take responsibility for all parts of the codebase. This fosters a sense of shared ownership and encourages collaboration. Additionally, XP advocates for a sustainable development process that does not involve excessively long working hours, prioritizing the well-being and productivity of the team members.", "context": "3.2  \u25a0 Agile development techniques  77\n systems can be developed by co-located teams, so informal communications among \nteam members work well.\n \n3.2  Agile development techniques\nThe ideas underlying agile methods were developed around the same time by a number \nof different people in the 1990s. However, perhaps the most significant approach to \nchanging software development culture was the development of Extreme Programming \n(XP). The name was coined by Kent Beck (Beck 1998) because the approach was \ndeveloped by pushing recognized good practice, such as iterative development, to \n\u201cextreme\u201d levels. For example, in XP, several new versions of a system may be devel-\noped by different programmers, integrated, and tested in a day. Figure 3.3 illustrates \nthe XP process to produce an increment of the system that is being developed.\nIn XP, requirements are expressed as scenarios (called user stories), which are \nimplemented directly as a series of tasks. Programmers work in pairs and develop \ntests for each task before writing the code. All tests must be successfully executed \nwhen new code is integrated into the system. There is a short time gap between \nreleases of the system.\nExtreme programming was controversial as it introduced a number of agile prac-\ntices that were quite different from the development practice of that time. These prac-\ntices are summarized in Figure 3.4 and reflect the principles of the agile manifesto:\n1. \nIncremental development is supported through small, frequent releases of the sys-\ntem. Requirements are based on simple customer stories or scenarios that are used \nas a basis for deciding what functionality should be included in a system increment.\n2. Customer involvement is supported through the continuous engagement of the \ncustomer in the development team. The customer representative takes part in \nthe development and is responsible for defining acceptance tests for the system.\n3. People, not process, are supported through pair programming, collective owner-\nship of the system code, and a sustainable development process that does not \ninvolve excessively long working hours.\nBreak down\nstories to tasks\nSelect user\nstories for this\nrelease\nPlan release\nRelease\nsoftware\nEvaluate\nsystem\nDevelop/integrate/\ntest software\nFigure 3.3 The XP \nrelease cycle\n\n\n78  Chapter 3 \u25a0 Agile software development\nPrinciple or practice\nDescription\nCollective ownership\nThe pairs of developers work on all areas of the system, so that no islands of \nexpertise develop and all the developers take responsibility for all of the code. \nAnyone can change anything.\nContinuous \nintegration\nAs soon as the work on a task is complete, it is integrated into the whole \nsystem. After any such integration, all the unit tests in the system must pass.\nIncremental planning\nRequirements are recorded on \u201cstory cards,\u201d and the stories to be included in \na\u00a0release are determined by the time available and their relative priority. The \ndevelopers break these stories into development \u201ctasks.\u201d See Figures 3.5 \nand\u00a03.6.\nOn-site customer\nA representative of the end-user of the system (the Customer) should be \navailable full time for the use of the XP team. In an extreme programming \nprocess, the customer is a member of the development team and is \nresponsible for bringing system requirements to the team for implementation.\nPair programming\nDevelopers work in pairs, checking each other's work and providing the \nsupport to always do a good job.\nRefactoring\nAll developers are expected to refactor the code continuously as soon as \npotential code improvements are found. This keeps the code simple and \nmaintainable.\nSimple design\nEnough design is carried out to meet the current requirements and no more.\nSmall releases\nThe minimal useful set of functionality that provides business value is \ndeveloped first. Releases of the system are frequent and incrementally add \nfunctionality to the first release.\nSustainable pace\nLarge amounts of overtime are not considered acceptable, as the net effect is \noften to reduce code quality and medium-term productivity.\nTest first \ndevelopment\nAn automated unit test framework is used to write tests for a new piece of \nfunctionality before that functionality itself is implemented.\nFigure 3.4 Extreme \nprogramming practices 4. Change is embraced through regular system releases to customers, test-first \ndevelopment, refactoring to avoid code degeneration, and continuous integra-\ntion of new functionality.\n5. Maintaining simplicity is supported by constant refactoring that improves code \nquality and by using simple designs that do not unnecessarily anticipate future \nchanges to the system.\nIn practice, the application of Extreme Programming as originally proposed has \nproved to be more difficult than anticipated. It cannot be readily integrated with the \nmanagement practices and culture of most businesses. Therefore, companies adopt-\ning agile methods pick and choose those XP practices that are most appropriate for \ntheir way of working. Sometimes these are incorporated into their own development \nprocesses but, more commonly, they are used in conjunction with a management-\nfocused agile method such as Scrum (Rubin 2013)."}
{"query": "What is the XP release cycle?", "response": "The XP release cycle involves several steps. First, user stories are selected for a particular release. Then, the development team breaks down these stories into tasks. The software is developed, integrated, and tested. Once the work on a task is complete, it is integrated into the whole system. After integration, all unit tests in the system must pass. Finally, the software is released and evaluated.", "context": "3.2  \u25a0 Agile development techniques  77\n systems can be developed by co-located teams, so informal communications among \nteam members work well.\n \n3.2  Agile development techniques\nThe ideas underlying agile methods were developed around the same time by a number \nof different people in the 1990s. However, perhaps the most significant approach to \nchanging software development culture was the development of Extreme Programming \n(XP). The name was coined by Kent Beck (Beck 1998) because the approach was \ndeveloped by pushing recognized good practice, such as iterative development, to \n\u201cextreme\u201d levels. For example, in XP, several new versions of a system may be devel-\noped by different programmers, integrated, and tested in a day. Figure 3.3 illustrates \nthe XP process to produce an increment of the system that is being developed.\nIn XP, requirements are expressed as scenarios (called user stories), which are \nimplemented directly as a series of tasks. Programmers work in pairs and develop \ntests for each task before writing the code. All tests must be successfully executed \nwhen new code is integrated into the system. There is a short time gap between \nreleases of the system.\nExtreme programming was controversial as it introduced a number of agile prac-\ntices that were quite different from the development practice of that time. These prac-\ntices are summarized in Figure 3.4 and reflect the principles of the agile manifesto:\n1. \nIncremental development is supported through small, frequent releases of the sys-\ntem. Requirements are based on simple customer stories or scenarios that are used \nas a basis for deciding what functionality should be included in a system increment.\n2. Customer involvement is supported through the continuous engagement of the \ncustomer in the development team. The customer representative takes part in \nthe development and is responsible for defining acceptance tests for the system.\n3. People, not process, are supported through pair programming, collective owner-\nship of the system code, and a sustainable development process that does not \ninvolve excessively long working hours.\nBreak down\nstories to tasks\nSelect user\nstories for this\nrelease\nPlan release\nRelease\nsoftware\nEvaluate\nsystem\nDevelop/integrate/\ntest software\nFigure 3.3 The XP \nrelease cycle\n\n\n78  Chapter 3 \u25a0 Agile software development\nPrinciple or practice\nDescription\nCollective ownership\nThe pairs of developers work on all areas of the system, so that no islands of \nexpertise develop and all the developers take responsibility for all of the code. \nAnyone can change anything.\nContinuous \nintegration\nAs soon as the work on a task is complete, it is integrated into the whole \nsystem. After any such integration, all the unit tests in the system must pass.\nIncremental planning\nRequirements are recorded on \u201cstory cards,\u201d and the stories to be included in \na\u00a0release are determined by the time available and their relative priority. The \ndevelopers break these stories into development \u201ctasks.\u201d See Figures 3.5 \nand\u00a03.6.\nOn-site customer\nA representative of the end-user of the system (the Customer) should be \navailable full time for the use of the XP team. In an extreme programming \nprocess, the customer is a member of the development team and is \nresponsible for bringing system requirements to the team for implementation.\nPair programming\nDevelopers work in pairs, checking each other's work and providing the \nsupport to always do a good job.\nRefactoring\nAll developers are expected to refactor the code continuously as soon as \npotential code improvements are found. This keeps the code simple and \nmaintainable.\nSimple design\nEnough design is carried out to meet the current requirements and no more.\nSmall releases\nThe minimal useful set of functionality that provides business value is \ndeveloped first. Releases of the system are frequent and incrementally add \nfunctionality to the first release.\nSustainable pace\nLarge amounts of overtime are not considered acceptable, as the net effect is \noften to reduce code quality and medium-term productivity.\nTest first \ndevelopment\nAn automated unit test framework is used to write tests for a new piece of \nfunctionality before that functionality itself is implemented.\nFigure 3.4 Extreme \nprogramming practices 4. Change is embraced through regular system releases to customers, test-first \ndevelopment, refactoring to avoid code degeneration, and continuous integra-\ntion of new functionality.\n5. Maintaining simplicity is supported by constant refactoring that improves code \nquality and by using simple designs that do not unnecessarily anticipate future \nchanges to the system.\nIn practice, the application of Extreme Programming as originally proposed has \nproved to be more difficult than anticipated. It cannot be readily integrated with the \nmanagement practices and culture of most businesses. Therefore, companies adopt-\ning agile methods pick and choose those XP practices that are most appropriate for \ntheir way of working. Sometimes these are incorporated into their own development \nprocesses but, more commonly, they are used in conjunction with a management-\nfocused agile method such as Scrum (Rubin 2013)."}
{"query": "What is the principle of collective ownership in Extreme Programming (XP)?", "response": "The principle of collective ownership in Extreme Programming (XP) is that all developers work on all areas of the system, so that no islands of expertise develop and all the developers take responsibility for all of the code. This means that anyone can change anything in the code.", "context": "3.2  \u25a0 Agile development techniques  77\n systems can be developed by co-located teams, so informal communications among \nteam members work well.\n \n3.2  Agile development techniques\nThe ideas underlying agile methods were developed around the same time by a number \nof different people in the 1990s. However, perhaps the most significant approach to \nchanging software development culture was the development of Extreme Programming \n(XP). The name was coined by Kent Beck (Beck 1998) because the approach was \ndeveloped by pushing recognized good practice, such as iterative development, to \n\u201cextreme\u201d levels. For example, in XP, several new versions of a system may be devel-\noped by different programmers, integrated, and tested in a day. Figure 3.3 illustrates \nthe XP process to produce an increment of the system that is being developed.\nIn XP, requirements are expressed as scenarios (called user stories), which are \nimplemented directly as a series of tasks. Programmers work in pairs and develop \ntests for each task before writing the code. All tests must be successfully executed \nwhen new code is integrated into the system. There is a short time gap between \nreleases of the system.\nExtreme programming was controversial as it introduced a number of agile prac-\ntices that were quite different from the development practice of that time. These prac-\ntices are summarized in Figure 3.4 and reflect the principles of the agile manifesto:\n1. \nIncremental development is supported through small, frequent releases of the sys-\ntem. Requirements are based on simple customer stories or scenarios that are used \nas a basis for deciding what functionality should be included in a system increment.\n2. Customer involvement is supported through the continuous engagement of the \ncustomer in the development team. The customer representative takes part in \nthe development and is responsible for defining acceptance tests for the system.\n3. People, not process, are supported through pair programming, collective owner-\nship of the system code, and a sustainable development process that does not \ninvolve excessively long working hours.\nBreak down\nstories to tasks\nSelect user\nstories for this\nrelease\nPlan release\nRelease\nsoftware\nEvaluate\nsystem\nDevelop/integrate/\ntest software\nFigure 3.3 The XP \nrelease cycle\n\n\n78  Chapter 3 \u25a0 Agile software development\nPrinciple or practice\nDescription\nCollective ownership\nThe pairs of developers work on all areas of the system, so that no islands of \nexpertise develop and all the developers take responsibility for all of the code. \nAnyone can change anything.\nContinuous \nintegration\nAs soon as the work on a task is complete, it is integrated into the whole \nsystem. After any such integration, all the unit tests in the system must pass.\nIncremental planning\nRequirements are recorded on \u201cstory cards,\u201d and the stories to be included in \na\u00a0release are determined by the time available and their relative priority. The \ndevelopers break these stories into development \u201ctasks.\u201d See Figures 3.5 \nand\u00a03.6.\nOn-site customer\nA representative of the end-user of the system (the Customer) should be \navailable full time for the use of the XP team. In an extreme programming \nprocess, the customer is a member of the development team and is \nresponsible for bringing system requirements to the team for implementation.\nPair programming\nDevelopers work in pairs, checking each other's work and providing the \nsupport to always do a good job.\nRefactoring\nAll developers are expected to refactor the code continuously as soon as \npotential code improvements are found. This keeps the code simple and \nmaintainable.\nSimple design\nEnough design is carried out to meet the current requirements and no more.\nSmall releases\nThe minimal useful set of functionality that provides business value is \ndeveloped first. Releases of the system are frequent and incrementally add \nfunctionality to the first release.\nSustainable pace\nLarge amounts of overtime are not considered acceptable, as the net effect is \noften to reduce code quality and medium-term productivity.\nTest first \ndevelopment\nAn automated unit test framework is used to write tests for a new piece of \nfunctionality before that functionality itself is implemented.\nFigure 3.4 Extreme \nprogramming practices 4. Change is embraced through regular system releases to customers, test-first \ndevelopment, refactoring to avoid code degeneration, and continuous integra-\ntion of new functionality.\n5. Maintaining simplicity is supported by constant refactoring that improves code \nquality and by using simple designs that do not unnecessarily anticipate future \nchanges to the system.\nIn practice, the application of Extreme Programming as originally proposed has \nproved to be more difficult than anticipated. It cannot be readily integrated with the \nmanagement practices and culture of most businesses. Therefore, companies adopt-\ning agile methods pick and choose those XP practices that are most appropriate for \ntheir way of working. Sometimes these are incorporated into their own development \nprocesses but, more commonly, they are used in conjunction with a management-\nfocused agile method such as Scrum (Rubin 2013)."}
{"query": "How does Extreme Programming (XP) approach continuous integration?", "response": "Extreme Programming (XP) approach continuous integration by integrating the work on a task into the whole system as soon as it is complete. After integration, all the unit tests in the system must pass. This ensures that any changes made to the code are immediately tested and integrated into the system, promoting early detection of any issues or conflicts.", "context": "3.2  \u25a0 Agile development techniques  77\n systems can be developed by co-located teams, so informal communications among \nteam members work well.\n \n3.2  Agile development techniques\nThe ideas underlying agile methods were developed around the same time by a number \nof different people in the 1990s. However, perhaps the most significant approach to \nchanging software development culture was the development of Extreme Programming \n(XP). The name was coined by Kent Beck (Beck 1998) because the approach was \ndeveloped by pushing recognized good practice, such as iterative development, to \n\u201cextreme\u201d levels. For example, in XP, several new versions of a system may be devel-\noped by different programmers, integrated, and tested in a day. Figure 3.3 illustrates \nthe XP process to produce an increment of the system that is being developed.\nIn XP, requirements are expressed as scenarios (called user stories), which are \nimplemented directly as a series of tasks. Programmers work in pairs and develop \ntests for each task before writing the code. All tests must be successfully executed \nwhen new code is integrated into the system. There is a short time gap between \nreleases of the system.\nExtreme programming was controversial as it introduced a number of agile prac-\ntices that were quite different from the development practice of that time. These prac-\ntices are summarized in Figure 3.4 and reflect the principles of the agile manifesto:\n1. \nIncremental development is supported through small, frequent releases of the sys-\ntem. Requirements are based on simple customer stories or scenarios that are used \nas a basis for deciding what functionality should be included in a system increment.\n2. Customer involvement is supported through the continuous engagement of the \ncustomer in the development team. The customer representative takes part in \nthe development and is responsible for defining acceptance tests for the system.\n3. People, not process, are supported through pair programming, collective owner-\nship of the system code, and a sustainable development process that does not \ninvolve excessively long working hours.\nBreak down\nstories to tasks\nSelect user\nstories for this\nrelease\nPlan release\nRelease\nsoftware\nEvaluate\nsystem\nDevelop/integrate/\ntest software\nFigure 3.3 The XP \nrelease cycle\n\n\n78  Chapter 3 \u25a0 Agile software development\nPrinciple or practice\nDescription\nCollective ownership\nThe pairs of developers work on all areas of the system, so that no islands of \nexpertise develop and all the developers take responsibility for all of the code. \nAnyone can change anything.\nContinuous \nintegration\nAs soon as the work on a task is complete, it is integrated into the whole \nsystem. After any such integration, all the unit tests in the system must pass.\nIncremental planning\nRequirements are recorded on \u201cstory cards,\u201d and the stories to be included in \na\u00a0release are determined by the time available and their relative priority. The \ndevelopers break these stories into development \u201ctasks.\u201d See Figures 3.5 \nand\u00a03.6.\nOn-site customer\nA representative of the end-user of the system (the Customer) should be \navailable full time for the use of the XP team. In an extreme programming \nprocess, the customer is a member of the development team and is \nresponsible for bringing system requirements to the team for implementation.\nPair programming\nDevelopers work in pairs, checking each other's work and providing the \nsupport to always do a good job.\nRefactoring\nAll developers are expected to refactor the code continuously as soon as \npotential code improvements are found. This keeps the code simple and \nmaintainable.\nSimple design\nEnough design is carried out to meet the current requirements and no more.\nSmall releases\nThe minimal useful set of functionality that provides business value is \ndeveloped first. Releases of the system are frequent and incrementally add \nfunctionality to the first release.\nSustainable pace\nLarge amounts of overtime are not considered acceptable, as the net effect is \noften to reduce code quality and medium-term productivity.\nTest first \ndevelopment\nAn automated unit test framework is used to write tests for a new piece of \nfunctionality before that functionality itself is implemented.\nFigure 3.4 Extreme \nprogramming practices 4. Change is embraced through regular system releases to customers, test-first \ndevelopment, refactoring to avoid code degeneration, and continuous integra-\ntion of new functionality.\n5. Maintaining simplicity is supported by constant refactoring that improves code \nquality and by using simple designs that do not unnecessarily anticipate future \nchanges to the system.\nIn practice, the application of Extreme Programming as originally proposed has \nproved to be more difficult than anticipated. It cannot be readily integrated with the \nmanagement practices and culture of most businesses. Therefore, companies adopt-\ning agile methods pick and choose those XP practices that are most appropriate for \ntheir way of working. Sometimes these are incorporated into their own development \nprocesses but, more commonly, they are used in conjunction with a management-\nfocused agile method such as Scrum (Rubin 2013)."}
{"query": "What is the concept of incremental planning in Extreme Programming (XP)?", "response": "The concept of incremental planning in Extreme Programming (XP) is that requirements are recorded on \"story cards\" and the stories to be included in a release are determined by the time available and their relative priority. The developers then break these stories into development \"tasks.\" This approach allows for small, frequent releases of the system that incrementally add functionality to the first release.", "context": "3.2  \u25a0 Agile development techniques  77\n systems can be developed by co-located teams, so informal communications among \nteam members work well.\n \n3.2  Agile development techniques\nThe ideas underlying agile methods were developed around the same time by a number \nof different people in the 1990s. However, perhaps the most significant approach to \nchanging software development culture was the development of Extreme Programming \n(XP). The name was coined by Kent Beck (Beck 1998) because the approach was \ndeveloped by pushing recognized good practice, such as iterative development, to \n\u201cextreme\u201d levels. For example, in XP, several new versions of a system may be devel-\noped by different programmers, integrated, and tested in a day. Figure 3.3 illustrates \nthe XP process to produce an increment of the system that is being developed.\nIn XP, requirements are expressed as scenarios (called user stories), which are \nimplemented directly as a series of tasks. Programmers work in pairs and develop \ntests for each task before writing the code. All tests must be successfully executed \nwhen new code is integrated into the system. There is a short time gap between \nreleases of the system.\nExtreme programming was controversial as it introduced a number of agile prac-\ntices that were quite different from the development practice of that time. These prac-\ntices are summarized in Figure 3.4 and reflect the principles of the agile manifesto:\n1. \nIncremental development is supported through small, frequent releases of the sys-\ntem. Requirements are based on simple customer stories or scenarios that are used \nas a basis for deciding what functionality should be included in a system increment.\n2. Customer involvement is supported through the continuous engagement of the \ncustomer in the development team. The customer representative takes part in \nthe development and is responsible for defining acceptance tests for the system.\n3. People, not process, are supported through pair programming, collective owner-\nship of the system code, and a sustainable development process that does not \ninvolve excessively long working hours.\nBreak down\nstories to tasks\nSelect user\nstories for this\nrelease\nPlan release\nRelease\nsoftware\nEvaluate\nsystem\nDevelop/integrate/\ntest software\nFigure 3.3 The XP \nrelease cycle\n\n\n78  Chapter 3 \u25a0 Agile software development\nPrinciple or practice\nDescription\nCollective ownership\nThe pairs of developers work on all areas of the system, so that no islands of \nexpertise develop and all the developers take responsibility for all of the code. \nAnyone can change anything.\nContinuous \nintegration\nAs soon as the work on a task is complete, it is integrated into the whole \nsystem. After any such integration, all the unit tests in the system must pass.\nIncremental planning\nRequirements are recorded on \u201cstory cards,\u201d and the stories to be included in \na\u00a0release are determined by the time available and their relative priority. The \ndevelopers break these stories into development \u201ctasks.\u201d See Figures 3.5 \nand\u00a03.6.\nOn-site customer\nA representative of the end-user of the system (the Customer) should be \navailable full time for the use of the XP team. In an extreme programming \nprocess, the customer is a member of the development team and is \nresponsible for bringing system requirements to the team for implementation.\nPair programming\nDevelopers work in pairs, checking each other's work and providing the \nsupport to always do a good job.\nRefactoring\nAll developers are expected to refactor the code continuously as soon as \npotential code improvements are found. This keeps the code simple and \nmaintainable.\nSimple design\nEnough design is carried out to meet the current requirements and no more.\nSmall releases\nThe minimal useful set of functionality that provides business value is \ndeveloped first. Releases of the system are frequent and incrementally add \nfunctionality to the first release.\nSustainable pace\nLarge amounts of overtime are not considered acceptable, as the net effect is \noften to reduce code quality and medium-term productivity.\nTest first \ndevelopment\nAn automated unit test framework is used to write tests for a new piece of \nfunctionality before that functionality itself is implemented.\nFigure 3.4 Extreme \nprogramming practices 4. Change is embraced through regular system releases to customers, test-first \ndevelopment, refactoring to avoid code degeneration, and continuous integra-\ntion of new functionality.\n5. Maintaining simplicity is supported by constant refactoring that improves code \nquality and by using simple designs that do not unnecessarily anticipate future \nchanges to the system.\nIn practice, the application of Extreme Programming as originally proposed has \nproved to be more difficult than anticipated. It cannot be readily integrated with the \nmanagement practices and culture of most businesses. Therefore, companies adopt-\ning agile methods pick and choose those XP practices that are most appropriate for \ntheir way of working. Sometimes these are incorporated into their own development \nprocesses but, more commonly, they are used in conjunction with a management-\nfocused agile method such as Scrum (Rubin 2013)."}
{"query": "What is the role of the on-site customer in Extreme Programming (XP)?", "response": "The on-site customer in Extreme Programming (XP) is a representative of the end-user of the system. They are responsible for bringing system requirements to the development team for implementation. The on-site customer is available full time for the use of the XP team and is actively involved in the development process.", "context": "3.2  \u25a0 Agile development techniques  77\n systems can be developed by co-located teams, so informal communications among \nteam members work well.\n \n3.2  Agile development techniques\nThe ideas underlying agile methods were developed around the same time by a number \nof different people in the 1990s. However, perhaps the most significant approach to \nchanging software development culture was the development of Extreme Programming \n(XP). The name was coined by Kent Beck (Beck 1998) because the approach was \ndeveloped by pushing recognized good practice, such as iterative development, to \n\u201cextreme\u201d levels. For example, in XP, several new versions of a system may be devel-\noped by different programmers, integrated, and tested in a day. Figure 3.3 illustrates \nthe XP process to produce an increment of the system that is being developed.\nIn XP, requirements are expressed as scenarios (called user stories), which are \nimplemented directly as a series of tasks. Programmers work in pairs and develop \ntests for each task before writing the code. All tests must be successfully executed \nwhen new code is integrated into the system. There is a short time gap between \nreleases of the system.\nExtreme programming was controversial as it introduced a number of agile prac-\ntices that were quite different from the development practice of that time. These prac-\ntices are summarized in Figure 3.4 and reflect the principles of the agile manifesto:\n1. \nIncremental development is supported through small, frequent releases of the sys-\ntem. Requirements are based on simple customer stories or scenarios that are used \nas a basis for deciding what functionality should be included in a system increment.\n2. Customer involvement is supported through the continuous engagement of the \ncustomer in the development team. The customer representative takes part in \nthe development and is responsible for defining acceptance tests for the system.\n3. People, not process, are supported through pair programming, collective owner-\nship of the system code, and a sustainable development process that does not \ninvolve excessively long working hours.\nBreak down\nstories to tasks\nSelect user\nstories for this\nrelease\nPlan release\nRelease\nsoftware\nEvaluate\nsystem\nDevelop/integrate/\ntest software\nFigure 3.3 The XP \nrelease cycle\n\n\n78  Chapter 3 \u25a0 Agile software development\nPrinciple or practice\nDescription\nCollective ownership\nThe pairs of developers work on all areas of the system, so that no islands of \nexpertise develop and all the developers take responsibility for all of the code. \nAnyone can change anything.\nContinuous \nintegration\nAs soon as the work on a task is complete, it is integrated into the whole \nsystem. After any such integration, all the unit tests in the system must pass.\nIncremental planning\nRequirements are recorded on \u201cstory cards,\u201d and the stories to be included in \na\u00a0release are determined by the time available and their relative priority. The \ndevelopers break these stories into development \u201ctasks.\u201d See Figures 3.5 \nand\u00a03.6.\nOn-site customer\nA representative of the end-user of the system (the Customer) should be \navailable full time for the use of the XP team. In an extreme programming \nprocess, the customer is a member of the development team and is \nresponsible for bringing system requirements to the team for implementation.\nPair programming\nDevelopers work in pairs, checking each other's work and providing the \nsupport to always do a good job.\nRefactoring\nAll developers are expected to refactor the code continuously as soon as \npotential code improvements are found. This keeps the code simple and \nmaintainable.\nSimple design\nEnough design is carried out to meet the current requirements and no more.\nSmall releases\nThe minimal useful set of functionality that provides business value is \ndeveloped first. Releases of the system are frequent and incrementally add \nfunctionality to the first release.\nSustainable pace\nLarge amounts of overtime are not considered acceptable, as the net effect is \noften to reduce code quality and medium-term productivity.\nTest first \ndevelopment\nAn automated unit test framework is used to write tests for a new piece of \nfunctionality before that functionality itself is implemented.\nFigure 3.4 Extreme \nprogramming practices 4. Change is embraced through regular system releases to customers, test-first \ndevelopment, refactoring to avoid code degeneration, and continuous integra-\ntion of new functionality.\n5. Maintaining simplicity is supported by constant refactoring that improves code \nquality and by using simple designs that do not unnecessarily anticipate future \nchanges to the system.\nIn practice, the application of Extreme Programming as originally proposed has \nproved to be more difficult than anticipated. It cannot be readily integrated with the \nmanagement practices and culture of most businesses. Therefore, companies adopt-\ning agile methods pick and choose those XP practices that are most appropriate for \ntheir way of working. Sometimes these are incorporated into their own development \nprocesses but, more commonly, they are used in conjunction with a management-\nfocused agile method such as Scrum (Rubin 2013)."}
{"query": "What is the principle of pair programming in Extreme Programming (XP)?", "response": "The principle of pair programming in Extreme Programming (XP) is that developers work in pairs, checking each other's work and providing support to always do a good job.", "context": "3.2  \u25a0 Agile development techniques  77\n systems can be developed by co-located teams, so informal communications among \nteam members work well.\n \n3.2  Agile development techniques\nThe ideas underlying agile methods were developed around the same time by a number \nof different people in the 1990s. However, perhaps the most significant approach to \nchanging software development culture was the development of Extreme Programming \n(XP). The name was coined by Kent Beck (Beck 1998) because the approach was \ndeveloped by pushing recognized good practice, such as iterative development, to \n\u201cextreme\u201d levels. For example, in XP, several new versions of a system may be devel-\noped by different programmers, integrated, and tested in a day. Figure 3.3 illustrates \nthe XP process to produce an increment of the system that is being developed.\nIn XP, requirements are expressed as scenarios (called user stories), which are \nimplemented directly as a series of tasks. Programmers work in pairs and develop \ntests for each task before writing the code. All tests must be successfully executed \nwhen new code is integrated into the system. There is a short time gap between \nreleases of the system.\nExtreme programming was controversial as it introduced a number of agile prac-\ntices that were quite different from the development practice of that time. These prac-\ntices are summarized in Figure 3.4 and reflect the principles of the agile manifesto:\n1. \nIncremental development is supported through small, frequent releases of the sys-\ntem. Requirements are based on simple customer stories or scenarios that are used \nas a basis for deciding what functionality should be included in a system increment.\n2. Customer involvement is supported through the continuous engagement of the \ncustomer in the development team. The customer representative takes part in \nthe development and is responsible for defining acceptance tests for the system.\n3. People, not process, are supported through pair programming, collective owner-\nship of the system code, and a sustainable development process that does not \ninvolve excessively long working hours.\nBreak down\nstories to tasks\nSelect user\nstories for this\nrelease\nPlan release\nRelease\nsoftware\nEvaluate\nsystem\nDevelop/integrate/\ntest software\nFigure 3.3 The XP \nrelease cycle\n\n\n78  Chapter 3 \u25a0 Agile software development\nPrinciple or practice\nDescription\nCollective ownership\nThe pairs of developers work on all areas of the system, so that no islands of \nexpertise develop and all the developers take responsibility for all of the code. \nAnyone can change anything.\nContinuous \nintegration\nAs soon as the work on a task is complete, it is integrated into the whole \nsystem. After any such integration, all the unit tests in the system must pass.\nIncremental planning\nRequirements are recorded on \u201cstory cards,\u201d and the stories to be included in \na\u00a0release are determined by the time available and their relative priority. The \ndevelopers break these stories into development \u201ctasks.\u201d See Figures 3.5 \nand\u00a03.6.\nOn-site customer\nA representative of the end-user of the system (the Customer) should be \navailable full time for the use of the XP team. In an extreme programming \nprocess, the customer is a member of the development team and is \nresponsible for bringing system requirements to the team for implementation.\nPair programming\nDevelopers work in pairs, checking each other's work and providing the \nsupport to always do a good job.\nRefactoring\nAll developers are expected to refactor the code continuously as soon as \npotential code improvements are found. This keeps the code simple and \nmaintainable.\nSimple design\nEnough design is carried out to meet the current requirements and no more.\nSmall releases\nThe minimal useful set of functionality that provides business value is \ndeveloped first. Releases of the system are frequent and incrementally add \nfunctionality to the first release.\nSustainable pace\nLarge amounts of overtime are not considered acceptable, as the net effect is \noften to reduce code quality and medium-term productivity.\nTest first \ndevelopment\nAn automated unit test framework is used to write tests for a new piece of \nfunctionality before that functionality itself is implemented.\nFigure 3.4 Extreme \nprogramming practices 4. Change is embraced through regular system releases to customers, test-first \ndevelopment, refactoring to avoid code degeneration, and continuous integra-\ntion of new functionality.\n5. Maintaining simplicity is supported by constant refactoring that improves code \nquality and by using simple designs that do not unnecessarily anticipate future \nchanges to the system.\nIn practice, the application of Extreme Programming as originally proposed has \nproved to be more difficult than anticipated. It cannot be readily integrated with the \nmanagement practices and culture of most businesses. Therefore, companies adopt-\ning agile methods pick and choose those XP practices that are most appropriate for \ntheir way of working. Sometimes these are incorporated into their own development \nprocesses but, more commonly, they are used in conjunction with a management-\nfocused agile method such as Scrum (Rubin 2013)."}
{"query": "How does Extreme Programming (XP) approach refactoring?", "response": "Extreme Programming (XP) approach refactoring by expecting all developers to continuously refactor the code as soon as potential code improvements are found. This practice helps to keep the code simple and maintainable.", "context": "3.2  \u25a0 Agile development techniques  77\n systems can be developed by co-located teams, so informal communications among \nteam members work well.\n \n3.2  Agile development techniques\nThe ideas underlying agile methods were developed around the same time by a number \nof different people in the 1990s. However, perhaps the most significant approach to \nchanging software development culture was the development of Extreme Programming \n(XP). The name was coined by Kent Beck (Beck 1998) because the approach was \ndeveloped by pushing recognized good practice, such as iterative development, to \n\u201cextreme\u201d levels. For example, in XP, several new versions of a system may be devel-\noped by different programmers, integrated, and tested in a day. Figure 3.3 illustrates \nthe XP process to produce an increment of the system that is being developed.\nIn XP, requirements are expressed as scenarios (called user stories), which are \nimplemented directly as a series of tasks. Programmers work in pairs and develop \ntests for each task before writing the code. All tests must be successfully executed \nwhen new code is integrated into the system. There is a short time gap between \nreleases of the system.\nExtreme programming was controversial as it introduced a number of agile prac-\ntices that were quite different from the development practice of that time. These prac-\ntices are summarized in Figure 3.4 and reflect the principles of the agile manifesto:\n1. \nIncremental development is supported through small, frequent releases of the sys-\ntem. Requirements are based on simple customer stories or scenarios that are used \nas a basis for deciding what functionality should be included in a system increment.\n2. Customer involvement is supported through the continuous engagement of the \ncustomer in the development team. The customer representative takes part in \nthe development and is responsible for defining acceptance tests for the system.\n3. People, not process, are supported through pair programming, collective owner-\nship of the system code, and a sustainable development process that does not \ninvolve excessively long working hours.\nBreak down\nstories to tasks\nSelect user\nstories for this\nrelease\nPlan release\nRelease\nsoftware\nEvaluate\nsystem\nDevelop/integrate/\ntest software\nFigure 3.3 The XP \nrelease cycle\n\n\n78  Chapter 3 \u25a0 Agile software development\nPrinciple or practice\nDescription\nCollective ownership\nThe pairs of developers work on all areas of the system, so that no islands of \nexpertise develop and all the developers take responsibility for all of the code. \nAnyone can change anything.\nContinuous \nintegration\nAs soon as the work on a task is complete, it is integrated into the whole \nsystem. After any such integration, all the unit tests in the system must pass.\nIncremental planning\nRequirements are recorded on \u201cstory cards,\u201d and the stories to be included in \na\u00a0release are determined by the time available and their relative priority. The \ndevelopers break these stories into development \u201ctasks.\u201d See Figures 3.5 \nand\u00a03.6.\nOn-site customer\nA representative of the end-user of the system (the Customer) should be \navailable full time for the use of the XP team. In an extreme programming \nprocess, the customer is a member of the development team and is \nresponsible for bringing system requirements to the team for implementation.\nPair programming\nDevelopers work in pairs, checking each other's work and providing the \nsupport to always do a good job.\nRefactoring\nAll developers are expected to refactor the code continuously as soon as \npotential code improvements are found. This keeps the code simple and \nmaintainable.\nSimple design\nEnough design is carried out to meet the current requirements and no more.\nSmall releases\nThe minimal useful set of functionality that provides business value is \ndeveloped first. Releases of the system are frequent and incrementally add \nfunctionality to the first release.\nSustainable pace\nLarge amounts of overtime are not considered acceptable, as the net effect is \noften to reduce code quality and medium-term productivity.\nTest first \ndevelopment\nAn automated unit test framework is used to write tests for a new piece of \nfunctionality before that functionality itself is implemented.\nFigure 3.4 Extreme \nprogramming practices 4. Change is embraced through regular system releases to customers, test-first \ndevelopment, refactoring to avoid code degeneration, and continuous integra-\ntion of new functionality.\n5. Maintaining simplicity is supported by constant refactoring that improves code \nquality and by using simple designs that do not unnecessarily anticipate future \nchanges to the system.\nIn practice, the application of Extreme Programming as originally proposed has \nproved to be more difficult than anticipated. It cannot be readily integrated with the \nmanagement practices and culture of most businesses. Therefore, companies adopt-\ning agile methods pick and choose those XP practices that are most appropriate for \ntheir way of working. Sometimes these are incorporated into their own development \nprocesses but, more commonly, they are used in conjunction with a management-\nfocused agile method such as Scrum (Rubin 2013)."}
{"query": "What is the principle of simple design in Extreme Programming (XP)?", "response": "The principle of simple design in Extreme Programming (XP) is to carry out enough design to meet the current requirements and no more. This means that the design should be kept simple and not unnecessarily anticipate future changes to the system.", "context": "3.2  \u25a0 Agile development techniques  77\n systems can be developed by co-located teams, so informal communications among \nteam members work well.\n \n3.2  Agile development techniques\nThe ideas underlying agile methods were developed around the same time by a number \nof different people in the 1990s. However, perhaps the most significant approach to \nchanging software development culture was the development of Extreme Programming \n(XP). The name was coined by Kent Beck (Beck 1998) because the approach was \ndeveloped by pushing recognized good practice, such as iterative development, to \n\u201cextreme\u201d levels. For example, in XP, several new versions of a system may be devel-\noped by different programmers, integrated, and tested in a day. Figure 3.3 illustrates \nthe XP process to produce an increment of the system that is being developed.\nIn XP, requirements are expressed as scenarios (called user stories), which are \nimplemented directly as a series of tasks. Programmers work in pairs and develop \ntests for each task before writing the code. All tests must be successfully executed \nwhen new code is integrated into the system. There is a short time gap between \nreleases of the system.\nExtreme programming was controversial as it introduced a number of agile prac-\ntices that were quite different from the development practice of that time. These prac-\ntices are summarized in Figure 3.4 and reflect the principles of the agile manifesto:\n1. \nIncremental development is supported through small, frequent releases of the sys-\ntem. Requirements are based on simple customer stories or scenarios that are used \nas a basis for deciding what functionality should be included in a system increment.\n2. Customer involvement is supported through the continuous engagement of the \ncustomer in the development team. The customer representative takes part in \nthe development and is responsible for defining acceptance tests for the system.\n3. People, not process, are supported through pair programming, collective owner-\nship of the system code, and a sustainable development process that does not \ninvolve excessively long working hours.\nBreak down\nstories to tasks\nSelect user\nstories for this\nrelease\nPlan release\nRelease\nsoftware\nEvaluate\nsystem\nDevelop/integrate/\ntest software\nFigure 3.3 The XP \nrelease cycle\n\n\n78  Chapter 3 \u25a0 Agile software development\nPrinciple or practice\nDescription\nCollective ownership\nThe pairs of developers work on all areas of the system, so that no islands of \nexpertise develop and all the developers take responsibility for all of the code. \nAnyone can change anything.\nContinuous \nintegration\nAs soon as the work on a task is complete, it is integrated into the whole \nsystem. After any such integration, all the unit tests in the system must pass.\nIncremental planning\nRequirements are recorded on \u201cstory cards,\u201d and the stories to be included in \na\u00a0release are determined by the time available and their relative priority. The \ndevelopers break these stories into development \u201ctasks.\u201d See Figures 3.5 \nand\u00a03.6.\nOn-site customer\nA representative of the end-user of the system (the Customer) should be \navailable full time for the use of the XP team. In an extreme programming \nprocess, the customer is a member of the development team and is \nresponsible for bringing system requirements to the team for implementation.\nPair programming\nDevelopers work in pairs, checking each other's work and providing the \nsupport to always do a good job.\nRefactoring\nAll developers are expected to refactor the code continuously as soon as \npotential code improvements are found. This keeps the code simple and \nmaintainable.\nSimple design\nEnough design is carried out to meet the current requirements and no more.\nSmall releases\nThe minimal useful set of functionality that provides business value is \ndeveloped first. Releases of the system are frequent and incrementally add \nfunctionality to the first release.\nSustainable pace\nLarge amounts of overtime are not considered acceptable, as the net effect is \noften to reduce code quality and medium-term productivity.\nTest first \ndevelopment\nAn automated unit test framework is used to write tests for a new piece of \nfunctionality before that functionality itself is implemented.\nFigure 3.4 Extreme \nprogramming practices 4. Change is embraced through regular system releases to customers, test-first \ndevelopment, refactoring to avoid code degeneration, and continuous integra-\ntion of new functionality.\n5. Maintaining simplicity is supported by constant refactoring that improves code \nquality and by using simple designs that do not unnecessarily anticipate future \nchanges to the system.\nIn practice, the application of Extreme Programming as originally proposed has \nproved to be more difficult than anticipated. It cannot be readily integrated with the \nmanagement practices and culture of most businesses. Therefore, companies adopt-\ning agile methods pick and choose those XP practices that are most appropriate for \ntheir way of working. Sometimes these are incorporated into their own development \nprocesses but, more commonly, they are used in conjunction with a management-\nfocused agile method such as Scrum (Rubin 2013)."}
{"query": "How does Extreme Programming (XP) approach small releases?", "response": "Extreme Programming (XP) approach small releases by developing the minimal useful set of functionality that provides business value first. Releases of the system are frequent and incrementally add functionality to the first release. This allows for incremental development and ensures that the system is continuously delivering value to the customer.", "context": "3.2  \u25a0 Agile development techniques  77\n systems can be developed by co-located teams, so informal communications among \nteam members work well.\n \n3.2  Agile development techniques\nThe ideas underlying agile methods were developed around the same time by a number \nof different people in the 1990s. However, perhaps the most significant approach to \nchanging software development culture was the development of Extreme Programming \n(XP). The name was coined by Kent Beck (Beck 1998) because the approach was \ndeveloped by pushing recognized good practice, such as iterative development, to \n\u201cextreme\u201d levels. For example, in XP, several new versions of a system may be devel-\noped by different programmers, integrated, and tested in a day. Figure 3.3 illustrates \nthe XP process to produce an increment of the system that is being developed.\nIn XP, requirements are expressed as scenarios (called user stories), which are \nimplemented directly as a series of tasks. Programmers work in pairs and develop \ntests for each task before writing the code. All tests must be successfully executed \nwhen new code is integrated into the system. There is a short time gap between \nreleases of the system.\nExtreme programming was controversial as it introduced a number of agile prac-\ntices that were quite different from the development practice of that time. These prac-\ntices are summarized in Figure 3.4 and reflect the principles of the agile manifesto:\n1. \nIncremental development is supported through small, frequent releases of the sys-\ntem. Requirements are based on simple customer stories or scenarios that are used \nas a basis for deciding what functionality should be included in a system increment.\n2. Customer involvement is supported through the continuous engagement of the \ncustomer in the development team. The customer representative takes part in \nthe development and is responsible for defining acceptance tests for the system.\n3. People, not process, are supported through pair programming, collective owner-\nship of the system code, and a sustainable development process that does not \ninvolve excessively long working hours.\nBreak down\nstories to tasks\nSelect user\nstories for this\nrelease\nPlan release\nRelease\nsoftware\nEvaluate\nsystem\nDevelop/integrate/\ntest software\nFigure 3.3 The XP \nrelease cycle\n\n\n78  Chapter 3 \u25a0 Agile software development\nPrinciple or practice\nDescription\nCollective ownership\nThe pairs of developers work on all areas of the system, so that no islands of \nexpertise develop and all the developers take responsibility for all of the code. \nAnyone can change anything.\nContinuous \nintegration\nAs soon as the work on a task is complete, it is integrated into the whole \nsystem. After any such integration, all the unit tests in the system must pass.\nIncremental planning\nRequirements are recorded on \u201cstory cards,\u201d and the stories to be included in \na\u00a0release are determined by the time available and their relative priority. The \ndevelopers break these stories into development \u201ctasks.\u201d See Figures 3.5 \nand\u00a03.6.\nOn-site customer\nA representative of the end-user of the system (the Customer) should be \navailable full time for the use of the XP team. In an extreme programming \nprocess, the customer is a member of the development team and is \nresponsible for bringing system requirements to the team for implementation.\nPair programming\nDevelopers work in pairs, checking each other's work and providing the \nsupport to always do a good job.\nRefactoring\nAll developers are expected to refactor the code continuously as soon as \npotential code improvements are found. This keeps the code simple and \nmaintainable.\nSimple design\nEnough design is carried out to meet the current requirements and no more.\nSmall releases\nThe minimal useful set of functionality that provides business value is \ndeveloped first. Releases of the system are frequent and incrementally add \nfunctionality to the first release.\nSustainable pace\nLarge amounts of overtime are not considered acceptable, as the net effect is \noften to reduce code quality and medium-term productivity.\nTest first \ndevelopment\nAn automated unit test framework is used to write tests for a new piece of \nfunctionality before that functionality itself is implemented.\nFigure 3.4 Extreme \nprogramming practices 4. Change is embraced through regular system releases to customers, test-first \ndevelopment, refactoring to avoid code degeneration, and continuous integra-\ntion of new functionality.\n5. Maintaining simplicity is supported by constant refactoring that improves code \nquality and by using simple designs that do not unnecessarily anticipate future \nchanges to the system.\nIn practice, the application of Extreme Programming as originally proposed has \nproved to be more difficult than anticipated. It cannot be readily integrated with the \nmanagement practices and culture of most businesses. Therefore, companies adopt-\ning agile methods pick and choose those XP practices that are most appropriate for \ntheir way of working. Sometimes these are incorporated into their own development \nprocesses but, more commonly, they are used in conjunction with a management-\nfocused agile method such as Scrum (Rubin 2013)."}
{"query": "What is the principle of sustainable pace in Extreme Programming (XP)?", "response": "The principle of sustainable pace in Extreme Programming (XP) is that large amounts of overtime are not considered acceptable. This is because working excessive hours can often lead to a reduction in code quality and medium-term productivity.", "context": "3.2  \u25a0 Agile development techniques  77\n systems can be developed by co-located teams, so informal communications among \nteam members work well.\n \n3.2  Agile development techniques\nThe ideas underlying agile methods were developed around the same time by a number \nof different people in the 1990s. However, perhaps the most significant approach to \nchanging software development culture was the development of Extreme Programming \n(XP). The name was coined by Kent Beck (Beck 1998) because the approach was \ndeveloped by pushing recognized good practice, such as iterative development, to \n\u201cextreme\u201d levels. For example, in XP, several new versions of a system may be devel-\noped by different programmers, integrated, and tested in a day. Figure 3.3 illustrates \nthe XP process to produce an increment of the system that is being developed.\nIn XP, requirements are expressed as scenarios (called user stories), which are \nimplemented directly as a series of tasks. Programmers work in pairs and develop \ntests for each task before writing the code. All tests must be successfully executed \nwhen new code is integrated into the system. There is a short time gap between \nreleases of the system.\nExtreme programming was controversial as it introduced a number of agile prac-\ntices that were quite different from the development practice of that time. These prac-\ntices are summarized in Figure 3.4 and reflect the principles of the agile manifesto:\n1. \nIncremental development is supported through small, frequent releases of the sys-\ntem. Requirements are based on simple customer stories or scenarios that are used \nas a basis for deciding what functionality should be included in a system increment.\n2. Customer involvement is supported through the continuous engagement of the \ncustomer in the development team. The customer representative takes part in \nthe development and is responsible for defining acceptance tests for the system.\n3. People, not process, are supported through pair programming, collective owner-\nship of the system code, and a sustainable development process that does not \ninvolve excessively long working hours.\nBreak down\nstories to tasks\nSelect user\nstories for this\nrelease\nPlan release\nRelease\nsoftware\nEvaluate\nsystem\nDevelop/integrate/\ntest software\nFigure 3.3 The XP \nrelease cycle\n\n\n78  Chapter 3 \u25a0 Agile software development\nPrinciple or practice\nDescription\nCollective ownership\nThe pairs of developers work on all areas of the system, so that no islands of \nexpertise develop and all the developers take responsibility for all of the code. \nAnyone can change anything.\nContinuous \nintegration\nAs soon as the work on a task is complete, it is integrated into the whole \nsystem. After any such integration, all the unit tests in the system must pass.\nIncremental planning\nRequirements are recorded on \u201cstory cards,\u201d and the stories to be included in \na\u00a0release are determined by the time available and their relative priority. The \ndevelopers break these stories into development \u201ctasks.\u201d See Figures 3.5 \nand\u00a03.6.\nOn-site customer\nA representative of the end-user of the system (the Customer) should be \navailable full time for the use of the XP team. In an extreme programming \nprocess, the customer is a member of the development team and is \nresponsible for bringing system requirements to the team for implementation.\nPair programming\nDevelopers work in pairs, checking each other's work and providing the \nsupport to always do a good job.\nRefactoring\nAll developers are expected to refactor the code continuously as soon as \npotential code improvements are found. This keeps the code simple and \nmaintainable.\nSimple design\nEnough design is carried out to meet the current requirements and no more.\nSmall releases\nThe minimal useful set of functionality that provides business value is \ndeveloped first. Releases of the system are frequent and incrementally add \nfunctionality to the first release.\nSustainable pace\nLarge amounts of overtime are not considered acceptable, as the net effect is \noften to reduce code quality and medium-term productivity.\nTest first \ndevelopment\nAn automated unit test framework is used to write tests for a new piece of \nfunctionality before that functionality itself is implemented.\nFigure 3.4 Extreme \nprogramming practices 4. Change is embraced through regular system releases to customers, test-first \ndevelopment, refactoring to avoid code degeneration, and continuous integra-\ntion of new functionality.\n5. Maintaining simplicity is supported by constant refactoring that improves code \nquality and by using simple designs that do not unnecessarily anticipate future \nchanges to the system.\nIn practice, the application of Extreme Programming as originally proposed has \nproved to be more difficult than anticipated. It cannot be readily integrated with the \nmanagement practices and culture of most businesses. Therefore, companies adopt-\ning agile methods pick and choose those XP practices that are most appropriate for \ntheir way of working. Sometimes these are incorporated into their own development \nprocesses but, more commonly, they are used in conjunction with a management-\nfocused agile method such as Scrum (Rubin 2013)."}
{"query": "How does Extreme Programming (XP) approach test first development?", "response": "Extreme Programming (XP) approach test first development by using an automated unit test framework to write tests for a new piece of functionality before implementing that functionality itself. This ensures that all tests must be successfully executed when new code is integrated into the system.", "context": "3.2  \u25a0 Agile development techniques  77\n systems can be developed by co-located teams, so informal communications among \nteam members work well.\n \n3.2  Agile development techniques\nThe ideas underlying agile methods were developed around the same time by a number \nof different people in the 1990s. However, perhaps the most significant approach to \nchanging software development culture was the development of Extreme Programming \n(XP). The name was coined by Kent Beck (Beck 1998) because the approach was \ndeveloped by pushing recognized good practice, such as iterative development, to \n\u201cextreme\u201d levels. For example, in XP, several new versions of a system may be devel-\noped by different programmers, integrated, and tested in a day. Figure 3.3 illustrates \nthe XP process to produce an increment of the system that is being developed.\nIn XP, requirements are expressed as scenarios (called user stories), which are \nimplemented directly as a series of tasks. Programmers work in pairs and develop \ntests for each task before writing the code. All tests must be successfully executed \nwhen new code is integrated into the system. There is a short time gap between \nreleases of the system.\nExtreme programming was controversial as it introduced a number of agile prac-\ntices that were quite different from the development practice of that time. These prac-\ntices are summarized in Figure 3.4 and reflect the principles of the agile manifesto:\n1. \nIncremental development is supported through small, frequent releases of the sys-\ntem. Requirements are based on simple customer stories or scenarios that are used \nas a basis for deciding what functionality should be included in a system increment.\n2. Customer involvement is supported through the continuous engagement of the \ncustomer in the development team. The customer representative takes part in \nthe development and is responsible for defining acceptance tests for the system.\n3. People, not process, are supported through pair programming, collective owner-\nship of the system code, and a sustainable development process that does not \ninvolve excessively long working hours.\nBreak down\nstories to tasks\nSelect user\nstories for this\nrelease\nPlan release\nRelease\nsoftware\nEvaluate\nsystem\nDevelop/integrate/\ntest software\nFigure 3.3 The XP \nrelease cycle\n\n\n78  Chapter 3 \u25a0 Agile software development\nPrinciple or practice\nDescription\nCollective ownership\nThe pairs of developers work on all areas of the system, so that no islands of \nexpertise develop and all the developers take responsibility for all of the code. \nAnyone can change anything.\nContinuous \nintegration\nAs soon as the work on a task is complete, it is integrated into the whole \nsystem. After any such integration, all the unit tests in the system must pass.\nIncremental planning\nRequirements are recorded on \u201cstory cards,\u201d and the stories to be included in \na\u00a0release are determined by the time available and their relative priority. The \ndevelopers break these stories into development \u201ctasks.\u201d See Figures 3.5 \nand\u00a03.6.\nOn-site customer\nA representative of the end-user of the system (the Customer) should be \navailable full time for the use of the XP team. In an extreme programming \nprocess, the customer is a member of the development team and is \nresponsible for bringing system requirements to the team for implementation.\nPair programming\nDevelopers work in pairs, checking each other's work and providing the \nsupport to always do a good job.\nRefactoring\nAll developers are expected to refactor the code continuously as soon as \npotential code improvements are found. This keeps the code simple and \nmaintainable.\nSimple design\nEnough design is carried out to meet the current requirements and no more.\nSmall releases\nThe minimal useful set of functionality that provides business value is \ndeveloped first. Releases of the system are frequent and incrementally add \nfunctionality to the first release.\nSustainable pace\nLarge amounts of overtime are not considered acceptable, as the net effect is \noften to reduce code quality and medium-term productivity.\nTest first \ndevelopment\nAn automated unit test framework is used to write tests for a new piece of \nfunctionality before that functionality itself is implemented.\nFigure 3.4 Extreme \nprogramming practices 4. Change is embraced through regular system releases to customers, test-first \ndevelopment, refactoring to avoid code degeneration, and continuous integra-\ntion of new functionality.\n5. Maintaining simplicity is supported by constant refactoring that improves code \nquality and by using simple designs that do not unnecessarily anticipate future \nchanges to the system.\nIn practice, the application of Extreme Programming as originally proposed has \nproved to be more difficult than anticipated. It cannot be readily integrated with the \nmanagement practices and culture of most businesses. Therefore, companies adopt-\ning agile methods pick and choose those XP practices that are most appropriate for \ntheir way of working. Sometimes these are incorporated into their own development \nprocesses but, more commonly, they are used in conjunction with a management-\nfocused agile method such as Scrum (Rubin 2013)."}
{"query": "How does Extreme Programming (XP) embrace change?", "response": "Extreme Programming (XP) embraces change through regular system releases to customers, test-first development, refactoring to avoid code degeneration, and continuous integration of new functionality. This allows for the incorporation of changes and updates to the system in a timely manner.", "context": "3.2  \u25a0 Agile development techniques  77\n systems can be developed by co-located teams, so informal communications among \nteam members work well.\n \n3.2  Agile development techniques\nThe ideas underlying agile methods were developed around the same time by a number \nof different people in the 1990s. However, perhaps the most significant approach to \nchanging software development culture was the development of Extreme Programming \n(XP). The name was coined by Kent Beck (Beck 1998) because the approach was \ndeveloped by pushing recognized good practice, such as iterative development, to \n\u201cextreme\u201d levels. For example, in XP, several new versions of a system may be devel-\noped by different programmers, integrated, and tested in a day. Figure 3.3 illustrates \nthe XP process to produce an increment of the system that is being developed.\nIn XP, requirements are expressed as scenarios (called user stories), which are \nimplemented directly as a series of tasks. Programmers work in pairs and develop \ntests for each task before writing the code. All tests must be successfully executed \nwhen new code is integrated into the system. There is a short time gap between \nreleases of the system.\nExtreme programming was controversial as it introduced a number of agile prac-\ntices that were quite different from the development practice of that time. These prac-\ntices are summarized in Figure 3.4 and reflect the principles of the agile manifesto:\n1. \nIncremental development is supported through small, frequent releases of the sys-\ntem. Requirements are based on simple customer stories or scenarios that are used \nas a basis for deciding what functionality should be included in a system increment.\n2. Customer involvement is supported through the continuous engagement of the \ncustomer in the development team. The customer representative takes part in \nthe development and is responsible for defining acceptance tests for the system.\n3. People, not process, are supported through pair programming, collective owner-\nship of the system code, and a sustainable development process that does not \ninvolve excessively long working hours.\nBreak down\nstories to tasks\nSelect user\nstories for this\nrelease\nPlan release\nRelease\nsoftware\nEvaluate\nsystem\nDevelop/integrate/\ntest software\nFigure 3.3 The XP \nrelease cycle\n\n\n78  Chapter 3 \u25a0 Agile software development\nPrinciple or practice\nDescription\nCollective ownership\nThe pairs of developers work on all areas of the system, so that no islands of \nexpertise develop and all the developers take responsibility for all of the code. \nAnyone can change anything.\nContinuous \nintegration\nAs soon as the work on a task is complete, it is integrated into the whole \nsystem. After any such integration, all the unit tests in the system must pass.\nIncremental planning\nRequirements are recorded on \u201cstory cards,\u201d and the stories to be included in \na\u00a0release are determined by the time available and their relative priority. The \ndevelopers break these stories into development \u201ctasks.\u201d See Figures 3.5 \nand\u00a03.6.\nOn-site customer\nA representative of the end-user of the system (the Customer) should be \navailable full time for the use of the XP team. In an extreme programming \nprocess, the customer is a member of the development team and is \nresponsible for bringing system requirements to the team for implementation.\nPair programming\nDevelopers work in pairs, checking each other's work and providing the \nsupport to always do a good job.\nRefactoring\nAll developers are expected to refactor the code continuously as soon as \npotential code improvements are found. This keeps the code simple and \nmaintainable.\nSimple design\nEnough design is carried out to meet the current requirements and no more.\nSmall releases\nThe minimal useful set of functionality that provides business value is \ndeveloped first. Releases of the system are frequent and incrementally add \nfunctionality to the first release.\nSustainable pace\nLarge amounts of overtime are not considered acceptable, as the net effect is \noften to reduce code quality and medium-term productivity.\nTest first \ndevelopment\nAn automated unit test framework is used to write tests for a new piece of \nfunctionality before that functionality itself is implemented.\nFigure 3.4 Extreme \nprogramming practices 4. Change is embraced through regular system releases to customers, test-first \ndevelopment, refactoring to avoid code degeneration, and continuous integra-\ntion of new functionality.\n5. Maintaining simplicity is supported by constant refactoring that improves code \nquality and by using simple designs that do not unnecessarily anticipate future \nchanges to the system.\nIn practice, the application of Extreme Programming as originally proposed has \nproved to be more difficult than anticipated. It cannot be readily integrated with the \nmanagement practices and culture of most businesses. Therefore, companies adopt-\ning agile methods pick and choose those XP practices that are most appropriate for \ntheir way of working. Sometimes these are incorporated into their own development \nprocesses but, more commonly, they are used in conjunction with a management-\nfocused agile method such as Scrum (Rubin 2013)."}
{"query": "How does Extreme Programming (XP) maintain simplicity?", "response": "Extreme Programming (XP) maintains simplicity through constant refactoring and the use of simple designs that do not unnecessarily anticipate future changes to the system. This ensures that the code remains simple and maintainable.", "context": "3.2  \u25a0 Agile development techniques  77\n systems can be developed by co-located teams, so informal communications among \nteam members work well.\n \n3.2  Agile development techniques\nThe ideas underlying agile methods were developed around the same time by a number \nof different people in the 1990s. However, perhaps the most significant approach to \nchanging software development culture was the development of Extreme Programming \n(XP). The name was coined by Kent Beck (Beck 1998) because the approach was \ndeveloped by pushing recognized good practice, such as iterative development, to \n\u201cextreme\u201d levels. For example, in XP, several new versions of a system may be devel-\noped by different programmers, integrated, and tested in a day. Figure 3.3 illustrates \nthe XP process to produce an increment of the system that is being developed.\nIn XP, requirements are expressed as scenarios (called user stories), which are \nimplemented directly as a series of tasks. Programmers work in pairs and develop \ntests for each task before writing the code. All tests must be successfully executed \nwhen new code is integrated into the system. There is a short time gap between \nreleases of the system.\nExtreme programming was controversial as it introduced a number of agile prac-\ntices that were quite different from the development practice of that time. These prac-\ntices are summarized in Figure 3.4 and reflect the principles of the agile manifesto:\n1. \nIncremental development is supported through small, frequent releases of the sys-\ntem. Requirements are based on simple customer stories or scenarios that are used \nas a basis for deciding what functionality should be included in a system increment.\n2. Customer involvement is supported through the continuous engagement of the \ncustomer in the development team. The customer representative takes part in \nthe development and is responsible for defining acceptance tests for the system.\n3. People, not process, are supported through pair programming, collective owner-\nship of the system code, and a sustainable development process that does not \ninvolve excessively long working hours.\nBreak down\nstories to tasks\nSelect user\nstories for this\nrelease\nPlan release\nRelease\nsoftware\nEvaluate\nsystem\nDevelop/integrate/\ntest software\nFigure 3.3 The XP \nrelease cycle\n\n\n78  Chapter 3 \u25a0 Agile software development\nPrinciple or practice\nDescription\nCollective ownership\nThe pairs of developers work on all areas of the system, so that no islands of \nexpertise develop and all the developers take responsibility for all of the code. \nAnyone can change anything.\nContinuous \nintegration\nAs soon as the work on a task is complete, it is integrated into the whole \nsystem. After any such integration, all the unit tests in the system must pass.\nIncremental planning\nRequirements are recorded on \u201cstory cards,\u201d and the stories to be included in \na\u00a0release are determined by the time available and their relative priority. The \ndevelopers break these stories into development \u201ctasks.\u201d See Figures 3.5 \nand\u00a03.6.\nOn-site customer\nA representative of the end-user of the system (the Customer) should be \navailable full time for the use of the XP team. In an extreme programming \nprocess, the customer is a member of the development team and is \nresponsible for bringing system requirements to the team for implementation.\nPair programming\nDevelopers work in pairs, checking each other's work and providing the \nsupport to always do a good job.\nRefactoring\nAll developers are expected to refactor the code continuously as soon as \npotential code improvements are found. This keeps the code simple and \nmaintainable.\nSimple design\nEnough design is carried out to meet the current requirements and no more.\nSmall releases\nThe minimal useful set of functionality that provides business value is \ndeveloped first. Releases of the system are frequent and incrementally add \nfunctionality to the first release.\nSustainable pace\nLarge amounts of overtime are not considered acceptable, as the net effect is \noften to reduce code quality and medium-term productivity.\nTest first \ndevelopment\nAn automated unit test framework is used to write tests for a new piece of \nfunctionality before that functionality itself is implemented.\nFigure 3.4 Extreme \nprogramming practices 4. Change is embraced through regular system releases to customers, test-first \ndevelopment, refactoring to avoid code degeneration, and continuous integra-\ntion of new functionality.\n5. Maintaining simplicity is supported by constant refactoring that improves code \nquality and by using simple designs that do not unnecessarily anticipate future \nchanges to the system.\nIn practice, the application of Extreme Programming as originally proposed has \nproved to be more difficult than anticipated. It cannot be readily integrated with the \nmanagement practices and culture of most businesses. Therefore, companies adopt-\ning agile methods pick and choose those XP practices that are most appropriate for \ntheir way of working. Sometimes these are incorporated into their own development \nprocesses but, more commonly, they are used in conjunction with a management-\nfocused agile method such as Scrum (Rubin 2013)."}
{"query": "What are some of the challenges in applying Extreme Programming (XP) as originally proposed?", "response": "Applying Extreme Programming (XP) as originally proposed can be challenging because it cannot be readily integrated with the management practices and culture of most businesses. Therefore, companies adopting agile methods often pick and choose those XP practices that are most appropriate for their way of working. Sometimes these practices are incorporated into their own development processes, but more commonly, they are used in conjunction with a management-focused agile method such as Scrum.", "context": "3.2  \u25a0 Agile development techniques  77\n systems can be developed by co-located teams, so informal communications among \nteam members work well.\n \n3.2  Agile development techniques\nThe ideas underlying agile methods were developed around the same time by a number \nof different people in the 1990s. However, perhaps the most significant approach to \nchanging software development culture was the development of Extreme Programming \n(XP). The name was coined by Kent Beck (Beck 1998) because the approach was \ndeveloped by pushing recognized good practice, such as iterative development, to \n\u201cextreme\u201d levels. For example, in XP, several new versions of a system may be devel-\noped by different programmers, integrated, and tested in a day. Figure 3.3 illustrates \nthe XP process to produce an increment of the system that is being developed.\nIn XP, requirements are expressed as scenarios (called user stories), which are \nimplemented directly as a series of tasks. Programmers work in pairs and develop \ntests for each task before writing the code. All tests must be successfully executed \nwhen new code is integrated into the system. There is a short time gap between \nreleases of the system.\nExtreme programming was controversial as it introduced a number of agile prac-\ntices that were quite different from the development practice of that time. These prac-\ntices are summarized in Figure 3.4 and reflect the principles of the agile manifesto:\n1. \nIncremental development is supported through small, frequent releases of the sys-\ntem. Requirements are based on simple customer stories or scenarios that are used \nas a basis for deciding what functionality should be included in a system increment.\n2. Customer involvement is supported through the continuous engagement of the \ncustomer in the development team. The customer representative takes part in \nthe development and is responsible for defining acceptance tests for the system.\n3. People, not process, are supported through pair programming, collective owner-\nship of the system code, and a sustainable development process that does not \ninvolve excessively long working hours.\nBreak down\nstories to tasks\nSelect user\nstories for this\nrelease\nPlan release\nRelease\nsoftware\nEvaluate\nsystem\nDevelop/integrate/\ntest software\nFigure 3.3 The XP \nrelease cycle\n\n\n78  Chapter 3 \u25a0 Agile software development\nPrinciple or practice\nDescription\nCollective ownership\nThe pairs of developers work on all areas of the system, so that no islands of \nexpertise develop and all the developers take responsibility for all of the code. \nAnyone can change anything.\nContinuous \nintegration\nAs soon as the work on a task is complete, it is integrated into the whole \nsystem. After any such integration, all the unit tests in the system must pass.\nIncremental planning\nRequirements are recorded on \u201cstory cards,\u201d and the stories to be included in \na\u00a0release are determined by the time available and their relative priority. The \ndevelopers break these stories into development \u201ctasks.\u201d See Figures 3.5 \nand\u00a03.6.\nOn-site customer\nA representative of the end-user of the system (the Customer) should be \navailable full time for the use of the XP team. In an extreme programming \nprocess, the customer is a member of the development team and is \nresponsible for bringing system requirements to the team for implementation.\nPair programming\nDevelopers work in pairs, checking each other's work and providing the \nsupport to always do a good job.\nRefactoring\nAll developers are expected to refactor the code continuously as soon as \npotential code improvements are found. This keeps the code simple and \nmaintainable.\nSimple design\nEnough design is carried out to meet the current requirements and no more.\nSmall releases\nThe minimal useful set of functionality that provides business value is \ndeveloped first. Releases of the system are frequent and incrementally add \nfunctionality to the first release.\nSustainable pace\nLarge amounts of overtime are not considered acceptable, as the net effect is \noften to reduce code quality and medium-term productivity.\nTest first \ndevelopment\nAn automated unit test framework is used to write tests for a new piece of \nfunctionality before that functionality itself is implemented.\nFigure 3.4 Extreme \nprogramming practices 4. Change is embraced through regular system releases to customers, test-first \ndevelopment, refactoring to avoid code degeneration, and continuous integra-\ntion of new functionality.\n5. Maintaining simplicity is supported by constant refactoring that improves code \nquality and by using simple designs that do not unnecessarily anticipate future \nchanges to the system.\nIn practice, the application of Extreme Programming as originally proposed has \nproved to be more difficult than anticipated. It cannot be readily integrated with the \nmanagement practices and culture of most businesses. Therefore, companies adopt-\ning agile methods pick and choose those XP practices that are most appropriate for \ntheir way of working. Sometimes these are incorporated into their own development \nprocesses but, more commonly, they are used in conjunction with a management-\nfocused agile method such as Scrum (Rubin 2013)."}
{"query": "How do companies typically adopt agile methods like Extreme Programming (XP)?", "response": "Companies typically adopt agile methods like Extreme Programming (XP) by picking and choosing the XP practices that are most appropriate for their way of working. These practices are sometimes incorporated into their own development processes, but more commonly, they are used in conjunction with a management-focused agile method such as Scrum.", "context": "3.2  \u25a0 Agile development techniques  77\n systems can be developed by co-located teams, so informal communications among \nteam members work well.\n \n3.2  Agile development techniques\nThe ideas underlying agile methods were developed around the same time by a number \nof different people in the 1990s. However, perhaps the most significant approach to \nchanging software development culture was the development of Extreme Programming \n(XP). The name was coined by Kent Beck (Beck 1998) because the approach was \ndeveloped by pushing recognized good practice, such as iterative development, to \n\u201cextreme\u201d levels. For example, in XP, several new versions of a system may be devel-\noped by different programmers, integrated, and tested in a day. Figure 3.3 illustrates \nthe XP process to produce an increment of the system that is being developed.\nIn XP, requirements are expressed as scenarios (called user stories), which are \nimplemented directly as a series of tasks. Programmers work in pairs and develop \ntests for each task before writing the code. All tests must be successfully executed \nwhen new code is integrated into the system. There is a short time gap between \nreleases of the system.\nExtreme programming was controversial as it introduced a number of agile prac-\ntices that were quite different from the development practice of that time. These prac-\ntices are summarized in Figure 3.4 and reflect the principles of the agile manifesto:\n1. \nIncremental development is supported through small, frequent releases of the sys-\ntem. Requirements are based on simple customer stories or scenarios that are used \nas a basis for deciding what functionality should be included in a system increment.\n2. Customer involvement is supported through the continuous engagement of the \ncustomer in the development team. The customer representative takes part in \nthe development and is responsible for defining acceptance tests for the system.\n3. People, not process, are supported through pair programming, collective owner-\nship of the system code, and a sustainable development process that does not \ninvolve excessively long working hours.\nBreak down\nstories to tasks\nSelect user\nstories for this\nrelease\nPlan release\nRelease\nsoftware\nEvaluate\nsystem\nDevelop/integrate/\ntest software\nFigure 3.3 The XP \nrelease cycle\n\n\n78  Chapter 3 \u25a0 Agile software development\nPrinciple or practice\nDescription\nCollective ownership\nThe pairs of developers work on all areas of the system, so that no islands of \nexpertise develop and all the developers take responsibility for all of the code. \nAnyone can change anything.\nContinuous \nintegration\nAs soon as the work on a task is complete, it is integrated into the whole \nsystem. After any such integration, all the unit tests in the system must pass.\nIncremental planning\nRequirements are recorded on \u201cstory cards,\u201d and the stories to be included in \na\u00a0release are determined by the time available and their relative priority. The \ndevelopers break these stories into development \u201ctasks.\u201d See Figures 3.5 \nand\u00a03.6.\nOn-site customer\nA representative of the end-user of the system (the Customer) should be \navailable full time for the use of the XP team. In an extreme programming \nprocess, the customer is a member of the development team and is \nresponsible for bringing system requirements to the team for implementation.\nPair programming\nDevelopers work in pairs, checking each other's work and providing the \nsupport to always do a good job.\nRefactoring\nAll developers are expected to refactor the code continuously as soon as \npotential code improvements are found. This keeps the code simple and \nmaintainable.\nSimple design\nEnough design is carried out to meet the current requirements and no more.\nSmall releases\nThe minimal useful set of functionality that provides business value is \ndeveloped first. Releases of the system are frequent and incrementally add \nfunctionality to the first release.\nSustainable pace\nLarge amounts of overtime are not considered acceptable, as the net effect is \noften to reduce code quality and medium-term productivity.\nTest first \ndevelopment\nAn automated unit test framework is used to write tests for a new piece of \nfunctionality before that functionality itself is implemented.\nFigure 3.4 Extreme \nprogramming practices 4. Change is embraced through regular system releases to customers, test-first \ndevelopment, refactoring to avoid code degeneration, and continuous integra-\ntion of new functionality.\n5. Maintaining simplicity is supported by constant refactoring that improves code \nquality and by using simple designs that do not unnecessarily anticipate future \nchanges to the system.\nIn practice, the application of Extreme Programming as originally proposed has \nproved to be more difficult than anticipated. It cannot be readily integrated with the \nmanagement practices and culture of most businesses. Therefore, companies adopt-\ning agile methods pick and choose those XP practices that are most appropriate for \ntheir way of working. Sometimes these are incorporated into their own development \nprocesses but, more commonly, they are used in conjunction with a management-\nfocused agile method such as Scrum (Rubin 2013)."}
{"query": "How are Extreme Programming (XP) practices incorporated into companies' own development processes?", "response": "Companies adopting agile methods, including Extreme Programming (XP), often pick and choose the XP practices that are most suitable for their own development processes. These practices may be incorporated into their existing processes or used alongside a management-focused agile method such as Scrum. The specific XP practices that are adopted can vary depending on the company's way of working and the compatibility of XP practices with their management practices and culture.", "context": "3.2  \u25a0 Agile development techniques  77\n systems can be developed by co-located teams, so informal communications among \nteam members work well.\n \n3.2  Agile development techniques\nThe ideas underlying agile methods were developed around the same time by a number \nof different people in the 1990s. However, perhaps the most significant approach to \nchanging software development culture was the development of Extreme Programming \n(XP). The name was coined by Kent Beck (Beck 1998) because the approach was \ndeveloped by pushing recognized good practice, such as iterative development, to \n\u201cextreme\u201d levels. For example, in XP, several new versions of a system may be devel-\noped by different programmers, integrated, and tested in a day. Figure 3.3 illustrates \nthe XP process to produce an increment of the system that is being developed.\nIn XP, requirements are expressed as scenarios (called user stories), which are \nimplemented directly as a series of tasks. Programmers work in pairs and develop \ntests for each task before writing the code. All tests must be successfully executed \nwhen new code is integrated into the system. There is a short time gap between \nreleases of the system.\nExtreme programming was controversial as it introduced a number of agile prac-\ntices that were quite different from the development practice of that time. These prac-\ntices are summarized in Figure 3.4 and reflect the principles of the agile manifesto:\n1. \nIncremental development is supported through small, frequent releases of the sys-\ntem. Requirements are based on simple customer stories or scenarios that are used \nas a basis for deciding what functionality should be included in a system increment.\n2. Customer involvement is supported through the continuous engagement of the \ncustomer in the development team. The customer representative takes part in \nthe development and is responsible for defining acceptance tests for the system.\n3. People, not process, are supported through pair programming, collective owner-\nship of the system code, and a sustainable development process that does not \ninvolve excessively long working hours.\nBreak down\nstories to tasks\nSelect user\nstories for this\nrelease\nPlan release\nRelease\nsoftware\nEvaluate\nsystem\nDevelop/integrate/\ntest software\nFigure 3.3 The XP \nrelease cycle\n\n\n78  Chapter 3 \u25a0 Agile software development\nPrinciple or practice\nDescription\nCollective ownership\nThe pairs of developers work on all areas of the system, so that no islands of \nexpertise develop and all the developers take responsibility for all of the code. \nAnyone can change anything.\nContinuous \nintegration\nAs soon as the work on a task is complete, it is integrated into the whole \nsystem. After any such integration, all the unit tests in the system must pass.\nIncremental planning\nRequirements are recorded on \u201cstory cards,\u201d and the stories to be included in \na\u00a0release are determined by the time available and their relative priority. The \ndevelopers break these stories into development \u201ctasks.\u201d See Figures 3.5 \nand\u00a03.6.\nOn-site customer\nA representative of the end-user of the system (the Customer) should be \navailable full time for the use of the XP team. In an extreme programming \nprocess, the customer is a member of the development team and is \nresponsible for bringing system requirements to the team for implementation.\nPair programming\nDevelopers work in pairs, checking each other's work and providing the \nsupport to always do a good job.\nRefactoring\nAll developers are expected to refactor the code continuously as soon as \npotential code improvements are found. This keeps the code simple and \nmaintainable.\nSimple design\nEnough design is carried out to meet the current requirements and no more.\nSmall releases\nThe minimal useful set of functionality that provides business value is \ndeveloped first. Releases of the system are frequent and incrementally add \nfunctionality to the first release.\nSustainable pace\nLarge amounts of overtime are not considered acceptable, as the net effect is \noften to reduce code quality and medium-term productivity.\nTest first \ndevelopment\nAn automated unit test framework is used to write tests for a new piece of \nfunctionality before that functionality itself is implemented.\nFigure 3.4 Extreme \nprogramming practices 4. Change is embraced through regular system releases to customers, test-first \ndevelopment, refactoring to avoid code degeneration, and continuous integra-\ntion of new functionality.\n5. Maintaining simplicity is supported by constant refactoring that improves code \nquality and by using simple designs that do not unnecessarily anticipate future \nchanges to the system.\nIn practice, the application of Extreme Programming as originally proposed has \nproved to be more difficult than anticipated. It cannot be readily integrated with the \nmanagement practices and culture of most businesses. Therefore, companies adopt-\ning agile methods pick and choose those XP practices that are most appropriate for \ntheir way of working. Sometimes these are incorporated into their own development \nprocesses but, more commonly, they are used in conjunction with a management-\nfocused agile method such as Scrum (Rubin 2013)."}
{"query": "What is the role of Scrum in the context of agile methods?", "response": "Scrum is a management-focused agile method that is often used in conjunction with other agile practices, such as Extreme Programming (XP). It helps companies adopt agile methods by providing a framework for managing and organizing the development process. Scrum emphasizes iterative and incremental development, with regular releases of the system to customers. It also promotes customer involvement through the continuous engagement of the customer in the development team. Overall, Scrum plays a role in facilitating the adoption and implementation of agile practices in organizations.", "context": "3.2  \u25a0 Agile development techniques  77\n systems can be developed by co-located teams, so informal communications among \nteam members work well.\n \n3.2  Agile development techniques\nThe ideas underlying agile methods were developed around the same time by a number \nof different people in the 1990s. However, perhaps the most significant approach to \nchanging software development culture was the development of Extreme Programming \n(XP). The name was coined by Kent Beck (Beck 1998) because the approach was \ndeveloped by pushing recognized good practice, such as iterative development, to \n\u201cextreme\u201d levels. For example, in XP, several new versions of a system may be devel-\noped by different programmers, integrated, and tested in a day. Figure 3.3 illustrates \nthe XP process to produce an increment of the system that is being developed.\nIn XP, requirements are expressed as scenarios (called user stories), which are \nimplemented directly as a series of tasks. Programmers work in pairs and develop \ntests for each task before writing the code. All tests must be successfully executed \nwhen new code is integrated into the system. There is a short time gap between \nreleases of the system.\nExtreme programming was controversial as it introduced a number of agile prac-\ntices that were quite different from the development practice of that time. These prac-\ntices are summarized in Figure 3.4 and reflect the principles of the agile manifesto:\n1. \nIncremental development is supported through small, frequent releases of the sys-\ntem. Requirements are based on simple customer stories or scenarios that are used \nas a basis for deciding what functionality should be included in a system increment.\n2. Customer involvement is supported through the continuous engagement of the \ncustomer in the development team. The customer representative takes part in \nthe development and is responsible for defining acceptance tests for the system.\n3. People, not process, are supported through pair programming, collective owner-\nship of the system code, and a sustainable development process that does not \ninvolve excessively long working hours.\nBreak down\nstories to tasks\nSelect user\nstories for this\nrelease\nPlan release\nRelease\nsoftware\nEvaluate\nsystem\nDevelop/integrate/\ntest software\nFigure 3.3 The XP \nrelease cycle\n\n\n78  Chapter 3 \u25a0 Agile software development\nPrinciple or practice\nDescription\nCollective ownership\nThe pairs of developers work on all areas of the system, so that no islands of \nexpertise develop and all the developers take responsibility for all of the code. \nAnyone can change anything.\nContinuous \nintegration\nAs soon as the work on a task is complete, it is integrated into the whole \nsystem. After any such integration, all the unit tests in the system must pass.\nIncremental planning\nRequirements are recorded on \u201cstory cards,\u201d and the stories to be included in \na\u00a0release are determined by the time available and their relative priority. The \ndevelopers break these stories into development \u201ctasks.\u201d See Figures 3.5 \nand\u00a03.6.\nOn-site customer\nA representative of the end-user of the system (the Customer) should be \navailable full time for the use of the XP team. In an extreme programming \nprocess, the customer is a member of the development team and is \nresponsible for bringing system requirements to the team for implementation.\nPair programming\nDevelopers work in pairs, checking each other's work and providing the \nsupport to always do a good job.\nRefactoring\nAll developers are expected to refactor the code continuously as soon as \npotential code improvements are found. This keeps the code simple and \nmaintainable.\nSimple design\nEnough design is carried out to meet the current requirements and no more.\nSmall releases\nThe minimal useful set of functionality that provides business value is \ndeveloped first. Releases of the system are frequent and incrementally add \nfunctionality to the first release.\nSustainable pace\nLarge amounts of overtime are not considered acceptable, as the net effect is \noften to reduce code quality and medium-term productivity.\nTest first \ndevelopment\nAn automated unit test framework is used to write tests for a new piece of \nfunctionality before that functionality itself is implemented.\nFigure 3.4 Extreme \nprogramming practices 4. Change is embraced through regular system releases to customers, test-first \ndevelopment, refactoring to avoid code degeneration, and continuous integra-\ntion of new functionality.\n5. Maintaining simplicity is supported by constant refactoring that improves code \nquality and by using simple designs that do not unnecessarily anticipate future \nchanges to the system.\nIn practice, the application of Extreme Programming as originally proposed has \nproved to be more difficult than anticipated. It cannot be readily integrated with the \nmanagement practices and culture of most businesses. Therefore, companies adopt-\ning agile methods pick and choose those XP practices that are most appropriate for \ntheir way of working. Sometimes these are incorporated into their own development \nprocesses but, more commonly, they are used in conjunction with a management-\nfocused agile method such as Scrum (Rubin 2013)."}
{"query": "How does Extreme Programming (XP) support the principles of the agile manifesto?", "response": "Extreme Programming (XP) supports the principles of the agile manifesto through several practices. These practices include incremental development, customer involvement, people-centric approach, continuous integration, incremental planning, on-site customer, pair programming, refactoring, simple design, small releases, sustainable pace, and test-first development. These practices promote collaboration, flexibility, customer satisfaction, and continuous improvement, which are key principles of the agile manifesto.", "context": "3.2  \u25a0 Agile development techniques  77\n systems can be developed by co-located teams, so informal communications among \nteam members work well.\n \n3.2  Agile development techniques\nThe ideas underlying agile methods were developed around the same time by a number \nof different people in the 1990s. However, perhaps the most significant approach to \nchanging software development culture was the development of Extreme Programming \n(XP). The name was coined by Kent Beck (Beck 1998) because the approach was \ndeveloped by pushing recognized good practice, such as iterative development, to \n\u201cextreme\u201d levels. For example, in XP, several new versions of a system may be devel-\noped by different programmers, integrated, and tested in a day. Figure 3.3 illustrates \nthe XP process to produce an increment of the system that is being developed.\nIn XP, requirements are expressed as scenarios (called user stories), which are \nimplemented directly as a series of tasks. Programmers work in pairs and develop \ntests for each task before writing the code. All tests must be successfully executed \nwhen new code is integrated into the system. There is a short time gap between \nreleases of the system.\nExtreme programming was controversial as it introduced a number of agile prac-\ntices that were quite different from the development practice of that time. These prac-\ntices are summarized in Figure 3.4 and reflect the principles of the agile manifesto:\n1. \nIncremental development is supported through small, frequent releases of the sys-\ntem. Requirements are based on simple customer stories or scenarios that are used \nas a basis for deciding what functionality should be included in a system increment.\n2. Customer involvement is supported through the continuous engagement of the \ncustomer in the development team. The customer representative takes part in \nthe development and is responsible for defining acceptance tests for the system.\n3. People, not process, are supported through pair programming, collective owner-\nship of the system code, and a sustainable development process that does not \ninvolve excessively long working hours.\nBreak down\nstories to tasks\nSelect user\nstories for this\nrelease\nPlan release\nRelease\nsoftware\nEvaluate\nsystem\nDevelop/integrate/\ntest software\nFigure 3.3 The XP \nrelease cycle\n\n\n78  Chapter 3 \u25a0 Agile software development\nPrinciple or practice\nDescription\nCollective ownership\nThe pairs of developers work on all areas of the system, so that no islands of \nexpertise develop and all the developers take responsibility for all of the code. \nAnyone can change anything.\nContinuous \nintegration\nAs soon as the work on a task is complete, it is integrated into the whole \nsystem. After any such integration, all the unit tests in the system must pass.\nIncremental planning\nRequirements are recorded on \u201cstory cards,\u201d and the stories to be included in \na\u00a0release are determined by the time available and their relative priority. The \ndevelopers break these stories into development \u201ctasks.\u201d See Figures 3.5 \nand\u00a03.6.\nOn-site customer\nA representative of the end-user of the system (the Customer) should be \navailable full time for the use of the XP team. In an extreme programming \nprocess, the customer is a member of the development team and is \nresponsible for bringing system requirements to the team for implementation.\nPair programming\nDevelopers work in pairs, checking each other's work and providing the \nsupport to always do a good job.\nRefactoring\nAll developers are expected to refactor the code continuously as soon as \npotential code improvements are found. This keeps the code simple and \nmaintainable.\nSimple design\nEnough design is carried out to meet the current requirements and no more.\nSmall releases\nThe minimal useful set of functionality that provides business value is \ndeveloped first. Releases of the system are frequent and incrementally add \nfunctionality to the first release.\nSustainable pace\nLarge amounts of overtime are not considered acceptable, as the net effect is \noften to reduce code quality and medium-term productivity.\nTest first \ndevelopment\nAn automated unit test framework is used to write tests for a new piece of \nfunctionality before that functionality itself is implemented.\nFigure 3.4 Extreme \nprogramming practices 4. Change is embraced through regular system releases to customers, test-first \ndevelopment, refactoring to avoid code degeneration, and continuous integra-\ntion of new functionality.\n5. Maintaining simplicity is supported by constant refactoring that improves code \nquality and by using simple designs that do not unnecessarily anticipate future \nchanges to the system.\nIn practice, the application of Extreme Programming as originally proposed has \nproved to be more difficult than anticipated. It cannot be readily integrated with the \nmanagement practices and culture of most businesses. Therefore, companies adopt-\ning agile methods pick and choose those XP practices that are most appropriate for \ntheir way of working. Sometimes these are incorporated into their own development \nprocesses but, more commonly, they are used in conjunction with a management-\nfocused agile method such as Scrum (Rubin 2013)."}
{"query": "What is the role of the customer representative in the development team in Extreme Programming (XP)?", "response": "The customer representative in Extreme Programming (XP) is responsible for defining acceptance tests for the system and takes part in the development process. They are a member of the development team and bring system requirements to the team for implementation.", "context": "3.2  \u25a0 Agile development techniques  77\n systems can be developed by co-located teams, so informal communications among \nteam members work well.\n \n3.2  Agile development techniques\nThe ideas underlying agile methods were developed around the same time by a number \nof different people in the 1990s. However, perhaps the most significant approach to \nchanging software development culture was the development of Extreme Programming \n(XP). The name was coined by Kent Beck (Beck 1998) because the approach was \ndeveloped by pushing recognized good practice, such as iterative development, to \n\u201cextreme\u201d levels. For example, in XP, several new versions of a system may be devel-\noped by different programmers, integrated, and tested in a day. Figure 3.3 illustrates \nthe XP process to produce an increment of the system that is being developed.\nIn XP, requirements are expressed as scenarios (called user stories), which are \nimplemented directly as a series of tasks. Programmers work in pairs and develop \ntests for each task before writing the code. All tests must be successfully executed \nwhen new code is integrated into the system. There is a short time gap between \nreleases of the system.\nExtreme programming was controversial as it introduced a number of agile prac-\ntices that were quite different from the development practice of that time. These prac-\ntices are summarized in Figure 3.4 and reflect the principles of the agile manifesto:\n1. \nIncremental development is supported through small, frequent releases of the sys-\ntem. Requirements are based on simple customer stories or scenarios that are used \nas a basis for deciding what functionality should be included in a system increment.\n2. Customer involvement is supported through the continuous engagement of the \ncustomer in the development team. The customer representative takes part in \nthe development and is responsible for defining acceptance tests for the system.\n3. People, not process, are supported through pair programming, collective owner-\nship of the system code, and a sustainable development process that does not \ninvolve excessively long working hours.\nBreak down\nstories to tasks\nSelect user\nstories for this\nrelease\nPlan release\nRelease\nsoftware\nEvaluate\nsystem\nDevelop/integrate/\ntest software\nFigure 3.3 The XP \nrelease cycle\n\n\n78  Chapter 3 \u25a0 Agile software development\nPrinciple or practice\nDescription\nCollective ownership\nThe pairs of developers work on all areas of the system, so that no islands of \nexpertise develop and all the developers take responsibility for all of the code. \nAnyone can change anything.\nContinuous \nintegration\nAs soon as the work on a task is complete, it is integrated into the whole \nsystem. After any such integration, all the unit tests in the system must pass.\nIncremental planning\nRequirements are recorded on \u201cstory cards,\u201d and the stories to be included in \na\u00a0release are determined by the time available and their relative priority. The \ndevelopers break these stories into development \u201ctasks.\u201d See Figures 3.5 \nand\u00a03.6.\nOn-site customer\nA representative of the end-user of the system (the Customer) should be \navailable full time for the use of the XP team. In an extreme programming \nprocess, the customer is a member of the development team and is \nresponsible for bringing system requirements to the team for implementation.\nPair programming\nDevelopers work in pairs, checking each other's work and providing the \nsupport to always do a good job.\nRefactoring\nAll developers are expected to refactor the code continuously as soon as \npotential code improvements are found. This keeps the code simple and \nmaintainable.\nSimple design\nEnough design is carried out to meet the current requirements and no more.\nSmall releases\nThe minimal useful set of functionality that provides business value is \ndeveloped first. Releases of the system are frequent and incrementally add \nfunctionality to the first release.\nSustainable pace\nLarge amounts of overtime are not considered acceptable, as the net effect is \noften to reduce code quality and medium-term productivity.\nTest first \ndevelopment\nAn automated unit test framework is used to write tests for a new piece of \nfunctionality before that functionality itself is implemented.\nFigure 3.4 Extreme \nprogramming practices 4. Change is embraced through regular system releases to customers, test-first \ndevelopment, refactoring to avoid code degeneration, and continuous integra-\ntion of new functionality.\n5. Maintaining simplicity is supported by constant refactoring that improves code \nquality and by using simple designs that do not unnecessarily anticipate future \nchanges to the system.\nIn practice, the application of Extreme Programming as originally proposed has \nproved to be more difficult than anticipated. It cannot be readily integrated with the \nmanagement practices and culture of most businesses. Therefore, companies adopt-\ning agile methods pick and choose those XP practices that are most appropriate for \ntheir way of working. Sometimes these are incorporated into their own development \nprocesses but, more commonly, they are used in conjunction with a management-\nfocused agile method such as Scrum (Rubin 2013)."}
{"query": "How does Extreme Programming (XP) avoid code degeneration?", "response": "Extreme Programming (XP) avoids code degeneration through the practice of refactoring. Refactoring is the continuous process of improving the code by making small changes to enhance its quality. By constantly refactoring the code, XP ensures that it remains simple and maintainable, preventing it from degenerating over time.", "context": "3.2  \u25a0 Agile development techniques  77\n systems can be developed by co-located teams, so informal communications among \nteam members work well.\n \n3.2  Agile development techniques\nThe ideas underlying agile methods were developed around the same time by a number \nof different people in the 1990s. However, perhaps the most significant approach to \nchanging software development culture was the development of Extreme Programming \n(XP). The name was coined by Kent Beck (Beck 1998) because the approach was \ndeveloped by pushing recognized good practice, such as iterative development, to \n\u201cextreme\u201d levels. For example, in XP, several new versions of a system may be devel-\noped by different programmers, integrated, and tested in a day. Figure 3.3 illustrates \nthe XP process to produce an increment of the system that is being developed.\nIn XP, requirements are expressed as scenarios (called user stories), which are \nimplemented directly as a series of tasks. Programmers work in pairs and develop \ntests for each task before writing the code. All tests must be successfully executed \nwhen new code is integrated into the system. There is a short time gap between \nreleases of the system.\nExtreme programming was controversial as it introduced a number of agile prac-\ntices that were quite different from the development practice of that time. These prac-\ntices are summarized in Figure 3.4 and reflect the principles of the agile manifesto:\n1. \nIncremental development is supported through small, frequent releases of the sys-\ntem. Requirements are based on simple customer stories or scenarios that are used \nas a basis for deciding what functionality should be included in a system increment.\n2. Customer involvement is supported through the continuous engagement of the \ncustomer in the development team. The customer representative takes part in \nthe development and is responsible for defining acceptance tests for the system.\n3. People, not process, are supported through pair programming, collective owner-\nship of the system code, and a sustainable development process that does not \ninvolve excessively long working hours.\nBreak down\nstories to tasks\nSelect user\nstories for this\nrelease\nPlan release\nRelease\nsoftware\nEvaluate\nsystem\nDevelop/integrate/\ntest software\nFigure 3.3 The XP \nrelease cycle\n\n\n78  Chapter 3 \u25a0 Agile software development\nPrinciple or practice\nDescription\nCollective ownership\nThe pairs of developers work on all areas of the system, so that no islands of \nexpertise develop and all the developers take responsibility for all of the code. \nAnyone can change anything.\nContinuous \nintegration\nAs soon as the work on a task is complete, it is integrated into the whole \nsystem. After any such integration, all the unit tests in the system must pass.\nIncremental planning\nRequirements are recorded on \u201cstory cards,\u201d and the stories to be included in \na\u00a0release are determined by the time available and their relative priority. The \ndevelopers break these stories into development \u201ctasks.\u201d See Figures 3.5 \nand\u00a03.6.\nOn-site customer\nA representative of the end-user of the system (the Customer) should be \navailable full time for the use of the XP team. In an extreme programming \nprocess, the customer is a member of the development team and is \nresponsible for bringing system requirements to the team for implementation.\nPair programming\nDevelopers work in pairs, checking each other's work and providing the \nsupport to always do a good job.\nRefactoring\nAll developers are expected to refactor the code continuously as soon as \npotential code improvements are found. This keeps the code simple and \nmaintainable.\nSimple design\nEnough design is carried out to meet the current requirements and no more.\nSmall releases\nThe minimal useful set of functionality that provides business value is \ndeveloped first. Releases of the system are frequent and incrementally add \nfunctionality to the first release.\nSustainable pace\nLarge amounts of overtime are not considered acceptable, as the net effect is \noften to reduce code quality and medium-term productivity.\nTest first \ndevelopment\nAn automated unit test framework is used to write tests for a new piece of \nfunctionality before that functionality itself is implemented.\nFigure 3.4 Extreme \nprogramming practices 4. Change is embraced through regular system releases to customers, test-first \ndevelopment, refactoring to avoid code degeneration, and continuous integra-\ntion of new functionality.\n5. Maintaining simplicity is supported by constant refactoring that improves code \nquality and by using simple designs that do not unnecessarily anticipate future \nchanges to the system.\nIn practice, the application of Extreme Programming as originally proposed has \nproved to be more difficult than anticipated. It cannot be readily integrated with the \nmanagement practices and culture of most businesses. Therefore, companies adopt-\ning agile methods pick and choose those XP practices that are most appropriate for \ntheir way of working. Sometimes these are incorporated into their own development \nprocesses but, more commonly, they are used in conjunction with a management-\nfocused agile method such as Scrum (Rubin 2013)."}
{"query": "What is the main contribution of XP to the agile development community?", "response": "The main contribution of XP to the agile development community is the set of agile development practices that it introduced.", "context": "3.2  \u25a0 Agile development techniques  79\nI am not convinced that XP on its own is a practical agile method for most com-\npanies, but its most significant contribution is probably the set of agile development \npractices that it introduced to the community. I discuss the most important of these \npractices in this section.\n \n3.2.1  User stories\nSoftware requirements always change. To handle these changes, agile methods do not \nhave a separate requirements engineering activity. Rather, they integrate requirements \nelicitation with development. To make this easier, the idea of \u201cuser stories\u201d was devel-\noped where a user story is a scenario of use that might be experienced by a system user.\nAs far as possible, the system customer works closely with the development team \nand discusses these scenarios with other team members. Together, they develop a \n\u201cstory card\u201d that briefly describes a story that encapsulates the customer needs. The \ndevelopment team then aims to implement that scenario in a future release of the \nsoftware. An example of a story card for the Mentcare system is shown in Figure 3.5. \nThis is a short description of a scenario for prescribing medication for a patient.\nUser stories may be used in planning system iterations. Once the story cards have \nbeen developed, the development team breaks these down into tasks (Figure 3.6) and \nestimates the effort and resources required for implementing each task. This usually \ninvolves discussions with the customer to refine the requirements. The customer \nthen prioritizes the stories for implementation, choosing those stories that can be \nKate is a doctor who wishes to prescribe medication for a patient attending a clinic.\nThe patient record is already displayed on her computer so she clicks on the\nmedication \ufb01eld and can select \u2018current medication\u2019, \u2018new medication\u2019 or \u2018formulary\u2019.\nIf she selects \u2018current medication\u2019, the system asks her to check the dose; If she\nwants to change the dose, she enters the new dose then con\ufb01rms the prescription.\nIf she chooses \u2018new medication\u2019, the system assumes that she knows which\nmedication to prescribe. She types the \ufb01rst few letters of the drug name. The system\ndisplays a list of possible drugs starting with these letters. She chooses the required\nmedication and the system responds by asking her to check that the medication\nselected is correct. She enters the dose then con\ufb01rms the prescription.\nIf she chooses \u2018formulary\u2019, the system displays a search box for the approved\nformulary. She can then search for the drug required. She selects a drug and is asked\nto check that the medication is correct. She enters the dose then con\ufb01rms the\nprescription.\nThe system always checks that the dose is within the approved range. If it isn\u2019t, Kate\nis asked to change the dose.\nAfter Kate has con\ufb01rmed the prescription, it will be displayed for checking. She either\nclicks \u2018OK\u2019 or \u2018Change\u2019. If she clicks \u2018OK\u2019, the prescription is recorded on the audit\ndatabase. If she clicks on \u2018Change\u2019, she reenters the \u2018Prescribing medication\u2019 process.\nPrescribing medication\nFigure 3.5 A  \n\u201cprescribing medication\u201d \nstory\n\n\n80  Chapter 3 \u25a0 Agile software development\nused immediately to deliver useful business support. The intention is to identify \n useful functionality that can be implemented in about two weeks, when the next \nrelease of the system is made available to the customer.\nOf course, as requirements change, the unimplemented stories change or may be \ndiscarded. If changes are required for a system that has already been delivered, new \nstory cards are developed and again, the customer decides whether these changes \nshould have priority over new functionality.\nThe idea of user stories is a powerful one\u2014people find it much easier to relate to \nthese stories than to a conventional requirements document or use cases. User stories can \nbe helpful in getting users involved in suggesting requirements during an initial prede-\nvelopment requirements elicitation activity. I discuss this in more detail in Chapter 4.\nThe principal problem with user stories is completeness. It is difficult to judge if \nenough user stories have been developed to cover all of the essential requirements \nof\u00a0a system. It is also difficult to judge if a single story gives a true picture of an \nactivity. Experienced users are often so familiar with their work that they leave \nthings out when describing it.\n \n3.2.2  Refactoring\nA fundamental precept of traditional software engineering is that you should design \nfor change. That is, you should anticipate future changes to the software and design \nit so that these changes can be easily implemented. Extreme programming, however, \nhas discarded this principle on the basis that designing for change is often wasted \neffort. It isn\u2019t worth taking time to add generality to a program to cope with change. \nOften the changes anticipated never materialize, or completely different change \nrequests may actually be made.\nOf course, in practice, changes will always have to be made to the code being devel-\noped. To make these changes easier, the developers of XP suggested that the code being \ndeveloped should be constantly refactored. Refactoring (Fowler et al. 1999) means that \nthe programming team look for possible improvements to the software and implements \nTask 1: Change dose of prescribed drug\nTask 2: Formulary selection\nTask 3: Dose checking\nDose checking is a safety precaution to check that\nthe doctor has not prescribed a dangerously small or\nlarge dose.\nUsing the formulary id for the generic drug name,\nlook up the formulary and retrieve the recommended\nmaximum and minimum dose.\nCheck the prescribed dose against the minimum and\nmaximum. If outside the range, issue an error\nmessage saying that the dose is too high or too low.\nIf within the range, enable the \u2018Con\ufb01rm\u2019 button.\nFigure 3.6 Examples of \ntask cards for prescribing \nmedication"}
{"query": "How do agile methods handle changing software requirements?", "response": "Agile methods handle changing software requirements by integrating requirements elicitation with development. Instead of having a separate requirements engineering activity, agile methods use user stories to capture and communicate the customer needs. User stories are scenarios of use that are developed in collaboration with the system customer and the development team. These stories are then broken down into tasks and estimated for effort and resources required for implementation. The customer prioritizes the stories for implementation, choosing those that can be used immediately to deliver useful business support. As requirements change, new story cards are developed and the customer decides whether these changes should have priority over new functionality. The use of user stories allows for flexibility and adaptability in responding to changing requirements.", "context": "3.2  \u25a0 Agile development techniques  79\nI am not convinced that XP on its own is a practical agile method for most com-\npanies, but its most significant contribution is probably the set of agile development \npractices that it introduced to the community. I discuss the most important of these \npractices in this section.\n \n3.2.1  User stories\nSoftware requirements always change. To handle these changes, agile methods do not \nhave a separate requirements engineering activity. Rather, they integrate requirements \nelicitation with development. To make this easier, the idea of \u201cuser stories\u201d was devel-\noped where a user story is a scenario of use that might be experienced by a system user.\nAs far as possible, the system customer works closely with the development team \nand discusses these scenarios with other team members. Together, they develop a \n\u201cstory card\u201d that briefly describes a story that encapsulates the customer needs. The \ndevelopment team then aims to implement that scenario in a future release of the \nsoftware. An example of a story card for the Mentcare system is shown in Figure 3.5. \nThis is a short description of a scenario for prescribing medication for a patient.\nUser stories may be used in planning system iterations. Once the story cards have \nbeen developed, the development team breaks these down into tasks (Figure 3.6) and \nestimates the effort and resources required for implementing each task. This usually \ninvolves discussions with the customer to refine the requirements. The customer \nthen prioritizes the stories for implementation, choosing those stories that can be \nKate is a doctor who wishes to prescribe medication for a patient attending a clinic.\nThe patient record is already displayed on her computer so she clicks on the\nmedication \ufb01eld and can select \u2018current medication\u2019, \u2018new medication\u2019 or \u2018formulary\u2019.\nIf she selects \u2018current medication\u2019, the system asks her to check the dose; If she\nwants to change the dose, she enters the new dose then con\ufb01rms the prescription.\nIf she chooses \u2018new medication\u2019, the system assumes that she knows which\nmedication to prescribe. She types the \ufb01rst few letters of the drug name. The system\ndisplays a list of possible drugs starting with these letters. She chooses the required\nmedication and the system responds by asking her to check that the medication\nselected is correct. She enters the dose then con\ufb01rms the prescription.\nIf she chooses \u2018formulary\u2019, the system displays a search box for the approved\nformulary. She can then search for the drug required. She selects a drug and is asked\nto check that the medication is correct. She enters the dose then con\ufb01rms the\nprescription.\nThe system always checks that the dose is within the approved range. If it isn\u2019t, Kate\nis asked to change the dose.\nAfter Kate has con\ufb01rmed the prescription, it will be displayed for checking. She either\nclicks \u2018OK\u2019 or \u2018Change\u2019. If she clicks \u2018OK\u2019, the prescription is recorded on the audit\ndatabase. If she clicks on \u2018Change\u2019, she reenters the \u2018Prescribing medication\u2019 process.\nPrescribing medication\nFigure 3.5 A  \n\u201cprescribing medication\u201d \nstory\n\n\n80  Chapter 3 \u25a0 Agile software development\nused immediately to deliver useful business support. The intention is to identify \n useful functionality that can be implemented in about two weeks, when the next \nrelease of the system is made available to the customer.\nOf course, as requirements change, the unimplemented stories change or may be \ndiscarded. If changes are required for a system that has already been delivered, new \nstory cards are developed and again, the customer decides whether these changes \nshould have priority over new functionality.\nThe idea of user stories is a powerful one\u2014people find it much easier to relate to \nthese stories than to a conventional requirements document or use cases. User stories can \nbe helpful in getting users involved in suggesting requirements during an initial prede-\nvelopment requirements elicitation activity. I discuss this in more detail in Chapter 4.\nThe principal problem with user stories is completeness. It is difficult to judge if \nenough user stories have been developed to cover all of the essential requirements \nof\u00a0a system. It is also difficult to judge if a single story gives a true picture of an \nactivity. Experienced users are often so familiar with their work that they leave \nthings out when describing it.\n \n3.2.2  Refactoring\nA fundamental precept of traditional software engineering is that you should design \nfor change. That is, you should anticipate future changes to the software and design \nit so that these changes can be easily implemented. Extreme programming, however, \nhas discarded this principle on the basis that designing for change is often wasted \neffort. It isn\u2019t worth taking time to add generality to a program to cope with change. \nOften the changes anticipated never materialize, or completely different change \nrequests may actually be made.\nOf course, in practice, changes will always have to be made to the code being devel-\noped. To make these changes easier, the developers of XP suggested that the code being \ndeveloped should be constantly refactored. Refactoring (Fowler et al. 1999) means that \nthe programming team look for possible improvements to the software and implements \nTask 1: Change dose of prescribed drug\nTask 2: Formulary selection\nTask 3: Dose checking\nDose checking is a safety precaution to check that\nthe doctor has not prescribed a dangerously small or\nlarge dose.\nUsing the formulary id for the generic drug name,\nlook up the formulary and retrieve the recommended\nmaximum and minimum dose.\nCheck the prescribed dose against the minimum and\nmaximum. If outside the range, issue an error\nmessage saying that the dose is too high or too low.\nIf within the range, enable the \u2018Con\ufb01rm\u2019 button.\nFigure 3.6 Examples of \ntask cards for prescribing \nmedication"}
{"query": "What is a user story in the context of agile development?", "response": "A user story in the context of agile development is a scenario of use that might be experienced by a system user. It is a way to integrate requirements elicitation with development, where the system customer works closely with the development team to develop a \"story card\" that briefly describes a story encapsulating the customer needs. User stories are used to plan system iterations and are broken down into tasks for implementation. They are a powerful way to involve users in suggesting requirements and are easier for people to relate to compared to conventional requirements documents or use cases.", "context": "3.2  \u25a0 Agile development techniques  79\nI am not convinced that XP on its own is a practical agile method for most com-\npanies, but its most significant contribution is probably the set of agile development \npractices that it introduced to the community. I discuss the most important of these \npractices in this section.\n \n3.2.1  User stories\nSoftware requirements always change. To handle these changes, agile methods do not \nhave a separate requirements engineering activity. Rather, they integrate requirements \nelicitation with development. To make this easier, the idea of \u201cuser stories\u201d was devel-\noped where a user story is a scenario of use that might be experienced by a system user.\nAs far as possible, the system customer works closely with the development team \nand discusses these scenarios with other team members. Together, they develop a \n\u201cstory card\u201d that briefly describes a story that encapsulates the customer needs. The \ndevelopment team then aims to implement that scenario in a future release of the \nsoftware. An example of a story card for the Mentcare system is shown in Figure 3.5. \nThis is a short description of a scenario for prescribing medication for a patient.\nUser stories may be used in planning system iterations. Once the story cards have \nbeen developed, the development team breaks these down into tasks (Figure 3.6) and \nestimates the effort and resources required for implementing each task. This usually \ninvolves discussions with the customer to refine the requirements. The customer \nthen prioritizes the stories for implementation, choosing those stories that can be \nKate is a doctor who wishes to prescribe medication for a patient attending a clinic.\nThe patient record is already displayed on her computer so she clicks on the\nmedication \ufb01eld and can select \u2018current medication\u2019, \u2018new medication\u2019 or \u2018formulary\u2019.\nIf she selects \u2018current medication\u2019, the system asks her to check the dose; If she\nwants to change the dose, she enters the new dose then con\ufb01rms the prescription.\nIf she chooses \u2018new medication\u2019, the system assumes that she knows which\nmedication to prescribe. She types the \ufb01rst few letters of the drug name. The system\ndisplays a list of possible drugs starting with these letters. She chooses the required\nmedication and the system responds by asking her to check that the medication\nselected is correct. She enters the dose then con\ufb01rms the prescription.\nIf she chooses \u2018formulary\u2019, the system displays a search box for the approved\nformulary. She can then search for the drug required. She selects a drug and is asked\nto check that the medication is correct. She enters the dose then con\ufb01rms the\nprescription.\nThe system always checks that the dose is within the approved range. If it isn\u2019t, Kate\nis asked to change the dose.\nAfter Kate has con\ufb01rmed the prescription, it will be displayed for checking. She either\nclicks \u2018OK\u2019 or \u2018Change\u2019. If she clicks \u2018OK\u2019, the prescription is recorded on the audit\ndatabase. If she clicks on \u2018Change\u2019, she reenters the \u2018Prescribing medication\u2019 process.\nPrescribing medication\nFigure 3.5 A  \n\u201cprescribing medication\u201d \nstory\n\n\n80  Chapter 3 \u25a0 Agile software development\nused immediately to deliver useful business support. The intention is to identify \n useful functionality that can be implemented in about two weeks, when the next \nrelease of the system is made available to the customer.\nOf course, as requirements change, the unimplemented stories change or may be \ndiscarded. If changes are required for a system that has already been delivered, new \nstory cards are developed and again, the customer decides whether these changes \nshould have priority over new functionality.\nThe idea of user stories is a powerful one\u2014people find it much easier to relate to \nthese stories than to a conventional requirements document or use cases. User stories can \nbe helpful in getting users involved in suggesting requirements during an initial prede-\nvelopment requirements elicitation activity. I discuss this in more detail in Chapter 4.\nThe principal problem with user stories is completeness. It is difficult to judge if \nenough user stories have been developed to cover all of the essential requirements \nof\u00a0a system. It is also difficult to judge if a single story gives a true picture of an \nactivity. Experienced users are often so familiar with their work that they leave \nthings out when describing it.\n \n3.2.2  Refactoring\nA fundamental precept of traditional software engineering is that you should design \nfor change. That is, you should anticipate future changes to the software and design \nit so that these changes can be easily implemented. Extreme programming, however, \nhas discarded this principle on the basis that designing for change is often wasted \neffort. It isn\u2019t worth taking time to add generality to a program to cope with change. \nOften the changes anticipated never materialize, or completely different change \nrequests may actually be made.\nOf course, in practice, changes will always have to be made to the code being devel-\noped. To make these changes easier, the developers of XP suggested that the code being \ndeveloped should be constantly refactored. Refactoring (Fowler et al. 1999) means that \nthe programming team look for possible improvements to the software and implements \nTask 1: Change dose of prescribed drug\nTask 2: Formulary selection\nTask 3: Dose checking\nDose checking is a safety precaution to check that\nthe doctor has not prescribed a dangerously small or\nlarge dose.\nUsing the formulary id for the generic drug name,\nlook up the formulary and retrieve the recommended\nmaximum and minimum dose.\nCheck the prescribed dose against the minimum and\nmaximum. If outside the range, issue an error\nmessage saying that the dose is too high or too low.\nIf within the range, enable the \u2018Con\ufb01rm\u2019 button.\nFigure 3.6 Examples of \ntask cards for prescribing \nmedication"}
{"query": "How does the development team use a story card in agile development?", "response": "The development team uses a story card in agile development to briefly describe a user story that encapsulates the customer needs. The team works closely with the customer to develop the story card, which is then used to plan system iterations. The story cards are broken down into tasks, and the team estimates the effort and resources required for implementing each task. The customer prioritizes the stories for implementation, and the team aims to implement the scenarios described in the story cards in future releases of the software.", "context": "3.2  \u25a0 Agile development techniques  79\nI am not convinced that XP on its own is a practical agile method for most com-\npanies, but its most significant contribution is probably the set of agile development \npractices that it introduced to the community. I discuss the most important of these \npractices in this section.\n \n3.2.1  User stories\nSoftware requirements always change. To handle these changes, agile methods do not \nhave a separate requirements engineering activity. Rather, they integrate requirements \nelicitation with development. To make this easier, the idea of \u201cuser stories\u201d was devel-\noped where a user story is a scenario of use that might be experienced by a system user.\nAs far as possible, the system customer works closely with the development team \nand discusses these scenarios with other team members. Together, they develop a \n\u201cstory card\u201d that briefly describes a story that encapsulates the customer needs. The \ndevelopment team then aims to implement that scenario in a future release of the \nsoftware. An example of a story card for the Mentcare system is shown in Figure 3.5. \nThis is a short description of a scenario for prescribing medication for a patient.\nUser stories may be used in planning system iterations. Once the story cards have \nbeen developed, the development team breaks these down into tasks (Figure 3.6) and \nestimates the effort and resources required for implementing each task. This usually \ninvolves discussions with the customer to refine the requirements. The customer \nthen prioritizes the stories for implementation, choosing those stories that can be \nKate is a doctor who wishes to prescribe medication for a patient attending a clinic.\nThe patient record is already displayed on her computer so she clicks on the\nmedication \ufb01eld and can select \u2018current medication\u2019, \u2018new medication\u2019 or \u2018formulary\u2019.\nIf she selects \u2018current medication\u2019, the system asks her to check the dose; If she\nwants to change the dose, she enters the new dose then con\ufb01rms the prescription.\nIf she chooses \u2018new medication\u2019, the system assumes that she knows which\nmedication to prescribe. She types the \ufb01rst few letters of the drug name. The system\ndisplays a list of possible drugs starting with these letters. She chooses the required\nmedication and the system responds by asking her to check that the medication\nselected is correct. She enters the dose then con\ufb01rms the prescription.\nIf she chooses \u2018formulary\u2019, the system displays a search box for the approved\nformulary. She can then search for the drug required. She selects a drug and is asked\nto check that the medication is correct. She enters the dose then con\ufb01rms the\nprescription.\nThe system always checks that the dose is within the approved range. If it isn\u2019t, Kate\nis asked to change the dose.\nAfter Kate has con\ufb01rmed the prescription, it will be displayed for checking. She either\nclicks \u2018OK\u2019 or \u2018Change\u2019. If she clicks \u2018OK\u2019, the prescription is recorded on the audit\ndatabase. If she clicks on \u2018Change\u2019, she reenters the \u2018Prescribing medication\u2019 process.\nPrescribing medication\nFigure 3.5 A  \n\u201cprescribing medication\u201d \nstory\n\n\n80  Chapter 3 \u25a0 Agile software development\nused immediately to deliver useful business support. The intention is to identify \n useful functionality that can be implemented in about two weeks, when the next \nrelease of the system is made available to the customer.\nOf course, as requirements change, the unimplemented stories change or may be \ndiscarded. If changes are required for a system that has already been delivered, new \nstory cards are developed and again, the customer decides whether these changes \nshould have priority over new functionality.\nThe idea of user stories is a powerful one\u2014people find it much easier to relate to \nthese stories than to a conventional requirements document or use cases. User stories can \nbe helpful in getting users involved in suggesting requirements during an initial prede-\nvelopment requirements elicitation activity. I discuss this in more detail in Chapter 4.\nThe principal problem with user stories is completeness. It is difficult to judge if \nenough user stories have been developed to cover all of the essential requirements \nof\u00a0a system. It is also difficult to judge if a single story gives a true picture of an \nactivity. Experienced users are often so familiar with their work that they leave \nthings out when describing it.\n \n3.2.2  Refactoring\nA fundamental precept of traditional software engineering is that you should design \nfor change. That is, you should anticipate future changes to the software and design \nit so that these changes can be easily implemented. Extreme programming, however, \nhas discarded this principle on the basis that designing for change is often wasted \neffort. It isn\u2019t worth taking time to add generality to a program to cope with change. \nOften the changes anticipated never materialize, or completely different change \nrequests may actually be made.\nOf course, in practice, changes will always have to be made to the code being devel-\noped. To make these changes easier, the developers of XP suggested that the code being \ndeveloped should be constantly refactored. Refactoring (Fowler et al. 1999) means that \nthe programming team look for possible improvements to the software and implements \nTask 1: Change dose of prescribed drug\nTask 2: Formulary selection\nTask 3: Dose checking\nDose checking is a safety precaution to check that\nthe doctor has not prescribed a dangerously small or\nlarge dose.\nUsing the formulary id for the generic drug name,\nlook up the formulary and retrieve the recommended\nmaximum and minimum dose.\nCheck the prescribed dose against the minimum and\nmaximum. If outside the range, issue an error\nmessage saying that the dose is too high or too low.\nIf within the range, enable the \u2018Con\ufb01rm\u2019 button.\nFigure 3.6 Examples of \ntask cards for prescribing \nmedication"}
{"query": "What is the role of the customer in the development of user stories?", "response": "The customer plays an active role in the development of user stories. They work closely with the development team and discuss scenarios with other team members. Together, they develop a \"story card\" that encapsulates the customer needs. The customer also prioritizes the stories for implementation, choosing those stories that can be used immediately to deliver useful business support.", "context": "3.2  \u25a0 Agile development techniques  79\nI am not convinced that XP on its own is a practical agile method for most com-\npanies, but its most significant contribution is probably the set of agile development \npractices that it introduced to the community. I discuss the most important of these \npractices in this section.\n \n3.2.1  User stories\nSoftware requirements always change. To handle these changes, agile methods do not \nhave a separate requirements engineering activity. Rather, they integrate requirements \nelicitation with development. To make this easier, the idea of \u201cuser stories\u201d was devel-\noped where a user story is a scenario of use that might be experienced by a system user.\nAs far as possible, the system customer works closely with the development team \nand discusses these scenarios with other team members. Together, they develop a \n\u201cstory card\u201d that briefly describes a story that encapsulates the customer needs. The \ndevelopment team then aims to implement that scenario in a future release of the \nsoftware. An example of a story card for the Mentcare system is shown in Figure 3.5. \nThis is a short description of a scenario for prescribing medication for a patient.\nUser stories may be used in planning system iterations. Once the story cards have \nbeen developed, the development team breaks these down into tasks (Figure 3.6) and \nestimates the effort and resources required for implementing each task. This usually \ninvolves discussions with the customer to refine the requirements. The customer \nthen prioritizes the stories for implementation, choosing those stories that can be \nKate is a doctor who wishes to prescribe medication for a patient attending a clinic.\nThe patient record is already displayed on her computer so she clicks on the\nmedication \ufb01eld and can select \u2018current medication\u2019, \u2018new medication\u2019 or \u2018formulary\u2019.\nIf she selects \u2018current medication\u2019, the system asks her to check the dose; If she\nwants to change the dose, she enters the new dose then con\ufb01rms the prescription.\nIf she chooses \u2018new medication\u2019, the system assumes that she knows which\nmedication to prescribe. She types the \ufb01rst few letters of the drug name. The system\ndisplays a list of possible drugs starting with these letters. She chooses the required\nmedication and the system responds by asking her to check that the medication\nselected is correct. She enters the dose then con\ufb01rms the prescription.\nIf she chooses \u2018formulary\u2019, the system displays a search box for the approved\nformulary. She can then search for the drug required. She selects a drug and is asked\nto check that the medication is correct. She enters the dose then con\ufb01rms the\nprescription.\nThe system always checks that the dose is within the approved range. If it isn\u2019t, Kate\nis asked to change the dose.\nAfter Kate has con\ufb01rmed the prescription, it will be displayed for checking. She either\nclicks \u2018OK\u2019 or \u2018Change\u2019. If she clicks \u2018OK\u2019, the prescription is recorded on the audit\ndatabase. If she clicks on \u2018Change\u2019, she reenters the \u2018Prescribing medication\u2019 process.\nPrescribing medication\nFigure 3.5 A  \n\u201cprescribing medication\u201d \nstory\n\n\n80  Chapter 3 \u25a0 Agile software development\nused immediately to deliver useful business support. The intention is to identify \n useful functionality that can be implemented in about two weeks, when the next \nrelease of the system is made available to the customer.\nOf course, as requirements change, the unimplemented stories change or may be \ndiscarded. If changes are required for a system that has already been delivered, new \nstory cards are developed and again, the customer decides whether these changes \nshould have priority over new functionality.\nThe idea of user stories is a powerful one\u2014people find it much easier to relate to \nthese stories than to a conventional requirements document or use cases. User stories can \nbe helpful in getting users involved in suggesting requirements during an initial prede-\nvelopment requirements elicitation activity. I discuss this in more detail in Chapter 4.\nThe principal problem with user stories is completeness. It is difficult to judge if \nenough user stories have been developed to cover all of the essential requirements \nof\u00a0a system. It is also difficult to judge if a single story gives a true picture of an \nactivity. Experienced users are often so familiar with their work that they leave \nthings out when describing it.\n \n3.2.2  Refactoring\nA fundamental precept of traditional software engineering is that you should design \nfor change. That is, you should anticipate future changes to the software and design \nit so that these changes can be easily implemented. Extreme programming, however, \nhas discarded this principle on the basis that designing for change is often wasted \neffort. It isn\u2019t worth taking time to add generality to a program to cope with change. \nOften the changes anticipated never materialize, or completely different change \nrequests may actually be made.\nOf course, in practice, changes will always have to be made to the code being devel-\noped. To make these changes easier, the developers of XP suggested that the code being \ndeveloped should be constantly refactored. Refactoring (Fowler et al. 1999) means that \nthe programming team look for possible improvements to the software and implements \nTask 1: Change dose of prescribed drug\nTask 2: Formulary selection\nTask 3: Dose checking\nDose checking is a safety precaution to check that\nthe doctor has not prescribed a dangerously small or\nlarge dose.\nUsing the formulary id for the generic drug name,\nlook up the formulary and retrieve the recommended\nmaximum and minimum dose.\nCheck the prescribed dose against the minimum and\nmaximum. If outside the range, issue an error\nmessage saying that the dose is too high or too low.\nIf within the range, enable the \u2018Con\ufb01rm\u2019 button.\nFigure 3.6 Examples of \ntask cards for prescribing \nmedication"}
{"query": "How are user stories used in planning system iterations?", "response": "User stories are used in planning system iterations by breaking them down into tasks and estimating the effort and resources required for implementing each task. This involves discussions with the customer to refine the requirements. The customer then prioritizes the stories for implementation, choosing those stories that can be used immediately to deliver useful business support. The intention is to identify useful functionality that can be implemented in about two weeks, when the next release of the system is made available to the customer.", "context": "3.2  \u25a0 Agile development techniques  79\nI am not convinced that XP on its own is a practical agile method for most com-\npanies, but its most significant contribution is probably the set of agile development \npractices that it introduced to the community. I discuss the most important of these \npractices in this section.\n \n3.2.1  User stories\nSoftware requirements always change. To handle these changes, agile methods do not \nhave a separate requirements engineering activity. Rather, they integrate requirements \nelicitation with development. To make this easier, the idea of \u201cuser stories\u201d was devel-\noped where a user story is a scenario of use that might be experienced by a system user.\nAs far as possible, the system customer works closely with the development team \nand discusses these scenarios with other team members. Together, they develop a \n\u201cstory card\u201d that briefly describes a story that encapsulates the customer needs. The \ndevelopment team then aims to implement that scenario in a future release of the \nsoftware. An example of a story card for the Mentcare system is shown in Figure 3.5. \nThis is a short description of a scenario for prescribing medication for a patient.\nUser stories may be used in planning system iterations. Once the story cards have \nbeen developed, the development team breaks these down into tasks (Figure 3.6) and \nestimates the effort and resources required for implementing each task. This usually \ninvolves discussions with the customer to refine the requirements. The customer \nthen prioritizes the stories for implementation, choosing those stories that can be \nKate is a doctor who wishes to prescribe medication for a patient attending a clinic.\nThe patient record is already displayed on her computer so she clicks on the\nmedication \ufb01eld and can select \u2018current medication\u2019, \u2018new medication\u2019 or \u2018formulary\u2019.\nIf she selects \u2018current medication\u2019, the system asks her to check the dose; If she\nwants to change the dose, she enters the new dose then con\ufb01rms the prescription.\nIf she chooses \u2018new medication\u2019, the system assumes that she knows which\nmedication to prescribe. She types the \ufb01rst few letters of the drug name. The system\ndisplays a list of possible drugs starting with these letters. She chooses the required\nmedication and the system responds by asking her to check that the medication\nselected is correct. She enters the dose then con\ufb01rms the prescription.\nIf she chooses \u2018formulary\u2019, the system displays a search box for the approved\nformulary. She can then search for the drug required. She selects a drug and is asked\nto check that the medication is correct. She enters the dose then con\ufb01rms the\nprescription.\nThe system always checks that the dose is within the approved range. If it isn\u2019t, Kate\nis asked to change the dose.\nAfter Kate has con\ufb01rmed the prescription, it will be displayed for checking. She either\nclicks \u2018OK\u2019 or \u2018Change\u2019. If she clicks \u2018OK\u2019, the prescription is recorded on the audit\ndatabase. If she clicks on \u2018Change\u2019, she reenters the \u2018Prescribing medication\u2019 process.\nPrescribing medication\nFigure 3.5 A  \n\u201cprescribing medication\u201d \nstory\n\n\n80  Chapter 3 \u25a0 Agile software development\nused immediately to deliver useful business support. The intention is to identify \n useful functionality that can be implemented in about two weeks, when the next \nrelease of the system is made available to the customer.\nOf course, as requirements change, the unimplemented stories change or may be \ndiscarded. If changes are required for a system that has already been delivered, new \nstory cards are developed and again, the customer decides whether these changes \nshould have priority over new functionality.\nThe idea of user stories is a powerful one\u2014people find it much easier to relate to \nthese stories than to a conventional requirements document or use cases. User stories can \nbe helpful in getting users involved in suggesting requirements during an initial prede-\nvelopment requirements elicitation activity. I discuss this in more detail in Chapter 4.\nThe principal problem with user stories is completeness. It is difficult to judge if \nenough user stories have been developed to cover all of the essential requirements \nof\u00a0a system. It is also difficult to judge if a single story gives a true picture of an \nactivity. Experienced users are often so familiar with their work that they leave \nthings out when describing it.\n \n3.2.2  Refactoring\nA fundamental precept of traditional software engineering is that you should design \nfor change. That is, you should anticipate future changes to the software and design \nit so that these changes can be easily implemented. Extreme programming, however, \nhas discarded this principle on the basis that designing for change is often wasted \neffort. It isn\u2019t worth taking time to add generality to a program to cope with change. \nOften the changes anticipated never materialize, or completely different change \nrequests may actually be made.\nOf course, in practice, changes will always have to be made to the code being devel-\noped. To make these changes easier, the developers of XP suggested that the code being \ndeveloped should be constantly refactored. Refactoring (Fowler et al. 1999) means that \nthe programming team look for possible improvements to the software and implements \nTask 1: Change dose of prescribed drug\nTask 2: Formulary selection\nTask 3: Dose checking\nDose checking is a safety precaution to check that\nthe doctor has not prescribed a dangerously small or\nlarge dose.\nUsing the formulary id for the generic drug name,\nlook up the formulary and retrieve the recommended\nmaximum and minimum dose.\nCheck the prescribed dose against the minimum and\nmaximum. If outside the range, issue an error\nmessage saying that the dose is too high or too low.\nIf within the range, enable the \u2018Con\ufb01rm\u2019 button.\nFigure 3.6 Examples of \ntask cards for prescribing \nmedication"}
{"query": "What happens after the story cards have been developed?", "response": "After the story cards have been developed, the development team breaks them down into tasks. They then estimate the effort and resources required for implementing each task. This usually involves discussions with the customer to refine the requirements. The customer then prioritizes the stories for implementation, choosing those stories that can be used immediately to deliver useful business support. The intention is to identify useful functionality that can be implemented in about two weeks, when the next release of the system is made available to the customer.", "context": "3.2  \u25a0 Agile development techniques  79\nI am not convinced that XP on its own is a practical agile method for most com-\npanies, but its most significant contribution is probably the set of agile development \npractices that it introduced to the community. I discuss the most important of these \npractices in this section.\n \n3.2.1  User stories\nSoftware requirements always change. To handle these changes, agile methods do not \nhave a separate requirements engineering activity. Rather, they integrate requirements \nelicitation with development. To make this easier, the idea of \u201cuser stories\u201d was devel-\noped where a user story is a scenario of use that might be experienced by a system user.\nAs far as possible, the system customer works closely with the development team \nand discusses these scenarios with other team members. Together, they develop a \n\u201cstory card\u201d that briefly describes a story that encapsulates the customer needs. The \ndevelopment team then aims to implement that scenario in a future release of the \nsoftware. An example of a story card for the Mentcare system is shown in Figure 3.5. \nThis is a short description of a scenario for prescribing medication for a patient.\nUser stories may be used in planning system iterations. Once the story cards have \nbeen developed, the development team breaks these down into tasks (Figure 3.6) and \nestimates the effort and resources required for implementing each task. This usually \ninvolves discussions with the customer to refine the requirements. The customer \nthen prioritizes the stories for implementation, choosing those stories that can be \nKate is a doctor who wishes to prescribe medication for a patient attending a clinic.\nThe patient record is already displayed on her computer so she clicks on the\nmedication \ufb01eld and can select \u2018current medication\u2019, \u2018new medication\u2019 or \u2018formulary\u2019.\nIf she selects \u2018current medication\u2019, the system asks her to check the dose; If she\nwants to change the dose, she enters the new dose then con\ufb01rms the prescription.\nIf she chooses \u2018new medication\u2019, the system assumes that she knows which\nmedication to prescribe. She types the \ufb01rst few letters of the drug name. The system\ndisplays a list of possible drugs starting with these letters. She chooses the required\nmedication and the system responds by asking her to check that the medication\nselected is correct. She enters the dose then con\ufb01rms the prescription.\nIf she chooses \u2018formulary\u2019, the system displays a search box for the approved\nformulary. She can then search for the drug required. She selects a drug and is asked\nto check that the medication is correct. She enters the dose then con\ufb01rms the\nprescription.\nThe system always checks that the dose is within the approved range. If it isn\u2019t, Kate\nis asked to change the dose.\nAfter Kate has con\ufb01rmed the prescription, it will be displayed for checking. She either\nclicks \u2018OK\u2019 or \u2018Change\u2019. If she clicks \u2018OK\u2019, the prescription is recorded on the audit\ndatabase. If she clicks on \u2018Change\u2019, she reenters the \u2018Prescribing medication\u2019 process.\nPrescribing medication\nFigure 3.5 A  \n\u201cprescribing medication\u201d \nstory\n\n\n80  Chapter 3 \u25a0 Agile software development\nused immediately to deliver useful business support. The intention is to identify \n useful functionality that can be implemented in about two weeks, when the next \nrelease of the system is made available to the customer.\nOf course, as requirements change, the unimplemented stories change or may be \ndiscarded. If changes are required for a system that has already been delivered, new \nstory cards are developed and again, the customer decides whether these changes \nshould have priority over new functionality.\nThe idea of user stories is a powerful one\u2014people find it much easier to relate to \nthese stories than to a conventional requirements document or use cases. User stories can \nbe helpful in getting users involved in suggesting requirements during an initial prede-\nvelopment requirements elicitation activity. I discuss this in more detail in Chapter 4.\nThe principal problem with user stories is completeness. It is difficult to judge if \nenough user stories have been developed to cover all of the essential requirements \nof\u00a0a system. It is also difficult to judge if a single story gives a true picture of an \nactivity. Experienced users are often so familiar with their work that they leave \nthings out when describing it.\n \n3.2.2  Refactoring\nA fundamental precept of traditional software engineering is that you should design \nfor change. That is, you should anticipate future changes to the software and design \nit so that these changes can be easily implemented. Extreme programming, however, \nhas discarded this principle on the basis that designing for change is often wasted \neffort. It isn\u2019t worth taking time to add generality to a program to cope with change. \nOften the changes anticipated never materialize, or completely different change \nrequests may actually be made.\nOf course, in practice, changes will always have to be made to the code being devel-\noped. To make these changes easier, the developers of XP suggested that the code being \ndeveloped should be constantly refactored. Refactoring (Fowler et al. 1999) means that \nthe programming team look for possible improvements to the software and implements \nTask 1: Change dose of prescribed drug\nTask 2: Formulary selection\nTask 3: Dose checking\nDose checking is a safety precaution to check that\nthe doctor has not prescribed a dangerously small or\nlarge dose.\nUsing the formulary id for the generic drug name,\nlook up the formulary and retrieve the recommended\nmaximum and minimum dose.\nCheck the prescribed dose against the minimum and\nmaximum. If outside the range, issue an error\nmessage saying that the dose is too high or too low.\nIf within the range, enable the \u2018Con\ufb01rm\u2019 button.\nFigure 3.6 Examples of \ntask cards for prescribing \nmedication"}
{"query": "How are the requirements refined in the agile development process?", "response": "The requirements in the agile development process are refined through discussions with the customer. Once the user stories have been developed, the development team breaks them down into tasks and estimates the effort and resources required for each task. This refinement process usually involves discussions with the customer to clarify and refine the requirements. The customer then prioritizes the stories for implementation, choosing those stories that can be used immediately to deliver useful business support.", "context": "3.2  \u25a0 Agile development techniques  79\nI am not convinced that XP on its own is a practical agile method for most com-\npanies, but its most significant contribution is probably the set of agile development \npractices that it introduced to the community. I discuss the most important of these \npractices in this section.\n \n3.2.1  User stories\nSoftware requirements always change. To handle these changes, agile methods do not \nhave a separate requirements engineering activity. Rather, they integrate requirements \nelicitation with development. To make this easier, the idea of \u201cuser stories\u201d was devel-\noped where a user story is a scenario of use that might be experienced by a system user.\nAs far as possible, the system customer works closely with the development team \nand discusses these scenarios with other team members. Together, they develop a \n\u201cstory card\u201d that briefly describes a story that encapsulates the customer needs. The \ndevelopment team then aims to implement that scenario in a future release of the \nsoftware. An example of a story card for the Mentcare system is shown in Figure 3.5. \nThis is a short description of a scenario for prescribing medication for a patient.\nUser stories may be used in planning system iterations. Once the story cards have \nbeen developed, the development team breaks these down into tasks (Figure 3.6) and \nestimates the effort and resources required for implementing each task. This usually \ninvolves discussions with the customer to refine the requirements. The customer \nthen prioritizes the stories for implementation, choosing those stories that can be \nKate is a doctor who wishes to prescribe medication for a patient attending a clinic.\nThe patient record is already displayed on her computer so she clicks on the\nmedication \ufb01eld and can select \u2018current medication\u2019, \u2018new medication\u2019 or \u2018formulary\u2019.\nIf she selects \u2018current medication\u2019, the system asks her to check the dose; If she\nwants to change the dose, she enters the new dose then con\ufb01rms the prescription.\nIf she chooses \u2018new medication\u2019, the system assumes that she knows which\nmedication to prescribe. She types the \ufb01rst few letters of the drug name. The system\ndisplays a list of possible drugs starting with these letters. She chooses the required\nmedication and the system responds by asking her to check that the medication\nselected is correct. She enters the dose then con\ufb01rms the prescription.\nIf she chooses \u2018formulary\u2019, the system displays a search box for the approved\nformulary. She can then search for the drug required. She selects a drug and is asked\nto check that the medication is correct. She enters the dose then con\ufb01rms the\nprescription.\nThe system always checks that the dose is within the approved range. If it isn\u2019t, Kate\nis asked to change the dose.\nAfter Kate has con\ufb01rmed the prescription, it will be displayed for checking. She either\nclicks \u2018OK\u2019 or \u2018Change\u2019. If she clicks \u2018OK\u2019, the prescription is recorded on the audit\ndatabase. If she clicks on \u2018Change\u2019, she reenters the \u2018Prescribing medication\u2019 process.\nPrescribing medication\nFigure 3.5 A  \n\u201cprescribing medication\u201d \nstory\n\n\n80  Chapter 3 \u25a0 Agile software development\nused immediately to deliver useful business support. The intention is to identify \n useful functionality that can be implemented in about two weeks, when the next \nrelease of the system is made available to the customer.\nOf course, as requirements change, the unimplemented stories change or may be \ndiscarded. If changes are required for a system that has already been delivered, new \nstory cards are developed and again, the customer decides whether these changes \nshould have priority over new functionality.\nThe idea of user stories is a powerful one\u2014people find it much easier to relate to \nthese stories than to a conventional requirements document or use cases. User stories can \nbe helpful in getting users involved in suggesting requirements during an initial prede-\nvelopment requirements elicitation activity. I discuss this in more detail in Chapter 4.\nThe principal problem with user stories is completeness. It is difficult to judge if \nenough user stories have been developed to cover all of the essential requirements \nof\u00a0a system. It is also difficult to judge if a single story gives a true picture of an \nactivity. Experienced users are often so familiar with their work that they leave \nthings out when describing it.\n \n3.2.2  Refactoring\nA fundamental precept of traditional software engineering is that you should design \nfor change. That is, you should anticipate future changes to the software and design \nit so that these changes can be easily implemented. Extreme programming, however, \nhas discarded this principle on the basis that designing for change is often wasted \neffort. It isn\u2019t worth taking time to add generality to a program to cope with change. \nOften the changes anticipated never materialize, or completely different change \nrequests may actually be made.\nOf course, in practice, changes will always have to be made to the code being devel-\noped. To make these changes easier, the developers of XP suggested that the code being \ndeveloped should be constantly refactored. Refactoring (Fowler et al. 1999) means that \nthe programming team look for possible improvements to the software and implements \nTask 1: Change dose of prescribed drug\nTask 2: Formulary selection\nTask 3: Dose checking\nDose checking is a safety precaution to check that\nthe doctor has not prescribed a dangerously small or\nlarge dose.\nUsing the formulary id for the generic drug name,\nlook up the formulary and retrieve the recommended\nmaximum and minimum dose.\nCheck the prescribed dose against the minimum and\nmaximum. If outside the range, issue an error\nmessage saying that the dose is too high or too low.\nIf within the range, enable the \u2018Con\ufb01rm\u2019 button.\nFigure 3.6 Examples of \ntask cards for prescribing \nmedication"}
{"query": "What is the role of the customer in prioritizing the stories for implementation?", "response": "The customer plays a role in prioritizing the stories for implementation.", "context": "3.2  \u25a0 Agile development techniques  79\nI am not convinced that XP on its own is a practical agile method for most com-\npanies, but its most significant contribution is probably the set of agile development \npractices that it introduced to the community. I discuss the most important of these \npractices in this section.\n \n3.2.1  User stories\nSoftware requirements always change. To handle these changes, agile methods do not \nhave a separate requirements engineering activity. Rather, they integrate requirements \nelicitation with development. To make this easier, the idea of \u201cuser stories\u201d was devel-\noped where a user story is a scenario of use that might be experienced by a system user.\nAs far as possible, the system customer works closely with the development team \nand discusses these scenarios with other team members. Together, they develop a \n\u201cstory card\u201d that briefly describes a story that encapsulates the customer needs. The \ndevelopment team then aims to implement that scenario in a future release of the \nsoftware. An example of a story card for the Mentcare system is shown in Figure 3.5. \nThis is a short description of a scenario for prescribing medication for a patient.\nUser stories may be used in planning system iterations. Once the story cards have \nbeen developed, the development team breaks these down into tasks (Figure 3.6) and \nestimates the effort and resources required for implementing each task. This usually \ninvolves discussions with the customer to refine the requirements. The customer \nthen prioritizes the stories for implementation, choosing those stories that can be \nKate is a doctor who wishes to prescribe medication for a patient attending a clinic.\nThe patient record is already displayed on her computer so she clicks on the\nmedication \ufb01eld and can select \u2018current medication\u2019, \u2018new medication\u2019 or \u2018formulary\u2019.\nIf she selects \u2018current medication\u2019, the system asks her to check the dose; If she\nwants to change the dose, she enters the new dose then con\ufb01rms the prescription.\nIf she chooses \u2018new medication\u2019, the system assumes that she knows which\nmedication to prescribe. She types the \ufb01rst few letters of the drug name. The system\ndisplays a list of possible drugs starting with these letters. She chooses the required\nmedication and the system responds by asking her to check that the medication\nselected is correct. She enters the dose then con\ufb01rms the prescription.\nIf she chooses \u2018formulary\u2019, the system displays a search box for the approved\nformulary. She can then search for the drug required. She selects a drug and is asked\nto check that the medication is correct. She enters the dose then con\ufb01rms the\nprescription.\nThe system always checks that the dose is within the approved range. If it isn\u2019t, Kate\nis asked to change the dose.\nAfter Kate has con\ufb01rmed the prescription, it will be displayed for checking. She either\nclicks \u2018OK\u2019 or \u2018Change\u2019. If she clicks \u2018OK\u2019, the prescription is recorded on the audit\ndatabase. If she clicks on \u2018Change\u2019, she reenters the \u2018Prescribing medication\u2019 process.\nPrescribing medication\nFigure 3.5 A  \n\u201cprescribing medication\u201d \nstory\n\n\n80  Chapter 3 \u25a0 Agile software development\nused immediately to deliver useful business support. The intention is to identify \n useful functionality that can be implemented in about two weeks, when the next \nrelease of the system is made available to the customer.\nOf course, as requirements change, the unimplemented stories change or may be \ndiscarded. If changes are required for a system that has already been delivered, new \nstory cards are developed and again, the customer decides whether these changes \nshould have priority over new functionality.\nThe idea of user stories is a powerful one\u2014people find it much easier to relate to \nthese stories than to a conventional requirements document or use cases. User stories can \nbe helpful in getting users involved in suggesting requirements during an initial prede-\nvelopment requirements elicitation activity. I discuss this in more detail in Chapter 4.\nThe principal problem with user stories is completeness. It is difficult to judge if \nenough user stories have been developed to cover all of the essential requirements \nof\u00a0a system. It is also difficult to judge if a single story gives a true picture of an \nactivity. Experienced users are often so familiar with their work that they leave \nthings out when describing it.\n \n3.2.2  Refactoring\nA fundamental precept of traditional software engineering is that you should design \nfor change. That is, you should anticipate future changes to the software and design \nit so that these changes can be easily implemented. Extreme programming, however, \nhas discarded this principle on the basis that designing for change is often wasted \neffort. It isn\u2019t worth taking time to add generality to a program to cope with change. \nOften the changes anticipated never materialize, or completely different change \nrequests may actually be made.\nOf course, in practice, changes will always have to be made to the code being devel-\noped. To make these changes easier, the developers of XP suggested that the code being \ndeveloped should be constantly refactored. Refactoring (Fowler et al. 1999) means that \nthe programming team look for possible improvements to the software and implements \nTask 1: Change dose of prescribed drug\nTask 2: Formulary selection\nTask 3: Dose checking\nDose checking is a safety precaution to check that\nthe doctor has not prescribed a dangerously small or\nlarge dose.\nUsing the formulary id for the generic drug name,\nlook up the formulary and retrieve the recommended\nmaximum and minimum dose.\nCheck the prescribed dose against the minimum and\nmaximum. If outside the range, issue an error\nmessage saying that the dose is too high or too low.\nIf within the range, enable the \u2018Con\ufb01rm\u2019 button.\nFigure 3.6 Examples of \ntask cards for prescribing \nmedication"}
{"query": "How often is the new release of the system made available to the customer in agile development?", "response": "The new release of the system is made available to the customer approximately every two weeks in agile development.", "context": "3.2  \u25a0 Agile development techniques  79\nI am not convinced that XP on its own is a practical agile method for most com-\npanies, but its most significant contribution is probably the set of agile development \npractices that it introduced to the community. I discuss the most important of these \npractices in this section.\n \n3.2.1  User stories\nSoftware requirements always change. To handle these changes, agile methods do not \nhave a separate requirements engineering activity. Rather, they integrate requirements \nelicitation with development. To make this easier, the idea of \u201cuser stories\u201d was devel-\noped where a user story is a scenario of use that might be experienced by a system user.\nAs far as possible, the system customer works closely with the development team \nand discusses these scenarios with other team members. Together, they develop a \n\u201cstory card\u201d that briefly describes a story that encapsulates the customer needs. The \ndevelopment team then aims to implement that scenario in a future release of the \nsoftware. An example of a story card for the Mentcare system is shown in Figure 3.5. \nThis is a short description of a scenario for prescribing medication for a patient.\nUser stories may be used in planning system iterations. Once the story cards have \nbeen developed, the development team breaks these down into tasks (Figure 3.6) and \nestimates the effort and resources required for implementing each task. This usually \ninvolves discussions with the customer to refine the requirements. The customer \nthen prioritizes the stories for implementation, choosing those stories that can be \nKate is a doctor who wishes to prescribe medication for a patient attending a clinic.\nThe patient record is already displayed on her computer so she clicks on the\nmedication \ufb01eld and can select \u2018current medication\u2019, \u2018new medication\u2019 or \u2018formulary\u2019.\nIf she selects \u2018current medication\u2019, the system asks her to check the dose; If she\nwants to change the dose, she enters the new dose then con\ufb01rms the prescription.\nIf she chooses \u2018new medication\u2019, the system assumes that she knows which\nmedication to prescribe. She types the \ufb01rst few letters of the drug name. The system\ndisplays a list of possible drugs starting with these letters. She chooses the required\nmedication and the system responds by asking her to check that the medication\nselected is correct. She enters the dose then con\ufb01rms the prescription.\nIf she chooses \u2018formulary\u2019, the system displays a search box for the approved\nformulary. She can then search for the drug required. She selects a drug and is asked\nto check that the medication is correct. She enters the dose then con\ufb01rms the\nprescription.\nThe system always checks that the dose is within the approved range. If it isn\u2019t, Kate\nis asked to change the dose.\nAfter Kate has con\ufb01rmed the prescription, it will be displayed for checking. She either\nclicks \u2018OK\u2019 or \u2018Change\u2019. If she clicks \u2018OK\u2019, the prescription is recorded on the audit\ndatabase. If she clicks on \u2018Change\u2019, she reenters the \u2018Prescribing medication\u2019 process.\nPrescribing medication\nFigure 3.5 A  \n\u201cprescribing medication\u201d \nstory\n\n\n80  Chapter 3 \u25a0 Agile software development\nused immediately to deliver useful business support. The intention is to identify \n useful functionality that can be implemented in about two weeks, when the next \nrelease of the system is made available to the customer.\nOf course, as requirements change, the unimplemented stories change or may be \ndiscarded. If changes are required for a system that has already been delivered, new \nstory cards are developed and again, the customer decides whether these changes \nshould have priority over new functionality.\nThe idea of user stories is a powerful one\u2014people find it much easier to relate to \nthese stories than to a conventional requirements document or use cases. User stories can \nbe helpful in getting users involved in suggesting requirements during an initial prede-\nvelopment requirements elicitation activity. I discuss this in more detail in Chapter 4.\nThe principal problem with user stories is completeness. It is difficult to judge if \nenough user stories have been developed to cover all of the essential requirements \nof\u00a0a system. It is also difficult to judge if a single story gives a true picture of an \nactivity. Experienced users are often so familiar with their work that they leave \nthings out when describing it.\n \n3.2.2  Refactoring\nA fundamental precept of traditional software engineering is that you should design \nfor change. That is, you should anticipate future changes to the software and design \nit so that these changes can be easily implemented. Extreme programming, however, \nhas discarded this principle on the basis that designing for change is often wasted \neffort. It isn\u2019t worth taking time to add generality to a program to cope with change. \nOften the changes anticipated never materialize, or completely different change \nrequests may actually be made.\nOf course, in practice, changes will always have to be made to the code being devel-\noped. To make these changes easier, the developers of XP suggested that the code being \ndeveloped should be constantly refactored. Refactoring (Fowler et al. 1999) means that \nthe programming team look for possible improvements to the software and implements \nTask 1: Change dose of prescribed drug\nTask 2: Formulary selection\nTask 3: Dose checking\nDose checking is a safety precaution to check that\nthe doctor has not prescribed a dangerously small or\nlarge dose.\nUsing the formulary id for the generic drug name,\nlook up the formulary and retrieve the recommended\nmaximum and minimum dose.\nCheck the prescribed dose against the minimum and\nmaximum. If outside the range, issue an error\nmessage saying that the dose is too high or too low.\nIf within the range, enable the \u2018Con\ufb01rm\u2019 button.\nFigure 3.6 Examples of \ntask cards for prescribing \nmedication"}
{"query": "What happens when requirements change in the agile development process?", "response": "When requirements change in the agile development process, the agile methods do not have a separate requirements engineering activity. Instead, they integrate requirements elicitation with development. User stories are used to handle these changes. User stories are scenarios of use that might be experienced by a system user. The system customer works closely with the development team to discuss these scenarios and develop story cards that encapsulate the customer needs. The development team then aims to implement these scenarios in future releases of the software. If changes are required for a system that has already been delivered, new story cards are developed and the customer decides whether these changes should have priority over new functionality.", "context": "3.2  \u25a0 Agile development techniques  79\nI am not convinced that XP on its own is a practical agile method for most com-\npanies, but its most significant contribution is probably the set of agile development \npractices that it introduced to the community. I discuss the most important of these \npractices in this section.\n \n3.2.1  User stories\nSoftware requirements always change. To handle these changes, agile methods do not \nhave a separate requirements engineering activity. Rather, they integrate requirements \nelicitation with development. To make this easier, the idea of \u201cuser stories\u201d was devel-\noped where a user story is a scenario of use that might be experienced by a system user.\nAs far as possible, the system customer works closely with the development team \nand discusses these scenarios with other team members. Together, they develop a \n\u201cstory card\u201d that briefly describes a story that encapsulates the customer needs. The \ndevelopment team then aims to implement that scenario in a future release of the \nsoftware. An example of a story card for the Mentcare system is shown in Figure 3.5. \nThis is a short description of a scenario for prescribing medication for a patient.\nUser stories may be used in planning system iterations. Once the story cards have \nbeen developed, the development team breaks these down into tasks (Figure 3.6) and \nestimates the effort and resources required for implementing each task. This usually \ninvolves discussions with the customer to refine the requirements. The customer \nthen prioritizes the stories for implementation, choosing those stories that can be \nKate is a doctor who wishes to prescribe medication for a patient attending a clinic.\nThe patient record is already displayed on her computer so she clicks on the\nmedication \ufb01eld and can select \u2018current medication\u2019, \u2018new medication\u2019 or \u2018formulary\u2019.\nIf she selects \u2018current medication\u2019, the system asks her to check the dose; If she\nwants to change the dose, she enters the new dose then con\ufb01rms the prescription.\nIf she chooses \u2018new medication\u2019, the system assumes that she knows which\nmedication to prescribe. She types the \ufb01rst few letters of the drug name. The system\ndisplays a list of possible drugs starting with these letters. She chooses the required\nmedication and the system responds by asking her to check that the medication\nselected is correct. She enters the dose then con\ufb01rms the prescription.\nIf she chooses \u2018formulary\u2019, the system displays a search box for the approved\nformulary. She can then search for the drug required. She selects a drug and is asked\nto check that the medication is correct. She enters the dose then con\ufb01rms the\nprescription.\nThe system always checks that the dose is within the approved range. If it isn\u2019t, Kate\nis asked to change the dose.\nAfter Kate has con\ufb01rmed the prescription, it will be displayed for checking. She either\nclicks \u2018OK\u2019 or \u2018Change\u2019. If she clicks \u2018OK\u2019, the prescription is recorded on the audit\ndatabase. If she clicks on \u2018Change\u2019, she reenters the \u2018Prescribing medication\u2019 process.\nPrescribing medication\nFigure 3.5 A  \n\u201cprescribing medication\u201d \nstory\n\n\n80  Chapter 3 \u25a0 Agile software development\nused immediately to deliver useful business support. The intention is to identify \n useful functionality that can be implemented in about two weeks, when the next \nrelease of the system is made available to the customer.\nOf course, as requirements change, the unimplemented stories change or may be \ndiscarded. If changes are required for a system that has already been delivered, new \nstory cards are developed and again, the customer decides whether these changes \nshould have priority over new functionality.\nThe idea of user stories is a powerful one\u2014people find it much easier to relate to \nthese stories than to a conventional requirements document or use cases. User stories can \nbe helpful in getting users involved in suggesting requirements during an initial prede-\nvelopment requirements elicitation activity. I discuss this in more detail in Chapter 4.\nThe principal problem with user stories is completeness. It is difficult to judge if \nenough user stories have been developed to cover all of the essential requirements \nof\u00a0a system. It is also difficult to judge if a single story gives a true picture of an \nactivity. Experienced users are often so familiar with their work that they leave \nthings out when describing it.\n \n3.2.2  Refactoring\nA fundamental precept of traditional software engineering is that you should design \nfor change. That is, you should anticipate future changes to the software and design \nit so that these changes can be easily implemented. Extreme programming, however, \nhas discarded this principle on the basis that designing for change is often wasted \neffort. It isn\u2019t worth taking time to add generality to a program to cope with change. \nOften the changes anticipated never materialize, or completely different change \nrequests may actually be made.\nOf course, in practice, changes will always have to be made to the code being devel-\noped. To make these changes easier, the developers of XP suggested that the code being \ndeveloped should be constantly refactored. Refactoring (Fowler et al. 1999) means that \nthe programming team look for possible improvements to the software and implements \nTask 1: Change dose of prescribed drug\nTask 2: Formulary selection\nTask 3: Dose checking\nDose checking is a safety precaution to check that\nthe doctor has not prescribed a dangerously small or\nlarge dose.\nUsing the formulary id for the generic drug name,\nlook up the formulary and retrieve the recommended\nmaximum and minimum dose.\nCheck the prescribed dose against the minimum and\nmaximum. If outside the range, issue an error\nmessage saying that the dose is too high or too low.\nIf within the range, enable the \u2018Con\ufb01rm\u2019 button.\nFigure 3.6 Examples of \ntask cards for prescribing \nmedication"}
{"query": "What is the advantage of user stories over a conventional requirements document or use cases?", "response": "User stories have an advantage over a conventional requirements document or use cases because people find it much easier to relate to these stories. User stories can be helpful in getting users involved in suggesting requirements during an initial pre-development requirements elicitation activity.", "context": "3.2  \u25a0 Agile development techniques  79\nI am not convinced that XP on its own is a practical agile method for most com-\npanies, but its most significant contribution is probably the set of agile development \npractices that it introduced to the community. I discuss the most important of these \npractices in this section.\n \n3.2.1  User stories\nSoftware requirements always change. To handle these changes, agile methods do not \nhave a separate requirements engineering activity. Rather, they integrate requirements \nelicitation with development. To make this easier, the idea of \u201cuser stories\u201d was devel-\noped where a user story is a scenario of use that might be experienced by a system user.\nAs far as possible, the system customer works closely with the development team \nand discusses these scenarios with other team members. Together, they develop a \n\u201cstory card\u201d that briefly describes a story that encapsulates the customer needs. The \ndevelopment team then aims to implement that scenario in a future release of the \nsoftware. An example of a story card for the Mentcare system is shown in Figure 3.5. \nThis is a short description of a scenario for prescribing medication for a patient.\nUser stories may be used in planning system iterations. Once the story cards have \nbeen developed, the development team breaks these down into tasks (Figure 3.6) and \nestimates the effort and resources required for implementing each task. This usually \ninvolves discussions with the customer to refine the requirements. The customer \nthen prioritizes the stories for implementation, choosing those stories that can be \nKate is a doctor who wishes to prescribe medication for a patient attending a clinic.\nThe patient record is already displayed on her computer so she clicks on the\nmedication \ufb01eld and can select \u2018current medication\u2019, \u2018new medication\u2019 or \u2018formulary\u2019.\nIf she selects \u2018current medication\u2019, the system asks her to check the dose; If she\nwants to change the dose, she enters the new dose then con\ufb01rms the prescription.\nIf she chooses \u2018new medication\u2019, the system assumes that she knows which\nmedication to prescribe. She types the \ufb01rst few letters of the drug name. The system\ndisplays a list of possible drugs starting with these letters. She chooses the required\nmedication and the system responds by asking her to check that the medication\nselected is correct. She enters the dose then con\ufb01rms the prescription.\nIf she chooses \u2018formulary\u2019, the system displays a search box for the approved\nformulary. She can then search for the drug required. She selects a drug and is asked\nto check that the medication is correct. She enters the dose then con\ufb01rms the\nprescription.\nThe system always checks that the dose is within the approved range. If it isn\u2019t, Kate\nis asked to change the dose.\nAfter Kate has con\ufb01rmed the prescription, it will be displayed for checking. She either\nclicks \u2018OK\u2019 or \u2018Change\u2019. If she clicks \u2018OK\u2019, the prescription is recorded on the audit\ndatabase. If she clicks on \u2018Change\u2019, she reenters the \u2018Prescribing medication\u2019 process.\nPrescribing medication\nFigure 3.5 A  \n\u201cprescribing medication\u201d \nstory\n\n\n80  Chapter 3 \u25a0 Agile software development\nused immediately to deliver useful business support. The intention is to identify \n useful functionality that can be implemented in about two weeks, when the next \nrelease of the system is made available to the customer.\nOf course, as requirements change, the unimplemented stories change or may be \ndiscarded. If changes are required for a system that has already been delivered, new \nstory cards are developed and again, the customer decides whether these changes \nshould have priority over new functionality.\nThe idea of user stories is a powerful one\u2014people find it much easier to relate to \nthese stories than to a conventional requirements document or use cases. User stories can \nbe helpful in getting users involved in suggesting requirements during an initial prede-\nvelopment requirements elicitation activity. I discuss this in more detail in Chapter 4.\nThe principal problem with user stories is completeness. It is difficult to judge if \nenough user stories have been developed to cover all of the essential requirements \nof\u00a0a system. It is also difficult to judge if a single story gives a true picture of an \nactivity. Experienced users are often so familiar with their work that they leave \nthings out when describing it.\n \n3.2.2  Refactoring\nA fundamental precept of traditional software engineering is that you should design \nfor change. That is, you should anticipate future changes to the software and design \nit so that these changes can be easily implemented. Extreme programming, however, \nhas discarded this principle on the basis that designing for change is often wasted \neffort. It isn\u2019t worth taking time to add generality to a program to cope with change. \nOften the changes anticipated never materialize, or completely different change \nrequests may actually be made.\nOf course, in practice, changes will always have to be made to the code being devel-\noped. To make these changes easier, the developers of XP suggested that the code being \ndeveloped should be constantly refactored. Refactoring (Fowler et al. 1999) means that \nthe programming team look for possible improvements to the software and implements \nTask 1: Change dose of prescribed drug\nTask 2: Formulary selection\nTask 3: Dose checking\nDose checking is a safety precaution to check that\nthe doctor has not prescribed a dangerously small or\nlarge dose.\nUsing the formulary id for the generic drug name,\nlook up the formulary and retrieve the recommended\nmaximum and minimum dose.\nCheck the prescribed dose against the minimum and\nmaximum. If outside the range, issue an error\nmessage saying that the dose is too high or too low.\nIf within the range, enable the \u2018Con\ufb01rm\u2019 button.\nFigure 3.6 Examples of \ntask cards for prescribing \nmedication"}
{"query": "What is the main problem with user stories in agile development?", "response": "The main problem with user stories in agile development is their completeness. It is difficult to determine if enough user stories have been developed to cover all of the essential requirements of a system. Additionally, it is challenging to judge if a single story provides a true picture of an activity, as experienced users may unintentionally leave out important details when describing their work.", "context": "3.2  \u25a0 Agile development techniques  79\nI am not convinced that XP on its own is a practical agile method for most com-\npanies, but its most significant contribution is probably the set of agile development \npractices that it introduced to the community. I discuss the most important of these \npractices in this section.\n \n3.2.1  User stories\nSoftware requirements always change. To handle these changes, agile methods do not \nhave a separate requirements engineering activity. Rather, they integrate requirements \nelicitation with development. To make this easier, the idea of \u201cuser stories\u201d was devel-\noped where a user story is a scenario of use that might be experienced by a system user.\nAs far as possible, the system customer works closely with the development team \nand discusses these scenarios with other team members. Together, they develop a \n\u201cstory card\u201d that briefly describes a story that encapsulates the customer needs. The \ndevelopment team then aims to implement that scenario in a future release of the \nsoftware. An example of a story card for the Mentcare system is shown in Figure 3.5. \nThis is a short description of a scenario for prescribing medication for a patient.\nUser stories may be used in planning system iterations. Once the story cards have \nbeen developed, the development team breaks these down into tasks (Figure 3.6) and \nestimates the effort and resources required for implementing each task. This usually \ninvolves discussions with the customer to refine the requirements. The customer \nthen prioritizes the stories for implementation, choosing those stories that can be \nKate is a doctor who wishes to prescribe medication for a patient attending a clinic.\nThe patient record is already displayed on her computer so she clicks on the\nmedication \ufb01eld and can select \u2018current medication\u2019, \u2018new medication\u2019 or \u2018formulary\u2019.\nIf she selects \u2018current medication\u2019, the system asks her to check the dose; If she\nwants to change the dose, she enters the new dose then con\ufb01rms the prescription.\nIf she chooses \u2018new medication\u2019, the system assumes that she knows which\nmedication to prescribe. She types the \ufb01rst few letters of the drug name. The system\ndisplays a list of possible drugs starting with these letters. She chooses the required\nmedication and the system responds by asking her to check that the medication\nselected is correct. She enters the dose then con\ufb01rms the prescription.\nIf she chooses \u2018formulary\u2019, the system displays a search box for the approved\nformulary. She can then search for the drug required. She selects a drug and is asked\nto check that the medication is correct. She enters the dose then con\ufb01rms the\nprescription.\nThe system always checks that the dose is within the approved range. If it isn\u2019t, Kate\nis asked to change the dose.\nAfter Kate has con\ufb01rmed the prescription, it will be displayed for checking. She either\nclicks \u2018OK\u2019 or \u2018Change\u2019. If she clicks \u2018OK\u2019, the prescription is recorded on the audit\ndatabase. If she clicks on \u2018Change\u2019, she reenters the \u2018Prescribing medication\u2019 process.\nPrescribing medication\nFigure 3.5 A  \n\u201cprescribing medication\u201d \nstory\n\n\n80  Chapter 3 \u25a0 Agile software development\nused immediately to deliver useful business support. The intention is to identify \n useful functionality that can be implemented in about two weeks, when the next \nrelease of the system is made available to the customer.\nOf course, as requirements change, the unimplemented stories change or may be \ndiscarded. If changes are required for a system that has already been delivered, new \nstory cards are developed and again, the customer decides whether these changes \nshould have priority over new functionality.\nThe idea of user stories is a powerful one\u2014people find it much easier to relate to \nthese stories than to a conventional requirements document or use cases. User stories can \nbe helpful in getting users involved in suggesting requirements during an initial prede-\nvelopment requirements elicitation activity. I discuss this in more detail in Chapter 4.\nThe principal problem with user stories is completeness. It is difficult to judge if \nenough user stories have been developed to cover all of the essential requirements \nof\u00a0a system. It is also difficult to judge if a single story gives a true picture of an \nactivity. Experienced users are often so familiar with their work that they leave \nthings out when describing it.\n \n3.2.2  Refactoring\nA fundamental precept of traditional software engineering is that you should design \nfor change. That is, you should anticipate future changes to the software and design \nit so that these changes can be easily implemented. Extreme programming, however, \nhas discarded this principle on the basis that designing for change is often wasted \neffort. It isn\u2019t worth taking time to add generality to a program to cope with change. \nOften the changes anticipated never materialize, or completely different change \nrequests may actually be made.\nOf course, in practice, changes will always have to be made to the code being devel-\noped. To make these changes easier, the developers of XP suggested that the code being \ndeveloped should be constantly refactored. Refactoring (Fowler et al. 1999) means that \nthe programming team look for possible improvements to the software and implements \nTask 1: Change dose of prescribed drug\nTask 2: Formulary selection\nTask 3: Dose checking\nDose checking is a safety precaution to check that\nthe doctor has not prescribed a dangerously small or\nlarge dose.\nUsing the formulary id for the generic drug name,\nlook up the formulary and retrieve the recommended\nmaximum and minimum dose.\nCheck the prescribed dose against the minimum and\nmaximum. If outside the range, issue an error\nmessage saying that the dose is too high or too low.\nIf within the range, enable the \u2018Con\ufb01rm\u2019 button.\nFigure 3.6 Examples of \ntask cards for prescribing \nmedication"}
{"query": "Why is it difficult to judge if enough user stories have been developed?", "response": "It is difficult to judge if enough user stories have been developed because user stories are used to capture scenarios of use that might be experienced by a system user. However, experienced users may leave out important details when describing their work, and it is challenging to determine if a single story gives a complete picture of an activity. Additionally, it is not always clear if all the essential requirements of a system have been covered by the user stories.", "context": "3.2  \u25a0 Agile development techniques  79\nI am not convinced that XP on its own is a practical agile method for most com-\npanies, but its most significant contribution is probably the set of agile development \npractices that it introduced to the community. I discuss the most important of these \npractices in this section.\n \n3.2.1  User stories\nSoftware requirements always change. To handle these changes, agile methods do not \nhave a separate requirements engineering activity. Rather, they integrate requirements \nelicitation with development. To make this easier, the idea of \u201cuser stories\u201d was devel-\noped where a user story is a scenario of use that might be experienced by a system user.\nAs far as possible, the system customer works closely with the development team \nand discusses these scenarios with other team members. Together, they develop a \n\u201cstory card\u201d that briefly describes a story that encapsulates the customer needs. The \ndevelopment team then aims to implement that scenario in a future release of the \nsoftware. An example of a story card for the Mentcare system is shown in Figure 3.5. \nThis is a short description of a scenario for prescribing medication for a patient.\nUser stories may be used in planning system iterations. Once the story cards have \nbeen developed, the development team breaks these down into tasks (Figure 3.6) and \nestimates the effort and resources required for implementing each task. This usually \ninvolves discussions with the customer to refine the requirements. The customer \nthen prioritizes the stories for implementation, choosing those stories that can be \nKate is a doctor who wishes to prescribe medication for a patient attending a clinic.\nThe patient record is already displayed on her computer so she clicks on the\nmedication \ufb01eld and can select \u2018current medication\u2019, \u2018new medication\u2019 or \u2018formulary\u2019.\nIf she selects \u2018current medication\u2019, the system asks her to check the dose; If she\nwants to change the dose, she enters the new dose then con\ufb01rms the prescription.\nIf she chooses \u2018new medication\u2019, the system assumes that she knows which\nmedication to prescribe. She types the \ufb01rst few letters of the drug name. The system\ndisplays a list of possible drugs starting with these letters. She chooses the required\nmedication and the system responds by asking her to check that the medication\nselected is correct. She enters the dose then con\ufb01rms the prescription.\nIf she chooses \u2018formulary\u2019, the system displays a search box for the approved\nformulary. She can then search for the drug required. She selects a drug and is asked\nto check that the medication is correct. She enters the dose then con\ufb01rms the\nprescription.\nThe system always checks that the dose is within the approved range. If it isn\u2019t, Kate\nis asked to change the dose.\nAfter Kate has con\ufb01rmed the prescription, it will be displayed for checking. She either\nclicks \u2018OK\u2019 or \u2018Change\u2019. If she clicks \u2018OK\u2019, the prescription is recorded on the audit\ndatabase. If she clicks on \u2018Change\u2019, she reenters the \u2018Prescribing medication\u2019 process.\nPrescribing medication\nFigure 3.5 A  \n\u201cprescribing medication\u201d \nstory\n\n\n80  Chapter 3 \u25a0 Agile software development\nused immediately to deliver useful business support. The intention is to identify \n useful functionality that can be implemented in about two weeks, when the next \nrelease of the system is made available to the customer.\nOf course, as requirements change, the unimplemented stories change or may be \ndiscarded. If changes are required for a system that has already been delivered, new \nstory cards are developed and again, the customer decides whether these changes \nshould have priority over new functionality.\nThe idea of user stories is a powerful one\u2014people find it much easier to relate to \nthese stories than to a conventional requirements document or use cases. User stories can \nbe helpful in getting users involved in suggesting requirements during an initial prede-\nvelopment requirements elicitation activity. I discuss this in more detail in Chapter 4.\nThe principal problem with user stories is completeness. It is difficult to judge if \nenough user stories have been developed to cover all of the essential requirements \nof\u00a0a system. It is also difficult to judge if a single story gives a true picture of an \nactivity. Experienced users are often so familiar with their work that they leave \nthings out when describing it.\n \n3.2.2  Refactoring\nA fundamental precept of traditional software engineering is that you should design \nfor change. That is, you should anticipate future changes to the software and design \nit so that these changes can be easily implemented. Extreme programming, however, \nhas discarded this principle on the basis that designing for change is often wasted \neffort. It isn\u2019t worth taking time to add generality to a program to cope with change. \nOften the changes anticipated never materialize, or completely different change \nrequests may actually be made.\nOf course, in practice, changes will always have to be made to the code being devel-\noped. To make these changes easier, the developers of XP suggested that the code being \ndeveloped should be constantly refactored. Refactoring (Fowler et al. 1999) means that \nthe programming team look for possible improvements to the software and implements \nTask 1: Change dose of prescribed drug\nTask 2: Formulary selection\nTask 3: Dose checking\nDose checking is a safety precaution to check that\nthe doctor has not prescribed a dangerously small or\nlarge dose.\nUsing the formulary id for the generic drug name,\nlook up the formulary and retrieve the recommended\nmaximum and minimum dose.\nCheck the prescribed dose against the minimum and\nmaximum. If outside the range, issue an error\nmessage saying that the dose is too high or too low.\nIf within the range, enable the \u2018Con\ufb01rm\u2019 button.\nFigure 3.6 Examples of \ntask cards for prescribing \nmedication"}
{"query": "What is the principle of designing for change in traditional software engineering?", "response": "The principle of designing for change in traditional software engineering is to anticipate future changes to the software and design it in a way that these changes can be easily implemented.", "context": "3.2  \u25a0 Agile development techniques  79\nI am not convinced that XP on its own is a practical agile method for most com-\npanies, but its most significant contribution is probably the set of agile development \npractices that it introduced to the community. I discuss the most important of these \npractices in this section.\n \n3.2.1  User stories\nSoftware requirements always change. To handle these changes, agile methods do not \nhave a separate requirements engineering activity. Rather, they integrate requirements \nelicitation with development. To make this easier, the idea of \u201cuser stories\u201d was devel-\noped where a user story is a scenario of use that might be experienced by a system user.\nAs far as possible, the system customer works closely with the development team \nand discusses these scenarios with other team members. Together, they develop a \n\u201cstory card\u201d that briefly describes a story that encapsulates the customer needs. The \ndevelopment team then aims to implement that scenario in a future release of the \nsoftware. An example of a story card for the Mentcare system is shown in Figure 3.5. \nThis is a short description of a scenario for prescribing medication for a patient.\nUser stories may be used in planning system iterations. Once the story cards have \nbeen developed, the development team breaks these down into tasks (Figure 3.6) and \nestimates the effort and resources required for implementing each task. This usually \ninvolves discussions with the customer to refine the requirements. The customer \nthen prioritizes the stories for implementation, choosing those stories that can be \nKate is a doctor who wishes to prescribe medication for a patient attending a clinic.\nThe patient record is already displayed on her computer so she clicks on the\nmedication \ufb01eld and can select \u2018current medication\u2019, \u2018new medication\u2019 or \u2018formulary\u2019.\nIf she selects \u2018current medication\u2019, the system asks her to check the dose; If she\nwants to change the dose, she enters the new dose then con\ufb01rms the prescription.\nIf she chooses \u2018new medication\u2019, the system assumes that she knows which\nmedication to prescribe. She types the \ufb01rst few letters of the drug name. The system\ndisplays a list of possible drugs starting with these letters. She chooses the required\nmedication and the system responds by asking her to check that the medication\nselected is correct. She enters the dose then con\ufb01rms the prescription.\nIf she chooses \u2018formulary\u2019, the system displays a search box for the approved\nformulary. She can then search for the drug required. She selects a drug and is asked\nto check that the medication is correct. She enters the dose then con\ufb01rms the\nprescription.\nThe system always checks that the dose is within the approved range. If it isn\u2019t, Kate\nis asked to change the dose.\nAfter Kate has con\ufb01rmed the prescription, it will be displayed for checking. She either\nclicks \u2018OK\u2019 or \u2018Change\u2019. If she clicks \u2018OK\u2019, the prescription is recorded on the audit\ndatabase. If she clicks on \u2018Change\u2019, she reenters the \u2018Prescribing medication\u2019 process.\nPrescribing medication\nFigure 3.5 A  \n\u201cprescribing medication\u201d \nstory\n\n\n80  Chapter 3 \u25a0 Agile software development\nused immediately to deliver useful business support. The intention is to identify \n useful functionality that can be implemented in about two weeks, when the next \nrelease of the system is made available to the customer.\nOf course, as requirements change, the unimplemented stories change or may be \ndiscarded. If changes are required for a system that has already been delivered, new \nstory cards are developed and again, the customer decides whether these changes \nshould have priority over new functionality.\nThe idea of user stories is a powerful one\u2014people find it much easier to relate to \nthese stories than to a conventional requirements document or use cases. User stories can \nbe helpful in getting users involved in suggesting requirements during an initial prede-\nvelopment requirements elicitation activity. I discuss this in more detail in Chapter 4.\nThe principal problem with user stories is completeness. It is difficult to judge if \nenough user stories have been developed to cover all of the essential requirements \nof\u00a0a system. It is also difficult to judge if a single story gives a true picture of an \nactivity. Experienced users are often so familiar with their work that they leave \nthings out when describing it.\n \n3.2.2  Refactoring\nA fundamental precept of traditional software engineering is that you should design \nfor change. That is, you should anticipate future changes to the software and design \nit so that these changes can be easily implemented. Extreme programming, however, \nhas discarded this principle on the basis that designing for change is often wasted \neffort. It isn\u2019t worth taking time to add generality to a program to cope with change. \nOften the changes anticipated never materialize, or completely different change \nrequests may actually be made.\nOf course, in practice, changes will always have to be made to the code being devel-\noped. To make these changes easier, the developers of XP suggested that the code being \ndeveloped should be constantly refactored. Refactoring (Fowler et al. 1999) means that \nthe programming team look for possible improvements to the software and implements \nTask 1: Change dose of prescribed drug\nTask 2: Formulary selection\nTask 3: Dose checking\nDose checking is a safety precaution to check that\nthe doctor has not prescribed a dangerously small or\nlarge dose.\nUsing the formulary id for the generic drug name,\nlook up the formulary and retrieve the recommended\nmaximum and minimum dose.\nCheck the prescribed dose against the minimum and\nmaximum. If outside the range, issue an error\nmessage saying that the dose is too high or too low.\nIf within the range, enable the \u2018Con\ufb01rm\u2019 button.\nFigure 3.6 Examples of \ntask cards for prescribing \nmedication"}
{"query": "Why has extreme programming discarded the principle of designing for change?", "response": "Extreme programming (XP) has discarded the principle of designing for change because it believes that designing for change is often wasted effort. XP argues that it is not worth taking time to add generality to a program to cope with change because often the anticipated changes never materialize or completely different change requests may be made.", "context": "3.2  \u25a0 Agile development techniques  79\nI am not convinced that XP on its own is a practical agile method for most com-\npanies, but its most significant contribution is probably the set of agile development \npractices that it introduced to the community. I discuss the most important of these \npractices in this section.\n \n3.2.1  User stories\nSoftware requirements always change. To handle these changes, agile methods do not \nhave a separate requirements engineering activity. Rather, they integrate requirements \nelicitation with development. To make this easier, the idea of \u201cuser stories\u201d was devel-\noped where a user story is a scenario of use that might be experienced by a system user.\nAs far as possible, the system customer works closely with the development team \nand discusses these scenarios with other team members. Together, they develop a \n\u201cstory card\u201d that briefly describes a story that encapsulates the customer needs. The \ndevelopment team then aims to implement that scenario in a future release of the \nsoftware. An example of a story card for the Mentcare system is shown in Figure 3.5. \nThis is a short description of a scenario for prescribing medication for a patient.\nUser stories may be used in planning system iterations. Once the story cards have \nbeen developed, the development team breaks these down into tasks (Figure 3.6) and \nestimates the effort and resources required for implementing each task. This usually \ninvolves discussions with the customer to refine the requirements. The customer \nthen prioritizes the stories for implementation, choosing those stories that can be \nKate is a doctor who wishes to prescribe medication for a patient attending a clinic.\nThe patient record is already displayed on her computer so she clicks on the\nmedication \ufb01eld and can select \u2018current medication\u2019, \u2018new medication\u2019 or \u2018formulary\u2019.\nIf she selects \u2018current medication\u2019, the system asks her to check the dose; If she\nwants to change the dose, she enters the new dose then con\ufb01rms the prescription.\nIf she chooses \u2018new medication\u2019, the system assumes that she knows which\nmedication to prescribe. She types the \ufb01rst few letters of the drug name. The system\ndisplays a list of possible drugs starting with these letters. She chooses the required\nmedication and the system responds by asking her to check that the medication\nselected is correct. She enters the dose then con\ufb01rms the prescription.\nIf she chooses \u2018formulary\u2019, the system displays a search box for the approved\nformulary. She can then search for the drug required. She selects a drug and is asked\nto check that the medication is correct. She enters the dose then con\ufb01rms the\nprescription.\nThe system always checks that the dose is within the approved range. If it isn\u2019t, Kate\nis asked to change the dose.\nAfter Kate has con\ufb01rmed the prescription, it will be displayed for checking. She either\nclicks \u2018OK\u2019 or \u2018Change\u2019. If she clicks \u2018OK\u2019, the prescription is recorded on the audit\ndatabase. If she clicks on \u2018Change\u2019, she reenters the \u2018Prescribing medication\u2019 process.\nPrescribing medication\nFigure 3.5 A  \n\u201cprescribing medication\u201d \nstory\n\n\n80  Chapter 3 \u25a0 Agile software development\nused immediately to deliver useful business support. The intention is to identify \n useful functionality that can be implemented in about two weeks, when the next \nrelease of the system is made available to the customer.\nOf course, as requirements change, the unimplemented stories change or may be \ndiscarded. If changes are required for a system that has already been delivered, new \nstory cards are developed and again, the customer decides whether these changes \nshould have priority over new functionality.\nThe idea of user stories is a powerful one\u2014people find it much easier to relate to \nthese stories than to a conventional requirements document or use cases. User stories can \nbe helpful in getting users involved in suggesting requirements during an initial prede-\nvelopment requirements elicitation activity. I discuss this in more detail in Chapter 4.\nThe principal problem with user stories is completeness. It is difficult to judge if \nenough user stories have been developed to cover all of the essential requirements \nof\u00a0a system. It is also difficult to judge if a single story gives a true picture of an \nactivity. Experienced users are often so familiar with their work that they leave \nthings out when describing it.\n \n3.2.2  Refactoring\nA fundamental precept of traditional software engineering is that you should design \nfor change. That is, you should anticipate future changes to the software and design \nit so that these changes can be easily implemented. Extreme programming, however, \nhas discarded this principle on the basis that designing for change is often wasted \neffort. It isn\u2019t worth taking time to add generality to a program to cope with change. \nOften the changes anticipated never materialize, or completely different change \nrequests may actually be made.\nOf course, in practice, changes will always have to be made to the code being devel-\noped. To make these changes easier, the developers of XP suggested that the code being \ndeveloped should be constantly refactored. Refactoring (Fowler et al. 1999) means that \nthe programming team look for possible improvements to the software and implements \nTask 1: Change dose of prescribed drug\nTask 2: Formulary selection\nTask 3: Dose checking\nDose checking is a safety precaution to check that\nthe doctor has not prescribed a dangerously small or\nlarge dose.\nUsing the formulary id for the generic drug name,\nlook up the formulary and retrieve the recommended\nmaximum and minimum dose.\nCheck the prescribed dose against the minimum and\nmaximum. If outside the range, issue an error\nmessage saying that the dose is too high or too low.\nIf within the range, enable the \u2018Con\ufb01rm\u2019 button.\nFigure 3.6 Examples of \ntask cards for prescribing \nmedication"}
{"query": "What is the concept of refactoring in extreme programming?", "response": "Refactoring in extreme programming refers to the practice of constantly improving the code being developed. It involves the programming team looking for possible improvements to the software and implementing them. The goal of refactoring is to make the code more maintainable, readable, and efficient. This practice is based on the belief that it is better to continuously refactor the code rather than spending time upfront designing for potential future changes that may never occur.", "context": "3.2  \u25a0 Agile development techniques  79\nI am not convinced that XP on its own is a practical agile method for most com-\npanies, but its most significant contribution is probably the set of agile development \npractices that it introduced to the community. I discuss the most important of these \npractices in this section.\n \n3.2.1  User stories\nSoftware requirements always change. To handle these changes, agile methods do not \nhave a separate requirements engineering activity. Rather, they integrate requirements \nelicitation with development. To make this easier, the idea of \u201cuser stories\u201d was devel-\noped where a user story is a scenario of use that might be experienced by a system user.\nAs far as possible, the system customer works closely with the development team \nand discusses these scenarios with other team members. Together, they develop a \n\u201cstory card\u201d that briefly describes a story that encapsulates the customer needs. The \ndevelopment team then aims to implement that scenario in a future release of the \nsoftware. An example of a story card for the Mentcare system is shown in Figure 3.5. \nThis is a short description of a scenario for prescribing medication for a patient.\nUser stories may be used in planning system iterations. Once the story cards have \nbeen developed, the development team breaks these down into tasks (Figure 3.6) and \nestimates the effort and resources required for implementing each task. This usually \ninvolves discussions with the customer to refine the requirements. The customer \nthen prioritizes the stories for implementation, choosing those stories that can be \nKate is a doctor who wishes to prescribe medication for a patient attending a clinic.\nThe patient record is already displayed on her computer so she clicks on the\nmedication \ufb01eld and can select \u2018current medication\u2019, \u2018new medication\u2019 or \u2018formulary\u2019.\nIf she selects \u2018current medication\u2019, the system asks her to check the dose; If she\nwants to change the dose, she enters the new dose then con\ufb01rms the prescription.\nIf she chooses \u2018new medication\u2019, the system assumes that she knows which\nmedication to prescribe. She types the \ufb01rst few letters of the drug name. The system\ndisplays a list of possible drugs starting with these letters. She chooses the required\nmedication and the system responds by asking her to check that the medication\nselected is correct. She enters the dose then con\ufb01rms the prescription.\nIf she chooses \u2018formulary\u2019, the system displays a search box for the approved\nformulary. She can then search for the drug required. She selects a drug and is asked\nto check that the medication is correct. She enters the dose then con\ufb01rms the\nprescription.\nThe system always checks that the dose is within the approved range. If it isn\u2019t, Kate\nis asked to change the dose.\nAfter Kate has con\ufb01rmed the prescription, it will be displayed for checking. She either\nclicks \u2018OK\u2019 or \u2018Change\u2019. If she clicks \u2018OK\u2019, the prescription is recorded on the audit\ndatabase. If she clicks on \u2018Change\u2019, she reenters the \u2018Prescribing medication\u2019 process.\nPrescribing medication\nFigure 3.5 A  \n\u201cprescribing medication\u201d \nstory\n\n\n80  Chapter 3 \u25a0 Agile software development\nused immediately to deliver useful business support. The intention is to identify \n useful functionality that can be implemented in about two weeks, when the next \nrelease of the system is made available to the customer.\nOf course, as requirements change, the unimplemented stories change or may be \ndiscarded. If changes are required for a system that has already been delivered, new \nstory cards are developed and again, the customer decides whether these changes \nshould have priority over new functionality.\nThe idea of user stories is a powerful one\u2014people find it much easier to relate to \nthese stories than to a conventional requirements document or use cases. User stories can \nbe helpful in getting users involved in suggesting requirements during an initial prede-\nvelopment requirements elicitation activity. I discuss this in more detail in Chapter 4.\nThe principal problem with user stories is completeness. It is difficult to judge if \nenough user stories have been developed to cover all of the essential requirements \nof\u00a0a system. It is also difficult to judge if a single story gives a true picture of an \nactivity. Experienced users are often so familiar with their work that they leave \nthings out when describing it.\n \n3.2.2  Refactoring\nA fundamental precept of traditional software engineering is that you should design \nfor change. That is, you should anticipate future changes to the software and design \nit so that these changes can be easily implemented. Extreme programming, however, \nhas discarded this principle on the basis that designing for change is often wasted \neffort. It isn\u2019t worth taking time to add generality to a program to cope with change. \nOften the changes anticipated never materialize, or completely different change \nrequests may actually be made.\nOf course, in practice, changes will always have to be made to the code being devel-\noped. To make these changes easier, the developers of XP suggested that the code being \ndeveloped should be constantly refactored. Refactoring (Fowler et al. 1999) means that \nthe programming team look for possible improvements to the software and implements \nTask 1: Change dose of prescribed drug\nTask 2: Formulary selection\nTask 3: Dose checking\nDose checking is a safety precaution to check that\nthe doctor has not prescribed a dangerously small or\nlarge dose.\nUsing the formulary id for the generic drug name,\nlook up the formulary and retrieve the recommended\nmaximum and minimum dose.\nCheck the prescribed dose against the minimum and\nmaximum. If outside the range, issue an error\nmessage saying that the dose is too high or too low.\nIf within the range, enable the \u2018Con\ufb01rm\u2019 button.\nFigure 3.6 Examples of \ntask cards for prescribing \nmedication"}
{"query": "How does refactoring make changes easier in extreme programming?", "response": "Refactoring makes changes easier in extreme programming by constantly looking for possible improvements to the software and implementing them. This means that the code being developed is continuously reviewed and modified to make it more efficient, maintainable, and adaptable to future changes. By regularly refactoring the code, developers can ensure that any changes or updates can be easily implemented without causing disruptions or introducing errors into the system. This approach allows for a more flexible and responsive development process.", "context": "3.2  \u25a0 Agile development techniques  79\nI am not convinced that XP on its own is a practical agile method for most com-\npanies, but its most significant contribution is probably the set of agile development \npractices that it introduced to the community. I discuss the most important of these \npractices in this section.\n \n3.2.1  User stories\nSoftware requirements always change. To handle these changes, agile methods do not \nhave a separate requirements engineering activity. Rather, they integrate requirements \nelicitation with development. To make this easier, the idea of \u201cuser stories\u201d was devel-\noped where a user story is a scenario of use that might be experienced by a system user.\nAs far as possible, the system customer works closely with the development team \nand discusses these scenarios with other team members. Together, they develop a \n\u201cstory card\u201d that briefly describes a story that encapsulates the customer needs. The \ndevelopment team then aims to implement that scenario in a future release of the \nsoftware. An example of a story card for the Mentcare system is shown in Figure 3.5. \nThis is a short description of a scenario for prescribing medication for a patient.\nUser stories may be used in planning system iterations. Once the story cards have \nbeen developed, the development team breaks these down into tasks (Figure 3.6) and \nestimates the effort and resources required for implementing each task. This usually \ninvolves discussions with the customer to refine the requirements. The customer \nthen prioritizes the stories for implementation, choosing those stories that can be \nKate is a doctor who wishes to prescribe medication for a patient attending a clinic.\nThe patient record is already displayed on her computer so she clicks on the\nmedication \ufb01eld and can select \u2018current medication\u2019, \u2018new medication\u2019 or \u2018formulary\u2019.\nIf she selects \u2018current medication\u2019, the system asks her to check the dose; If she\nwants to change the dose, she enters the new dose then con\ufb01rms the prescription.\nIf she chooses \u2018new medication\u2019, the system assumes that she knows which\nmedication to prescribe. She types the \ufb01rst few letters of the drug name. The system\ndisplays a list of possible drugs starting with these letters. She chooses the required\nmedication and the system responds by asking her to check that the medication\nselected is correct. She enters the dose then con\ufb01rms the prescription.\nIf she chooses \u2018formulary\u2019, the system displays a search box for the approved\nformulary. She can then search for the drug required. She selects a drug and is asked\nto check that the medication is correct. She enters the dose then con\ufb01rms the\nprescription.\nThe system always checks that the dose is within the approved range. If it isn\u2019t, Kate\nis asked to change the dose.\nAfter Kate has con\ufb01rmed the prescription, it will be displayed for checking. She either\nclicks \u2018OK\u2019 or \u2018Change\u2019. If she clicks \u2018OK\u2019, the prescription is recorded on the audit\ndatabase. If she clicks on \u2018Change\u2019, she reenters the \u2018Prescribing medication\u2019 process.\nPrescribing medication\nFigure 3.5 A  \n\u201cprescribing medication\u201d \nstory\n\n\n80  Chapter 3 \u25a0 Agile software development\nused immediately to deliver useful business support. The intention is to identify \n useful functionality that can be implemented in about two weeks, when the next \nrelease of the system is made available to the customer.\nOf course, as requirements change, the unimplemented stories change or may be \ndiscarded. If changes are required for a system that has already been delivered, new \nstory cards are developed and again, the customer decides whether these changes \nshould have priority over new functionality.\nThe idea of user stories is a powerful one\u2014people find it much easier to relate to \nthese stories than to a conventional requirements document or use cases. User stories can \nbe helpful in getting users involved in suggesting requirements during an initial prede-\nvelopment requirements elicitation activity. I discuss this in more detail in Chapter 4.\nThe principal problem with user stories is completeness. It is difficult to judge if \nenough user stories have been developed to cover all of the essential requirements \nof\u00a0a system. It is also difficult to judge if a single story gives a true picture of an \nactivity. Experienced users are often so familiar with their work that they leave \nthings out when describing it.\n \n3.2.2  Refactoring\nA fundamental precept of traditional software engineering is that you should design \nfor change. That is, you should anticipate future changes to the software and design \nit so that these changes can be easily implemented. Extreme programming, however, \nhas discarded this principle on the basis that designing for change is often wasted \neffort. It isn\u2019t worth taking time to add generality to a program to cope with change. \nOften the changes anticipated never materialize, or completely different change \nrequests may actually be made.\nOf course, in practice, changes will always have to be made to the code being devel-\noped. To make these changes easier, the developers of XP suggested that the code being \ndeveloped should be constantly refactored. Refactoring (Fowler et al. 1999) means that \nthe programming team look for possible improvements to the software and implements \nTask 1: Change dose of prescribed drug\nTask 2: Formulary selection\nTask 3: Dose checking\nDose checking is a safety precaution to check that\nthe doctor has not prescribed a dangerously small or\nlarge dose.\nUsing the formulary id for the generic drug name,\nlook up the formulary and retrieve the recommended\nmaximum and minimum dose.\nCheck the prescribed dose against the minimum and\nmaximum. If outside the range, issue an error\nmessage saying that the dose is too high or too low.\nIf within the range, enable the \u2018Con\ufb01rm\u2019 button.\nFigure 3.6 Examples of \ntask cards for prescribing \nmedication"}
{"query": "Why is it not worth taking time to add generality to a program to cope with change in extreme programming?", "response": "In extreme programming (XP), it is not considered worth taking time to add generality to a program to cope with change because the changes anticipated may never actually happen or completely different change requests may be made. XP suggests that instead of designing for change, the code should be constantly refactored to make future changes easier to implement. This approach focuses on making improvements to the software as it is being developed, rather than trying to anticipate and accommodate all possible future changes.", "context": "3.2  \u25a0 Agile development techniques  79\nI am not convinced that XP on its own is a practical agile method for most com-\npanies, but its most significant contribution is probably the set of agile development \npractices that it introduced to the community. I discuss the most important of these \npractices in this section.\n \n3.2.1  User stories\nSoftware requirements always change. To handle these changes, agile methods do not \nhave a separate requirements engineering activity. Rather, they integrate requirements \nelicitation with development. To make this easier, the idea of \u201cuser stories\u201d was devel-\noped where a user story is a scenario of use that might be experienced by a system user.\nAs far as possible, the system customer works closely with the development team \nand discusses these scenarios with other team members. Together, they develop a \n\u201cstory card\u201d that briefly describes a story that encapsulates the customer needs. The \ndevelopment team then aims to implement that scenario in a future release of the \nsoftware. An example of a story card for the Mentcare system is shown in Figure 3.5. \nThis is a short description of a scenario for prescribing medication for a patient.\nUser stories may be used in planning system iterations. Once the story cards have \nbeen developed, the development team breaks these down into tasks (Figure 3.6) and \nestimates the effort and resources required for implementing each task. This usually \ninvolves discussions with the customer to refine the requirements. The customer \nthen prioritizes the stories for implementation, choosing those stories that can be \nKate is a doctor who wishes to prescribe medication for a patient attending a clinic.\nThe patient record is already displayed on her computer so she clicks on the\nmedication \ufb01eld and can select \u2018current medication\u2019, \u2018new medication\u2019 or \u2018formulary\u2019.\nIf she selects \u2018current medication\u2019, the system asks her to check the dose; If she\nwants to change the dose, she enters the new dose then con\ufb01rms the prescription.\nIf she chooses \u2018new medication\u2019, the system assumes that she knows which\nmedication to prescribe. She types the \ufb01rst few letters of the drug name. The system\ndisplays a list of possible drugs starting with these letters. She chooses the required\nmedication and the system responds by asking her to check that the medication\nselected is correct. She enters the dose then con\ufb01rms the prescription.\nIf she chooses \u2018formulary\u2019, the system displays a search box for the approved\nformulary. She can then search for the drug required. She selects a drug and is asked\nto check that the medication is correct. She enters the dose then con\ufb01rms the\nprescription.\nThe system always checks that the dose is within the approved range. If it isn\u2019t, Kate\nis asked to change the dose.\nAfter Kate has con\ufb01rmed the prescription, it will be displayed for checking. She either\nclicks \u2018OK\u2019 or \u2018Change\u2019. If she clicks \u2018OK\u2019, the prescription is recorded on the audit\ndatabase. If she clicks on \u2018Change\u2019, she reenters the \u2018Prescribing medication\u2019 process.\nPrescribing medication\nFigure 3.5 A  \n\u201cprescribing medication\u201d \nstory\n\n\n80  Chapter 3 \u25a0 Agile software development\nused immediately to deliver useful business support. The intention is to identify \n useful functionality that can be implemented in about two weeks, when the next \nrelease of the system is made available to the customer.\nOf course, as requirements change, the unimplemented stories change or may be \ndiscarded. If changes are required for a system that has already been delivered, new \nstory cards are developed and again, the customer decides whether these changes \nshould have priority over new functionality.\nThe idea of user stories is a powerful one\u2014people find it much easier to relate to \nthese stories than to a conventional requirements document or use cases. User stories can \nbe helpful in getting users involved in suggesting requirements during an initial prede-\nvelopment requirements elicitation activity. I discuss this in more detail in Chapter 4.\nThe principal problem with user stories is completeness. It is difficult to judge if \nenough user stories have been developed to cover all of the essential requirements \nof\u00a0a system. It is also difficult to judge if a single story gives a true picture of an \nactivity. Experienced users are often so familiar with their work that they leave \nthings out when describing it.\n \n3.2.2  Refactoring\nA fundamental precept of traditional software engineering is that you should design \nfor change. That is, you should anticipate future changes to the software and design \nit so that these changes can be easily implemented. Extreme programming, however, \nhas discarded this principle on the basis that designing for change is often wasted \neffort. It isn\u2019t worth taking time to add generality to a program to cope with change. \nOften the changes anticipated never materialize, or completely different change \nrequests may actually be made.\nOf course, in practice, changes will always have to be made to the code being devel-\noped. To make these changes easier, the developers of XP suggested that the code being \ndeveloped should be constantly refactored. Refactoring (Fowler et al. 1999) means that \nthe programming team look for possible improvements to the software and implements \nTask 1: Change dose of prescribed drug\nTask 2: Formulary selection\nTask 3: Dose checking\nDose checking is a safety precaution to check that\nthe doctor has not prescribed a dangerously small or\nlarge dose.\nUsing the formulary id for the generic drug name,\nlook up the formulary and retrieve the recommended\nmaximum and minimum dose.\nCheck the prescribed dose against the minimum and\nmaximum. If outside the range, issue an error\nmessage saying that the dose is too high or too low.\nIf within the range, enable the \u2018Con\ufb01rm\u2019 button.\nFigure 3.6 Examples of \ntask cards for prescribing \nmedication"}
{"query": "What happens when the changes anticipated in traditional software engineering never materialize?", "response": "The developers of Extreme Programming (XP) believe that designing for change in traditional software engineering is often wasted effort because the changes anticipated may never materialize or completely different change requests may be made. In XP, the code being developed is constantly refactored to make future changes easier. Refactoring involves looking for possible improvements to the software and implementing them. So, when the changes anticipated in traditional software engineering never materialize, the code in XP is still constantly refactored to improve the software.", "context": "3.2  \u25a0 Agile development techniques  79\nI am not convinced that XP on its own is a practical agile method for most com-\npanies, but its most significant contribution is probably the set of agile development \npractices that it introduced to the community. I discuss the most important of these \npractices in this section.\n \n3.2.1  User stories\nSoftware requirements always change. To handle these changes, agile methods do not \nhave a separate requirements engineering activity. Rather, they integrate requirements \nelicitation with development. To make this easier, the idea of \u201cuser stories\u201d was devel-\noped where a user story is a scenario of use that might be experienced by a system user.\nAs far as possible, the system customer works closely with the development team \nand discusses these scenarios with other team members. Together, they develop a \n\u201cstory card\u201d that briefly describes a story that encapsulates the customer needs. The \ndevelopment team then aims to implement that scenario in a future release of the \nsoftware. An example of a story card for the Mentcare system is shown in Figure 3.5. \nThis is a short description of a scenario for prescribing medication for a patient.\nUser stories may be used in planning system iterations. Once the story cards have \nbeen developed, the development team breaks these down into tasks (Figure 3.6) and \nestimates the effort and resources required for implementing each task. This usually \ninvolves discussions with the customer to refine the requirements. The customer \nthen prioritizes the stories for implementation, choosing those stories that can be \nKate is a doctor who wishes to prescribe medication for a patient attending a clinic.\nThe patient record is already displayed on her computer so she clicks on the\nmedication \ufb01eld and can select \u2018current medication\u2019, \u2018new medication\u2019 or \u2018formulary\u2019.\nIf she selects \u2018current medication\u2019, the system asks her to check the dose; If she\nwants to change the dose, she enters the new dose then con\ufb01rms the prescription.\nIf she chooses \u2018new medication\u2019, the system assumes that she knows which\nmedication to prescribe. She types the \ufb01rst few letters of the drug name. The system\ndisplays a list of possible drugs starting with these letters. She chooses the required\nmedication and the system responds by asking her to check that the medication\nselected is correct. She enters the dose then con\ufb01rms the prescription.\nIf she chooses \u2018formulary\u2019, the system displays a search box for the approved\nformulary. She can then search for the drug required. She selects a drug and is asked\nto check that the medication is correct. She enters the dose then con\ufb01rms the\nprescription.\nThe system always checks that the dose is within the approved range. If it isn\u2019t, Kate\nis asked to change the dose.\nAfter Kate has con\ufb01rmed the prescription, it will be displayed for checking. She either\nclicks \u2018OK\u2019 or \u2018Change\u2019. If she clicks \u2018OK\u2019, the prescription is recorded on the audit\ndatabase. If she clicks on \u2018Change\u2019, she reenters the \u2018Prescribing medication\u2019 process.\nPrescribing medication\nFigure 3.5 A  \n\u201cprescribing medication\u201d \nstory\n\n\n80  Chapter 3 \u25a0 Agile software development\nused immediately to deliver useful business support. The intention is to identify \n useful functionality that can be implemented in about two weeks, when the next \nrelease of the system is made available to the customer.\nOf course, as requirements change, the unimplemented stories change or may be \ndiscarded. If changes are required for a system that has already been delivered, new \nstory cards are developed and again, the customer decides whether these changes \nshould have priority over new functionality.\nThe idea of user stories is a powerful one\u2014people find it much easier to relate to \nthese stories than to a conventional requirements document or use cases. User stories can \nbe helpful in getting users involved in suggesting requirements during an initial prede-\nvelopment requirements elicitation activity. I discuss this in more detail in Chapter 4.\nThe principal problem with user stories is completeness. It is difficult to judge if \nenough user stories have been developed to cover all of the essential requirements \nof\u00a0a system. It is also difficult to judge if a single story gives a true picture of an \nactivity. Experienced users are often so familiar with their work that they leave \nthings out when describing it.\n \n3.2.2  Refactoring\nA fundamental precept of traditional software engineering is that you should design \nfor change. That is, you should anticipate future changes to the software and design \nit so that these changes can be easily implemented. Extreme programming, however, \nhas discarded this principle on the basis that designing for change is often wasted \neffort. It isn\u2019t worth taking time to add generality to a program to cope with change. \nOften the changes anticipated never materialize, or completely different change \nrequests may actually be made.\nOf course, in practice, changes will always have to be made to the code being devel-\noped. To make these changes easier, the developers of XP suggested that the code being \ndeveloped should be constantly refactored. Refactoring (Fowler et al. 1999) means that \nthe programming team look for possible improvements to the software and implements \nTask 1: Change dose of prescribed drug\nTask 2: Formulary selection\nTask 3: Dose checking\nDose checking is a safety precaution to check that\nthe doctor has not prescribed a dangerously small or\nlarge dose.\nUsing the formulary id for the generic drug name,\nlook up the formulary and retrieve the recommended\nmaximum and minimum dose.\nCheck the prescribed dose against the minimum and\nmaximum. If outside the range, issue an error\nmessage saying that the dose is too high or too low.\nIf within the range, enable the \u2018Con\ufb01rm\u2019 button.\nFigure 3.6 Examples of \ntask cards for prescribing \nmedication"}
{"query": "What does the programming team do in the process of refactoring?", "response": "The programming team looks for possible improvements to the software and implements them.", "context": "3.2  \u25a0 Agile development techniques  79\nI am not convinced that XP on its own is a practical agile method for most com-\npanies, but its most significant contribution is probably the set of agile development \npractices that it introduced to the community. I discuss the most important of these \npractices in this section.\n \n3.2.1  User stories\nSoftware requirements always change. To handle these changes, agile methods do not \nhave a separate requirements engineering activity. Rather, they integrate requirements \nelicitation with development. To make this easier, the idea of \u201cuser stories\u201d was devel-\noped where a user story is a scenario of use that might be experienced by a system user.\nAs far as possible, the system customer works closely with the development team \nand discusses these scenarios with other team members. Together, they develop a \n\u201cstory card\u201d that briefly describes a story that encapsulates the customer needs. The \ndevelopment team then aims to implement that scenario in a future release of the \nsoftware. An example of a story card for the Mentcare system is shown in Figure 3.5. \nThis is a short description of a scenario for prescribing medication for a patient.\nUser stories may be used in planning system iterations. Once the story cards have \nbeen developed, the development team breaks these down into tasks (Figure 3.6) and \nestimates the effort and resources required for implementing each task. This usually \ninvolves discussions with the customer to refine the requirements. The customer \nthen prioritizes the stories for implementation, choosing those stories that can be \nKate is a doctor who wishes to prescribe medication for a patient attending a clinic.\nThe patient record is already displayed on her computer so she clicks on the\nmedication \ufb01eld and can select \u2018current medication\u2019, \u2018new medication\u2019 or \u2018formulary\u2019.\nIf she selects \u2018current medication\u2019, the system asks her to check the dose; If she\nwants to change the dose, she enters the new dose then con\ufb01rms the prescription.\nIf she chooses \u2018new medication\u2019, the system assumes that she knows which\nmedication to prescribe. She types the \ufb01rst few letters of the drug name. The system\ndisplays a list of possible drugs starting with these letters. She chooses the required\nmedication and the system responds by asking her to check that the medication\nselected is correct. She enters the dose then con\ufb01rms the prescription.\nIf she chooses \u2018formulary\u2019, the system displays a search box for the approved\nformulary. She can then search for the drug required. She selects a drug and is asked\nto check that the medication is correct. She enters the dose then con\ufb01rms the\nprescription.\nThe system always checks that the dose is within the approved range. If it isn\u2019t, Kate\nis asked to change the dose.\nAfter Kate has con\ufb01rmed the prescription, it will be displayed for checking. She either\nclicks \u2018OK\u2019 or \u2018Change\u2019. If she clicks \u2018OK\u2019, the prescription is recorded on the audit\ndatabase. If she clicks on \u2018Change\u2019, she reenters the \u2018Prescribing medication\u2019 process.\nPrescribing medication\nFigure 3.5 A  \n\u201cprescribing medication\u201d \nstory\n\n\n80  Chapter 3 \u25a0 Agile software development\nused immediately to deliver useful business support. The intention is to identify \n useful functionality that can be implemented in about two weeks, when the next \nrelease of the system is made available to the customer.\nOf course, as requirements change, the unimplemented stories change or may be \ndiscarded. If changes are required for a system that has already been delivered, new \nstory cards are developed and again, the customer decides whether these changes \nshould have priority over new functionality.\nThe idea of user stories is a powerful one\u2014people find it much easier to relate to \nthese stories than to a conventional requirements document or use cases. User stories can \nbe helpful in getting users involved in suggesting requirements during an initial prede-\nvelopment requirements elicitation activity. I discuss this in more detail in Chapter 4.\nThe principal problem with user stories is completeness. It is difficult to judge if \nenough user stories have been developed to cover all of the essential requirements \nof\u00a0a system. It is also difficult to judge if a single story gives a true picture of an \nactivity. Experienced users are often so familiar with their work that they leave \nthings out when describing it.\n \n3.2.2  Refactoring\nA fundamental precept of traditional software engineering is that you should design \nfor change. That is, you should anticipate future changes to the software and design \nit so that these changes can be easily implemented. Extreme programming, however, \nhas discarded this principle on the basis that designing for change is often wasted \neffort. It isn\u2019t worth taking time to add generality to a program to cope with change. \nOften the changes anticipated never materialize, or completely different change \nrequests may actually be made.\nOf course, in practice, changes will always have to be made to the code being devel-\noped. To make these changes easier, the developers of XP suggested that the code being \ndeveloped should be constantly refactored. Refactoring (Fowler et al. 1999) means that \nthe programming team look for possible improvements to the software and implements \nTask 1: Change dose of prescribed drug\nTask 2: Formulary selection\nTask 3: Dose checking\nDose checking is a safety precaution to check that\nthe doctor has not prescribed a dangerously small or\nlarge dose.\nUsing the formulary id for the generic drug name,\nlook up the formulary and retrieve the recommended\nmaximum and minimum dose.\nCheck the prescribed dose against the minimum and\nmaximum. If outside the range, issue an error\nmessage saying that the dose is too high or too low.\nIf within the range, enable the \u2018Con\ufb01rm\u2019 button.\nFigure 3.6 Examples of \ntask cards for prescribing \nmedication"}
{"query": "How are tasks broken down in the agile development process?", "response": "Tasks are broken down in the agile development process by first developing user stories. Once the user stories have been developed, the development team breaks them down into tasks. The team then estimates the effort and resources required for implementing each task. This usually involves discussions with the customer to refine the requirements. The tasks are then prioritized by the customer for implementation, choosing those tasks that can be used immediately to deliver useful business support. The intention is to identify useful functionality that can be implemented in about two weeks, when the next release of the system is made available to the customer.", "context": "3.2  \u25a0 Agile development techniques  79\nI am not convinced that XP on its own is a practical agile method for most com-\npanies, but its most significant contribution is probably the set of agile development \npractices that it introduced to the community. I discuss the most important of these \npractices in this section.\n \n3.2.1  User stories\nSoftware requirements always change. To handle these changes, agile methods do not \nhave a separate requirements engineering activity. Rather, they integrate requirements \nelicitation with development. To make this easier, the idea of \u201cuser stories\u201d was devel-\noped where a user story is a scenario of use that might be experienced by a system user.\nAs far as possible, the system customer works closely with the development team \nand discusses these scenarios with other team members. Together, they develop a \n\u201cstory card\u201d that briefly describes a story that encapsulates the customer needs. The \ndevelopment team then aims to implement that scenario in a future release of the \nsoftware. An example of a story card for the Mentcare system is shown in Figure 3.5. \nThis is a short description of a scenario for prescribing medication for a patient.\nUser stories may be used in planning system iterations. Once the story cards have \nbeen developed, the development team breaks these down into tasks (Figure 3.6) and \nestimates the effort and resources required for implementing each task. This usually \ninvolves discussions with the customer to refine the requirements. The customer \nthen prioritizes the stories for implementation, choosing those stories that can be \nKate is a doctor who wishes to prescribe medication for a patient attending a clinic.\nThe patient record is already displayed on her computer so she clicks on the\nmedication \ufb01eld and can select \u2018current medication\u2019, \u2018new medication\u2019 or \u2018formulary\u2019.\nIf she selects \u2018current medication\u2019, the system asks her to check the dose; If she\nwants to change the dose, she enters the new dose then con\ufb01rms the prescription.\nIf she chooses \u2018new medication\u2019, the system assumes that she knows which\nmedication to prescribe. She types the \ufb01rst few letters of the drug name. The system\ndisplays a list of possible drugs starting with these letters. She chooses the required\nmedication and the system responds by asking her to check that the medication\nselected is correct. She enters the dose then con\ufb01rms the prescription.\nIf she chooses \u2018formulary\u2019, the system displays a search box for the approved\nformulary. She can then search for the drug required. She selects a drug and is asked\nto check that the medication is correct. She enters the dose then con\ufb01rms the\nprescription.\nThe system always checks that the dose is within the approved range. If it isn\u2019t, Kate\nis asked to change the dose.\nAfter Kate has con\ufb01rmed the prescription, it will be displayed for checking. She either\nclicks \u2018OK\u2019 or \u2018Change\u2019. If she clicks \u2018OK\u2019, the prescription is recorded on the audit\ndatabase. If she clicks on \u2018Change\u2019, she reenters the \u2018Prescribing medication\u2019 process.\nPrescribing medication\nFigure 3.5 A  \n\u201cprescribing medication\u201d \nstory\n\n\n80  Chapter 3 \u25a0 Agile software development\nused immediately to deliver useful business support. The intention is to identify \n useful functionality that can be implemented in about two weeks, when the next \nrelease of the system is made available to the customer.\nOf course, as requirements change, the unimplemented stories change or may be \ndiscarded. If changes are required for a system that has already been delivered, new \nstory cards are developed and again, the customer decides whether these changes \nshould have priority over new functionality.\nThe idea of user stories is a powerful one\u2014people find it much easier to relate to \nthese stories than to a conventional requirements document or use cases. User stories can \nbe helpful in getting users involved in suggesting requirements during an initial prede-\nvelopment requirements elicitation activity. I discuss this in more detail in Chapter 4.\nThe principal problem with user stories is completeness. It is difficult to judge if \nenough user stories have been developed to cover all of the essential requirements \nof\u00a0a system. It is also difficult to judge if a single story gives a true picture of an \nactivity. Experienced users are often so familiar with their work that they leave \nthings out when describing it.\n \n3.2.2  Refactoring\nA fundamental precept of traditional software engineering is that you should design \nfor change. That is, you should anticipate future changes to the software and design \nit so that these changes can be easily implemented. Extreme programming, however, \nhas discarded this principle on the basis that designing for change is often wasted \neffort. It isn\u2019t worth taking time to add generality to a program to cope with change. \nOften the changes anticipated never materialize, or completely different change \nrequests may actually be made.\nOf course, in practice, changes will always have to be made to the code being devel-\noped. To make these changes easier, the developers of XP suggested that the code being \ndeveloped should be constantly refactored. Refactoring (Fowler et al. 1999) means that \nthe programming team look for possible improvements to the software and implements \nTask 1: Change dose of prescribed drug\nTask 2: Formulary selection\nTask 3: Dose checking\nDose checking is a safety precaution to check that\nthe doctor has not prescribed a dangerously small or\nlarge dose.\nUsing the formulary id for the generic drug name,\nlook up the formulary and retrieve the recommended\nmaximum and minimum dose.\nCheck the prescribed dose against the minimum and\nmaximum. If outside the range, issue an error\nmessage saying that the dose is too high or too low.\nIf within the range, enable the \u2018Con\ufb01rm\u2019 button.\nFigure 3.6 Examples of \ntask cards for prescribing \nmedication"}
{"query": "How is the effort and resources required for implementing each task estimated in agile development?", "response": "The effort and resources required for implementing each task in agile development are estimated through discussions with the customer to refine the requirements. The development team breaks down the user stories into tasks and then estimates the effort and resources needed for each task. This estimation process usually involves collaboration between the development team and the customer to ensure that the requirements are well understood and prioritized.", "context": "3.2  \u25a0 Agile development techniques  79\nI am not convinced that XP on its own is a practical agile method for most com-\npanies, but its most significant contribution is probably the set of agile development \npractices that it introduced to the community. I discuss the most important of these \npractices in this section.\n \n3.2.1  User stories\nSoftware requirements always change. To handle these changes, agile methods do not \nhave a separate requirements engineering activity. Rather, they integrate requirements \nelicitation with development. To make this easier, the idea of \u201cuser stories\u201d was devel-\noped where a user story is a scenario of use that might be experienced by a system user.\nAs far as possible, the system customer works closely with the development team \nand discusses these scenarios with other team members. Together, they develop a \n\u201cstory card\u201d that briefly describes a story that encapsulates the customer needs. The \ndevelopment team then aims to implement that scenario in a future release of the \nsoftware. An example of a story card for the Mentcare system is shown in Figure 3.5. \nThis is a short description of a scenario for prescribing medication for a patient.\nUser stories may be used in planning system iterations. Once the story cards have \nbeen developed, the development team breaks these down into tasks (Figure 3.6) and \nestimates the effort and resources required for implementing each task. This usually \ninvolves discussions with the customer to refine the requirements. The customer \nthen prioritizes the stories for implementation, choosing those stories that can be \nKate is a doctor who wishes to prescribe medication for a patient attending a clinic.\nThe patient record is already displayed on her computer so she clicks on the\nmedication \ufb01eld and can select \u2018current medication\u2019, \u2018new medication\u2019 or \u2018formulary\u2019.\nIf she selects \u2018current medication\u2019, the system asks her to check the dose; If she\nwants to change the dose, she enters the new dose then con\ufb01rms the prescription.\nIf she chooses \u2018new medication\u2019, the system assumes that she knows which\nmedication to prescribe. She types the \ufb01rst few letters of the drug name. The system\ndisplays a list of possible drugs starting with these letters. She chooses the required\nmedication and the system responds by asking her to check that the medication\nselected is correct. She enters the dose then con\ufb01rms the prescription.\nIf she chooses \u2018formulary\u2019, the system displays a search box for the approved\nformulary. She can then search for the drug required. She selects a drug and is asked\nto check that the medication is correct. She enters the dose then con\ufb01rms the\nprescription.\nThe system always checks that the dose is within the approved range. If it isn\u2019t, Kate\nis asked to change the dose.\nAfter Kate has con\ufb01rmed the prescription, it will be displayed for checking. She either\nclicks \u2018OK\u2019 or \u2018Change\u2019. If she clicks \u2018OK\u2019, the prescription is recorded on the audit\ndatabase. If she clicks on \u2018Change\u2019, she reenters the \u2018Prescribing medication\u2019 process.\nPrescribing medication\nFigure 3.5 A  \n\u201cprescribing medication\u201d \nstory\n\n\n80  Chapter 3 \u25a0 Agile software development\nused immediately to deliver useful business support. The intention is to identify \n useful functionality that can be implemented in about two weeks, when the next \nrelease of the system is made available to the customer.\nOf course, as requirements change, the unimplemented stories change or may be \ndiscarded. If changes are required for a system that has already been delivered, new \nstory cards are developed and again, the customer decides whether these changes \nshould have priority over new functionality.\nThe idea of user stories is a powerful one\u2014people find it much easier to relate to \nthese stories than to a conventional requirements document or use cases. User stories can \nbe helpful in getting users involved in suggesting requirements during an initial prede-\nvelopment requirements elicitation activity. I discuss this in more detail in Chapter 4.\nThe principal problem with user stories is completeness. It is difficult to judge if \nenough user stories have been developed to cover all of the essential requirements \nof\u00a0a system. It is also difficult to judge if a single story gives a true picture of an \nactivity. Experienced users are often so familiar with their work that they leave \nthings out when describing it.\n \n3.2.2  Refactoring\nA fundamental precept of traditional software engineering is that you should design \nfor change. That is, you should anticipate future changes to the software and design \nit so that these changes can be easily implemented. Extreme programming, however, \nhas discarded this principle on the basis that designing for change is often wasted \neffort. It isn\u2019t worth taking time to add generality to a program to cope with change. \nOften the changes anticipated never materialize, or completely different change \nrequests may actually be made.\nOf course, in practice, changes will always have to be made to the code being devel-\noped. To make these changes easier, the developers of XP suggested that the code being \ndeveloped should be constantly refactored. Refactoring (Fowler et al. 1999) means that \nthe programming team look for possible improvements to the software and implements \nTask 1: Change dose of prescribed drug\nTask 2: Formulary selection\nTask 3: Dose checking\nDose checking is a safety precaution to check that\nthe doctor has not prescribed a dangerously small or\nlarge dose.\nUsing the formulary id for the generic drug name,\nlook up the formulary and retrieve the recommended\nmaximum and minimum dose.\nCheck the prescribed dose against the minimum and\nmaximum. If outside the range, issue an error\nmessage saying that the dose is too high or too low.\nIf within the range, enable the \u2018Con\ufb01rm\u2019 button.\nFigure 3.6 Examples of \ntask cards for prescribing \nmedication"}
{"query": "How does the system customer contribute to the development process in agile methods?", "response": "The system customer in agile methods contributes to the development process by working closely with the development team and discussing user scenarios with other team members. Together, they develop \"story cards\" that describe the customer needs in the form of user stories. The customer also prioritizes the stories for implementation and chooses those stories that can be used immediately to deliver useful business support. Additionally, the customer may suggest changes or new functionality based on evolving requirements.", "context": "3.2  \u25a0 Agile development techniques  79\nI am not convinced that XP on its own is a practical agile method for most com-\npanies, but its most significant contribution is probably the set of agile development \npractices that it introduced to the community. I discuss the most important of these \npractices in this section.\n \n3.2.1  User stories\nSoftware requirements always change. To handle these changes, agile methods do not \nhave a separate requirements engineering activity. Rather, they integrate requirements \nelicitation with development. To make this easier, the idea of \u201cuser stories\u201d was devel-\noped where a user story is a scenario of use that might be experienced by a system user.\nAs far as possible, the system customer works closely with the development team \nand discusses these scenarios with other team members. Together, they develop a \n\u201cstory card\u201d that briefly describes a story that encapsulates the customer needs. The \ndevelopment team then aims to implement that scenario in a future release of the \nsoftware. An example of a story card for the Mentcare system is shown in Figure 3.5. \nThis is a short description of a scenario for prescribing medication for a patient.\nUser stories may be used in planning system iterations. Once the story cards have \nbeen developed, the development team breaks these down into tasks (Figure 3.6) and \nestimates the effort and resources required for implementing each task. This usually \ninvolves discussions with the customer to refine the requirements. The customer \nthen prioritizes the stories for implementation, choosing those stories that can be \nKate is a doctor who wishes to prescribe medication for a patient attending a clinic.\nThe patient record is already displayed on her computer so she clicks on the\nmedication \ufb01eld and can select \u2018current medication\u2019, \u2018new medication\u2019 or \u2018formulary\u2019.\nIf she selects \u2018current medication\u2019, the system asks her to check the dose; If she\nwants to change the dose, she enters the new dose then con\ufb01rms the prescription.\nIf she chooses \u2018new medication\u2019, the system assumes that she knows which\nmedication to prescribe. She types the \ufb01rst few letters of the drug name. The system\ndisplays a list of possible drugs starting with these letters. She chooses the required\nmedication and the system responds by asking her to check that the medication\nselected is correct. She enters the dose then con\ufb01rms the prescription.\nIf she chooses \u2018formulary\u2019, the system displays a search box for the approved\nformulary. She can then search for the drug required. She selects a drug and is asked\nto check that the medication is correct. She enters the dose then con\ufb01rms the\nprescription.\nThe system always checks that the dose is within the approved range. If it isn\u2019t, Kate\nis asked to change the dose.\nAfter Kate has con\ufb01rmed the prescription, it will be displayed for checking. She either\nclicks \u2018OK\u2019 or \u2018Change\u2019. If she clicks \u2018OK\u2019, the prescription is recorded on the audit\ndatabase. If she clicks on \u2018Change\u2019, she reenters the \u2018Prescribing medication\u2019 process.\nPrescribing medication\nFigure 3.5 A  \n\u201cprescribing medication\u201d \nstory\n\n\n80  Chapter 3 \u25a0 Agile software development\nused immediately to deliver useful business support. The intention is to identify \n useful functionality that can be implemented in about two weeks, when the next \nrelease of the system is made available to the customer.\nOf course, as requirements change, the unimplemented stories change or may be \ndiscarded. If changes are required for a system that has already been delivered, new \nstory cards are developed and again, the customer decides whether these changes \nshould have priority over new functionality.\nThe idea of user stories is a powerful one\u2014people find it much easier to relate to \nthese stories than to a conventional requirements document or use cases. User stories can \nbe helpful in getting users involved in suggesting requirements during an initial prede-\nvelopment requirements elicitation activity. I discuss this in more detail in Chapter 4.\nThe principal problem with user stories is completeness. It is difficult to judge if \nenough user stories have been developed to cover all of the essential requirements \nof\u00a0a system. It is also difficult to judge if a single story gives a true picture of an \nactivity. Experienced users are often so familiar with their work that they leave \nthings out when describing it.\n \n3.2.2  Refactoring\nA fundamental precept of traditional software engineering is that you should design \nfor change. That is, you should anticipate future changes to the software and design \nit so that these changes can be easily implemented. Extreme programming, however, \nhas discarded this principle on the basis that designing for change is often wasted \neffort. It isn\u2019t worth taking time to add generality to a program to cope with change. \nOften the changes anticipated never materialize, or completely different change \nrequests may actually be made.\nOf course, in practice, changes will always have to be made to the code being devel-\noped. To make these changes easier, the developers of XP suggested that the code being \ndeveloped should be constantly refactored. Refactoring (Fowler et al. 1999) means that \nthe programming team look for possible improvements to the software and implements \nTask 1: Change dose of prescribed drug\nTask 2: Formulary selection\nTask 3: Dose checking\nDose checking is a safety precaution to check that\nthe doctor has not prescribed a dangerously small or\nlarge dose.\nUsing the formulary id for the generic drug name,\nlook up the formulary and retrieve the recommended\nmaximum and minimum dose.\nCheck the prescribed dose against the minimum and\nmaximum. If outside the range, issue an error\nmessage saying that the dose is too high or too low.\nIf within the range, enable the \u2018Con\ufb01rm\u2019 button.\nFigure 3.6 Examples of \ntask cards for prescribing \nmedication"}
{"query": "What is the role of user stories in the initial predevelopment requirements elicitation activity?", "response": "User stories can be helpful in getting users involved in suggesting requirements during an initial predevelopment requirements elicitation activity.", "context": "3.2  \u25a0 Agile development techniques  79\nI am not convinced that XP on its own is a practical agile method for most com-\npanies, but its most significant contribution is probably the set of agile development \npractices that it introduced to the community. I discuss the most important of these \npractices in this section.\n \n3.2.1  User stories\nSoftware requirements always change. To handle these changes, agile methods do not \nhave a separate requirements engineering activity. Rather, they integrate requirements \nelicitation with development. To make this easier, the idea of \u201cuser stories\u201d was devel-\noped where a user story is a scenario of use that might be experienced by a system user.\nAs far as possible, the system customer works closely with the development team \nand discusses these scenarios with other team members. Together, they develop a \n\u201cstory card\u201d that briefly describes a story that encapsulates the customer needs. The \ndevelopment team then aims to implement that scenario in a future release of the \nsoftware. An example of a story card for the Mentcare system is shown in Figure 3.5. \nThis is a short description of a scenario for prescribing medication for a patient.\nUser stories may be used in planning system iterations. Once the story cards have \nbeen developed, the development team breaks these down into tasks (Figure 3.6) and \nestimates the effort and resources required for implementing each task. This usually \ninvolves discussions with the customer to refine the requirements. The customer \nthen prioritizes the stories for implementation, choosing those stories that can be \nKate is a doctor who wishes to prescribe medication for a patient attending a clinic.\nThe patient record is already displayed on her computer so she clicks on the\nmedication \ufb01eld and can select \u2018current medication\u2019, \u2018new medication\u2019 or \u2018formulary\u2019.\nIf she selects \u2018current medication\u2019, the system asks her to check the dose; If she\nwants to change the dose, she enters the new dose then con\ufb01rms the prescription.\nIf she chooses \u2018new medication\u2019, the system assumes that she knows which\nmedication to prescribe. She types the \ufb01rst few letters of the drug name. The system\ndisplays a list of possible drugs starting with these letters. She chooses the required\nmedication and the system responds by asking her to check that the medication\nselected is correct. She enters the dose then con\ufb01rms the prescription.\nIf she chooses \u2018formulary\u2019, the system displays a search box for the approved\nformulary. She can then search for the drug required. She selects a drug and is asked\nto check that the medication is correct. She enters the dose then con\ufb01rms the\nprescription.\nThe system always checks that the dose is within the approved range. If it isn\u2019t, Kate\nis asked to change the dose.\nAfter Kate has con\ufb01rmed the prescription, it will be displayed for checking. She either\nclicks \u2018OK\u2019 or \u2018Change\u2019. If she clicks \u2018OK\u2019, the prescription is recorded on the audit\ndatabase. If she clicks on \u2018Change\u2019, she reenters the \u2018Prescribing medication\u2019 process.\nPrescribing medication\nFigure 3.5 A  \n\u201cprescribing medication\u201d \nstory\n\n\n80  Chapter 3 \u25a0 Agile software development\nused immediately to deliver useful business support. The intention is to identify \n useful functionality that can be implemented in about two weeks, when the next \nrelease of the system is made available to the customer.\nOf course, as requirements change, the unimplemented stories change or may be \ndiscarded. If changes are required for a system that has already been delivered, new \nstory cards are developed and again, the customer decides whether these changes \nshould have priority over new functionality.\nThe idea of user stories is a powerful one\u2014people find it much easier to relate to \nthese stories than to a conventional requirements document or use cases. User stories can \nbe helpful in getting users involved in suggesting requirements during an initial prede-\nvelopment requirements elicitation activity. I discuss this in more detail in Chapter 4.\nThe principal problem with user stories is completeness. It is difficult to judge if \nenough user stories have been developed to cover all of the essential requirements \nof\u00a0a system. It is also difficult to judge if a single story gives a true picture of an \nactivity. Experienced users are often so familiar with their work that they leave \nthings out when describing it.\n \n3.2.2  Refactoring\nA fundamental precept of traditional software engineering is that you should design \nfor change. That is, you should anticipate future changes to the software and design \nit so that these changes can be easily implemented. Extreme programming, however, \nhas discarded this principle on the basis that designing for change is often wasted \neffort. It isn\u2019t worth taking time to add generality to a program to cope with change. \nOften the changes anticipated never materialize, or completely different change \nrequests may actually be made.\nOf course, in practice, changes will always have to be made to the code being devel-\noped. To make these changes easier, the developers of XP suggested that the code being \ndeveloped should be constantly refactored. Refactoring (Fowler et al. 1999) means that \nthe programming team look for possible improvements to the software and implements \nTask 1: Change dose of prescribed drug\nTask 2: Formulary selection\nTask 3: Dose checking\nDose checking is a safety precaution to check that\nthe doctor has not prescribed a dangerously small or\nlarge dose.\nUsing the formulary id for the generic drug name,\nlook up the formulary and retrieve the recommended\nmaximum and minimum dose.\nCheck the prescribed dose against the minimum and\nmaximum. If outside the range, issue an error\nmessage saying that the dose is too high or too low.\nIf within the range, enable the \u2018Con\ufb01rm\u2019 button.\nFigure 3.6 Examples of \ntask cards for prescribing \nmedication"}
{"query": "How are new story cards developed when changes are required for a system that has already been delivered?", "response": "When changes are required for a system that has already been delivered, new story cards are developed. The customer decides whether these changes should have priority over new functionality.", "context": "3.2  \u25a0 Agile development techniques  79\nI am not convinced that XP on its own is a practical agile method for most com-\npanies, but its most significant contribution is probably the set of agile development \npractices that it introduced to the community. I discuss the most important of these \npractices in this section.\n \n3.2.1  User stories\nSoftware requirements always change. To handle these changes, agile methods do not \nhave a separate requirements engineering activity. Rather, they integrate requirements \nelicitation with development. To make this easier, the idea of \u201cuser stories\u201d was devel-\noped where a user story is a scenario of use that might be experienced by a system user.\nAs far as possible, the system customer works closely with the development team \nand discusses these scenarios with other team members. Together, they develop a \n\u201cstory card\u201d that briefly describes a story that encapsulates the customer needs. The \ndevelopment team then aims to implement that scenario in a future release of the \nsoftware. An example of a story card for the Mentcare system is shown in Figure 3.5. \nThis is a short description of a scenario for prescribing medication for a patient.\nUser stories may be used in planning system iterations. Once the story cards have \nbeen developed, the development team breaks these down into tasks (Figure 3.6) and \nestimates the effort and resources required for implementing each task. This usually \ninvolves discussions with the customer to refine the requirements. The customer \nthen prioritizes the stories for implementation, choosing those stories that can be \nKate is a doctor who wishes to prescribe medication for a patient attending a clinic.\nThe patient record is already displayed on her computer so she clicks on the\nmedication \ufb01eld and can select \u2018current medication\u2019, \u2018new medication\u2019 or \u2018formulary\u2019.\nIf she selects \u2018current medication\u2019, the system asks her to check the dose; If she\nwants to change the dose, she enters the new dose then con\ufb01rms the prescription.\nIf she chooses \u2018new medication\u2019, the system assumes that she knows which\nmedication to prescribe. She types the \ufb01rst few letters of the drug name. The system\ndisplays a list of possible drugs starting with these letters. She chooses the required\nmedication and the system responds by asking her to check that the medication\nselected is correct. She enters the dose then con\ufb01rms the prescription.\nIf she chooses \u2018formulary\u2019, the system displays a search box for the approved\nformulary. She can then search for the drug required. She selects a drug and is asked\nto check that the medication is correct. She enters the dose then con\ufb01rms the\nprescription.\nThe system always checks that the dose is within the approved range. If it isn\u2019t, Kate\nis asked to change the dose.\nAfter Kate has con\ufb01rmed the prescription, it will be displayed for checking. She either\nclicks \u2018OK\u2019 or \u2018Change\u2019. If she clicks \u2018OK\u2019, the prescription is recorded on the audit\ndatabase. If she clicks on \u2018Change\u2019, she reenters the \u2018Prescribing medication\u2019 process.\nPrescribing medication\nFigure 3.5 A  \n\u201cprescribing medication\u201d \nstory\n\n\n80  Chapter 3 \u25a0 Agile software development\nused immediately to deliver useful business support. The intention is to identify \n useful functionality that can be implemented in about two weeks, when the next \nrelease of the system is made available to the customer.\nOf course, as requirements change, the unimplemented stories change or may be \ndiscarded. If changes are required for a system that has already been delivered, new \nstory cards are developed and again, the customer decides whether these changes \nshould have priority over new functionality.\nThe idea of user stories is a powerful one\u2014people find it much easier to relate to \nthese stories than to a conventional requirements document or use cases. User stories can \nbe helpful in getting users involved in suggesting requirements during an initial prede-\nvelopment requirements elicitation activity. I discuss this in more detail in Chapter 4.\nThe principal problem with user stories is completeness. It is difficult to judge if \nenough user stories have been developed to cover all of the essential requirements \nof\u00a0a system. It is also difficult to judge if a single story gives a true picture of an \nactivity. Experienced users are often so familiar with their work that they leave \nthings out when describing it.\n \n3.2.2  Refactoring\nA fundamental precept of traditional software engineering is that you should design \nfor change. That is, you should anticipate future changes to the software and design \nit so that these changes can be easily implemented. Extreme programming, however, \nhas discarded this principle on the basis that designing for change is often wasted \neffort. It isn\u2019t worth taking time to add generality to a program to cope with change. \nOften the changes anticipated never materialize, or completely different change \nrequests may actually be made.\nOf course, in practice, changes will always have to be made to the code being devel-\noped. To make these changes easier, the developers of XP suggested that the code being \ndeveloped should be constantly refactored. Refactoring (Fowler et al. 1999) means that \nthe programming team look for possible improvements to the software and implements \nTask 1: Change dose of prescribed drug\nTask 2: Formulary selection\nTask 3: Dose checking\nDose checking is a safety precaution to check that\nthe doctor has not prescribed a dangerously small or\nlarge dose.\nUsing the formulary id for the generic drug name,\nlook up the formulary and retrieve the recommended\nmaximum and minimum dose.\nCheck the prescribed dose against the minimum and\nmaximum. If outside the range, issue an error\nmessage saying that the dose is too high or too low.\nIf within the range, enable the \u2018Con\ufb01rm\u2019 button.\nFigure 3.6 Examples of \ntask cards for prescribing \nmedication"}
{"query": "How does the customer decide whether these changes should have priority over new functionality?", "response": "The customer decides whether changes should have priority over new functionality based on their assessment of the importance and urgency of the changes. They prioritize the user stories for implementation, choosing those stories that can be used immediately to deliver useful business support. This prioritization process helps identify the most valuable functionality that should be implemented in the next release of the system.", "context": "3.2  \u25a0 Agile development techniques  79\nI am not convinced that XP on its own is a practical agile method for most com-\npanies, but its most significant contribution is probably the set of agile development \npractices that it introduced to the community. I discuss the most important of these \npractices in this section.\n \n3.2.1  User stories\nSoftware requirements always change. To handle these changes, agile methods do not \nhave a separate requirements engineering activity. Rather, they integrate requirements \nelicitation with development. To make this easier, the idea of \u201cuser stories\u201d was devel-\noped where a user story is a scenario of use that might be experienced by a system user.\nAs far as possible, the system customer works closely with the development team \nand discusses these scenarios with other team members. Together, they develop a \n\u201cstory card\u201d that briefly describes a story that encapsulates the customer needs. The \ndevelopment team then aims to implement that scenario in a future release of the \nsoftware. An example of a story card for the Mentcare system is shown in Figure 3.5. \nThis is a short description of a scenario for prescribing medication for a patient.\nUser stories may be used in planning system iterations. Once the story cards have \nbeen developed, the development team breaks these down into tasks (Figure 3.6) and \nestimates the effort and resources required for implementing each task. This usually \ninvolves discussions with the customer to refine the requirements. The customer \nthen prioritizes the stories for implementation, choosing those stories that can be \nKate is a doctor who wishes to prescribe medication for a patient attending a clinic.\nThe patient record is already displayed on her computer so she clicks on the\nmedication \ufb01eld and can select \u2018current medication\u2019, \u2018new medication\u2019 or \u2018formulary\u2019.\nIf she selects \u2018current medication\u2019, the system asks her to check the dose; If she\nwants to change the dose, she enters the new dose then con\ufb01rms the prescription.\nIf she chooses \u2018new medication\u2019, the system assumes that she knows which\nmedication to prescribe. She types the \ufb01rst few letters of the drug name. The system\ndisplays a list of possible drugs starting with these letters. She chooses the required\nmedication and the system responds by asking her to check that the medication\nselected is correct. She enters the dose then con\ufb01rms the prescription.\nIf she chooses \u2018formulary\u2019, the system displays a search box for the approved\nformulary. She can then search for the drug required. She selects a drug and is asked\nto check that the medication is correct. She enters the dose then con\ufb01rms the\nprescription.\nThe system always checks that the dose is within the approved range. If it isn\u2019t, Kate\nis asked to change the dose.\nAfter Kate has con\ufb01rmed the prescription, it will be displayed for checking. She either\nclicks \u2018OK\u2019 or \u2018Change\u2019. If she clicks \u2018OK\u2019, the prescription is recorded on the audit\ndatabase. If she clicks on \u2018Change\u2019, she reenters the \u2018Prescribing medication\u2019 process.\nPrescribing medication\nFigure 3.5 A  \n\u201cprescribing medication\u201d \nstory\n\n\n80  Chapter 3 \u25a0 Agile software development\nused immediately to deliver useful business support. The intention is to identify \n useful functionality that can be implemented in about two weeks, when the next \nrelease of the system is made available to the customer.\nOf course, as requirements change, the unimplemented stories change or may be \ndiscarded. If changes are required for a system that has already been delivered, new \nstory cards are developed and again, the customer decides whether these changes \nshould have priority over new functionality.\nThe idea of user stories is a powerful one\u2014people find it much easier to relate to \nthese stories than to a conventional requirements document or use cases. User stories can \nbe helpful in getting users involved in suggesting requirements during an initial prede-\nvelopment requirements elicitation activity. I discuss this in more detail in Chapter 4.\nThe principal problem with user stories is completeness. It is difficult to judge if \nenough user stories have been developed to cover all of the essential requirements \nof\u00a0a system. It is also difficult to judge if a single story gives a true picture of an \nactivity. Experienced users are often so familiar with their work that they leave \nthings out when describing it.\n \n3.2.2  Refactoring\nA fundamental precept of traditional software engineering is that you should design \nfor change. That is, you should anticipate future changes to the software and design \nit so that these changes can be easily implemented. Extreme programming, however, \nhas discarded this principle on the basis that designing for change is often wasted \neffort. It isn\u2019t worth taking time to add generality to a program to cope with change. \nOften the changes anticipated never materialize, or completely different change \nrequests may actually be made.\nOf course, in practice, changes will always have to be made to the code being devel-\noped. To make these changes easier, the developers of XP suggested that the code being \ndeveloped should be constantly refactored. Refactoring (Fowler et al. 1999) means that \nthe programming team look for possible improvements to the software and implements \nTask 1: Change dose of prescribed drug\nTask 2: Formulary selection\nTask 3: Dose checking\nDose checking is a safety precaution to check that\nthe doctor has not prescribed a dangerously small or\nlarge dose.\nUsing the formulary id for the generic drug name,\nlook up the formulary and retrieve the recommended\nmaximum and minimum dose.\nCheck the prescribed dose against the minimum and\nmaximum. If outside the range, issue an error\nmessage saying that the dose is too high or too low.\nIf within the range, enable the \u2018Con\ufb01rm\u2019 button.\nFigure 3.6 Examples of \ntask cards for prescribing \nmedication"}
{"query": "What is the intention of identifying useful functionality that can be implemented in about two weeks?", "response": "The intention of identifying useful functionality that can be implemented in about two weeks is to deliver immediate business support and provide a new release of the system to the customer.", "context": "3.2  \u25a0 Agile development techniques  79\nI am not convinced that XP on its own is a practical agile method for most com-\npanies, but its most significant contribution is probably the set of agile development \npractices that it introduced to the community. I discuss the most important of these \npractices in this section.\n \n3.2.1  User stories\nSoftware requirements always change. To handle these changes, agile methods do not \nhave a separate requirements engineering activity. Rather, they integrate requirements \nelicitation with development. To make this easier, the idea of \u201cuser stories\u201d was devel-\noped where a user story is a scenario of use that might be experienced by a system user.\nAs far as possible, the system customer works closely with the development team \nand discusses these scenarios with other team members. Together, they develop a \n\u201cstory card\u201d that briefly describes a story that encapsulates the customer needs. The \ndevelopment team then aims to implement that scenario in a future release of the \nsoftware. An example of a story card for the Mentcare system is shown in Figure 3.5. \nThis is a short description of a scenario for prescribing medication for a patient.\nUser stories may be used in planning system iterations. Once the story cards have \nbeen developed, the development team breaks these down into tasks (Figure 3.6) and \nestimates the effort and resources required for implementing each task. This usually \ninvolves discussions with the customer to refine the requirements. The customer \nthen prioritizes the stories for implementation, choosing those stories that can be \nKate is a doctor who wishes to prescribe medication for a patient attending a clinic.\nThe patient record is already displayed on her computer so she clicks on the\nmedication \ufb01eld and can select \u2018current medication\u2019, \u2018new medication\u2019 or \u2018formulary\u2019.\nIf she selects \u2018current medication\u2019, the system asks her to check the dose; If she\nwants to change the dose, she enters the new dose then con\ufb01rms the prescription.\nIf she chooses \u2018new medication\u2019, the system assumes that she knows which\nmedication to prescribe. She types the \ufb01rst few letters of the drug name. The system\ndisplays a list of possible drugs starting with these letters. She chooses the required\nmedication and the system responds by asking her to check that the medication\nselected is correct. She enters the dose then con\ufb01rms the prescription.\nIf she chooses \u2018formulary\u2019, the system displays a search box for the approved\nformulary. She can then search for the drug required. She selects a drug and is asked\nto check that the medication is correct. She enters the dose then con\ufb01rms the\nprescription.\nThe system always checks that the dose is within the approved range. If it isn\u2019t, Kate\nis asked to change the dose.\nAfter Kate has con\ufb01rmed the prescription, it will be displayed for checking. She either\nclicks \u2018OK\u2019 or \u2018Change\u2019. If she clicks \u2018OK\u2019, the prescription is recorded on the audit\ndatabase. If she clicks on \u2018Change\u2019, she reenters the \u2018Prescribing medication\u2019 process.\nPrescribing medication\nFigure 3.5 A  \n\u201cprescribing medication\u201d \nstory\n\n\n80  Chapter 3 \u25a0 Agile software development\nused immediately to deliver useful business support. The intention is to identify \n useful functionality that can be implemented in about two weeks, when the next \nrelease of the system is made available to the customer.\nOf course, as requirements change, the unimplemented stories change or may be \ndiscarded. If changes are required for a system that has already been delivered, new \nstory cards are developed and again, the customer decides whether these changes \nshould have priority over new functionality.\nThe idea of user stories is a powerful one\u2014people find it much easier to relate to \nthese stories than to a conventional requirements document or use cases. User stories can \nbe helpful in getting users involved in suggesting requirements during an initial prede-\nvelopment requirements elicitation activity. I discuss this in more detail in Chapter 4.\nThe principal problem with user stories is completeness. It is difficult to judge if \nenough user stories have been developed to cover all of the essential requirements \nof\u00a0a system. It is also difficult to judge if a single story gives a true picture of an \nactivity. Experienced users are often so familiar with their work that they leave \nthings out when describing it.\n \n3.2.2  Refactoring\nA fundamental precept of traditional software engineering is that you should design \nfor change. That is, you should anticipate future changes to the software and design \nit so that these changes can be easily implemented. Extreme programming, however, \nhas discarded this principle on the basis that designing for change is often wasted \neffort. It isn\u2019t worth taking time to add generality to a program to cope with change. \nOften the changes anticipated never materialize, or completely different change \nrequests may actually be made.\nOf course, in practice, changes will always have to be made to the code being devel-\noped. To make these changes easier, the developers of XP suggested that the code being \ndeveloped should be constantly refactored. Refactoring (Fowler et al. 1999) means that \nthe programming team look for possible improvements to the software and implements \nTask 1: Change dose of prescribed drug\nTask 2: Formulary selection\nTask 3: Dose checking\nDose checking is a safety precaution to check that\nthe doctor has not prescribed a dangerously small or\nlarge dose.\nUsing the formulary id for the generic drug name,\nlook up the formulary and retrieve the recommended\nmaximum and minimum dose.\nCheck the prescribed dose against the minimum and\nmaximum. If outside the range, issue an error\nmessage saying that the dose is too high or too low.\nIf within the range, enable the \u2018Con\ufb01rm\u2019 button.\nFigure 3.6 Examples of \ntask cards for prescribing \nmedication"}
{"query": "How does refactoring improve the software in extreme programming?", "response": "Refactoring in extreme programming improves the software by constantly looking for possible improvements and implementing them. This helps to keep the code clean, maintainable, and adaptable to future changes. By regularly refactoring the code, the development team can eliminate any unnecessary complexity, improve the design, and enhance the overall quality of the software. This approach allows for easier and more efficient modifications to be made in response to changing requirements or new feature requests.", "context": "3.2  \u25a0 Agile development techniques  79\nI am not convinced that XP on its own is a practical agile method for most com-\npanies, but its most significant contribution is probably the set of agile development \npractices that it introduced to the community. I discuss the most important of these \npractices in this section.\n \n3.2.1  User stories\nSoftware requirements always change. To handle these changes, agile methods do not \nhave a separate requirements engineering activity. Rather, they integrate requirements \nelicitation with development. To make this easier, the idea of \u201cuser stories\u201d was devel-\noped where a user story is a scenario of use that might be experienced by a system user.\nAs far as possible, the system customer works closely with the development team \nand discusses these scenarios with other team members. Together, they develop a \n\u201cstory card\u201d that briefly describes a story that encapsulates the customer needs. The \ndevelopment team then aims to implement that scenario in a future release of the \nsoftware. An example of a story card for the Mentcare system is shown in Figure 3.5. \nThis is a short description of a scenario for prescribing medication for a patient.\nUser stories may be used in planning system iterations. Once the story cards have \nbeen developed, the development team breaks these down into tasks (Figure 3.6) and \nestimates the effort and resources required for implementing each task. This usually \ninvolves discussions with the customer to refine the requirements. The customer \nthen prioritizes the stories for implementation, choosing those stories that can be \nKate is a doctor who wishes to prescribe medication for a patient attending a clinic.\nThe patient record is already displayed on her computer so she clicks on the\nmedication \ufb01eld and can select \u2018current medication\u2019, \u2018new medication\u2019 or \u2018formulary\u2019.\nIf she selects \u2018current medication\u2019, the system asks her to check the dose; If she\nwants to change the dose, she enters the new dose then con\ufb01rms the prescription.\nIf she chooses \u2018new medication\u2019, the system assumes that she knows which\nmedication to prescribe. She types the \ufb01rst few letters of the drug name. The system\ndisplays a list of possible drugs starting with these letters. She chooses the required\nmedication and the system responds by asking her to check that the medication\nselected is correct. She enters the dose then con\ufb01rms the prescription.\nIf she chooses \u2018formulary\u2019, the system displays a search box for the approved\nformulary. She can then search for the drug required. She selects a drug and is asked\nto check that the medication is correct. She enters the dose then con\ufb01rms the\nprescription.\nThe system always checks that the dose is within the approved range. If it isn\u2019t, Kate\nis asked to change the dose.\nAfter Kate has con\ufb01rmed the prescription, it will be displayed for checking. She either\nclicks \u2018OK\u2019 or \u2018Change\u2019. If she clicks \u2018OK\u2019, the prescription is recorded on the audit\ndatabase. If she clicks on \u2018Change\u2019, she reenters the \u2018Prescribing medication\u2019 process.\nPrescribing medication\nFigure 3.5 A  \n\u201cprescribing medication\u201d \nstory\n\n\n80  Chapter 3 \u25a0 Agile software development\nused immediately to deliver useful business support. The intention is to identify \n useful functionality that can be implemented in about two weeks, when the next \nrelease of the system is made available to the customer.\nOf course, as requirements change, the unimplemented stories change or may be \ndiscarded. If changes are required for a system that has already been delivered, new \nstory cards are developed and again, the customer decides whether these changes \nshould have priority over new functionality.\nThe idea of user stories is a powerful one\u2014people find it much easier to relate to \nthese stories than to a conventional requirements document or use cases. User stories can \nbe helpful in getting users involved in suggesting requirements during an initial prede-\nvelopment requirements elicitation activity. I discuss this in more detail in Chapter 4.\nThe principal problem with user stories is completeness. It is difficult to judge if \nenough user stories have been developed to cover all of the essential requirements \nof\u00a0a system. It is also difficult to judge if a single story gives a true picture of an \nactivity. Experienced users are often so familiar with their work that they leave \nthings out when describing it.\n \n3.2.2  Refactoring\nA fundamental precept of traditional software engineering is that you should design \nfor change. That is, you should anticipate future changes to the software and design \nit so that these changes can be easily implemented. Extreme programming, however, \nhas discarded this principle on the basis that designing for change is often wasted \neffort. It isn\u2019t worth taking time to add generality to a program to cope with change. \nOften the changes anticipated never materialize, or completely different change \nrequests may actually be made.\nOf course, in practice, changes will always have to be made to the code being devel-\noped. To make these changes easier, the developers of XP suggested that the code being \ndeveloped should be constantly refactored. Refactoring (Fowler et al. 1999) means that \nthe programming team look for possible improvements to the software and implements \nTask 1: Change dose of prescribed drug\nTask 2: Formulary selection\nTask 3: Dose checking\nDose checking is a safety precaution to check that\nthe doctor has not prescribed a dangerously small or\nlarge dose.\nUsing the formulary id for the generic drug name,\nlook up the formulary and retrieve the recommended\nmaximum and minimum dose.\nCheck the prescribed dose against the minimum and\nmaximum. If outside the range, issue an error\nmessage saying that the dose is too high or too low.\nIf within the range, enable the \u2018Con\ufb01rm\u2019 button.\nFigure 3.6 Examples of \ntask cards for prescribing \nmedication"}
{"query": "Why is it difficult to judge if a single story gives a true picture of an activity in agile development?", "response": "It is difficult to judge if a single story gives a true picture of an activity in agile development because experienced users often leave out important details when describing their work. They may be so familiar with their tasks that they unintentionally omit certain steps or requirements. This can result in incomplete user stories that do not fully capture the essential requirements of the system.", "context": "3.2  \u25a0 Agile development techniques  79\nI am not convinced that XP on its own is a practical agile method for most com-\npanies, but its most significant contribution is probably the set of agile development \npractices that it introduced to the community. I discuss the most important of these \npractices in this section.\n \n3.2.1  User stories\nSoftware requirements always change. To handle these changes, agile methods do not \nhave a separate requirements engineering activity. Rather, they integrate requirements \nelicitation with development. To make this easier, the idea of \u201cuser stories\u201d was devel-\noped where a user story is a scenario of use that might be experienced by a system user.\nAs far as possible, the system customer works closely with the development team \nand discusses these scenarios with other team members. Together, they develop a \n\u201cstory card\u201d that briefly describes a story that encapsulates the customer needs. The \ndevelopment team then aims to implement that scenario in a future release of the \nsoftware. An example of a story card for the Mentcare system is shown in Figure 3.5. \nThis is a short description of a scenario for prescribing medication for a patient.\nUser stories may be used in planning system iterations. Once the story cards have \nbeen developed, the development team breaks these down into tasks (Figure 3.6) and \nestimates the effort and resources required for implementing each task. This usually \ninvolves discussions with the customer to refine the requirements. The customer \nthen prioritizes the stories for implementation, choosing those stories that can be \nKate is a doctor who wishes to prescribe medication for a patient attending a clinic.\nThe patient record is already displayed on her computer so she clicks on the\nmedication \ufb01eld and can select \u2018current medication\u2019, \u2018new medication\u2019 or \u2018formulary\u2019.\nIf she selects \u2018current medication\u2019, the system asks her to check the dose; If she\nwants to change the dose, she enters the new dose then con\ufb01rms the prescription.\nIf she chooses \u2018new medication\u2019, the system assumes that she knows which\nmedication to prescribe. She types the \ufb01rst few letters of the drug name. The system\ndisplays a list of possible drugs starting with these letters. She chooses the required\nmedication and the system responds by asking her to check that the medication\nselected is correct. She enters the dose then con\ufb01rms the prescription.\nIf she chooses \u2018formulary\u2019, the system displays a search box for the approved\nformulary. She can then search for the drug required. She selects a drug and is asked\nto check that the medication is correct. She enters the dose then con\ufb01rms the\nprescription.\nThe system always checks that the dose is within the approved range. If it isn\u2019t, Kate\nis asked to change the dose.\nAfter Kate has con\ufb01rmed the prescription, it will be displayed for checking. She either\nclicks \u2018OK\u2019 or \u2018Change\u2019. If she clicks \u2018OK\u2019, the prescription is recorded on the audit\ndatabase. If she clicks on \u2018Change\u2019, she reenters the \u2018Prescribing medication\u2019 process.\nPrescribing medication\nFigure 3.5 A  \n\u201cprescribing medication\u201d \nstory\n\n\n80  Chapter 3 \u25a0 Agile software development\nused immediately to deliver useful business support. The intention is to identify \n useful functionality that can be implemented in about two weeks, when the next \nrelease of the system is made available to the customer.\nOf course, as requirements change, the unimplemented stories change or may be \ndiscarded. If changes are required for a system that has already been delivered, new \nstory cards are developed and again, the customer decides whether these changes \nshould have priority over new functionality.\nThe idea of user stories is a powerful one\u2014people find it much easier to relate to \nthese stories than to a conventional requirements document or use cases. User stories can \nbe helpful in getting users involved in suggesting requirements during an initial prede-\nvelopment requirements elicitation activity. I discuss this in more detail in Chapter 4.\nThe principal problem with user stories is completeness. It is difficult to judge if \nenough user stories have been developed to cover all of the essential requirements \nof\u00a0a system. It is also difficult to judge if a single story gives a true picture of an \nactivity. Experienced users are often so familiar with their work that they leave \nthings out when describing it.\n \n3.2.2  Refactoring\nA fundamental precept of traditional software engineering is that you should design \nfor change. That is, you should anticipate future changes to the software and design \nit so that these changes can be easily implemented. Extreme programming, however, \nhas discarded this principle on the basis that designing for change is often wasted \neffort. It isn\u2019t worth taking time to add generality to a program to cope with change. \nOften the changes anticipated never materialize, or completely different change \nrequests may actually be made.\nOf course, in practice, changes will always have to be made to the code being devel-\noped. To make these changes easier, the developers of XP suggested that the code being \ndeveloped should be constantly refactored. Refactoring (Fowler et al. 1999) means that \nthe programming team look for possible improvements to the software and implements \nTask 1: Change dose of prescribed drug\nTask 2: Formulary selection\nTask 3: Dose checking\nDose checking is a safety precaution to check that\nthe doctor has not prescribed a dangerously small or\nlarge dose.\nUsing the formulary id for the generic drug name,\nlook up the formulary and retrieve the recommended\nmaximum and minimum dose.\nCheck the prescribed dose against the minimum and\nmaximum. If outside the range, issue an error\nmessage saying that the dose is too high or too low.\nIf within the range, enable the \u2018Con\ufb01rm\u2019 button.\nFigure 3.6 Examples of \ntask cards for prescribing \nmedication"}
{"query": "What is a fundamental problem of incremental development?", "response": "The fundamental problem of incremental development is that local changes tend to degrade the software structure. This degradation makes it harder to implement further changes to the software. As a result, workarounds are often found to address problems, leading to code duplication, inappropriate reuse of software parts, and overall degradation of the software structure. Refactoring is a technique used to improve the software structure and readability, preventing this deterioration that naturally occurs when software is changed.", "context": "3.2  \u25a0 Agile development techniques  81\nthem immediately. When team members see code that can be improved, they make \nthese improvements even in situations where there is no immediate need for them.\nA fundamental problem of incremental development is that local changes tend to \ndegrade the software structure. Consequently, further changes to the software become \nharder and harder to implement. Essentially, the development proceeds by finding \nworkarounds to problems, with the result that code is often duplicated, parts of the \nsoftware are reused in inappropriate ways, and the overall structure degrades as code is \nadded to the system. Refactoring improves the software structure and readability and \nso avoids the structural deterioration that naturally occurs when software is changed.\nExamples of refactoring include the reorganization of a class hierarchy to remove \nduplicate code, the tidying up and renaming of attributes and methods, and the \nreplacement of similar code sections, with calls to methods defined in a program \nlibrary. Program development environments usually include tools for refactoring. \nThese simplify the process of finding dependencies between code sections and mak-\ning global code modifications.\nIn principle, when refactoring is part of the development process, the software \nshould always be easy to understand and change as new requirements are proposed. \nIn practice, this is not always the case. Sometimes development pressure means that \nrefactoring is delayed because the time is devoted to the implementation of new \nfunctionality. Some new features and changes cannot readily be accommodated by \ncode-level refactoring and require that the architecture of the system be modified.\n \n3.2.3  Test-first development\nAs I discussed in the introduction to this chapter, one of the important differences \nbetween incremental development and plan-driven development is in the way that \nthe system is tested. With incremental development, there is no system specification \nthat can be used by an external testing team to develop system tests. As a conse-\nquence, some approaches to incremental development have a very informal testing \nprocess, in comparison with plan-driven testing.\nExtreme Programming developed a new approach to program testing to address \nthe difficulties of testing without a specification. Testing is automated and is central \nto the development process, and development cannot proceed until all tests have \nbeen successfully executed. The key features of testing in XP are:\n1. test-first development,\n2. incremental test development from scenarios,\n3. user involvement in the test development and validation, and\n4. the use of automated testing frameworks.\nXP\u2019s test-first philosophy has now evolved into more general test-driven develop-\nment techniques (Jeffries and Melnik 2007). I believe that test-driven development is \none of the most important innovations in software engineering. Instead of writing code \nand then writing tests for that code, you write the tests before you write the code. This \n\n\n82  Chapter 3 \u25a0 Agile software development\nmeans that you can run the test as the code is being written and discover problems dur-\ning development. I discuss test-driven development in more depth in Chapter 8.\nWriting tests implicitly defines both an interface and a specification of behavior for \nthe functionality being developed. Problems of requirements and interface misunder-\nstandings are reduced. Test-first development requires there to be a clear relationship \nbetween system requirements and the code implementing the corresponding require-\nments. In XP, this relationship is clear because the story cards representing the require-\nments are broken down into tasks and the tasks are the principal unit of implementation.\nIn test-first development, the task implementers have to thoroughly understand \nthe specification so that they can write tests for the system. This means that ambi-\nguities and omissions in the specification have to be clarified before implementation \nbegins. Furthermore, it also avoids the problem of \u201ctest-lag.\u201d This may happen when \nthe developer of the system works at a faster pace than the tester. The implementa-\ntion gets further and further ahead of the testing and there is a tendency to skip tests, \nso that the development schedule can be maintained.\nXP\u2019s test-first approach assumes that user stories have been developed, and these \nhave been broken down into a set of task cards, as shown in Figure 3.6. Each task \ngenerates one or more unit tests that check the implementation described in that task. \nFigure 3.7 is a shortened description of a test case that has been developed to check \nthat the prescribed dose of a drug does not fall outside known safe limits.\nThe role of the customer in the testing process is to help develop acceptance tests \nfor the stories that are to be implemented in the next release of the system. As I \nexplain in Chapter 8, acceptance  testing is the process whereby the system is tested \nusing customer data to check that it meets the customer\u2019s real needs.\nTest automation is essential for test-first development. Tests are written as exe-\ncutable components before the task is implemented. These testing components \nshould be stand-alone, should simulate the submission of input to be tested, and \nshould check that the result meets the output specification. An automated test frame-\nwork is a system that makes it easy to write executable tests and submit a set of tests \nfor execution. Junit (Tahchiev et al. 2010) is a widely used example of an automated \ntesting framework for Java programs.\nInput:\n1.  A number in mg representing a single dose of the drug.\n2.  A number representing the number of single doses per day.\nTests:\n1.   Test for inputs where the single dose is correct but the frequency is too\nhigh.\n2.   Test for inputs where the single dose is too high and too low.\n3.   Test for inputs where the single dose * frequency is too high and too low.\n4.   Test for inputs where single dose * frequency is in the permitted range.\nOutput:\nOK or error message indicating that the dose is outside the safe range.\nTest 4: Dose checking\nFigure 3.7 Test case \ndescription for dose \nchecking"}
{"query": "How does refactoring improve the software structure and readability?", "response": "Refactoring improves the software structure and readability by making changes to the code that remove duplicate code, tidy up and rename attributes and methods, and replace similar code sections with calls to methods defined in a program library. This process helps to eliminate code duplication, improve code organization, and enhance the overall structure of the software. As a result, the software becomes easier to understand and maintain, and the readability of the code is improved.", "context": "3.2  \u25a0 Agile development techniques  81\nthem immediately. When team members see code that can be improved, they make \nthese improvements even in situations where there is no immediate need for them.\nA fundamental problem of incremental development is that local changes tend to \ndegrade the software structure. Consequently, further changes to the software become \nharder and harder to implement. Essentially, the development proceeds by finding \nworkarounds to problems, with the result that code is often duplicated, parts of the \nsoftware are reused in inappropriate ways, and the overall structure degrades as code is \nadded to the system. Refactoring improves the software structure and readability and \nso avoids the structural deterioration that naturally occurs when software is changed.\nExamples of refactoring include the reorganization of a class hierarchy to remove \nduplicate code, the tidying up and renaming of attributes and methods, and the \nreplacement of similar code sections, with calls to methods defined in a program \nlibrary. Program development environments usually include tools for refactoring. \nThese simplify the process of finding dependencies between code sections and mak-\ning global code modifications.\nIn principle, when refactoring is part of the development process, the software \nshould always be easy to understand and change as new requirements are proposed. \nIn practice, this is not always the case. Sometimes development pressure means that \nrefactoring is delayed because the time is devoted to the implementation of new \nfunctionality. Some new features and changes cannot readily be accommodated by \ncode-level refactoring and require that the architecture of the system be modified.\n \n3.2.3  Test-first development\nAs I discussed in the introduction to this chapter, one of the important differences \nbetween incremental development and plan-driven development is in the way that \nthe system is tested. With incremental development, there is no system specification \nthat can be used by an external testing team to develop system tests. As a conse-\nquence, some approaches to incremental development have a very informal testing \nprocess, in comparison with plan-driven testing.\nExtreme Programming developed a new approach to program testing to address \nthe difficulties of testing without a specification. Testing is automated and is central \nto the development process, and development cannot proceed until all tests have \nbeen successfully executed. The key features of testing in XP are:\n1. test-first development,\n2. incremental test development from scenarios,\n3. user involvement in the test development and validation, and\n4. the use of automated testing frameworks.\nXP\u2019s test-first philosophy has now evolved into more general test-driven develop-\nment techniques (Jeffries and Melnik 2007). I believe that test-driven development is \none of the most important innovations in software engineering. Instead of writing code \nand then writing tests for that code, you write the tests before you write the code. This \n\n\n82  Chapter 3 \u25a0 Agile software development\nmeans that you can run the test as the code is being written and discover problems dur-\ning development. I discuss test-driven development in more depth in Chapter 8.\nWriting tests implicitly defines both an interface and a specification of behavior for \nthe functionality being developed. Problems of requirements and interface misunder-\nstandings are reduced. Test-first development requires there to be a clear relationship \nbetween system requirements and the code implementing the corresponding require-\nments. In XP, this relationship is clear because the story cards representing the require-\nments are broken down into tasks and the tasks are the principal unit of implementation.\nIn test-first development, the task implementers have to thoroughly understand \nthe specification so that they can write tests for the system. This means that ambi-\nguities and omissions in the specification have to be clarified before implementation \nbegins. Furthermore, it also avoids the problem of \u201ctest-lag.\u201d This may happen when \nthe developer of the system works at a faster pace than the tester. The implementa-\ntion gets further and further ahead of the testing and there is a tendency to skip tests, \nso that the development schedule can be maintained.\nXP\u2019s test-first approach assumes that user stories have been developed, and these \nhave been broken down into a set of task cards, as shown in Figure 3.6. Each task \ngenerates one or more unit tests that check the implementation described in that task. \nFigure 3.7 is a shortened description of a test case that has been developed to check \nthat the prescribed dose of a drug does not fall outside known safe limits.\nThe role of the customer in the testing process is to help develop acceptance tests \nfor the stories that are to be implemented in the next release of the system. As I \nexplain in Chapter 8, acceptance  testing is the process whereby the system is tested \nusing customer data to check that it meets the customer\u2019s real needs.\nTest automation is essential for test-first development. Tests are written as exe-\ncutable components before the task is implemented. These testing components \nshould be stand-alone, should simulate the submission of input to be tested, and \nshould check that the result meets the output specification. An automated test frame-\nwork is a system that makes it easy to write executable tests and submit a set of tests \nfor execution. Junit (Tahchiev et al. 2010) is a widely used example of an automated \ntesting framework for Java programs.\nInput:\n1.  A number in mg representing a single dose of the drug.\n2.  A number representing the number of single doses per day.\nTests:\n1.   Test for inputs where the single dose is correct but the frequency is too\nhigh.\n2.   Test for inputs where the single dose is too high and too low.\n3.   Test for inputs where the single dose * frequency is too high and too low.\n4.   Test for inputs where single dose * frequency is in the permitted range.\nOutput:\nOK or error message indicating that the dose is outside the safe range.\nTest 4: Dose checking\nFigure 3.7 Test case \ndescription for dose \nchecking"}
{"query": "What are some examples of refactoring?", "response": "Examples of refactoring include the reorganization of a class hierarchy to remove duplicate code, the tidying up and renaming of attributes and methods, and the replacement of similar code sections with calls to methods defined in a program library.", "context": "3.2  \u25a0 Agile development techniques  81\nthem immediately. When team members see code that can be improved, they make \nthese improvements even in situations where there is no immediate need for them.\nA fundamental problem of incremental development is that local changes tend to \ndegrade the software structure. Consequently, further changes to the software become \nharder and harder to implement. Essentially, the development proceeds by finding \nworkarounds to problems, with the result that code is often duplicated, parts of the \nsoftware are reused in inappropriate ways, and the overall structure degrades as code is \nadded to the system. Refactoring improves the software structure and readability and \nso avoids the structural deterioration that naturally occurs when software is changed.\nExamples of refactoring include the reorganization of a class hierarchy to remove \nduplicate code, the tidying up and renaming of attributes and methods, and the \nreplacement of similar code sections, with calls to methods defined in a program \nlibrary. Program development environments usually include tools for refactoring. \nThese simplify the process of finding dependencies between code sections and mak-\ning global code modifications.\nIn principle, when refactoring is part of the development process, the software \nshould always be easy to understand and change as new requirements are proposed. \nIn practice, this is not always the case. Sometimes development pressure means that \nrefactoring is delayed because the time is devoted to the implementation of new \nfunctionality. Some new features and changes cannot readily be accommodated by \ncode-level refactoring and require that the architecture of the system be modified.\n \n3.2.3  Test-first development\nAs I discussed in the introduction to this chapter, one of the important differences \nbetween incremental development and plan-driven development is in the way that \nthe system is tested. With incremental development, there is no system specification \nthat can be used by an external testing team to develop system tests. As a conse-\nquence, some approaches to incremental development have a very informal testing \nprocess, in comparison with plan-driven testing.\nExtreme Programming developed a new approach to program testing to address \nthe difficulties of testing without a specification. Testing is automated and is central \nto the development process, and development cannot proceed until all tests have \nbeen successfully executed. The key features of testing in XP are:\n1. test-first development,\n2. incremental test development from scenarios,\n3. user involvement in the test development and validation, and\n4. the use of automated testing frameworks.\nXP\u2019s test-first philosophy has now evolved into more general test-driven develop-\nment techniques (Jeffries and Melnik 2007). I believe that test-driven development is \none of the most important innovations in software engineering. Instead of writing code \nand then writing tests for that code, you write the tests before you write the code. This \n\n\n82  Chapter 3 \u25a0 Agile software development\nmeans that you can run the test as the code is being written and discover problems dur-\ning development. I discuss test-driven development in more depth in Chapter 8.\nWriting tests implicitly defines both an interface and a specification of behavior for \nthe functionality being developed. Problems of requirements and interface misunder-\nstandings are reduced. Test-first development requires there to be a clear relationship \nbetween system requirements and the code implementing the corresponding require-\nments. In XP, this relationship is clear because the story cards representing the require-\nments are broken down into tasks and the tasks are the principal unit of implementation.\nIn test-first development, the task implementers have to thoroughly understand \nthe specification so that they can write tests for the system. This means that ambi-\nguities and omissions in the specification have to be clarified before implementation \nbegins. Furthermore, it also avoids the problem of \u201ctest-lag.\u201d This may happen when \nthe developer of the system works at a faster pace than the tester. The implementa-\ntion gets further and further ahead of the testing and there is a tendency to skip tests, \nso that the development schedule can be maintained.\nXP\u2019s test-first approach assumes that user stories have been developed, and these \nhave been broken down into a set of task cards, as shown in Figure 3.6. Each task \ngenerates one or more unit tests that check the implementation described in that task. \nFigure 3.7 is a shortened description of a test case that has been developed to check \nthat the prescribed dose of a drug does not fall outside known safe limits.\nThe role of the customer in the testing process is to help develop acceptance tests \nfor the stories that are to be implemented in the next release of the system. As I \nexplain in Chapter 8, acceptance  testing is the process whereby the system is tested \nusing customer data to check that it meets the customer\u2019s real needs.\nTest automation is essential for test-first development. Tests are written as exe-\ncutable components before the task is implemented. These testing components \nshould be stand-alone, should simulate the submission of input to be tested, and \nshould check that the result meets the output specification. An automated test frame-\nwork is a system that makes it easy to write executable tests and submit a set of tests \nfor execution. Junit (Tahchiev et al. 2010) is a widely used example of an automated \ntesting framework for Java programs.\nInput:\n1.  A number in mg representing a single dose of the drug.\n2.  A number representing the number of single doses per day.\nTests:\n1.   Test for inputs where the single dose is correct but the frequency is too\nhigh.\n2.   Test for inputs where the single dose is too high and too low.\n3.   Test for inputs where the single dose * frequency is too high and too low.\n4.   Test for inputs where single dose * frequency is in the permitted range.\nOutput:\nOK or error message indicating that the dose is outside the safe range.\nTest 4: Dose checking\nFigure 3.7 Test case \ndescription for dose \nchecking"}
{"query": "What is the principle behind refactoring being part of the development process?", "response": "Refactoring is a principle in software development that involves improving the structure and readability of code. It is done to avoid the degradation of the software structure that occurs when code is changed or added to the system. By continuously refactoring the code, the software remains easy to understand and change as new requirements are proposed. This principle ensures that the software maintains a high level of quality and adaptability throughout the development process.", "context": "3.2  \u25a0 Agile development techniques  81\nthem immediately. When team members see code that can be improved, they make \nthese improvements even in situations where there is no immediate need for them.\nA fundamental problem of incremental development is that local changes tend to \ndegrade the software structure. Consequently, further changes to the software become \nharder and harder to implement. Essentially, the development proceeds by finding \nworkarounds to problems, with the result that code is often duplicated, parts of the \nsoftware are reused in inappropriate ways, and the overall structure degrades as code is \nadded to the system. Refactoring improves the software structure and readability and \nso avoids the structural deterioration that naturally occurs when software is changed.\nExamples of refactoring include the reorganization of a class hierarchy to remove \nduplicate code, the tidying up and renaming of attributes and methods, and the \nreplacement of similar code sections, with calls to methods defined in a program \nlibrary. Program development environments usually include tools for refactoring. \nThese simplify the process of finding dependencies between code sections and mak-\ning global code modifications.\nIn principle, when refactoring is part of the development process, the software \nshould always be easy to understand and change as new requirements are proposed. \nIn practice, this is not always the case. Sometimes development pressure means that \nrefactoring is delayed because the time is devoted to the implementation of new \nfunctionality. Some new features and changes cannot readily be accommodated by \ncode-level refactoring and require that the architecture of the system be modified.\n \n3.2.3  Test-first development\nAs I discussed in the introduction to this chapter, one of the important differences \nbetween incremental development and plan-driven development is in the way that \nthe system is tested. With incremental development, there is no system specification \nthat can be used by an external testing team to develop system tests. As a conse-\nquence, some approaches to incremental development have a very informal testing \nprocess, in comparison with plan-driven testing.\nExtreme Programming developed a new approach to program testing to address \nthe difficulties of testing without a specification. Testing is automated and is central \nto the development process, and development cannot proceed until all tests have \nbeen successfully executed. The key features of testing in XP are:\n1. test-first development,\n2. incremental test development from scenarios,\n3. user involvement in the test development and validation, and\n4. the use of automated testing frameworks.\nXP\u2019s test-first philosophy has now evolved into more general test-driven develop-\nment techniques (Jeffries and Melnik 2007). I believe that test-driven development is \none of the most important innovations in software engineering. Instead of writing code \nand then writing tests for that code, you write the tests before you write the code. This \n\n\n82  Chapter 3 \u25a0 Agile software development\nmeans that you can run the test as the code is being written and discover problems dur-\ning development. I discuss test-driven development in more depth in Chapter 8.\nWriting tests implicitly defines both an interface and a specification of behavior for \nthe functionality being developed. Problems of requirements and interface misunder-\nstandings are reduced. Test-first development requires there to be a clear relationship \nbetween system requirements and the code implementing the corresponding require-\nments. In XP, this relationship is clear because the story cards representing the require-\nments are broken down into tasks and the tasks are the principal unit of implementation.\nIn test-first development, the task implementers have to thoroughly understand \nthe specification so that they can write tests for the system. This means that ambi-\nguities and omissions in the specification have to be clarified before implementation \nbegins. Furthermore, it also avoids the problem of \u201ctest-lag.\u201d This may happen when \nthe developer of the system works at a faster pace than the tester. The implementa-\ntion gets further and further ahead of the testing and there is a tendency to skip tests, \nso that the development schedule can be maintained.\nXP\u2019s test-first approach assumes that user stories have been developed, and these \nhave been broken down into a set of task cards, as shown in Figure 3.6. Each task \ngenerates one or more unit tests that check the implementation described in that task. \nFigure 3.7 is a shortened description of a test case that has been developed to check \nthat the prescribed dose of a drug does not fall outside known safe limits.\nThe role of the customer in the testing process is to help develop acceptance tests \nfor the stories that are to be implemented in the next release of the system. As I \nexplain in Chapter 8, acceptance  testing is the process whereby the system is tested \nusing customer data to check that it meets the customer\u2019s real needs.\nTest automation is essential for test-first development. Tests are written as exe-\ncutable components before the task is implemented. These testing components \nshould be stand-alone, should simulate the submission of input to be tested, and \nshould check that the result meets the output specification. An automated test frame-\nwork is a system that makes it easy to write executable tests and submit a set of tests \nfor execution. Junit (Tahchiev et al. 2010) is a widely used example of an automated \ntesting framework for Java programs.\nInput:\n1.  A number in mg representing a single dose of the drug.\n2.  A number representing the number of single doses per day.\nTests:\n1.   Test for inputs where the single dose is correct but the frequency is too\nhigh.\n2.   Test for inputs where the single dose is too high and too low.\n3.   Test for inputs where the single dose * frequency is too high and too low.\n4.   Test for inputs where single dose * frequency is in the permitted range.\nOutput:\nOK or error message indicating that the dose is outside the safe range.\nTest 4: Dose checking\nFigure 3.7 Test case \ndescription for dose \nchecking"}
{"query": "What are some reasons why refactoring may be delayed in practice?", "response": "Development pressure and the focus on implementing new functionality are some reasons why refactoring may be delayed in practice.", "context": "3.2  \u25a0 Agile development techniques  81\nthem immediately. When team members see code that can be improved, they make \nthese improvements even in situations where there is no immediate need for them.\nA fundamental problem of incremental development is that local changes tend to \ndegrade the software structure. Consequently, further changes to the software become \nharder and harder to implement. Essentially, the development proceeds by finding \nworkarounds to problems, with the result that code is often duplicated, parts of the \nsoftware are reused in inappropriate ways, and the overall structure degrades as code is \nadded to the system. Refactoring improves the software structure and readability and \nso avoids the structural deterioration that naturally occurs when software is changed.\nExamples of refactoring include the reorganization of a class hierarchy to remove \nduplicate code, the tidying up and renaming of attributes and methods, and the \nreplacement of similar code sections, with calls to methods defined in a program \nlibrary. Program development environments usually include tools for refactoring. \nThese simplify the process of finding dependencies between code sections and mak-\ning global code modifications.\nIn principle, when refactoring is part of the development process, the software \nshould always be easy to understand and change as new requirements are proposed. \nIn practice, this is not always the case. Sometimes development pressure means that \nrefactoring is delayed because the time is devoted to the implementation of new \nfunctionality. Some new features and changes cannot readily be accommodated by \ncode-level refactoring and require that the architecture of the system be modified.\n \n3.2.3  Test-first development\nAs I discussed in the introduction to this chapter, one of the important differences \nbetween incremental development and plan-driven development is in the way that \nthe system is tested. With incremental development, there is no system specification \nthat can be used by an external testing team to develop system tests. As a conse-\nquence, some approaches to incremental development have a very informal testing \nprocess, in comparison with plan-driven testing.\nExtreme Programming developed a new approach to program testing to address \nthe difficulties of testing without a specification. Testing is automated and is central \nto the development process, and development cannot proceed until all tests have \nbeen successfully executed. The key features of testing in XP are:\n1. test-first development,\n2. incremental test development from scenarios,\n3. user involvement in the test development and validation, and\n4. the use of automated testing frameworks.\nXP\u2019s test-first philosophy has now evolved into more general test-driven develop-\nment techniques (Jeffries and Melnik 2007). I believe that test-driven development is \none of the most important innovations in software engineering. Instead of writing code \nand then writing tests for that code, you write the tests before you write the code. This \n\n\n82  Chapter 3 \u25a0 Agile software development\nmeans that you can run the test as the code is being written and discover problems dur-\ning development. I discuss test-driven development in more depth in Chapter 8.\nWriting tests implicitly defines both an interface and a specification of behavior for \nthe functionality being developed. Problems of requirements and interface misunder-\nstandings are reduced. Test-first development requires there to be a clear relationship \nbetween system requirements and the code implementing the corresponding require-\nments. In XP, this relationship is clear because the story cards representing the require-\nments are broken down into tasks and the tasks are the principal unit of implementation.\nIn test-first development, the task implementers have to thoroughly understand \nthe specification so that they can write tests for the system. This means that ambi-\nguities and omissions in the specification have to be clarified before implementation \nbegins. Furthermore, it also avoids the problem of \u201ctest-lag.\u201d This may happen when \nthe developer of the system works at a faster pace than the tester. The implementa-\ntion gets further and further ahead of the testing and there is a tendency to skip tests, \nso that the development schedule can be maintained.\nXP\u2019s test-first approach assumes that user stories have been developed, and these \nhave been broken down into a set of task cards, as shown in Figure 3.6. Each task \ngenerates one or more unit tests that check the implementation described in that task. \nFigure 3.7 is a shortened description of a test case that has been developed to check \nthat the prescribed dose of a drug does not fall outside known safe limits.\nThe role of the customer in the testing process is to help develop acceptance tests \nfor the stories that are to be implemented in the next release of the system. As I \nexplain in Chapter 8, acceptance  testing is the process whereby the system is tested \nusing customer data to check that it meets the customer\u2019s real needs.\nTest automation is essential for test-first development. Tests are written as exe-\ncutable components before the task is implemented. These testing components \nshould be stand-alone, should simulate the submission of input to be tested, and \nshould check that the result meets the output specification. An automated test frame-\nwork is a system that makes it easy to write executable tests and submit a set of tests \nfor execution. Junit (Tahchiev et al. 2010) is a widely used example of an automated \ntesting framework for Java programs.\nInput:\n1.  A number in mg representing a single dose of the drug.\n2.  A number representing the number of single doses per day.\nTests:\n1.   Test for inputs where the single dose is correct but the frequency is too\nhigh.\n2.   Test for inputs where the single dose is too high and too low.\n3.   Test for inputs where the single dose * frequency is too high and too low.\n4.   Test for inputs where single dose * frequency is in the permitted range.\nOutput:\nOK or error message indicating that the dose is outside the safe range.\nTest 4: Dose checking\nFigure 3.7 Test case \ndescription for dose \nchecking"}
{"query": "What is the test-first development approach?", "response": "The test-first development approach is a technique where tests are written before writing the actual code. This means that tests are run as the code is being written, allowing for the discovery of problems during development. This approach implicitly defines both an interface and a specification of behavior for the functionality being developed, reducing problems of requirements and interface misunderstandings. Test-first development requires a clear relationship between system requirements and the corresponding code implementation.", "context": "3.2  \u25a0 Agile development techniques  81\nthem immediately. When team members see code that can be improved, they make \nthese improvements even in situations where there is no immediate need for them.\nA fundamental problem of incremental development is that local changes tend to \ndegrade the software structure. Consequently, further changes to the software become \nharder and harder to implement. Essentially, the development proceeds by finding \nworkarounds to problems, with the result that code is often duplicated, parts of the \nsoftware are reused in inappropriate ways, and the overall structure degrades as code is \nadded to the system. Refactoring improves the software structure and readability and \nso avoids the structural deterioration that naturally occurs when software is changed.\nExamples of refactoring include the reorganization of a class hierarchy to remove \nduplicate code, the tidying up and renaming of attributes and methods, and the \nreplacement of similar code sections, with calls to methods defined in a program \nlibrary. Program development environments usually include tools for refactoring. \nThese simplify the process of finding dependencies between code sections and mak-\ning global code modifications.\nIn principle, when refactoring is part of the development process, the software \nshould always be easy to understand and change as new requirements are proposed. \nIn practice, this is not always the case. Sometimes development pressure means that \nrefactoring is delayed because the time is devoted to the implementation of new \nfunctionality. Some new features and changes cannot readily be accommodated by \ncode-level refactoring and require that the architecture of the system be modified.\n \n3.2.3  Test-first development\nAs I discussed in the introduction to this chapter, one of the important differences \nbetween incremental development and plan-driven development is in the way that \nthe system is tested. With incremental development, there is no system specification \nthat can be used by an external testing team to develop system tests. As a conse-\nquence, some approaches to incremental development have a very informal testing \nprocess, in comparison with plan-driven testing.\nExtreme Programming developed a new approach to program testing to address \nthe difficulties of testing without a specification. Testing is automated and is central \nto the development process, and development cannot proceed until all tests have \nbeen successfully executed. The key features of testing in XP are:\n1. test-first development,\n2. incremental test development from scenarios,\n3. user involvement in the test development and validation, and\n4. the use of automated testing frameworks.\nXP\u2019s test-first philosophy has now evolved into more general test-driven develop-\nment techniques (Jeffries and Melnik 2007). I believe that test-driven development is \none of the most important innovations in software engineering. Instead of writing code \nand then writing tests for that code, you write the tests before you write the code. This \n\n\n82  Chapter 3 \u25a0 Agile software development\nmeans that you can run the test as the code is being written and discover problems dur-\ning development. I discuss test-driven development in more depth in Chapter 8.\nWriting tests implicitly defines both an interface and a specification of behavior for \nthe functionality being developed. Problems of requirements and interface misunder-\nstandings are reduced. Test-first development requires there to be a clear relationship \nbetween system requirements and the code implementing the corresponding require-\nments. In XP, this relationship is clear because the story cards representing the require-\nments are broken down into tasks and the tasks are the principal unit of implementation.\nIn test-first development, the task implementers have to thoroughly understand \nthe specification so that they can write tests for the system. This means that ambi-\nguities and omissions in the specification have to be clarified before implementation \nbegins. Furthermore, it also avoids the problem of \u201ctest-lag.\u201d This may happen when \nthe developer of the system works at a faster pace than the tester. The implementa-\ntion gets further and further ahead of the testing and there is a tendency to skip tests, \nso that the development schedule can be maintained.\nXP\u2019s test-first approach assumes that user stories have been developed, and these \nhave been broken down into a set of task cards, as shown in Figure 3.6. Each task \ngenerates one or more unit tests that check the implementation described in that task. \nFigure 3.7 is a shortened description of a test case that has been developed to check \nthat the prescribed dose of a drug does not fall outside known safe limits.\nThe role of the customer in the testing process is to help develop acceptance tests \nfor the stories that are to be implemented in the next release of the system. As I \nexplain in Chapter 8, acceptance  testing is the process whereby the system is tested \nusing customer data to check that it meets the customer\u2019s real needs.\nTest automation is essential for test-first development. Tests are written as exe-\ncutable components before the task is implemented. These testing components \nshould be stand-alone, should simulate the submission of input to be tested, and \nshould check that the result meets the output specification. An automated test frame-\nwork is a system that makes it easy to write executable tests and submit a set of tests \nfor execution. Junit (Tahchiev et al. 2010) is a widely used example of an automated \ntesting framework for Java programs.\nInput:\n1.  A number in mg representing a single dose of the drug.\n2.  A number representing the number of single doses per day.\nTests:\n1.   Test for inputs where the single dose is correct but the frequency is too\nhigh.\n2.   Test for inputs where the single dose is too high and too low.\n3.   Test for inputs where the single dose * frequency is too high and too low.\n4.   Test for inputs where single dose * frequency is in the permitted range.\nOutput:\nOK or error message indicating that the dose is outside the safe range.\nTest 4: Dose checking\nFigure 3.7 Test case \ndescription for dose \nchecking"}
{"query": "What are the key features of testing in Extreme Programming?", "response": "The key features of testing in Extreme Programming (XP) are:\n1. Test-first development: Tests are written before the code is implemented, allowing for early detection of problems during development.\n2. Incremental test development from scenarios: Tests are developed incrementally based on specific scenarios or use cases.\n3. User involvement in test development and validation: Users actively participate in the test development process and validate the tests.\n4. Use of automated testing frameworks: XP emphasizes the use of automated testing frameworks, such as Junit, to facilitate the writing and execution of tests.", "context": "3.2  \u25a0 Agile development techniques  81\nthem immediately. When team members see code that can be improved, they make \nthese improvements even in situations where there is no immediate need for them.\nA fundamental problem of incremental development is that local changes tend to \ndegrade the software structure. Consequently, further changes to the software become \nharder and harder to implement. Essentially, the development proceeds by finding \nworkarounds to problems, with the result that code is often duplicated, parts of the \nsoftware are reused in inappropriate ways, and the overall structure degrades as code is \nadded to the system. Refactoring improves the software structure and readability and \nso avoids the structural deterioration that naturally occurs when software is changed.\nExamples of refactoring include the reorganization of a class hierarchy to remove \nduplicate code, the tidying up and renaming of attributes and methods, and the \nreplacement of similar code sections, with calls to methods defined in a program \nlibrary. Program development environments usually include tools for refactoring. \nThese simplify the process of finding dependencies between code sections and mak-\ning global code modifications.\nIn principle, when refactoring is part of the development process, the software \nshould always be easy to understand and change as new requirements are proposed. \nIn practice, this is not always the case. Sometimes development pressure means that \nrefactoring is delayed because the time is devoted to the implementation of new \nfunctionality. Some new features and changes cannot readily be accommodated by \ncode-level refactoring and require that the architecture of the system be modified.\n \n3.2.3  Test-first development\nAs I discussed in the introduction to this chapter, one of the important differences \nbetween incremental development and plan-driven development is in the way that \nthe system is tested. With incremental development, there is no system specification \nthat can be used by an external testing team to develop system tests. As a conse-\nquence, some approaches to incremental development have a very informal testing \nprocess, in comparison with plan-driven testing.\nExtreme Programming developed a new approach to program testing to address \nthe difficulties of testing without a specification. Testing is automated and is central \nto the development process, and development cannot proceed until all tests have \nbeen successfully executed. The key features of testing in XP are:\n1. test-first development,\n2. incremental test development from scenarios,\n3. user involvement in the test development and validation, and\n4. the use of automated testing frameworks.\nXP\u2019s test-first philosophy has now evolved into more general test-driven develop-\nment techniques (Jeffries and Melnik 2007). I believe that test-driven development is \none of the most important innovations in software engineering. Instead of writing code \nand then writing tests for that code, you write the tests before you write the code. This \n\n\n82  Chapter 3 \u25a0 Agile software development\nmeans that you can run the test as the code is being written and discover problems dur-\ning development. I discuss test-driven development in more depth in Chapter 8.\nWriting tests implicitly defines both an interface and a specification of behavior for \nthe functionality being developed. Problems of requirements and interface misunder-\nstandings are reduced. Test-first development requires there to be a clear relationship \nbetween system requirements and the code implementing the corresponding require-\nments. In XP, this relationship is clear because the story cards representing the require-\nments are broken down into tasks and the tasks are the principal unit of implementation.\nIn test-first development, the task implementers have to thoroughly understand \nthe specification so that they can write tests for the system. This means that ambi-\nguities and omissions in the specification have to be clarified before implementation \nbegins. Furthermore, it also avoids the problem of \u201ctest-lag.\u201d This may happen when \nthe developer of the system works at a faster pace than the tester. The implementa-\ntion gets further and further ahead of the testing and there is a tendency to skip tests, \nso that the development schedule can be maintained.\nXP\u2019s test-first approach assumes that user stories have been developed, and these \nhave been broken down into a set of task cards, as shown in Figure 3.6. Each task \ngenerates one or more unit tests that check the implementation described in that task. \nFigure 3.7 is a shortened description of a test case that has been developed to check \nthat the prescribed dose of a drug does not fall outside known safe limits.\nThe role of the customer in the testing process is to help develop acceptance tests \nfor the stories that are to be implemented in the next release of the system. As I \nexplain in Chapter 8, acceptance  testing is the process whereby the system is tested \nusing customer data to check that it meets the customer\u2019s real needs.\nTest automation is essential for test-first development. Tests are written as exe-\ncutable components before the task is implemented. These testing components \nshould be stand-alone, should simulate the submission of input to be tested, and \nshould check that the result meets the output specification. An automated test frame-\nwork is a system that makes it easy to write executable tests and submit a set of tests \nfor execution. Junit (Tahchiev et al. 2010) is a widely used example of an automated \ntesting framework for Java programs.\nInput:\n1.  A number in mg representing a single dose of the drug.\n2.  A number representing the number of single doses per day.\nTests:\n1.   Test for inputs where the single dose is correct but the frequency is too\nhigh.\n2.   Test for inputs where the single dose is too high and too low.\n3.   Test for inputs where the single dose * frequency is too high and too low.\n4.   Test for inputs where single dose * frequency is in the permitted range.\nOutput:\nOK or error message indicating that the dose is outside the safe range.\nTest 4: Dose checking\nFigure 3.7 Test case \ndescription for dose \nchecking"}
{"query": "What is the order of operations in test-first development?", "response": "The order of operations in test-first development is as follows:\n1. Write tests for the functionality being developed.\n2. Run the tests to discover any problems during development.\n3. Clarify any ambiguities or omissions in the specification before implementation begins.\n4. Implement the code based on the tests and the specification.\n5. Submit the tests for execution using an automated testing framework.\n6. Check that the results of the tests meet the output specification.\n7. Repeat the process for each task or functionality being developed.", "context": "3.2  \u25a0 Agile development techniques  81\nthem immediately. When team members see code that can be improved, they make \nthese improvements even in situations where there is no immediate need for them.\nA fundamental problem of incremental development is that local changes tend to \ndegrade the software structure. Consequently, further changes to the software become \nharder and harder to implement. Essentially, the development proceeds by finding \nworkarounds to problems, with the result that code is often duplicated, parts of the \nsoftware are reused in inappropriate ways, and the overall structure degrades as code is \nadded to the system. Refactoring improves the software structure and readability and \nso avoids the structural deterioration that naturally occurs when software is changed.\nExamples of refactoring include the reorganization of a class hierarchy to remove \nduplicate code, the tidying up and renaming of attributes and methods, and the \nreplacement of similar code sections, with calls to methods defined in a program \nlibrary. Program development environments usually include tools for refactoring. \nThese simplify the process of finding dependencies between code sections and mak-\ning global code modifications.\nIn principle, when refactoring is part of the development process, the software \nshould always be easy to understand and change as new requirements are proposed. \nIn practice, this is not always the case. Sometimes development pressure means that \nrefactoring is delayed because the time is devoted to the implementation of new \nfunctionality. Some new features and changes cannot readily be accommodated by \ncode-level refactoring and require that the architecture of the system be modified.\n \n3.2.3  Test-first development\nAs I discussed in the introduction to this chapter, one of the important differences \nbetween incremental development and plan-driven development is in the way that \nthe system is tested. With incremental development, there is no system specification \nthat can be used by an external testing team to develop system tests. As a conse-\nquence, some approaches to incremental development have a very informal testing \nprocess, in comparison with plan-driven testing.\nExtreme Programming developed a new approach to program testing to address \nthe difficulties of testing without a specification. Testing is automated and is central \nto the development process, and development cannot proceed until all tests have \nbeen successfully executed. The key features of testing in XP are:\n1. test-first development,\n2. incremental test development from scenarios,\n3. user involvement in the test development and validation, and\n4. the use of automated testing frameworks.\nXP\u2019s test-first philosophy has now evolved into more general test-driven develop-\nment techniques (Jeffries and Melnik 2007). I believe that test-driven development is \none of the most important innovations in software engineering. Instead of writing code \nand then writing tests for that code, you write the tests before you write the code. This \n\n\n82  Chapter 3 \u25a0 Agile software development\nmeans that you can run the test as the code is being written and discover problems dur-\ning development. I discuss test-driven development in more depth in Chapter 8.\nWriting tests implicitly defines both an interface and a specification of behavior for \nthe functionality being developed. Problems of requirements and interface misunder-\nstandings are reduced. Test-first development requires there to be a clear relationship \nbetween system requirements and the code implementing the corresponding require-\nments. In XP, this relationship is clear because the story cards representing the require-\nments are broken down into tasks and the tasks are the principal unit of implementation.\nIn test-first development, the task implementers have to thoroughly understand \nthe specification so that they can write tests for the system. This means that ambi-\nguities and omissions in the specification have to be clarified before implementation \nbegins. Furthermore, it also avoids the problem of \u201ctest-lag.\u201d This may happen when \nthe developer of the system works at a faster pace than the tester. The implementa-\ntion gets further and further ahead of the testing and there is a tendency to skip tests, \nso that the development schedule can be maintained.\nXP\u2019s test-first approach assumes that user stories have been developed, and these \nhave been broken down into a set of task cards, as shown in Figure 3.6. Each task \ngenerates one or more unit tests that check the implementation described in that task. \nFigure 3.7 is a shortened description of a test case that has been developed to check \nthat the prescribed dose of a drug does not fall outside known safe limits.\nThe role of the customer in the testing process is to help develop acceptance tests \nfor the stories that are to be implemented in the next release of the system. As I \nexplain in Chapter 8, acceptance  testing is the process whereby the system is tested \nusing customer data to check that it meets the customer\u2019s real needs.\nTest automation is essential for test-first development. Tests are written as exe-\ncutable components before the task is implemented. These testing components \nshould be stand-alone, should simulate the submission of input to be tested, and \nshould check that the result meets the output specification. An automated test frame-\nwork is a system that makes it easy to write executable tests and submit a set of tests \nfor execution. Junit (Tahchiev et al. 2010) is a widely used example of an automated \ntesting framework for Java programs.\nInput:\n1.  A number in mg representing a single dose of the drug.\n2.  A number representing the number of single doses per day.\nTests:\n1.   Test for inputs where the single dose is correct but the frequency is too\nhigh.\n2.   Test for inputs where the single dose is too high and too low.\n3.   Test for inputs where the single dose * frequency is too high and too low.\n4.   Test for inputs where single dose * frequency is in the permitted range.\nOutput:\nOK or error message indicating that the dose is outside the safe range.\nTest 4: Dose checking\nFigure 3.7 Test case \ndescription for dose \nchecking"}
{"query": "How does writing tests before writing code benefit the development process?", "response": "Writing tests before writing code benefits the development process by allowing developers to run the tests as the code is being written. This helps in discovering problems and bugs during the development phase itself. By writing tests first, developers implicitly define the interface and behavior of the functionality being developed, reducing problems of requirements and interface misunderstandings. It also ensures that there is a clear relationship between system requirements and the code implementing those requirements. Writing tests before writing code also helps in clarifying any ambiguities or omissions in the specification before implementation begins. Additionally, it helps in avoiding the problem of \"test-lag\" where the development pace is faster than the testing pace, leading to skipped tests. Overall, writing tests before writing code improves the quality and reliability of the software being developed.", "context": "3.2  \u25a0 Agile development techniques  81\nthem immediately. When team members see code that can be improved, they make \nthese improvements even in situations where there is no immediate need for them.\nA fundamental problem of incremental development is that local changes tend to \ndegrade the software structure. Consequently, further changes to the software become \nharder and harder to implement. Essentially, the development proceeds by finding \nworkarounds to problems, with the result that code is often duplicated, parts of the \nsoftware are reused in inappropriate ways, and the overall structure degrades as code is \nadded to the system. Refactoring improves the software structure and readability and \nso avoids the structural deterioration that naturally occurs when software is changed.\nExamples of refactoring include the reorganization of a class hierarchy to remove \nduplicate code, the tidying up and renaming of attributes and methods, and the \nreplacement of similar code sections, with calls to methods defined in a program \nlibrary. Program development environments usually include tools for refactoring. \nThese simplify the process of finding dependencies between code sections and mak-\ning global code modifications.\nIn principle, when refactoring is part of the development process, the software \nshould always be easy to understand and change as new requirements are proposed. \nIn practice, this is not always the case. Sometimes development pressure means that \nrefactoring is delayed because the time is devoted to the implementation of new \nfunctionality. Some new features and changes cannot readily be accommodated by \ncode-level refactoring and require that the architecture of the system be modified.\n \n3.2.3  Test-first development\nAs I discussed in the introduction to this chapter, one of the important differences \nbetween incremental development and plan-driven development is in the way that \nthe system is tested. With incremental development, there is no system specification \nthat can be used by an external testing team to develop system tests. As a conse-\nquence, some approaches to incremental development have a very informal testing \nprocess, in comparison with plan-driven testing.\nExtreme Programming developed a new approach to program testing to address \nthe difficulties of testing without a specification. Testing is automated and is central \nto the development process, and development cannot proceed until all tests have \nbeen successfully executed. The key features of testing in XP are:\n1. test-first development,\n2. incremental test development from scenarios,\n3. user involvement in the test development and validation, and\n4. the use of automated testing frameworks.\nXP\u2019s test-first philosophy has now evolved into more general test-driven develop-\nment techniques (Jeffries and Melnik 2007). I believe that test-driven development is \none of the most important innovations in software engineering. Instead of writing code \nand then writing tests for that code, you write the tests before you write the code. This \n\n\n82  Chapter 3 \u25a0 Agile software development\nmeans that you can run the test as the code is being written and discover problems dur-\ning development. I discuss test-driven development in more depth in Chapter 8.\nWriting tests implicitly defines both an interface and a specification of behavior for \nthe functionality being developed. Problems of requirements and interface misunder-\nstandings are reduced. Test-first development requires there to be a clear relationship \nbetween system requirements and the code implementing the corresponding require-\nments. In XP, this relationship is clear because the story cards representing the require-\nments are broken down into tasks and the tasks are the principal unit of implementation.\nIn test-first development, the task implementers have to thoroughly understand \nthe specification so that they can write tests for the system. This means that ambi-\nguities and omissions in the specification have to be clarified before implementation \nbegins. Furthermore, it also avoids the problem of \u201ctest-lag.\u201d This may happen when \nthe developer of the system works at a faster pace than the tester. The implementa-\ntion gets further and further ahead of the testing and there is a tendency to skip tests, \nso that the development schedule can be maintained.\nXP\u2019s test-first approach assumes that user stories have been developed, and these \nhave been broken down into a set of task cards, as shown in Figure 3.6. Each task \ngenerates one or more unit tests that check the implementation described in that task. \nFigure 3.7 is a shortened description of a test case that has been developed to check \nthat the prescribed dose of a drug does not fall outside known safe limits.\nThe role of the customer in the testing process is to help develop acceptance tests \nfor the stories that are to be implemented in the next release of the system. As I \nexplain in Chapter 8, acceptance  testing is the process whereby the system is tested \nusing customer data to check that it meets the customer\u2019s real needs.\nTest automation is essential for test-first development. Tests are written as exe-\ncutable components before the task is implemented. These testing components \nshould be stand-alone, should simulate the submission of input to be tested, and \nshould check that the result meets the output specification. An automated test frame-\nwork is a system that makes it easy to write executable tests and submit a set of tests \nfor execution. Junit (Tahchiev et al. 2010) is a widely used example of an automated \ntesting framework for Java programs.\nInput:\n1.  A number in mg representing a single dose of the drug.\n2.  A number representing the number of single doses per day.\nTests:\n1.   Test for inputs where the single dose is correct but the frequency is too\nhigh.\n2.   Test for inputs where the single dose is too high and too low.\n3.   Test for inputs where the single dose * frequency is too high and too low.\n4.   Test for inputs where single dose * frequency is in the permitted range.\nOutput:\nOK or error message indicating that the dose is outside the safe range.\nTest 4: Dose checking\nFigure 3.7 Test case \ndescription for dose \nchecking"}
{"query": "What is the relationship between system requirements and the code implementing the corresponding requirements in XP?", "response": "In XP (Extreme Programming), there is a clear relationship between system requirements and the code implementing the corresponding requirements. The story cards representing the requirements are broken down into tasks, and the tasks are the principal unit of implementation. This means that the task implementers in XP have to thoroughly understand the specification so that they can write tests for the system. This helps reduce ambiguities and omissions in the specification before implementation begins.", "context": "3.2  \u25a0 Agile development techniques  81\nthem immediately. When team members see code that can be improved, they make \nthese improvements even in situations where there is no immediate need for them.\nA fundamental problem of incremental development is that local changes tend to \ndegrade the software structure. Consequently, further changes to the software become \nharder and harder to implement. Essentially, the development proceeds by finding \nworkarounds to problems, with the result that code is often duplicated, parts of the \nsoftware are reused in inappropriate ways, and the overall structure degrades as code is \nadded to the system. Refactoring improves the software structure and readability and \nso avoids the structural deterioration that naturally occurs when software is changed.\nExamples of refactoring include the reorganization of a class hierarchy to remove \nduplicate code, the tidying up and renaming of attributes and methods, and the \nreplacement of similar code sections, with calls to methods defined in a program \nlibrary. Program development environments usually include tools for refactoring. \nThese simplify the process of finding dependencies between code sections and mak-\ning global code modifications.\nIn principle, when refactoring is part of the development process, the software \nshould always be easy to understand and change as new requirements are proposed. \nIn practice, this is not always the case. Sometimes development pressure means that \nrefactoring is delayed because the time is devoted to the implementation of new \nfunctionality. Some new features and changes cannot readily be accommodated by \ncode-level refactoring and require that the architecture of the system be modified.\n \n3.2.3  Test-first development\nAs I discussed in the introduction to this chapter, one of the important differences \nbetween incremental development and plan-driven development is in the way that \nthe system is tested. With incremental development, there is no system specification \nthat can be used by an external testing team to develop system tests. As a conse-\nquence, some approaches to incremental development have a very informal testing \nprocess, in comparison with plan-driven testing.\nExtreme Programming developed a new approach to program testing to address \nthe difficulties of testing without a specification. Testing is automated and is central \nto the development process, and development cannot proceed until all tests have \nbeen successfully executed. The key features of testing in XP are:\n1. test-first development,\n2. incremental test development from scenarios,\n3. user involvement in the test development and validation, and\n4. the use of automated testing frameworks.\nXP\u2019s test-first philosophy has now evolved into more general test-driven develop-\nment techniques (Jeffries and Melnik 2007). I believe that test-driven development is \none of the most important innovations in software engineering. Instead of writing code \nand then writing tests for that code, you write the tests before you write the code. This \n\n\n82  Chapter 3 \u25a0 Agile software development\nmeans that you can run the test as the code is being written and discover problems dur-\ning development. I discuss test-driven development in more depth in Chapter 8.\nWriting tests implicitly defines both an interface and a specification of behavior for \nthe functionality being developed. Problems of requirements and interface misunder-\nstandings are reduced. Test-first development requires there to be a clear relationship \nbetween system requirements and the code implementing the corresponding require-\nments. In XP, this relationship is clear because the story cards representing the require-\nments are broken down into tasks and the tasks are the principal unit of implementation.\nIn test-first development, the task implementers have to thoroughly understand \nthe specification so that they can write tests for the system. This means that ambi-\nguities and omissions in the specification have to be clarified before implementation \nbegins. Furthermore, it also avoids the problem of \u201ctest-lag.\u201d This may happen when \nthe developer of the system works at a faster pace than the tester. The implementa-\ntion gets further and further ahead of the testing and there is a tendency to skip tests, \nso that the development schedule can be maintained.\nXP\u2019s test-first approach assumes that user stories have been developed, and these \nhave been broken down into a set of task cards, as shown in Figure 3.6. Each task \ngenerates one or more unit tests that check the implementation described in that task. \nFigure 3.7 is a shortened description of a test case that has been developed to check \nthat the prescribed dose of a drug does not fall outside known safe limits.\nThe role of the customer in the testing process is to help develop acceptance tests \nfor the stories that are to be implemented in the next release of the system. As I \nexplain in Chapter 8, acceptance  testing is the process whereby the system is tested \nusing customer data to check that it meets the customer\u2019s real needs.\nTest automation is essential for test-first development. Tests are written as exe-\ncutable components before the task is implemented. These testing components \nshould be stand-alone, should simulate the submission of input to be tested, and \nshould check that the result meets the output specification. An automated test frame-\nwork is a system that makes it easy to write executable tests and submit a set of tests \nfor execution. Junit (Tahchiev et al. 2010) is a widely used example of an automated \ntesting framework for Java programs.\nInput:\n1.  A number in mg representing a single dose of the drug.\n2.  A number representing the number of single doses per day.\nTests:\n1.   Test for inputs where the single dose is correct but the frequency is too\nhigh.\n2.   Test for inputs where the single dose is too high and too low.\n3.   Test for inputs where the single dose * frequency is too high and too low.\n4.   Test for inputs where single dose * frequency is in the permitted range.\nOutput:\nOK or error message indicating that the dose is outside the safe range.\nTest 4: Dose checking\nFigure 3.7 Test case \ndescription for dose \nchecking"}
{"query": "What is the role of task implementers in test-first development?", "response": "The role of task implementers in test-first development is to thoroughly understand the specification of the system requirements so that they can write tests for the system. They are responsible for writing the tests before writing the code and ensuring that there is a clear relationship between the system requirements and the corresponding code implementation. This helps clarify any ambiguities or omissions in the specification before implementation begins and avoids the problem of \"test-lag\" where the development gets ahead of testing.", "context": "3.2  \u25a0 Agile development techniques  81\nthem immediately. When team members see code that can be improved, they make \nthese improvements even in situations where there is no immediate need for them.\nA fundamental problem of incremental development is that local changes tend to \ndegrade the software structure. Consequently, further changes to the software become \nharder and harder to implement. Essentially, the development proceeds by finding \nworkarounds to problems, with the result that code is often duplicated, parts of the \nsoftware are reused in inappropriate ways, and the overall structure degrades as code is \nadded to the system. Refactoring improves the software structure and readability and \nso avoids the structural deterioration that naturally occurs when software is changed.\nExamples of refactoring include the reorganization of a class hierarchy to remove \nduplicate code, the tidying up and renaming of attributes and methods, and the \nreplacement of similar code sections, with calls to methods defined in a program \nlibrary. Program development environments usually include tools for refactoring. \nThese simplify the process of finding dependencies between code sections and mak-\ning global code modifications.\nIn principle, when refactoring is part of the development process, the software \nshould always be easy to understand and change as new requirements are proposed. \nIn practice, this is not always the case. Sometimes development pressure means that \nrefactoring is delayed because the time is devoted to the implementation of new \nfunctionality. Some new features and changes cannot readily be accommodated by \ncode-level refactoring and require that the architecture of the system be modified.\n \n3.2.3  Test-first development\nAs I discussed in the introduction to this chapter, one of the important differences \nbetween incremental development and plan-driven development is in the way that \nthe system is tested. With incremental development, there is no system specification \nthat can be used by an external testing team to develop system tests. As a conse-\nquence, some approaches to incremental development have a very informal testing \nprocess, in comparison with plan-driven testing.\nExtreme Programming developed a new approach to program testing to address \nthe difficulties of testing without a specification. Testing is automated and is central \nto the development process, and development cannot proceed until all tests have \nbeen successfully executed. The key features of testing in XP are:\n1. test-first development,\n2. incremental test development from scenarios,\n3. user involvement in the test development and validation, and\n4. the use of automated testing frameworks.\nXP\u2019s test-first philosophy has now evolved into more general test-driven develop-\nment techniques (Jeffries and Melnik 2007). I believe that test-driven development is \none of the most important innovations in software engineering. Instead of writing code \nand then writing tests for that code, you write the tests before you write the code. This \n\n\n82  Chapter 3 \u25a0 Agile software development\nmeans that you can run the test as the code is being written and discover problems dur-\ning development. I discuss test-driven development in more depth in Chapter 8.\nWriting tests implicitly defines both an interface and a specification of behavior for \nthe functionality being developed. Problems of requirements and interface misunder-\nstandings are reduced. Test-first development requires there to be a clear relationship \nbetween system requirements and the code implementing the corresponding require-\nments. In XP, this relationship is clear because the story cards representing the require-\nments are broken down into tasks and the tasks are the principal unit of implementation.\nIn test-first development, the task implementers have to thoroughly understand \nthe specification so that they can write tests for the system. This means that ambi-\nguities and omissions in the specification have to be clarified before implementation \nbegins. Furthermore, it also avoids the problem of \u201ctest-lag.\u201d This may happen when \nthe developer of the system works at a faster pace than the tester. The implementa-\ntion gets further and further ahead of the testing and there is a tendency to skip tests, \nso that the development schedule can be maintained.\nXP\u2019s test-first approach assumes that user stories have been developed, and these \nhave been broken down into a set of task cards, as shown in Figure 3.6. Each task \ngenerates one or more unit tests that check the implementation described in that task. \nFigure 3.7 is a shortened description of a test case that has been developed to check \nthat the prescribed dose of a drug does not fall outside known safe limits.\nThe role of the customer in the testing process is to help develop acceptance tests \nfor the stories that are to be implemented in the next release of the system. As I \nexplain in Chapter 8, acceptance  testing is the process whereby the system is tested \nusing customer data to check that it meets the customer\u2019s real needs.\nTest automation is essential for test-first development. Tests are written as exe-\ncutable components before the task is implemented. These testing components \nshould be stand-alone, should simulate the submission of input to be tested, and \nshould check that the result meets the output specification. An automated test frame-\nwork is a system that makes it easy to write executable tests and submit a set of tests \nfor execution. Junit (Tahchiev et al. 2010) is a widely used example of an automated \ntesting framework for Java programs.\nInput:\n1.  A number in mg representing a single dose of the drug.\n2.  A number representing the number of single doses per day.\nTests:\n1.   Test for inputs where the single dose is correct but the frequency is too\nhigh.\n2.   Test for inputs where the single dose is too high and too low.\n3.   Test for inputs where the single dose * frequency is too high and too low.\n4.   Test for inputs where single dose * frequency is in the permitted range.\nOutput:\nOK or error message indicating that the dose is outside the safe range.\nTest 4: Dose checking\nFigure 3.7 Test case \ndescription for dose \nchecking"}
{"query": "What is the problem of \"test-lag\" and how can it be avoided?", "response": "The problem of \"test-lag\" refers to a situation where the development of the system progresses at a faster pace than the testing process. This can lead to the implementation getting further ahead of the testing, resulting in a tendency to skip tests in order to maintain the development schedule. \n\nTo avoid test-lag, it is important to follow the test-first development approach. In this approach, tests are written before the code is implemented. This ensures that tests are an integral part of the development process and that they are executed as the code is being written. By writing tests first, any problems or issues can be identified and addressed during the development phase, reducing the likelihood of test-lag. Additionally, involving the customer in the testing process and developing acceptance tests based on customer needs can help ensure that the system is thoroughly tested and meets the required specifications.", "context": "3.2  \u25a0 Agile development techniques  81\nthem immediately. When team members see code that can be improved, they make \nthese improvements even in situations where there is no immediate need for them.\nA fundamental problem of incremental development is that local changes tend to \ndegrade the software structure. Consequently, further changes to the software become \nharder and harder to implement. Essentially, the development proceeds by finding \nworkarounds to problems, with the result that code is often duplicated, parts of the \nsoftware are reused in inappropriate ways, and the overall structure degrades as code is \nadded to the system. Refactoring improves the software structure and readability and \nso avoids the structural deterioration that naturally occurs when software is changed.\nExamples of refactoring include the reorganization of a class hierarchy to remove \nduplicate code, the tidying up and renaming of attributes and methods, and the \nreplacement of similar code sections, with calls to methods defined in a program \nlibrary. Program development environments usually include tools for refactoring. \nThese simplify the process of finding dependencies between code sections and mak-\ning global code modifications.\nIn principle, when refactoring is part of the development process, the software \nshould always be easy to understand and change as new requirements are proposed. \nIn practice, this is not always the case. Sometimes development pressure means that \nrefactoring is delayed because the time is devoted to the implementation of new \nfunctionality. Some new features and changes cannot readily be accommodated by \ncode-level refactoring and require that the architecture of the system be modified.\n \n3.2.3  Test-first development\nAs I discussed in the introduction to this chapter, one of the important differences \nbetween incremental development and plan-driven development is in the way that \nthe system is tested. With incremental development, there is no system specification \nthat can be used by an external testing team to develop system tests. As a conse-\nquence, some approaches to incremental development have a very informal testing \nprocess, in comparison with plan-driven testing.\nExtreme Programming developed a new approach to program testing to address \nthe difficulties of testing without a specification. Testing is automated and is central \nto the development process, and development cannot proceed until all tests have \nbeen successfully executed. The key features of testing in XP are:\n1. test-first development,\n2. incremental test development from scenarios,\n3. user involvement in the test development and validation, and\n4. the use of automated testing frameworks.\nXP\u2019s test-first philosophy has now evolved into more general test-driven develop-\nment techniques (Jeffries and Melnik 2007). I believe that test-driven development is \none of the most important innovations in software engineering. Instead of writing code \nand then writing tests for that code, you write the tests before you write the code. This \n\n\n82  Chapter 3 \u25a0 Agile software development\nmeans that you can run the test as the code is being written and discover problems dur-\ning development. I discuss test-driven development in more depth in Chapter 8.\nWriting tests implicitly defines both an interface and a specification of behavior for \nthe functionality being developed. Problems of requirements and interface misunder-\nstandings are reduced. Test-first development requires there to be a clear relationship \nbetween system requirements and the code implementing the corresponding require-\nments. In XP, this relationship is clear because the story cards representing the require-\nments are broken down into tasks and the tasks are the principal unit of implementation.\nIn test-first development, the task implementers have to thoroughly understand \nthe specification so that they can write tests for the system. This means that ambi-\nguities and omissions in the specification have to be clarified before implementation \nbegins. Furthermore, it also avoids the problem of \u201ctest-lag.\u201d This may happen when \nthe developer of the system works at a faster pace than the tester. The implementa-\ntion gets further and further ahead of the testing and there is a tendency to skip tests, \nso that the development schedule can be maintained.\nXP\u2019s test-first approach assumes that user stories have been developed, and these \nhave been broken down into a set of task cards, as shown in Figure 3.6. Each task \ngenerates one or more unit tests that check the implementation described in that task. \nFigure 3.7 is a shortened description of a test case that has been developed to check \nthat the prescribed dose of a drug does not fall outside known safe limits.\nThe role of the customer in the testing process is to help develop acceptance tests \nfor the stories that are to be implemented in the next release of the system. As I \nexplain in Chapter 8, acceptance  testing is the process whereby the system is tested \nusing customer data to check that it meets the customer\u2019s real needs.\nTest automation is essential for test-first development. Tests are written as exe-\ncutable components before the task is implemented. These testing components \nshould be stand-alone, should simulate the submission of input to be tested, and \nshould check that the result meets the output specification. An automated test frame-\nwork is a system that makes it easy to write executable tests and submit a set of tests \nfor execution. Junit (Tahchiev et al. 2010) is a widely used example of an automated \ntesting framework for Java programs.\nInput:\n1.  A number in mg representing a single dose of the drug.\n2.  A number representing the number of single doses per day.\nTests:\n1.   Test for inputs where the single dose is correct but the frequency is too\nhigh.\n2.   Test for inputs where the single dose is too high and too low.\n3.   Test for inputs where the single dose * frequency is too high and too low.\n4.   Test for inputs where single dose * frequency is in the permitted range.\nOutput:\nOK or error message indicating that the dose is outside the safe range.\nTest 4: Dose checking\nFigure 3.7 Test case \ndescription for dose \nchecking"}
{"query": "What is the role of the customer in the testing process?", "response": "The role of the customer in the testing process is to help develop acceptance tests for the stories that are to be implemented in the next release of the system. Acceptance testing is the process whereby the system is tested using customer data to check that it meets the customer's real needs.", "context": "3.2  \u25a0 Agile development techniques  81\nthem immediately. When team members see code that can be improved, they make \nthese improvements even in situations where there is no immediate need for them.\nA fundamental problem of incremental development is that local changes tend to \ndegrade the software structure. Consequently, further changes to the software become \nharder and harder to implement. Essentially, the development proceeds by finding \nworkarounds to problems, with the result that code is often duplicated, parts of the \nsoftware are reused in inappropriate ways, and the overall structure degrades as code is \nadded to the system. Refactoring improves the software structure and readability and \nso avoids the structural deterioration that naturally occurs when software is changed.\nExamples of refactoring include the reorganization of a class hierarchy to remove \nduplicate code, the tidying up and renaming of attributes and methods, and the \nreplacement of similar code sections, with calls to methods defined in a program \nlibrary. Program development environments usually include tools for refactoring. \nThese simplify the process of finding dependencies between code sections and mak-\ning global code modifications.\nIn principle, when refactoring is part of the development process, the software \nshould always be easy to understand and change as new requirements are proposed. \nIn practice, this is not always the case. Sometimes development pressure means that \nrefactoring is delayed because the time is devoted to the implementation of new \nfunctionality. Some new features and changes cannot readily be accommodated by \ncode-level refactoring and require that the architecture of the system be modified.\n \n3.2.3  Test-first development\nAs I discussed in the introduction to this chapter, one of the important differences \nbetween incremental development and plan-driven development is in the way that \nthe system is tested. With incremental development, there is no system specification \nthat can be used by an external testing team to develop system tests. As a conse-\nquence, some approaches to incremental development have a very informal testing \nprocess, in comparison with plan-driven testing.\nExtreme Programming developed a new approach to program testing to address \nthe difficulties of testing without a specification. Testing is automated and is central \nto the development process, and development cannot proceed until all tests have \nbeen successfully executed. The key features of testing in XP are:\n1. test-first development,\n2. incremental test development from scenarios,\n3. user involvement in the test development and validation, and\n4. the use of automated testing frameworks.\nXP\u2019s test-first philosophy has now evolved into more general test-driven develop-\nment techniques (Jeffries and Melnik 2007). I believe that test-driven development is \none of the most important innovations in software engineering. Instead of writing code \nand then writing tests for that code, you write the tests before you write the code. This \n\n\n82  Chapter 3 \u25a0 Agile software development\nmeans that you can run the test as the code is being written and discover problems dur-\ning development. I discuss test-driven development in more depth in Chapter 8.\nWriting tests implicitly defines both an interface and a specification of behavior for \nthe functionality being developed. Problems of requirements and interface misunder-\nstandings are reduced. Test-first development requires there to be a clear relationship \nbetween system requirements and the code implementing the corresponding require-\nments. In XP, this relationship is clear because the story cards representing the require-\nments are broken down into tasks and the tasks are the principal unit of implementation.\nIn test-first development, the task implementers have to thoroughly understand \nthe specification so that they can write tests for the system. This means that ambi-\nguities and omissions in the specification have to be clarified before implementation \nbegins. Furthermore, it also avoids the problem of \u201ctest-lag.\u201d This may happen when \nthe developer of the system works at a faster pace than the tester. The implementa-\ntion gets further and further ahead of the testing and there is a tendency to skip tests, \nso that the development schedule can be maintained.\nXP\u2019s test-first approach assumes that user stories have been developed, and these \nhave been broken down into a set of task cards, as shown in Figure 3.6. Each task \ngenerates one or more unit tests that check the implementation described in that task. \nFigure 3.7 is a shortened description of a test case that has been developed to check \nthat the prescribed dose of a drug does not fall outside known safe limits.\nThe role of the customer in the testing process is to help develop acceptance tests \nfor the stories that are to be implemented in the next release of the system. As I \nexplain in Chapter 8, acceptance  testing is the process whereby the system is tested \nusing customer data to check that it meets the customer\u2019s real needs.\nTest automation is essential for test-first development. Tests are written as exe-\ncutable components before the task is implemented. These testing components \nshould be stand-alone, should simulate the submission of input to be tested, and \nshould check that the result meets the output specification. An automated test frame-\nwork is a system that makes it easy to write executable tests and submit a set of tests \nfor execution. Junit (Tahchiev et al. 2010) is a widely used example of an automated \ntesting framework for Java programs.\nInput:\n1.  A number in mg representing a single dose of the drug.\n2.  A number representing the number of single doses per day.\nTests:\n1.   Test for inputs where the single dose is correct but the frequency is too\nhigh.\n2.   Test for inputs where the single dose is too high and too low.\n3.   Test for inputs where the single dose * frequency is too high and too low.\n4.   Test for inputs where single dose * frequency is in the permitted range.\nOutput:\nOK or error message indicating that the dose is outside the safe range.\nTest 4: Dose checking\nFigure 3.7 Test case \ndescription for dose \nchecking"}
{"query": "What is acceptance testing?", "response": "Acceptance testing is the process of testing a system using customer data to ensure that it meets the customer's real needs. It involves developing acceptance tests for the stories or requirements that are to be implemented in the next release of the system. The role of the customer in the acceptance testing process is to help develop these tests and verify that the system meets their requirements.", "context": "3.2  \u25a0 Agile development techniques  81\nthem immediately. When team members see code that can be improved, they make \nthese improvements even in situations where there is no immediate need for them.\nA fundamental problem of incremental development is that local changes tend to \ndegrade the software structure. Consequently, further changes to the software become \nharder and harder to implement. Essentially, the development proceeds by finding \nworkarounds to problems, with the result that code is often duplicated, parts of the \nsoftware are reused in inappropriate ways, and the overall structure degrades as code is \nadded to the system. Refactoring improves the software structure and readability and \nso avoids the structural deterioration that naturally occurs when software is changed.\nExamples of refactoring include the reorganization of a class hierarchy to remove \nduplicate code, the tidying up and renaming of attributes and methods, and the \nreplacement of similar code sections, with calls to methods defined in a program \nlibrary. Program development environments usually include tools for refactoring. \nThese simplify the process of finding dependencies between code sections and mak-\ning global code modifications.\nIn principle, when refactoring is part of the development process, the software \nshould always be easy to understand and change as new requirements are proposed. \nIn practice, this is not always the case. Sometimes development pressure means that \nrefactoring is delayed because the time is devoted to the implementation of new \nfunctionality. Some new features and changes cannot readily be accommodated by \ncode-level refactoring and require that the architecture of the system be modified.\n \n3.2.3  Test-first development\nAs I discussed in the introduction to this chapter, one of the important differences \nbetween incremental development and plan-driven development is in the way that \nthe system is tested. With incremental development, there is no system specification \nthat can be used by an external testing team to develop system tests. As a conse-\nquence, some approaches to incremental development have a very informal testing \nprocess, in comparison with plan-driven testing.\nExtreme Programming developed a new approach to program testing to address \nthe difficulties of testing without a specification. Testing is automated and is central \nto the development process, and development cannot proceed until all tests have \nbeen successfully executed. The key features of testing in XP are:\n1. test-first development,\n2. incremental test development from scenarios,\n3. user involvement in the test development and validation, and\n4. the use of automated testing frameworks.\nXP\u2019s test-first philosophy has now evolved into more general test-driven develop-\nment techniques (Jeffries and Melnik 2007). I believe that test-driven development is \none of the most important innovations in software engineering. Instead of writing code \nand then writing tests for that code, you write the tests before you write the code. This \n\n\n82  Chapter 3 \u25a0 Agile software development\nmeans that you can run the test as the code is being written and discover problems dur-\ning development. I discuss test-driven development in more depth in Chapter 8.\nWriting tests implicitly defines both an interface and a specification of behavior for \nthe functionality being developed. Problems of requirements and interface misunder-\nstandings are reduced. Test-first development requires there to be a clear relationship \nbetween system requirements and the code implementing the corresponding require-\nments. In XP, this relationship is clear because the story cards representing the require-\nments are broken down into tasks and the tasks are the principal unit of implementation.\nIn test-first development, the task implementers have to thoroughly understand \nthe specification so that they can write tests for the system. This means that ambi-\nguities and omissions in the specification have to be clarified before implementation \nbegins. Furthermore, it also avoids the problem of \u201ctest-lag.\u201d This may happen when \nthe developer of the system works at a faster pace than the tester. The implementa-\ntion gets further and further ahead of the testing and there is a tendency to skip tests, \nso that the development schedule can be maintained.\nXP\u2019s test-first approach assumes that user stories have been developed, and these \nhave been broken down into a set of task cards, as shown in Figure 3.6. Each task \ngenerates one or more unit tests that check the implementation described in that task. \nFigure 3.7 is a shortened description of a test case that has been developed to check \nthat the prescribed dose of a drug does not fall outside known safe limits.\nThe role of the customer in the testing process is to help develop acceptance tests \nfor the stories that are to be implemented in the next release of the system. As I \nexplain in Chapter 8, acceptance  testing is the process whereby the system is tested \nusing customer data to check that it meets the customer\u2019s real needs.\nTest automation is essential for test-first development. Tests are written as exe-\ncutable components before the task is implemented. These testing components \nshould be stand-alone, should simulate the submission of input to be tested, and \nshould check that the result meets the output specification. An automated test frame-\nwork is a system that makes it easy to write executable tests and submit a set of tests \nfor execution. Junit (Tahchiev et al. 2010) is a widely used example of an automated \ntesting framework for Java programs.\nInput:\n1.  A number in mg representing a single dose of the drug.\n2.  A number representing the number of single doses per day.\nTests:\n1.   Test for inputs where the single dose is correct but the frequency is too\nhigh.\n2.   Test for inputs where the single dose is too high and too low.\n3.   Test for inputs where the single dose * frequency is too high and too low.\n4.   Test for inputs where single dose * frequency is in the permitted range.\nOutput:\nOK or error message indicating that the dose is outside the safe range.\nTest 4: Dose checking\nFigure 3.7 Test case \ndescription for dose \nchecking"}
{"query": "Why is test automation essential for test-first development?", "response": "Test automation is essential for test-first development because it allows tests to be written as executable components before the task is implemented. These testing components should be stand-alone and simulate the submission of input to be tested, checking that the result meets the output specification. An automated test framework makes it easy to write executable tests and submit a set of tests for execution. This automation ensures that tests can be run quickly and efficiently, allowing developers to continuously test their code as they write it.", "context": "3.2  \u25a0 Agile development techniques  81\nthem immediately. When team members see code that can be improved, they make \nthese improvements even in situations where there is no immediate need for them.\nA fundamental problem of incremental development is that local changes tend to \ndegrade the software structure. Consequently, further changes to the software become \nharder and harder to implement. Essentially, the development proceeds by finding \nworkarounds to problems, with the result that code is often duplicated, parts of the \nsoftware are reused in inappropriate ways, and the overall structure degrades as code is \nadded to the system. Refactoring improves the software structure and readability and \nso avoids the structural deterioration that naturally occurs when software is changed.\nExamples of refactoring include the reorganization of a class hierarchy to remove \nduplicate code, the tidying up and renaming of attributes and methods, and the \nreplacement of similar code sections, with calls to methods defined in a program \nlibrary. Program development environments usually include tools for refactoring. \nThese simplify the process of finding dependencies between code sections and mak-\ning global code modifications.\nIn principle, when refactoring is part of the development process, the software \nshould always be easy to understand and change as new requirements are proposed. \nIn practice, this is not always the case. Sometimes development pressure means that \nrefactoring is delayed because the time is devoted to the implementation of new \nfunctionality. Some new features and changes cannot readily be accommodated by \ncode-level refactoring and require that the architecture of the system be modified.\n \n3.2.3  Test-first development\nAs I discussed in the introduction to this chapter, one of the important differences \nbetween incremental development and plan-driven development is in the way that \nthe system is tested. With incremental development, there is no system specification \nthat can be used by an external testing team to develop system tests. As a conse-\nquence, some approaches to incremental development have a very informal testing \nprocess, in comparison with plan-driven testing.\nExtreme Programming developed a new approach to program testing to address \nthe difficulties of testing without a specification. Testing is automated and is central \nto the development process, and development cannot proceed until all tests have \nbeen successfully executed. The key features of testing in XP are:\n1. test-first development,\n2. incremental test development from scenarios,\n3. user involvement in the test development and validation, and\n4. the use of automated testing frameworks.\nXP\u2019s test-first philosophy has now evolved into more general test-driven develop-\nment techniques (Jeffries and Melnik 2007). I believe that test-driven development is \none of the most important innovations in software engineering. Instead of writing code \nand then writing tests for that code, you write the tests before you write the code. This \n\n\n82  Chapter 3 \u25a0 Agile software development\nmeans that you can run the test as the code is being written and discover problems dur-\ning development. I discuss test-driven development in more depth in Chapter 8.\nWriting tests implicitly defines both an interface and a specification of behavior for \nthe functionality being developed. Problems of requirements and interface misunder-\nstandings are reduced. Test-first development requires there to be a clear relationship \nbetween system requirements and the code implementing the corresponding require-\nments. In XP, this relationship is clear because the story cards representing the require-\nments are broken down into tasks and the tasks are the principal unit of implementation.\nIn test-first development, the task implementers have to thoroughly understand \nthe specification so that they can write tests for the system. This means that ambi-\nguities and omissions in the specification have to be clarified before implementation \nbegins. Furthermore, it also avoids the problem of \u201ctest-lag.\u201d This may happen when \nthe developer of the system works at a faster pace than the tester. The implementa-\ntion gets further and further ahead of the testing and there is a tendency to skip tests, \nso that the development schedule can be maintained.\nXP\u2019s test-first approach assumes that user stories have been developed, and these \nhave been broken down into a set of task cards, as shown in Figure 3.6. Each task \ngenerates one or more unit tests that check the implementation described in that task. \nFigure 3.7 is a shortened description of a test case that has been developed to check \nthat the prescribed dose of a drug does not fall outside known safe limits.\nThe role of the customer in the testing process is to help develop acceptance tests \nfor the stories that are to be implemented in the next release of the system. As I \nexplain in Chapter 8, acceptance  testing is the process whereby the system is tested \nusing customer data to check that it meets the customer\u2019s real needs.\nTest automation is essential for test-first development. Tests are written as exe-\ncutable components before the task is implemented. These testing components \nshould be stand-alone, should simulate the submission of input to be tested, and \nshould check that the result meets the output specification. An automated test frame-\nwork is a system that makes it easy to write executable tests and submit a set of tests \nfor execution. Junit (Tahchiev et al. 2010) is a widely used example of an automated \ntesting framework for Java programs.\nInput:\n1.  A number in mg representing a single dose of the drug.\n2.  A number representing the number of single doses per day.\nTests:\n1.   Test for inputs where the single dose is correct but the frequency is too\nhigh.\n2.   Test for inputs where the single dose is too high and too low.\n3.   Test for inputs where the single dose * frequency is too high and too low.\n4.   Test for inputs where single dose * frequency is in the permitted range.\nOutput:\nOK or error message indicating that the dose is outside the safe range.\nTest 4: Dose checking\nFigure 3.7 Test case \ndescription for dose \nchecking"}
{"query": "What are the characteristics of testing components in test-first development?", "response": "The characteristics of testing components in test-first development are that they should be stand-alone, simulate the submission of input to be tested, and check that the result meets the output specification.", "context": "3.2  \u25a0 Agile development techniques  81\nthem immediately. When team members see code that can be improved, they make \nthese improvements even in situations where there is no immediate need for them.\nA fundamental problem of incremental development is that local changes tend to \ndegrade the software structure. Consequently, further changes to the software become \nharder and harder to implement. Essentially, the development proceeds by finding \nworkarounds to problems, with the result that code is often duplicated, parts of the \nsoftware are reused in inappropriate ways, and the overall structure degrades as code is \nadded to the system. Refactoring improves the software structure and readability and \nso avoids the structural deterioration that naturally occurs when software is changed.\nExamples of refactoring include the reorganization of a class hierarchy to remove \nduplicate code, the tidying up and renaming of attributes and methods, and the \nreplacement of similar code sections, with calls to methods defined in a program \nlibrary. Program development environments usually include tools for refactoring. \nThese simplify the process of finding dependencies between code sections and mak-\ning global code modifications.\nIn principle, when refactoring is part of the development process, the software \nshould always be easy to understand and change as new requirements are proposed. \nIn practice, this is not always the case. Sometimes development pressure means that \nrefactoring is delayed because the time is devoted to the implementation of new \nfunctionality. Some new features and changes cannot readily be accommodated by \ncode-level refactoring and require that the architecture of the system be modified.\n \n3.2.3  Test-first development\nAs I discussed in the introduction to this chapter, one of the important differences \nbetween incremental development and plan-driven development is in the way that \nthe system is tested. With incremental development, there is no system specification \nthat can be used by an external testing team to develop system tests. As a conse-\nquence, some approaches to incremental development have a very informal testing \nprocess, in comparison with plan-driven testing.\nExtreme Programming developed a new approach to program testing to address \nthe difficulties of testing without a specification. Testing is automated and is central \nto the development process, and development cannot proceed until all tests have \nbeen successfully executed. The key features of testing in XP are:\n1. test-first development,\n2. incremental test development from scenarios,\n3. user involvement in the test development and validation, and\n4. the use of automated testing frameworks.\nXP\u2019s test-first philosophy has now evolved into more general test-driven develop-\nment techniques (Jeffries and Melnik 2007). I believe that test-driven development is \none of the most important innovations in software engineering. Instead of writing code \nand then writing tests for that code, you write the tests before you write the code. This \n\n\n82  Chapter 3 \u25a0 Agile software development\nmeans that you can run the test as the code is being written and discover problems dur-\ning development. I discuss test-driven development in more depth in Chapter 8.\nWriting tests implicitly defines both an interface and a specification of behavior for \nthe functionality being developed. Problems of requirements and interface misunder-\nstandings are reduced. Test-first development requires there to be a clear relationship \nbetween system requirements and the code implementing the corresponding require-\nments. In XP, this relationship is clear because the story cards representing the require-\nments are broken down into tasks and the tasks are the principal unit of implementation.\nIn test-first development, the task implementers have to thoroughly understand \nthe specification so that they can write tests for the system. This means that ambi-\nguities and omissions in the specification have to be clarified before implementation \nbegins. Furthermore, it also avoids the problem of \u201ctest-lag.\u201d This may happen when \nthe developer of the system works at a faster pace than the tester. The implementa-\ntion gets further and further ahead of the testing and there is a tendency to skip tests, \nso that the development schedule can be maintained.\nXP\u2019s test-first approach assumes that user stories have been developed, and these \nhave been broken down into a set of task cards, as shown in Figure 3.6. Each task \ngenerates one or more unit tests that check the implementation described in that task. \nFigure 3.7 is a shortened description of a test case that has been developed to check \nthat the prescribed dose of a drug does not fall outside known safe limits.\nThe role of the customer in the testing process is to help develop acceptance tests \nfor the stories that are to be implemented in the next release of the system. As I \nexplain in Chapter 8, acceptance  testing is the process whereby the system is tested \nusing customer data to check that it meets the customer\u2019s real needs.\nTest automation is essential for test-first development. Tests are written as exe-\ncutable components before the task is implemented. These testing components \nshould be stand-alone, should simulate the submission of input to be tested, and \nshould check that the result meets the output specification. An automated test frame-\nwork is a system that makes it easy to write executable tests and submit a set of tests \nfor execution. Junit (Tahchiev et al. 2010) is a widely used example of an automated \ntesting framework for Java programs.\nInput:\n1.  A number in mg representing a single dose of the drug.\n2.  A number representing the number of single doses per day.\nTests:\n1.   Test for inputs where the single dose is correct but the frequency is too\nhigh.\n2.   Test for inputs where the single dose is too high and too low.\n3.   Test for inputs where the single dose * frequency is too high and too low.\n4.   Test for inputs where single dose * frequency is in the permitted range.\nOutput:\nOK or error message indicating that the dose is outside the safe range.\nTest 4: Dose checking\nFigure 3.7 Test case \ndescription for dose \nchecking"}
{"query": "What is an automated test framework?", "response": "An automated test framework is a system that facilitates the writing and execution of tests. It provides a set of tools and functionalities that make it easier to create and run tests for software applications. These frameworks typically allow developers to write tests as executable components and provide features for simulating input, checking output, and managing test cases. They help automate the testing process, making it more efficient and reliable.", "context": "3.2  \u25a0 Agile development techniques  81\nthem immediately. When team members see code that can be improved, they make \nthese improvements even in situations where there is no immediate need for them.\nA fundamental problem of incremental development is that local changes tend to \ndegrade the software structure. Consequently, further changes to the software become \nharder and harder to implement. Essentially, the development proceeds by finding \nworkarounds to problems, with the result that code is often duplicated, parts of the \nsoftware are reused in inappropriate ways, and the overall structure degrades as code is \nadded to the system. Refactoring improves the software structure and readability and \nso avoids the structural deterioration that naturally occurs when software is changed.\nExamples of refactoring include the reorganization of a class hierarchy to remove \nduplicate code, the tidying up and renaming of attributes and methods, and the \nreplacement of similar code sections, with calls to methods defined in a program \nlibrary. Program development environments usually include tools for refactoring. \nThese simplify the process of finding dependencies between code sections and mak-\ning global code modifications.\nIn principle, when refactoring is part of the development process, the software \nshould always be easy to understand and change as new requirements are proposed. \nIn practice, this is not always the case. Sometimes development pressure means that \nrefactoring is delayed because the time is devoted to the implementation of new \nfunctionality. Some new features and changes cannot readily be accommodated by \ncode-level refactoring and require that the architecture of the system be modified.\n \n3.2.3  Test-first development\nAs I discussed in the introduction to this chapter, one of the important differences \nbetween incremental development and plan-driven development is in the way that \nthe system is tested. With incremental development, there is no system specification \nthat can be used by an external testing team to develop system tests. As a conse-\nquence, some approaches to incremental development have a very informal testing \nprocess, in comparison with plan-driven testing.\nExtreme Programming developed a new approach to program testing to address \nthe difficulties of testing without a specification. Testing is automated and is central \nto the development process, and development cannot proceed until all tests have \nbeen successfully executed. The key features of testing in XP are:\n1. test-first development,\n2. incremental test development from scenarios,\n3. user involvement in the test development and validation, and\n4. the use of automated testing frameworks.\nXP\u2019s test-first philosophy has now evolved into more general test-driven develop-\nment techniques (Jeffries and Melnik 2007). I believe that test-driven development is \none of the most important innovations in software engineering. Instead of writing code \nand then writing tests for that code, you write the tests before you write the code. This \n\n\n82  Chapter 3 \u25a0 Agile software development\nmeans that you can run the test as the code is being written and discover problems dur-\ning development. I discuss test-driven development in more depth in Chapter 8.\nWriting tests implicitly defines both an interface and a specification of behavior for \nthe functionality being developed. Problems of requirements and interface misunder-\nstandings are reduced. Test-first development requires there to be a clear relationship \nbetween system requirements and the code implementing the corresponding require-\nments. In XP, this relationship is clear because the story cards representing the require-\nments are broken down into tasks and the tasks are the principal unit of implementation.\nIn test-first development, the task implementers have to thoroughly understand \nthe specification so that they can write tests for the system. This means that ambi-\nguities and omissions in the specification have to be clarified before implementation \nbegins. Furthermore, it also avoids the problem of \u201ctest-lag.\u201d This may happen when \nthe developer of the system works at a faster pace than the tester. The implementa-\ntion gets further and further ahead of the testing and there is a tendency to skip tests, \nso that the development schedule can be maintained.\nXP\u2019s test-first approach assumes that user stories have been developed, and these \nhave been broken down into a set of task cards, as shown in Figure 3.6. Each task \ngenerates one or more unit tests that check the implementation described in that task. \nFigure 3.7 is a shortened description of a test case that has been developed to check \nthat the prescribed dose of a drug does not fall outside known safe limits.\nThe role of the customer in the testing process is to help develop acceptance tests \nfor the stories that are to be implemented in the next release of the system. As I \nexplain in Chapter 8, acceptance  testing is the process whereby the system is tested \nusing customer data to check that it meets the customer\u2019s real needs.\nTest automation is essential for test-first development. Tests are written as exe-\ncutable components before the task is implemented. These testing components \nshould be stand-alone, should simulate the submission of input to be tested, and \nshould check that the result meets the output specification. An automated test frame-\nwork is a system that makes it easy to write executable tests and submit a set of tests \nfor execution. Junit (Tahchiev et al. 2010) is a widely used example of an automated \ntesting framework for Java programs.\nInput:\n1.  A number in mg representing a single dose of the drug.\n2.  A number representing the number of single doses per day.\nTests:\n1.   Test for inputs where the single dose is correct but the frequency is too\nhigh.\n2.   Test for inputs where the single dose is too high and too low.\n3.   Test for inputs where the single dose * frequency is too high and too low.\n4.   Test for inputs where single dose * frequency is in the permitted range.\nOutput:\nOK or error message indicating that the dose is outside the safe range.\nTest 4: Dose checking\nFigure 3.7 Test case \ndescription for dose \nchecking"}
{"query": "What is the purpose of a class hierarchy reorganization in refactoring?", "response": "The purpose of a class hierarchy reorganization in refactoring is to remove duplicate code and improve the overall structure and readability of the software.", "context": "3.2  \u25a0 Agile development techniques  81\nthem immediately. When team members see code that can be improved, they make \nthese improvements even in situations where there is no immediate need for them.\nA fundamental problem of incremental development is that local changes tend to \ndegrade the software structure. Consequently, further changes to the software become \nharder and harder to implement. Essentially, the development proceeds by finding \nworkarounds to problems, with the result that code is often duplicated, parts of the \nsoftware are reused in inappropriate ways, and the overall structure degrades as code is \nadded to the system. Refactoring improves the software structure and readability and \nso avoids the structural deterioration that naturally occurs when software is changed.\nExamples of refactoring include the reorganization of a class hierarchy to remove \nduplicate code, the tidying up and renaming of attributes and methods, and the \nreplacement of similar code sections, with calls to methods defined in a program \nlibrary. Program development environments usually include tools for refactoring. \nThese simplify the process of finding dependencies between code sections and mak-\ning global code modifications.\nIn principle, when refactoring is part of the development process, the software \nshould always be easy to understand and change as new requirements are proposed. \nIn practice, this is not always the case. Sometimes development pressure means that \nrefactoring is delayed because the time is devoted to the implementation of new \nfunctionality. Some new features and changes cannot readily be accommodated by \ncode-level refactoring and require that the architecture of the system be modified.\n \n3.2.3  Test-first development\nAs I discussed in the introduction to this chapter, one of the important differences \nbetween incremental development and plan-driven development is in the way that \nthe system is tested. With incremental development, there is no system specification \nthat can be used by an external testing team to develop system tests. As a conse-\nquence, some approaches to incremental development have a very informal testing \nprocess, in comparison with plan-driven testing.\nExtreme Programming developed a new approach to program testing to address \nthe difficulties of testing without a specification. Testing is automated and is central \nto the development process, and development cannot proceed until all tests have \nbeen successfully executed. The key features of testing in XP are:\n1. test-first development,\n2. incremental test development from scenarios,\n3. user involvement in the test development and validation, and\n4. the use of automated testing frameworks.\nXP\u2019s test-first philosophy has now evolved into more general test-driven develop-\nment techniques (Jeffries and Melnik 2007). I believe that test-driven development is \none of the most important innovations in software engineering. Instead of writing code \nand then writing tests for that code, you write the tests before you write the code. This \n\n\n82  Chapter 3 \u25a0 Agile software development\nmeans that you can run the test as the code is being written and discover problems dur-\ning development. I discuss test-driven development in more depth in Chapter 8.\nWriting tests implicitly defines both an interface and a specification of behavior for \nthe functionality being developed. Problems of requirements and interface misunder-\nstandings are reduced. Test-first development requires there to be a clear relationship \nbetween system requirements and the code implementing the corresponding require-\nments. In XP, this relationship is clear because the story cards representing the require-\nments are broken down into tasks and the tasks are the principal unit of implementation.\nIn test-first development, the task implementers have to thoroughly understand \nthe specification so that they can write tests for the system. This means that ambi-\nguities and omissions in the specification have to be clarified before implementation \nbegins. Furthermore, it also avoids the problem of \u201ctest-lag.\u201d This may happen when \nthe developer of the system works at a faster pace than the tester. The implementa-\ntion gets further and further ahead of the testing and there is a tendency to skip tests, \nso that the development schedule can be maintained.\nXP\u2019s test-first approach assumes that user stories have been developed, and these \nhave been broken down into a set of task cards, as shown in Figure 3.6. Each task \ngenerates one or more unit tests that check the implementation described in that task. \nFigure 3.7 is a shortened description of a test case that has been developed to check \nthat the prescribed dose of a drug does not fall outside known safe limits.\nThe role of the customer in the testing process is to help develop acceptance tests \nfor the stories that are to be implemented in the next release of the system. As I \nexplain in Chapter 8, acceptance  testing is the process whereby the system is tested \nusing customer data to check that it meets the customer\u2019s real needs.\nTest automation is essential for test-first development. Tests are written as exe-\ncutable components before the task is implemented. These testing components \nshould be stand-alone, should simulate the submission of input to be tested, and \nshould check that the result meets the output specification. An automated test frame-\nwork is a system that makes it easy to write executable tests and submit a set of tests \nfor execution. Junit (Tahchiev et al. 2010) is a widely used example of an automated \ntesting framework for Java programs.\nInput:\n1.  A number in mg representing a single dose of the drug.\n2.  A number representing the number of single doses per day.\nTests:\n1.   Test for inputs where the single dose is correct but the frequency is too\nhigh.\n2.   Test for inputs where the single dose is too high and too low.\n3.   Test for inputs where the single dose * frequency is too high and too low.\n4.   Test for inputs where single dose * frequency is in the permitted range.\nOutput:\nOK or error message indicating that the dose is outside the safe range.\nTest 4: Dose checking\nFigure 3.7 Test case \ndescription for dose \nchecking"}
{"query": "How does refactoring prevent the structural deterioration of software?", "response": "Refactoring improves the software structure and readability, which helps prevent the structural deterioration of software. By reorganizing class hierarchies, removing duplicate code, tidying up and renaming attributes and methods, and replacing similar code sections with calls to methods defined in a program library, refactoring ensures that the software remains easy to understand and change as new requirements are proposed. This prevents the degradation of the overall structure that naturally occurs when software is changed incrementally.", "context": "3.2  \u25a0 Agile development techniques  81\nthem immediately. When team members see code that can be improved, they make \nthese improvements even in situations where there is no immediate need for them.\nA fundamental problem of incremental development is that local changes tend to \ndegrade the software structure. Consequently, further changes to the software become \nharder and harder to implement. Essentially, the development proceeds by finding \nworkarounds to problems, with the result that code is often duplicated, parts of the \nsoftware are reused in inappropriate ways, and the overall structure degrades as code is \nadded to the system. Refactoring improves the software structure and readability and \nso avoids the structural deterioration that naturally occurs when software is changed.\nExamples of refactoring include the reorganization of a class hierarchy to remove \nduplicate code, the tidying up and renaming of attributes and methods, and the \nreplacement of similar code sections, with calls to methods defined in a program \nlibrary. Program development environments usually include tools for refactoring. \nThese simplify the process of finding dependencies between code sections and mak-\ning global code modifications.\nIn principle, when refactoring is part of the development process, the software \nshould always be easy to understand and change as new requirements are proposed. \nIn practice, this is not always the case. Sometimes development pressure means that \nrefactoring is delayed because the time is devoted to the implementation of new \nfunctionality. Some new features and changes cannot readily be accommodated by \ncode-level refactoring and require that the architecture of the system be modified.\n \n3.2.3  Test-first development\nAs I discussed in the introduction to this chapter, one of the important differences \nbetween incremental development and plan-driven development is in the way that \nthe system is tested. With incremental development, there is no system specification \nthat can be used by an external testing team to develop system tests. As a conse-\nquence, some approaches to incremental development have a very informal testing \nprocess, in comparison with plan-driven testing.\nExtreme Programming developed a new approach to program testing to address \nthe difficulties of testing without a specification. Testing is automated and is central \nto the development process, and development cannot proceed until all tests have \nbeen successfully executed. The key features of testing in XP are:\n1. test-first development,\n2. incremental test development from scenarios,\n3. user involvement in the test development and validation, and\n4. the use of automated testing frameworks.\nXP\u2019s test-first philosophy has now evolved into more general test-driven develop-\nment techniques (Jeffries and Melnik 2007). I believe that test-driven development is \none of the most important innovations in software engineering. Instead of writing code \nand then writing tests for that code, you write the tests before you write the code. This \n\n\n82  Chapter 3 \u25a0 Agile software development\nmeans that you can run the test as the code is being written and discover problems dur-\ning development. I discuss test-driven development in more depth in Chapter 8.\nWriting tests implicitly defines both an interface and a specification of behavior for \nthe functionality being developed. Problems of requirements and interface misunder-\nstandings are reduced. Test-first development requires there to be a clear relationship \nbetween system requirements and the code implementing the corresponding require-\nments. In XP, this relationship is clear because the story cards representing the require-\nments are broken down into tasks and the tasks are the principal unit of implementation.\nIn test-first development, the task implementers have to thoroughly understand \nthe specification so that they can write tests for the system. This means that ambi-\nguities and omissions in the specification have to be clarified before implementation \nbegins. Furthermore, it also avoids the problem of \u201ctest-lag.\u201d This may happen when \nthe developer of the system works at a faster pace than the tester. The implementa-\ntion gets further and further ahead of the testing and there is a tendency to skip tests, \nso that the development schedule can be maintained.\nXP\u2019s test-first approach assumes that user stories have been developed, and these \nhave been broken down into a set of task cards, as shown in Figure 3.6. Each task \ngenerates one or more unit tests that check the implementation described in that task. \nFigure 3.7 is a shortened description of a test case that has been developed to check \nthat the prescribed dose of a drug does not fall outside known safe limits.\nThe role of the customer in the testing process is to help develop acceptance tests \nfor the stories that are to be implemented in the next release of the system. As I \nexplain in Chapter 8, acceptance  testing is the process whereby the system is tested \nusing customer data to check that it meets the customer\u2019s real needs.\nTest automation is essential for test-first development. Tests are written as exe-\ncutable components before the task is implemented. These testing components \nshould be stand-alone, should simulate the submission of input to be tested, and \nshould check that the result meets the output specification. An automated test frame-\nwork is a system that makes it easy to write executable tests and submit a set of tests \nfor execution. Junit (Tahchiev et al. 2010) is a widely used example of an automated \ntesting framework for Java programs.\nInput:\n1.  A number in mg representing a single dose of the drug.\n2.  A number representing the number of single doses per day.\nTests:\n1.   Test for inputs where the single dose is correct but the frequency is too\nhigh.\n2.   Test for inputs where the single dose is too high and too low.\n3.   Test for inputs where the single dose * frequency is too high and too low.\n4.   Test for inputs where single dose * frequency is in the permitted range.\nOutput:\nOK or error message indicating that the dose is outside the safe range.\nTest 4: Dose checking\nFigure 3.7 Test case \ndescription for dose \nchecking"}
{"query": "What are the potential consequences of delaying refactoring?", "response": "The potential consequences of delaying refactoring include the degradation of the software structure, increased difficulty in implementing further changes to the software, duplication of code, inappropriate reuse of parts of the software, and overall deterioration of the software's structure and readability.", "context": "3.2  \u25a0 Agile development techniques  81\nthem immediately. When team members see code that can be improved, they make \nthese improvements even in situations where there is no immediate need for them.\nA fundamental problem of incremental development is that local changes tend to \ndegrade the software structure. Consequently, further changes to the software become \nharder and harder to implement. Essentially, the development proceeds by finding \nworkarounds to problems, with the result that code is often duplicated, parts of the \nsoftware are reused in inappropriate ways, and the overall structure degrades as code is \nadded to the system. Refactoring improves the software structure and readability and \nso avoids the structural deterioration that naturally occurs when software is changed.\nExamples of refactoring include the reorganization of a class hierarchy to remove \nduplicate code, the tidying up and renaming of attributes and methods, and the \nreplacement of similar code sections, with calls to methods defined in a program \nlibrary. Program development environments usually include tools for refactoring. \nThese simplify the process of finding dependencies between code sections and mak-\ning global code modifications.\nIn principle, when refactoring is part of the development process, the software \nshould always be easy to understand and change as new requirements are proposed. \nIn practice, this is not always the case. Sometimes development pressure means that \nrefactoring is delayed because the time is devoted to the implementation of new \nfunctionality. Some new features and changes cannot readily be accommodated by \ncode-level refactoring and require that the architecture of the system be modified.\n \n3.2.3  Test-first development\nAs I discussed in the introduction to this chapter, one of the important differences \nbetween incremental development and plan-driven development is in the way that \nthe system is tested. With incremental development, there is no system specification \nthat can be used by an external testing team to develop system tests. As a conse-\nquence, some approaches to incremental development have a very informal testing \nprocess, in comparison with plan-driven testing.\nExtreme Programming developed a new approach to program testing to address \nthe difficulties of testing without a specification. Testing is automated and is central \nto the development process, and development cannot proceed until all tests have \nbeen successfully executed. The key features of testing in XP are:\n1. test-first development,\n2. incremental test development from scenarios,\n3. user involvement in the test development and validation, and\n4. the use of automated testing frameworks.\nXP\u2019s test-first philosophy has now evolved into more general test-driven develop-\nment techniques (Jeffries and Melnik 2007). I believe that test-driven development is \none of the most important innovations in software engineering. Instead of writing code \nand then writing tests for that code, you write the tests before you write the code. This \n\n\n82  Chapter 3 \u25a0 Agile software development\nmeans that you can run the test as the code is being written and discover problems dur-\ning development. I discuss test-driven development in more depth in Chapter 8.\nWriting tests implicitly defines both an interface and a specification of behavior for \nthe functionality being developed. Problems of requirements and interface misunder-\nstandings are reduced. Test-first development requires there to be a clear relationship \nbetween system requirements and the code implementing the corresponding require-\nments. In XP, this relationship is clear because the story cards representing the require-\nments are broken down into tasks and the tasks are the principal unit of implementation.\nIn test-first development, the task implementers have to thoroughly understand \nthe specification so that they can write tests for the system. This means that ambi-\nguities and omissions in the specification have to be clarified before implementation \nbegins. Furthermore, it also avoids the problem of \u201ctest-lag.\u201d This may happen when \nthe developer of the system works at a faster pace than the tester. The implementa-\ntion gets further and further ahead of the testing and there is a tendency to skip tests, \nso that the development schedule can be maintained.\nXP\u2019s test-first approach assumes that user stories have been developed, and these \nhave been broken down into a set of task cards, as shown in Figure 3.6. Each task \ngenerates one or more unit tests that check the implementation described in that task. \nFigure 3.7 is a shortened description of a test case that has been developed to check \nthat the prescribed dose of a drug does not fall outside known safe limits.\nThe role of the customer in the testing process is to help develop acceptance tests \nfor the stories that are to be implemented in the next release of the system. As I \nexplain in Chapter 8, acceptance  testing is the process whereby the system is tested \nusing customer data to check that it meets the customer\u2019s real needs.\nTest automation is essential for test-first development. Tests are written as exe-\ncutable components before the task is implemented. These testing components \nshould be stand-alone, should simulate the submission of input to be tested, and \nshould check that the result meets the output specification. An automated test frame-\nwork is a system that makes it easy to write executable tests and submit a set of tests \nfor execution. Junit (Tahchiev et al. 2010) is a widely used example of an automated \ntesting framework for Java programs.\nInput:\n1.  A number in mg representing a single dose of the drug.\n2.  A number representing the number of single doses per day.\nTests:\n1.   Test for inputs where the single dose is correct but the frequency is too\nhigh.\n2.   Test for inputs where the single dose is too high and too low.\n3.   Test for inputs where the single dose * frequency is too high and too low.\n4.   Test for inputs where single dose * frequency is in the permitted range.\nOutput:\nOK or error message indicating that the dose is outside the safe range.\nTest 4: Dose checking\nFigure 3.7 Test case \ndescription for dose \nchecking"}
{"query": "How does test-first development reduce problems of requirements and interface misunderstandings?", "response": "Test-first development reduces problems of requirements and interface misunderstandings by implicitly defining both an interface and a specification of behavior for the functionality being developed. By writing tests before writing the code, the developers have a clear understanding of the requirements and can clarify any ambiguities or omissions in the specification before implementation begins. This ensures that there is a clear relationship between the system requirements and the code implementing those requirements, reducing the chances of misunderstandings. Additionally, the test-first approach allows for early detection of problems during development, which further helps in identifying and resolving any requirements or interface issues.", "context": "3.2  \u25a0 Agile development techniques  81\nthem immediately. When team members see code that can be improved, they make \nthese improvements even in situations where there is no immediate need for them.\nA fundamental problem of incremental development is that local changes tend to \ndegrade the software structure. Consequently, further changes to the software become \nharder and harder to implement. Essentially, the development proceeds by finding \nworkarounds to problems, with the result that code is often duplicated, parts of the \nsoftware are reused in inappropriate ways, and the overall structure degrades as code is \nadded to the system. Refactoring improves the software structure and readability and \nso avoids the structural deterioration that naturally occurs when software is changed.\nExamples of refactoring include the reorganization of a class hierarchy to remove \nduplicate code, the tidying up and renaming of attributes and methods, and the \nreplacement of similar code sections, with calls to methods defined in a program \nlibrary. Program development environments usually include tools for refactoring. \nThese simplify the process of finding dependencies between code sections and mak-\ning global code modifications.\nIn principle, when refactoring is part of the development process, the software \nshould always be easy to understand and change as new requirements are proposed. \nIn practice, this is not always the case. Sometimes development pressure means that \nrefactoring is delayed because the time is devoted to the implementation of new \nfunctionality. Some new features and changes cannot readily be accommodated by \ncode-level refactoring and require that the architecture of the system be modified.\n \n3.2.3  Test-first development\nAs I discussed in the introduction to this chapter, one of the important differences \nbetween incremental development and plan-driven development is in the way that \nthe system is tested. With incremental development, there is no system specification \nthat can be used by an external testing team to develop system tests. As a conse-\nquence, some approaches to incremental development have a very informal testing \nprocess, in comparison with plan-driven testing.\nExtreme Programming developed a new approach to program testing to address \nthe difficulties of testing without a specification. Testing is automated and is central \nto the development process, and development cannot proceed until all tests have \nbeen successfully executed. The key features of testing in XP are:\n1. test-first development,\n2. incremental test development from scenarios,\n3. user involvement in the test development and validation, and\n4. the use of automated testing frameworks.\nXP\u2019s test-first philosophy has now evolved into more general test-driven develop-\nment techniques (Jeffries and Melnik 2007). I believe that test-driven development is \none of the most important innovations in software engineering. Instead of writing code \nand then writing tests for that code, you write the tests before you write the code. This \n\n\n82  Chapter 3 \u25a0 Agile software development\nmeans that you can run the test as the code is being written and discover problems dur-\ning development. I discuss test-driven development in more depth in Chapter 8.\nWriting tests implicitly defines both an interface and a specification of behavior for \nthe functionality being developed. Problems of requirements and interface misunder-\nstandings are reduced. Test-first development requires there to be a clear relationship \nbetween system requirements and the code implementing the corresponding require-\nments. In XP, this relationship is clear because the story cards representing the require-\nments are broken down into tasks and the tasks are the principal unit of implementation.\nIn test-first development, the task implementers have to thoroughly understand \nthe specification so that they can write tests for the system. This means that ambi-\nguities and omissions in the specification have to be clarified before implementation \nbegins. Furthermore, it also avoids the problem of \u201ctest-lag.\u201d This may happen when \nthe developer of the system works at a faster pace than the tester. The implementa-\ntion gets further and further ahead of the testing and there is a tendency to skip tests, \nso that the development schedule can be maintained.\nXP\u2019s test-first approach assumes that user stories have been developed, and these \nhave been broken down into a set of task cards, as shown in Figure 3.6. Each task \ngenerates one or more unit tests that check the implementation described in that task. \nFigure 3.7 is a shortened description of a test case that has been developed to check \nthat the prescribed dose of a drug does not fall outside known safe limits.\nThe role of the customer in the testing process is to help develop acceptance tests \nfor the stories that are to be implemented in the next release of the system. As I \nexplain in Chapter 8, acceptance  testing is the process whereby the system is tested \nusing customer data to check that it meets the customer\u2019s real needs.\nTest automation is essential for test-first development. Tests are written as exe-\ncutable components before the task is implemented. These testing components \nshould be stand-alone, should simulate the submission of input to be tested, and \nshould check that the result meets the output specification. An automated test frame-\nwork is a system that makes it easy to write executable tests and submit a set of tests \nfor execution. Junit (Tahchiev et al. 2010) is a widely used example of an automated \ntesting framework for Java programs.\nInput:\n1.  A number in mg representing a single dose of the drug.\n2.  A number representing the number of single doses per day.\nTests:\n1.   Test for inputs where the single dose is correct but the frequency is too\nhigh.\n2.   Test for inputs where the single dose is too high and too low.\n3.   Test for inputs where the single dose * frequency is too high and too low.\n4.   Test for inputs where single dose * frequency is in the permitted range.\nOutput:\nOK or error message indicating that the dose is outside the safe range.\nTest 4: Dose checking\nFigure 3.7 Test case \ndescription for dose \nchecking"}
{"query": "How does test-first development approach address the difficulties of testing without a specification?", "response": "The test-first development approach addresses the difficulties of testing without a specification by requiring tests to be written before the code is implemented. This means that the tests serve as a specification of the desired behavior for the functionality being developed. By writing tests first, ambiguities and omissions in the specification can be clarified before implementation begins. This approach also helps to reduce problems of requirements and interface misunderstandings. Additionally, test-first development ensures that the code is thoroughly tested during development, allowing for the discovery of problems early on. Overall, the test-first approach provides a clear relationship between system requirements and the corresponding code implementation, helping to overcome the challenges of testing without a formal specification.", "context": "3.2  \u25a0 Agile development techniques  81\nthem immediately. When team members see code that can be improved, they make \nthese improvements even in situations where there is no immediate need for them.\nA fundamental problem of incremental development is that local changes tend to \ndegrade the software structure. Consequently, further changes to the software become \nharder and harder to implement. Essentially, the development proceeds by finding \nworkarounds to problems, with the result that code is often duplicated, parts of the \nsoftware are reused in inappropriate ways, and the overall structure degrades as code is \nadded to the system. Refactoring improves the software structure and readability and \nso avoids the structural deterioration that naturally occurs when software is changed.\nExamples of refactoring include the reorganization of a class hierarchy to remove \nduplicate code, the tidying up and renaming of attributes and methods, and the \nreplacement of similar code sections, with calls to methods defined in a program \nlibrary. Program development environments usually include tools for refactoring. \nThese simplify the process of finding dependencies between code sections and mak-\ning global code modifications.\nIn principle, when refactoring is part of the development process, the software \nshould always be easy to understand and change as new requirements are proposed. \nIn practice, this is not always the case. Sometimes development pressure means that \nrefactoring is delayed because the time is devoted to the implementation of new \nfunctionality. Some new features and changes cannot readily be accommodated by \ncode-level refactoring and require that the architecture of the system be modified.\n \n3.2.3  Test-first development\nAs I discussed in the introduction to this chapter, one of the important differences \nbetween incremental development and plan-driven development is in the way that \nthe system is tested. With incremental development, there is no system specification \nthat can be used by an external testing team to develop system tests. As a conse-\nquence, some approaches to incremental development have a very informal testing \nprocess, in comparison with plan-driven testing.\nExtreme Programming developed a new approach to program testing to address \nthe difficulties of testing without a specification. Testing is automated and is central \nto the development process, and development cannot proceed until all tests have \nbeen successfully executed. The key features of testing in XP are:\n1. test-first development,\n2. incremental test development from scenarios,\n3. user involvement in the test development and validation, and\n4. the use of automated testing frameworks.\nXP\u2019s test-first philosophy has now evolved into more general test-driven develop-\nment techniques (Jeffries and Melnik 2007). I believe that test-driven development is \none of the most important innovations in software engineering. Instead of writing code \nand then writing tests for that code, you write the tests before you write the code. This \n\n\n82  Chapter 3 \u25a0 Agile software development\nmeans that you can run the test as the code is being written and discover problems dur-\ning development. I discuss test-driven development in more depth in Chapter 8.\nWriting tests implicitly defines both an interface and a specification of behavior for \nthe functionality being developed. Problems of requirements and interface misunder-\nstandings are reduced. Test-first development requires there to be a clear relationship \nbetween system requirements and the code implementing the corresponding require-\nments. In XP, this relationship is clear because the story cards representing the require-\nments are broken down into tasks and the tasks are the principal unit of implementation.\nIn test-first development, the task implementers have to thoroughly understand \nthe specification so that they can write tests for the system. This means that ambi-\nguities and omissions in the specification have to be clarified before implementation \nbegins. Furthermore, it also avoids the problem of \u201ctest-lag.\u201d This may happen when \nthe developer of the system works at a faster pace than the tester. The implementa-\ntion gets further and further ahead of the testing and there is a tendency to skip tests, \nso that the development schedule can be maintained.\nXP\u2019s test-first approach assumes that user stories have been developed, and these \nhave been broken down into a set of task cards, as shown in Figure 3.6. Each task \ngenerates one or more unit tests that check the implementation described in that task. \nFigure 3.7 is a shortened description of a test case that has been developed to check \nthat the prescribed dose of a drug does not fall outside known safe limits.\nThe role of the customer in the testing process is to help develop acceptance tests \nfor the stories that are to be implemented in the next release of the system. As I \nexplain in Chapter 8, acceptance  testing is the process whereby the system is tested \nusing customer data to check that it meets the customer\u2019s real needs.\nTest automation is essential for test-first development. Tests are written as exe-\ncutable components before the task is implemented. These testing components \nshould be stand-alone, should simulate the submission of input to be tested, and \nshould check that the result meets the output specification. An automated test frame-\nwork is a system that makes it easy to write executable tests and submit a set of tests \nfor execution. Junit (Tahchiev et al. 2010) is a widely used example of an automated \ntesting framework for Java programs.\nInput:\n1.  A number in mg representing a single dose of the drug.\n2.  A number representing the number of single doses per day.\nTests:\n1.   Test for inputs where the single dose is correct but the frequency is too\nhigh.\n2.   Test for inputs where the single dose is too high and too low.\n3.   Test for inputs where the single dose * frequency is too high and too low.\n4.   Test for inputs where single dose * frequency is in the permitted range.\nOutput:\nOK or error message indicating that the dose is outside the safe range.\nTest 4: Dose checking\nFigure 3.7 Test case \ndescription for dose \nchecking"}
{"query": "What is the process of developing user stories in XP?", "response": "The process of developing user stories in XP involves breaking down the user stories into a set of task cards. Each task card represents a specific task that needs to be implemented. These tasks are the principal unit of implementation in XP. The task implementers thoroughly understand the specification of the user story so that they can write tests for the system. This helps clarify any ambiguities or omissions in the specification before implementation begins.", "context": "3.2  \u25a0 Agile development techniques  81\nthem immediately. When team members see code that can be improved, they make \nthese improvements even in situations where there is no immediate need for them.\nA fundamental problem of incremental development is that local changes tend to \ndegrade the software structure. Consequently, further changes to the software become \nharder and harder to implement. Essentially, the development proceeds by finding \nworkarounds to problems, with the result that code is often duplicated, parts of the \nsoftware are reused in inappropriate ways, and the overall structure degrades as code is \nadded to the system. Refactoring improves the software structure and readability and \nso avoids the structural deterioration that naturally occurs when software is changed.\nExamples of refactoring include the reorganization of a class hierarchy to remove \nduplicate code, the tidying up and renaming of attributes and methods, and the \nreplacement of similar code sections, with calls to methods defined in a program \nlibrary. Program development environments usually include tools for refactoring. \nThese simplify the process of finding dependencies between code sections and mak-\ning global code modifications.\nIn principle, when refactoring is part of the development process, the software \nshould always be easy to understand and change as new requirements are proposed. \nIn practice, this is not always the case. Sometimes development pressure means that \nrefactoring is delayed because the time is devoted to the implementation of new \nfunctionality. Some new features and changes cannot readily be accommodated by \ncode-level refactoring and require that the architecture of the system be modified.\n \n3.2.3  Test-first development\nAs I discussed in the introduction to this chapter, one of the important differences \nbetween incremental development and plan-driven development is in the way that \nthe system is tested. With incremental development, there is no system specification \nthat can be used by an external testing team to develop system tests. As a conse-\nquence, some approaches to incremental development have a very informal testing \nprocess, in comparison with plan-driven testing.\nExtreme Programming developed a new approach to program testing to address \nthe difficulties of testing without a specification. Testing is automated and is central \nto the development process, and development cannot proceed until all tests have \nbeen successfully executed. The key features of testing in XP are:\n1. test-first development,\n2. incremental test development from scenarios,\n3. user involvement in the test development and validation, and\n4. the use of automated testing frameworks.\nXP\u2019s test-first philosophy has now evolved into more general test-driven develop-\nment techniques (Jeffries and Melnik 2007). I believe that test-driven development is \none of the most important innovations in software engineering. Instead of writing code \nand then writing tests for that code, you write the tests before you write the code. This \n\n\n82  Chapter 3 \u25a0 Agile software development\nmeans that you can run the test as the code is being written and discover problems dur-\ning development. I discuss test-driven development in more depth in Chapter 8.\nWriting tests implicitly defines both an interface and a specification of behavior for \nthe functionality being developed. Problems of requirements and interface misunder-\nstandings are reduced. Test-first development requires there to be a clear relationship \nbetween system requirements and the code implementing the corresponding require-\nments. In XP, this relationship is clear because the story cards representing the require-\nments are broken down into tasks and the tasks are the principal unit of implementation.\nIn test-first development, the task implementers have to thoroughly understand \nthe specification so that they can write tests for the system. This means that ambi-\nguities and omissions in the specification have to be clarified before implementation \nbegins. Furthermore, it also avoids the problem of \u201ctest-lag.\u201d This may happen when \nthe developer of the system works at a faster pace than the tester. The implementa-\ntion gets further and further ahead of the testing and there is a tendency to skip tests, \nso that the development schedule can be maintained.\nXP\u2019s test-first approach assumes that user stories have been developed, and these \nhave been broken down into a set of task cards, as shown in Figure 3.6. Each task \ngenerates one or more unit tests that check the implementation described in that task. \nFigure 3.7 is a shortened description of a test case that has been developed to check \nthat the prescribed dose of a drug does not fall outside known safe limits.\nThe role of the customer in the testing process is to help develop acceptance tests \nfor the stories that are to be implemented in the next release of the system. As I \nexplain in Chapter 8, acceptance  testing is the process whereby the system is tested \nusing customer data to check that it meets the customer\u2019s real needs.\nTest automation is essential for test-first development. Tests are written as exe-\ncutable components before the task is implemented. These testing components \nshould be stand-alone, should simulate the submission of input to be tested, and \nshould check that the result meets the output specification. An automated test frame-\nwork is a system that makes it easy to write executable tests and submit a set of tests \nfor execution. Junit (Tahchiev et al. 2010) is a widely used example of an automated \ntesting framework for Java programs.\nInput:\n1.  A number in mg representing a single dose of the drug.\n2.  A number representing the number of single doses per day.\nTests:\n1.   Test for inputs where the single dose is correct but the frequency is too\nhigh.\n2.   Test for inputs where the single dose is too high and too low.\n3.   Test for inputs where the single dose * frequency is too high and too low.\n4.   Test for inputs where single dose * frequency is in the permitted range.\nOutput:\nOK or error message indicating that the dose is outside the safe range.\nTest 4: Dose checking\nFigure 3.7 Test case \ndescription for dose \nchecking"}
{"query": "How does test-first development ensure that the software is always easy to understand and change?", "response": "Test-first development ensures that the software is always easy to understand and change by requiring a clear relationship between system requirements and the code implementing those requirements. In test-first development, the task implementers thoroughly understand the specification in order to write tests for the system. This helps clarify any ambiguities or omissions in the specification before implementation begins. By writing tests before writing the code, any problems or issues can be discovered and addressed during development. This approach reduces misunderstandings of requirements and interfaces, making the software easier to understand and change as new requirements are proposed.", "context": "3.2  \u25a0 Agile development techniques  81\nthem immediately. When team members see code that can be improved, they make \nthese improvements even in situations where there is no immediate need for them.\nA fundamental problem of incremental development is that local changes tend to \ndegrade the software structure. Consequently, further changes to the software become \nharder and harder to implement. Essentially, the development proceeds by finding \nworkarounds to problems, with the result that code is often duplicated, parts of the \nsoftware are reused in inappropriate ways, and the overall structure degrades as code is \nadded to the system. Refactoring improves the software structure and readability and \nso avoids the structural deterioration that naturally occurs when software is changed.\nExamples of refactoring include the reorganization of a class hierarchy to remove \nduplicate code, the tidying up and renaming of attributes and methods, and the \nreplacement of similar code sections, with calls to methods defined in a program \nlibrary. Program development environments usually include tools for refactoring. \nThese simplify the process of finding dependencies between code sections and mak-\ning global code modifications.\nIn principle, when refactoring is part of the development process, the software \nshould always be easy to understand and change as new requirements are proposed. \nIn practice, this is not always the case. Sometimes development pressure means that \nrefactoring is delayed because the time is devoted to the implementation of new \nfunctionality. Some new features and changes cannot readily be accommodated by \ncode-level refactoring and require that the architecture of the system be modified.\n \n3.2.3  Test-first development\nAs I discussed in the introduction to this chapter, one of the important differences \nbetween incremental development and plan-driven development is in the way that \nthe system is tested. With incremental development, there is no system specification \nthat can be used by an external testing team to develop system tests. As a conse-\nquence, some approaches to incremental development have a very informal testing \nprocess, in comparison with plan-driven testing.\nExtreme Programming developed a new approach to program testing to address \nthe difficulties of testing without a specification. Testing is automated and is central \nto the development process, and development cannot proceed until all tests have \nbeen successfully executed. The key features of testing in XP are:\n1. test-first development,\n2. incremental test development from scenarios,\n3. user involvement in the test development and validation, and\n4. the use of automated testing frameworks.\nXP\u2019s test-first philosophy has now evolved into more general test-driven develop-\nment techniques (Jeffries and Melnik 2007). I believe that test-driven development is \none of the most important innovations in software engineering. Instead of writing code \nand then writing tests for that code, you write the tests before you write the code. This \n\n\n82  Chapter 3 \u25a0 Agile software development\nmeans that you can run the test as the code is being written and discover problems dur-\ning development. I discuss test-driven development in more depth in Chapter 8.\nWriting tests implicitly defines both an interface and a specification of behavior for \nthe functionality being developed. Problems of requirements and interface misunder-\nstandings are reduced. Test-first development requires there to be a clear relationship \nbetween system requirements and the code implementing the corresponding require-\nments. In XP, this relationship is clear because the story cards representing the require-\nments are broken down into tasks and the tasks are the principal unit of implementation.\nIn test-first development, the task implementers have to thoroughly understand \nthe specification so that they can write tests for the system. This means that ambi-\nguities and omissions in the specification have to be clarified before implementation \nbegins. Furthermore, it also avoids the problem of \u201ctest-lag.\u201d This may happen when \nthe developer of the system works at a faster pace than the tester. The implementa-\ntion gets further and further ahead of the testing and there is a tendency to skip tests, \nso that the development schedule can be maintained.\nXP\u2019s test-first approach assumes that user stories have been developed, and these \nhave been broken down into a set of task cards, as shown in Figure 3.6. Each task \ngenerates one or more unit tests that check the implementation described in that task. \nFigure 3.7 is a shortened description of a test case that has been developed to check \nthat the prescribed dose of a drug does not fall outside known safe limits.\nThe role of the customer in the testing process is to help develop acceptance tests \nfor the stories that are to be implemented in the next release of the system. As I \nexplain in Chapter 8, acceptance  testing is the process whereby the system is tested \nusing customer data to check that it meets the customer\u2019s real needs.\nTest automation is essential for test-first development. Tests are written as exe-\ncutable components before the task is implemented. These testing components \nshould be stand-alone, should simulate the submission of input to be tested, and \nshould check that the result meets the output specification. An automated test frame-\nwork is a system that makes it easy to write executable tests and submit a set of tests \nfor execution. Junit (Tahchiev et al. 2010) is a widely used example of an automated \ntesting framework for Java programs.\nInput:\n1.  A number in mg representing a single dose of the drug.\n2.  A number representing the number of single doses per day.\nTests:\n1.   Test for inputs where the single dose is correct but the frequency is too\nhigh.\n2.   Test for inputs where the single dose is too high and too low.\n3.   Test for inputs where the single dose * frequency is too high and too low.\n4.   Test for inputs where single dose * frequency is in the permitted range.\nOutput:\nOK or error message indicating that the dose is outside the safe range.\nTest 4: Dose checking\nFigure 3.7 Test case \ndescription for dose \nchecking"}
{"query": "What is the purpose of renaming attributes and methods in refactoring?", "response": "Renaming attributes and methods in refactoring serves the purpose of improving the software structure and readability. By giving more meaningful and descriptive names to attributes and methods, the code becomes easier to understand and maintain. This helps to avoid confusion and reduces the likelihood of errors when working with the code.", "context": "3.2  \u25a0 Agile development techniques  81\nthem immediately. When team members see code that can be improved, they make \nthese improvements even in situations where there is no immediate need for them.\nA fundamental problem of incremental development is that local changes tend to \ndegrade the software structure. Consequently, further changes to the software become \nharder and harder to implement. Essentially, the development proceeds by finding \nworkarounds to problems, with the result that code is often duplicated, parts of the \nsoftware are reused in inappropriate ways, and the overall structure degrades as code is \nadded to the system. Refactoring improves the software structure and readability and \nso avoids the structural deterioration that naturally occurs when software is changed.\nExamples of refactoring include the reorganization of a class hierarchy to remove \nduplicate code, the tidying up and renaming of attributes and methods, and the \nreplacement of similar code sections, with calls to methods defined in a program \nlibrary. Program development environments usually include tools for refactoring. \nThese simplify the process of finding dependencies between code sections and mak-\ning global code modifications.\nIn principle, when refactoring is part of the development process, the software \nshould always be easy to understand and change as new requirements are proposed. \nIn practice, this is not always the case. Sometimes development pressure means that \nrefactoring is delayed because the time is devoted to the implementation of new \nfunctionality. Some new features and changes cannot readily be accommodated by \ncode-level refactoring and require that the architecture of the system be modified.\n \n3.2.3  Test-first development\nAs I discussed in the introduction to this chapter, one of the important differences \nbetween incremental development and plan-driven development is in the way that \nthe system is tested. With incremental development, there is no system specification \nthat can be used by an external testing team to develop system tests. As a conse-\nquence, some approaches to incremental development have a very informal testing \nprocess, in comparison with plan-driven testing.\nExtreme Programming developed a new approach to program testing to address \nthe difficulties of testing without a specification. Testing is automated and is central \nto the development process, and development cannot proceed until all tests have \nbeen successfully executed. The key features of testing in XP are:\n1. test-first development,\n2. incremental test development from scenarios,\n3. user involvement in the test development and validation, and\n4. the use of automated testing frameworks.\nXP\u2019s test-first philosophy has now evolved into more general test-driven develop-\nment techniques (Jeffries and Melnik 2007). I believe that test-driven development is \none of the most important innovations in software engineering. Instead of writing code \nand then writing tests for that code, you write the tests before you write the code. This \n\n\n82  Chapter 3 \u25a0 Agile software development\nmeans that you can run the test as the code is being written and discover problems dur-\ning development. I discuss test-driven development in more depth in Chapter 8.\nWriting tests implicitly defines both an interface and a specification of behavior for \nthe functionality being developed. Problems of requirements and interface misunder-\nstandings are reduced. Test-first development requires there to be a clear relationship \nbetween system requirements and the code implementing the corresponding require-\nments. In XP, this relationship is clear because the story cards representing the require-\nments are broken down into tasks and the tasks are the principal unit of implementation.\nIn test-first development, the task implementers have to thoroughly understand \nthe specification so that they can write tests for the system. This means that ambi-\nguities and omissions in the specification have to be clarified before implementation \nbegins. Furthermore, it also avoids the problem of \u201ctest-lag.\u201d This may happen when \nthe developer of the system works at a faster pace than the tester. The implementa-\ntion gets further and further ahead of the testing and there is a tendency to skip tests, \nso that the development schedule can be maintained.\nXP\u2019s test-first approach assumes that user stories have been developed, and these \nhave been broken down into a set of task cards, as shown in Figure 3.6. Each task \ngenerates one or more unit tests that check the implementation described in that task. \nFigure 3.7 is a shortened description of a test case that has been developed to check \nthat the prescribed dose of a drug does not fall outside known safe limits.\nThe role of the customer in the testing process is to help develop acceptance tests \nfor the stories that are to be implemented in the next release of the system. As I \nexplain in Chapter 8, acceptance  testing is the process whereby the system is tested \nusing customer data to check that it meets the customer\u2019s real needs.\nTest automation is essential for test-first development. Tests are written as exe-\ncutable components before the task is implemented. These testing components \nshould be stand-alone, should simulate the submission of input to be tested, and \nshould check that the result meets the output specification. An automated test frame-\nwork is a system that makes it easy to write executable tests and submit a set of tests \nfor execution. Junit (Tahchiev et al. 2010) is a widely used example of an automated \ntesting framework for Java programs.\nInput:\n1.  A number in mg representing a single dose of the drug.\n2.  A number representing the number of single doses per day.\nTests:\n1.   Test for inputs where the single dose is correct but the frequency is too\nhigh.\n2.   Test for inputs where the single dose is too high and too low.\n3.   Test for inputs where the single dose * frequency is too high and too low.\n4.   Test for inputs where single dose * frequency is in the permitted range.\nOutput:\nOK or error message indicating that the dose is outside the safe range.\nTest 4: Dose checking\nFigure 3.7 Test case \ndescription for dose \nchecking"}
{"query": "How does the test-first development approach differ from traditional software testing methods?", "response": "The test-first development approach differs from traditional software testing methods in that it emphasizes writing tests before writing the code. In test-first development, tests are written as executable components before the implementation of a task. This approach allows for running tests as the code is being written, enabling the discovery of problems during development. It also implicitly defines both an interface and a specification of behavior for the functionality being developed, reducing problems of requirements and interface misunderstandings. Additionally, test-first development requires a clear relationship between system requirements and the corresponding code, ensuring that ambiguities and omissions in the specification are clarified before implementation begins. This approach helps to avoid the problem of \"test-lag\" where the development pace outpaces testing, leading to skipped tests.", "context": "3.2  \u25a0 Agile development techniques  81\nthem immediately. When team members see code that can be improved, they make \nthese improvements even in situations where there is no immediate need for them.\nA fundamental problem of incremental development is that local changes tend to \ndegrade the software structure. Consequently, further changes to the software become \nharder and harder to implement. Essentially, the development proceeds by finding \nworkarounds to problems, with the result that code is often duplicated, parts of the \nsoftware are reused in inappropriate ways, and the overall structure degrades as code is \nadded to the system. Refactoring improves the software structure and readability and \nso avoids the structural deterioration that naturally occurs when software is changed.\nExamples of refactoring include the reorganization of a class hierarchy to remove \nduplicate code, the tidying up and renaming of attributes and methods, and the \nreplacement of similar code sections, with calls to methods defined in a program \nlibrary. Program development environments usually include tools for refactoring. \nThese simplify the process of finding dependencies between code sections and mak-\ning global code modifications.\nIn principle, when refactoring is part of the development process, the software \nshould always be easy to understand and change as new requirements are proposed. \nIn practice, this is not always the case. Sometimes development pressure means that \nrefactoring is delayed because the time is devoted to the implementation of new \nfunctionality. Some new features and changes cannot readily be accommodated by \ncode-level refactoring and require that the architecture of the system be modified.\n \n3.2.3  Test-first development\nAs I discussed in the introduction to this chapter, one of the important differences \nbetween incremental development and plan-driven development is in the way that \nthe system is tested. With incremental development, there is no system specification \nthat can be used by an external testing team to develop system tests. As a conse-\nquence, some approaches to incremental development have a very informal testing \nprocess, in comparison with plan-driven testing.\nExtreme Programming developed a new approach to program testing to address \nthe difficulties of testing without a specification. Testing is automated and is central \nto the development process, and development cannot proceed until all tests have \nbeen successfully executed. The key features of testing in XP are:\n1. test-first development,\n2. incremental test development from scenarios,\n3. user involvement in the test development and validation, and\n4. the use of automated testing frameworks.\nXP\u2019s test-first philosophy has now evolved into more general test-driven develop-\nment techniques (Jeffries and Melnik 2007). I believe that test-driven development is \none of the most important innovations in software engineering. Instead of writing code \nand then writing tests for that code, you write the tests before you write the code. This \n\n\n82  Chapter 3 \u25a0 Agile software development\nmeans that you can run the test as the code is being written and discover problems dur-\ning development. I discuss test-driven development in more depth in Chapter 8.\nWriting tests implicitly defines both an interface and a specification of behavior for \nthe functionality being developed. Problems of requirements and interface misunder-\nstandings are reduced. Test-first development requires there to be a clear relationship \nbetween system requirements and the code implementing the corresponding require-\nments. In XP, this relationship is clear because the story cards representing the require-\nments are broken down into tasks and the tasks are the principal unit of implementation.\nIn test-first development, the task implementers have to thoroughly understand \nthe specification so that they can write tests for the system. This means that ambi-\nguities and omissions in the specification have to be clarified before implementation \nbegins. Furthermore, it also avoids the problem of \u201ctest-lag.\u201d This may happen when \nthe developer of the system works at a faster pace than the tester. The implementa-\ntion gets further and further ahead of the testing and there is a tendency to skip tests, \nso that the development schedule can be maintained.\nXP\u2019s test-first approach assumes that user stories have been developed, and these \nhave been broken down into a set of task cards, as shown in Figure 3.6. Each task \ngenerates one or more unit tests that check the implementation described in that task. \nFigure 3.7 is a shortened description of a test case that has been developed to check \nthat the prescribed dose of a drug does not fall outside known safe limits.\nThe role of the customer in the testing process is to help develop acceptance tests \nfor the stories that are to be implemented in the next release of the system. As I \nexplain in Chapter 8, acceptance  testing is the process whereby the system is tested \nusing customer data to check that it meets the customer\u2019s real needs.\nTest automation is essential for test-first development. Tests are written as exe-\ncutable components before the task is implemented. These testing components \nshould be stand-alone, should simulate the submission of input to be tested, and \nshould check that the result meets the output specification. An automated test frame-\nwork is a system that makes it easy to write executable tests and submit a set of tests \nfor execution. Junit (Tahchiev et al. 2010) is a widely used example of an automated \ntesting framework for Java programs.\nInput:\n1.  A number in mg representing a single dose of the drug.\n2.  A number representing the number of single doses per day.\nTests:\n1.   Test for inputs where the single dose is correct but the frequency is too\nhigh.\n2.   Test for inputs where the single dose is too high and too low.\n3.   Test for inputs where the single dose * frequency is too high and too low.\n4.   Test for inputs where single dose * frequency is in the permitted range.\nOutput:\nOK or error message indicating that the dose is outside the safe range.\nTest 4: Dose checking\nFigure 3.7 Test case \ndescription for dose \nchecking"}
{"query": "What is the relationship between task cards and unit tests in XP?", "response": "In XP (Extreme Programming), task cards are broken down from user stories and serve as the principal unit of implementation. Each task card generates one or more unit tests that check the implementation described in that task. Therefore, the relationship between task cards and unit tests in XP is that unit tests are developed based on the tasks specified in the task cards.", "context": "3.2  \u25a0 Agile development techniques  81\nthem immediately. When team members see code that can be improved, they make \nthese improvements even in situations where there is no immediate need for them.\nA fundamental problem of incremental development is that local changes tend to \ndegrade the software structure. Consequently, further changes to the software become \nharder and harder to implement. Essentially, the development proceeds by finding \nworkarounds to problems, with the result that code is often duplicated, parts of the \nsoftware are reused in inappropriate ways, and the overall structure degrades as code is \nadded to the system. Refactoring improves the software structure and readability and \nso avoids the structural deterioration that naturally occurs when software is changed.\nExamples of refactoring include the reorganization of a class hierarchy to remove \nduplicate code, the tidying up and renaming of attributes and methods, and the \nreplacement of similar code sections, with calls to methods defined in a program \nlibrary. Program development environments usually include tools for refactoring. \nThese simplify the process of finding dependencies between code sections and mak-\ning global code modifications.\nIn principle, when refactoring is part of the development process, the software \nshould always be easy to understand and change as new requirements are proposed. \nIn practice, this is not always the case. Sometimes development pressure means that \nrefactoring is delayed because the time is devoted to the implementation of new \nfunctionality. Some new features and changes cannot readily be accommodated by \ncode-level refactoring and require that the architecture of the system be modified.\n \n3.2.3  Test-first development\nAs I discussed in the introduction to this chapter, one of the important differences \nbetween incremental development and plan-driven development is in the way that \nthe system is tested. With incremental development, there is no system specification \nthat can be used by an external testing team to develop system tests. As a conse-\nquence, some approaches to incremental development have a very informal testing \nprocess, in comparison with plan-driven testing.\nExtreme Programming developed a new approach to program testing to address \nthe difficulties of testing without a specification. Testing is automated and is central \nto the development process, and development cannot proceed until all tests have \nbeen successfully executed. The key features of testing in XP are:\n1. test-first development,\n2. incremental test development from scenarios,\n3. user involvement in the test development and validation, and\n4. the use of automated testing frameworks.\nXP\u2019s test-first philosophy has now evolved into more general test-driven develop-\nment techniques (Jeffries and Melnik 2007). I believe that test-driven development is \none of the most important innovations in software engineering. Instead of writing code \nand then writing tests for that code, you write the tests before you write the code. This \n\n\n82  Chapter 3 \u25a0 Agile software development\nmeans that you can run the test as the code is being written and discover problems dur-\ning development. I discuss test-driven development in more depth in Chapter 8.\nWriting tests implicitly defines both an interface and a specification of behavior for \nthe functionality being developed. Problems of requirements and interface misunder-\nstandings are reduced. Test-first development requires there to be a clear relationship \nbetween system requirements and the code implementing the corresponding require-\nments. In XP, this relationship is clear because the story cards representing the require-\nments are broken down into tasks and the tasks are the principal unit of implementation.\nIn test-first development, the task implementers have to thoroughly understand \nthe specification so that they can write tests for the system. This means that ambi-\nguities and omissions in the specification have to be clarified before implementation \nbegins. Furthermore, it also avoids the problem of \u201ctest-lag.\u201d This may happen when \nthe developer of the system works at a faster pace than the tester. The implementa-\ntion gets further and further ahead of the testing and there is a tendency to skip tests, \nso that the development schedule can be maintained.\nXP\u2019s test-first approach assumes that user stories have been developed, and these \nhave been broken down into a set of task cards, as shown in Figure 3.6. Each task \ngenerates one or more unit tests that check the implementation described in that task. \nFigure 3.7 is a shortened description of a test case that has been developed to check \nthat the prescribed dose of a drug does not fall outside known safe limits.\nThe role of the customer in the testing process is to help develop acceptance tests \nfor the stories that are to be implemented in the next release of the system. As I \nexplain in Chapter 8, acceptance  testing is the process whereby the system is tested \nusing customer data to check that it meets the customer\u2019s real needs.\nTest automation is essential for test-first development. Tests are written as exe-\ncutable components before the task is implemented. These testing components \nshould be stand-alone, should simulate the submission of input to be tested, and \nshould check that the result meets the output specification. An automated test frame-\nwork is a system that makes it easy to write executable tests and submit a set of tests \nfor execution. Junit (Tahchiev et al. 2010) is a widely used example of an automated \ntesting framework for Java programs.\nInput:\n1.  A number in mg representing a single dose of the drug.\n2.  A number representing the number of single doses per day.\nTests:\n1.   Test for inputs where the single dose is correct but the frequency is too\nhigh.\n2.   Test for inputs where the single dose is too high and too low.\n3.   Test for inputs where the single dose * frequency is too high and too low.\n4.   Test for inputs where single dose * frequency is in the permitted range.\nOutput:\nOK or error message indicating that the dose is outside the safe range.\nTest 4: Dose checking\nFigure 3.7 Test case \ndescription for dose \nchecking"}
{"query": "How does the test-first development approach handle ambiguities and omissions in the specification?", "response": "The test-first development approach handles ambiguities and omissions in the specification by requiring thorough understanding of the specification before implementation begins. In test-first development, the task implementers write tests for the system based on the specification, which helps clarify any ambiguities or omissions. This ensures that the relationship between system requirements and the corresponding code implementation is clear. By writing tests before writing the code, any issues or misunderstandings in the specification can be identified and resolved early in the development process.", "context": "3.2  \u25a0 Agile development techniques  81\nthem immediately. When team members see code that can be improved, they make \nthese improvements even in situations where there is no immediate need for them.\nA fundamental problem of incremental development is that local changes tend to \ndegrade the software structure. Consequently, further changes to the software become \nharder and harder to implement. Essentially, the development proceeds by finding \nworkarounds to problems, with the result that code is often duplicated, parts of the \nsoftware are reused in inappropriate ways, and the overall structure degrades as code is \nadded to the system. Refactoring improves the software structure and readability and \nso avoids the structural deterioration that naturally occurs when software is changed.\nExamples of refactoring include the reorganization of a class hierarchy to remove \nduplicate code, the tidying up and renaming of attributes and methods, and the \nreplacement of similar code sections, with calls to methods defined in a program \nlibrary. Program development environments usually include tools for refactoring. \nThese simplify the process of finding dependencies between code sections and mak-\ning global code modifications.\nIn principle, when refactoring is part of the development process, the software \nshould always be easy to understand and change as new requirements are proposed. \nIn practice, this is not always the case. Sometimes development pressure means that \nrefactoring is delayed because the time is devoted to the implementation of new \nfunctionality. Some new features and changes cannot readily be accommodated by \ncode-level refactoring and require that the architecture of the system be modified.\n \n3.2.3  Test-first development\nAs I discussed in the introduction to this chapter, one of the important differences \nbetween incremental development and plan-driven development is in the way that \nthe system is tested. With incremental development, there is no system specification \nthat can be used by an external testing team to develop system tests. As a conse-\nquence, some approaches to incremental development have a very informal testing \nprocess, in comparison with plan-driven testing.\nExtreme Programming developed a new approach to program testing to address \nthe difficulties of testing without a specification. Testing is automated and is central \nto the development process, and development cannot proceed until all tests have \nbeen successfully executed. The key features of testing in XP are:\n1. test-first development,\n2. incremental test development from scenarios,\n3. user involvement in the test development and validation, and\n4. the use of automated testing frameworks.\nXP\u2019s test-first philosophy has now evolved into more general test-driven develop-\nment techniques (Jeffries and Melnik 2007). I believe that test-driven development is \none of the most important innovations in software engineering. Instead of writing code \nand then writing tests for that code, you write the tests before you write the code. This \n\n\n82  Chapter 3 \u25a0 Agile software development\nmeans that you can run the test as the code is being written and discover problems dur-\ning development. I discuss test-driven development in more depth in Chapter 8.\nWriting tests implicitly defines both an interface and a specification of behavior for \nthe functionality being developed. Problems of requirements and interface misunder-\nstandings are reduced. Test-first development requires there to be a clear relationship \nbetween system requirements and the code implementing the corresponding require-\nments. In XP, this relationship is clear because the story cards representing the require-\nments are broken down into tasks and the tasks are the principal unit of implementation.\nIn test-first development, the task implementers have to thoroughly understand \nthe specification so that they can write tests for the system. This means that ambi-\nguities and omissions in the specification have to be clarified before implementation \nbegins. Furthermore, it also avoids the problem of \u201ctest-lag.\u201d This may happen when \nthe developer of the system works at a faster pace than the tester. The implementa-\ntion gets further and further ahead of the testing and there is a tendency to skip tests, \nso that the development schedule can be maintained.\nXP\u2019s test-first approach assumes that user stories have been developed, and these \nhave been broken down into a set of task cards, as shown in Figure 3.6. Each task \ngenerates one or more unit tests that check the implementation described in that task. \nFigure 3.7 is a shortened description of a test case that has been developed to check \nthat the prescribed dose of a drug does not fall outside known safe limits.\nThe role of the customer in the testing process is to help develop acceptance tests \nfor the stories that are to be implemented in the next release of the system. As I \nexplain in Chapter 8, acceptance  testing is the process whereby the system is tested \nusing customer data to check that it meets the customer\u2019s real needs.\nTest automation is essential for test-first development. Tests are written as exe-\ncutable components before the task is implemented. These testing components \nshould be stand-alone, should simulate the submission of input to be tested, and \nshould check that the result meets the output specification. An automated test frame-\nwork is a system that makes it easy to write executable tests and submit a set of tests \nfor execution. Junit (Tahchiev et al. 2010) is a widely used example of an automated \ntesting framework for Java programs.\nInput:\n1.  A number in mg representing a single dose of the drug.\n2.  A number representing the number of single doses per day.\nTests:\n1.   Test for inputs where the single dose is correct but the frequency is too\nhigh.\n2.   Test for inputs where the single dose is too high and too low.\n3.   Test for inputs where the single dose * frequency is too high and too low.\n4.   Test for inputs where single dose * frequency is in the permitted range.\nOutput:\nOK or error message indicating that the dose is outside the safe range.\nTest 4: Dose checking\nFigure 3.7 Test case \ndescription for dose \nchecking"}
{"query": "What is the role of an automated testing framework in test-first development?", "response": "An automated testing framework plays a crucial role in test-first development. It allows developers to write executable tests before implementing the corresponding tasks. These testing components are stand-alone and simulate the submission of input to be tested. The framework also checks that the output meets the specified requirements. By providing a system for easily writing and executing tests, an automated testing framework enables developers to ensure that all tests have been successfully executed before proceeding with the development process.", "context": "3.2  \u25a0 Agile development techniques  81\nthem immediately. When team members see code that can be improved, they make \nthese improvements even in situations where there is no immediate need for them.\nA fundamental problem of incremental development is that local changes tend to \ndegrade the software structure. Consequently, further changes to the software become \nharder and harder to implement. Essentially, the development proceeds by finding \nworkarounds to problems, with the result that code is often duplicated, parts of the \nsoftware are reused in inappropriate ways, and the overall structure degrades as code is \nadded to the system. Refactoring improves the software structure and readability and \nso avoids the structural deterioration that naturally occurs when software is changed.\nExamples of refactoring include the reorganization of a class hierarchy to remove \nduplicate code, the tidying up and renaming of attributes and methods, and the \nreplacement of similar code sections, with calls to methods defined in a program \nlibrary. Program development environments usually include tools for refactoring. \nThese simplify the process of finding dependencies between code sections and mak-\ning global code modifications.\nIn principle, when refactoring is part of the development process, the software \nshould always be easy to understand and change as new requirements are proposed. \nIn practice, this is not always the case. Sometimes development pressure means that \nrefactoring is delayed because the time is devoted to the implementation of new \nfunctionality. Some new features and changes cannot readily be accommodated by \ncode-level refactoring and require that the architecture of the system be modified.\n \n3.2.3  Test-first development\nAs I discussed in the introduction to this chapter, one of the important differences \nbetween incremental development and plan-driven development is in the way that \nthe system is tested. With incremental development, there is no system specification \nthat can be used by an external testing team to develop system tests. As a conse-\nquence, some approaches to incremental development have a very informal testing \nprocess, in comparison with plan-driven testing.\nExtreme Programming developed a new approach to program testing to address \nthe difficulties of testing without a specification. Testing is automated and is central \nto the development process, and development cannot proceed until all tests have \nbeen successfully executed. The key features of testing in XP are:\n1. test-first development,\n2. incremental test development from scenarios,\n3. user involvement in the test development and validation, and\n4. the use of automated testing frameworks.\nXP\u2019s test-first philosophy has now evolved into more general test-driven develop-\nment techniques (Jeffries and Melnik 2007). I believe that test-driven development is \none of the most important innovations in software engineering. Instead of writing code \nand then writing tests for that code, you write the tests before you write the code. This \n\n\n82  Chapter 3 \u25a0 Agile software development\nmeans that you can run the test as the code is being written and discover problems dur-\ning development. I discuss test-driven development in more depth in Chapter 8.\nWriting tests implicitly defines both an interface and a specification of behavior for \nthe functionality being developed. Problems of requirements and interface misunder-\nstandings are reduced. Test-first development requires there to be a clear relationship \nbetween system requirements and the code implementing the corresponding require-\nments. In XP, this relationship is clear because the story cards representing the require-\nments are broken down into tasks and the tasks are the principal unit of implementation.\nIn test-first development, the task implementers have to thoroughly understand \nthe specification so that they can write tests for the system. This means that ambi-\nguities and omissions in the specification have to be clarified before implementation \nbegins. Furthermore, it also avoids the problem of \u201ctest-lag.\u201d This may happen when \nthe developer of the system works at a faster pace than the tester. The implementa-\ntion gets further and further ahead of the testing and there is a tendency to skip tests, \nso that the development schedule can be maintained.\nXP\u2019s test-first approach assumes that user stories have been developed, and these \nhave been broken down into a set of task cards, as shown in Figure 3.6. Each task \ngenerates one or more unit tests that check the implementation described in that task. \nFigure 3.7 is a shortened description of a test case that has been developed to check \nthat the prescribed dose of a drug does not fall outside known safe limits.\nThe role of the customer in the testing process is to help develop acceptance tests \nfor the stories that are to be implemented in the next release of the system. As I \nexplain in Chapter 8, acceptance  testing is the process whereby the system is tested \nusing customer data to check that it meets the customer\u2019s real needs.\nTest automation is essential for test-first development. Tests are written as exe-\ncutable components before the task is implemented. These testing components \nshould be stand-alone, should simulate the submission of input to be tested, and \nshould check that the result meets the output specification. An automated test frame-\nwork is a system that makes it easy to write executable tests and submit a set of tests \nfor execution. Junit (Tahchiev et al. 2010) is a widely used example of an automated \ntesting framework for Java programs.\nInput:\n1.  A number in mg representing a single dose of the drug.\n2.  A number representing the number of single doses per day.\nTests:\n1.   Test for inputs where the single dose is correct but the frequency is too\nhigh.\n2.   Test for inputs where the single dose is too high and too low.\n3.   Test for inputs where the single dose * frequency is too high and too low.\n4.   Test for inputs where single dose * frequency is in the permitted range.\nOutput:\nOK or error message indicating that the dose is outside the safe range.\nTest 4: Dose checking\nFigure 3.7 Test case \ndescription for dose \nchecking"}
{"query": "How does test-first development ensure that the development schedule can be maintained?", "response": "Test-first development ensures that the development schedule can be maintained by avoiding the problem of \"test-lag.\" This occurs when the developer of the system works at a faster pace than the tester, causing the implementation to get further ahead of the testing. With test-first development, tests are written before the code is implemented, which means that the tests can be run as the code is being written. This allows any problems or issues to be discovered and addressed during development, preventing the need to skip tests and maintain the development schedule.", "context": "3.2  \u25a0 Agile development techniques  81\nthem immediately. When team members see code that can be improved, they make \nthese improvements even in situations where there is no immediate need for them.\nA fundamental problem of incremental development is that local changes tend to \ndegrade the software structure. Consequently, further changes to the software become \nharder and harder to implement. Essentially, the development proceeds by finding \nworkarounds to problems, with the result that code is often duplicated, parts of the \nsoftware are reused in inappropriate ways, and the overall structure degrades as code is \nadded to the system. Refactoring improves the software structure and readability and \nso avoids the structural deterioration that naturally occurs when software is changed.\nExamples of refactoring include the reorganization of a class hierarchy to remove \nduplicate code, the tidying up and renaming of attributes and methods, and the \nreplacement of similar code sections, with calls to methods defined in a program \nlibrary. Program development environments usually include tools for refactoring. \nThese simplify the process of finding dependencies between code sections and mak-\ning global code modifications.\nIn principle, when refactoring is part of the development process, the software \nshould always be easy to understand and change as new requirements are proposed. \nIn practice, this is not always the case. Sometimes development pressure means that \nrefactoring is delayed because the time is devoted to the implementation of new \nfunctionality. Some new features and changes cannot readily be accommodated by \ncode-level refactoring and require that the architecture of the system be modified.\n \n3.2.3  Test-first development\nAs I discussed in the introduction to this chapter, one of the important differences \nbetween incremental development and plan-driven development is in the way that \nthe system is tested. With incremental development, there is no system specification \nthat can be used by an external testing team to develop system tests. As a conse-\nquence, some approaches to incremental development have a very informal testing \nprocess, in comparison with plan-driven testing.\nExtreme Programming developed a new approach to program testing to address \nthe difficulties of testing without a specification. Testing is automated and is central \nto the development process, and development cannot proceed until all tests have \nbeen successfully executed. The key features of testing in XP are:\n1. test-first development,\n2. incremental test development from scenarios,\n3. user involvement in the test development and validation, and\n4. the use of automated testing frameworks.\nXP\u2019s test-first philosophy has now evolved into more general test-driven develop-\nment techniques (Jeffries and Melnik 2007). I believe that test-driven development is \none of the most important innovations in software engineering. Instead of writing code \nand then writing tests for that code, you write the tests before you write the code. This \n\n\n82  Chapter 3 \u25a0 Agile software development\nmeans that you can run the test as the code is being written and discover problems dur-\ning development. I discuss test-driven development in more depth in Chapter 8.\nWriting tests implicitly defines both an interface and a specification of behavior for \nthe functionality being developed. Problems of requirements and interface misunder-\nstandings are reduced. Test-first development requires there to be a clear relationship \nbetween system requirements and the code implementing the corresponding require-\nments. In XP, this relationship is clear because the story cards representing the require-\nments are broken down into tasks and the tasks are the principal unit of implementation.\nIn test-first development, the task implementers have to thoroughly understand \nthe specification so that they can write tests for the system. This means that ambi-\nguities and omissions in the specification have to be clarified before implementation \nbegins. Furthermore, it also avoids the problem of \u201ctest-lag.\u201d This may happen when \nthe developer of the system works at a faster pace than the tester. The implementa-\ntion gets further and further ahead of the testing and there is a tendency to skip tests, \nso that the development schedule can be maintained.\nXP\u2019s test-first approach assumes that user stories have been developed, and these \nhave been broken down into a set of task cards, as shown in Figure 3.6. Each task \ngenerates one or more unit tests that check the implementation described in that task. \nFigure 3.7 is a shortened description of a test case that has been developed to check \nthat the prescribed dose of a drug does not fall outside known safe limits.\nThe role of the customer in the testing process is to help develop acceptance tests \nfor the stories that are to be implemented in the next release of the system. As I \nexplain in Chapter 8, acceptance  testing is the process whereby the system is tested \nusing customer data to check that it meets the customer\u2019s real needs.\nTest automation is essential for test-first development. Tests are written as exe-\ncutable components before the task is implemented. These testing components \nshould be stand-alone, should simulate the submission of input to be tested, and \nshould check that the result meets the output specification. An automated test frame-\nwork is a system that makes it easy to write executable tests and submit a set of tests \nfor execution. Junit (Tahchiev et al. 2010) is a widely used example of an automated \ntesting framework for Java programs.\nInput:\n1.  A number in mg representing a single dose of the drug.\n2.  A number representing the number of single doses per day.\nTests:\n1.   Test for inputs where the single dose is correct but the frequency is too\nhigh.\n2.   Test for inputs where the single dose is too high and too low.\n3.   Test for inputs where the single dose * frequency is too high and too low.\n4.   Test for inputs where single dose * frequency is in the permitted range.\nOutput:\nOK or error message indicating that the dose is outside the safe range.\nTest 4: Dose checking\nFigure 3.7 Test case \ndescription for dose \nchecking"}
{"query": "What is the role of automated testing in agile development techniques?", "response": "Automated testing plays a crucial role in agile development techniques. It allows for quick and easy execution of tests whenever new functionality is added to the system. This helps in catching any problems introduced by the new code immediately. Test-first development and automated testing result in a large number of tests being written and executed. However, there can be challenges in ensuring complete test coverage. Programmers may sometimes take shortcuts when writing tests, leading to incomplete tests. Additionally, writing unit tests for complex user interfaces can be difficult. Despite these challenges, a large set of frequently executed tests may give the impression that the system is complete and correct. However, it is important to review the tests and write further tests after development to detect any undetected bugs before system release.", "context": "3.2  \u25a0 Agile development techniques  83\nAs testing is automated, there is always a set of tests that can be quickly and eas-\nily executed. Whenever any functionality is added to the system, the tests can be run \nand problems that the new code has introduced can be caught immediately.\nTest-first development and automated testing usually result in a large number of \ntests being written and executed. However, there are problems in ensuring that test \ncoverage is complete:\n1. Programmers prefer programming to testing, and sometimes they take shortcuts \nwhen writing tests. For example, they may write incomplete tests that do not \ncheck for all possible exceptions that may occur.\n2. Some tests can be very difficult to write incrementally. For example, in a com-\nplex user interface, it is often difficult to write unit tests for the code that imple-\nments the \u201cdisplay logic\u201d and workflow between screens.\nIt is difficult to judge the completeness of a set of tests. Although you may have a lot \nof system tests, your test set may not provide complete coverage. Crucial parts of \nthe\u00a0system may not be executed and so will remain untested. Therefore, although a \nlarge set of frequently executed tests may give the impression that the system is complete \nand correct, this may not be the case. If the tests are not reviewed and further tests are \nwritten after development, then undetected bugs may be delivered in the system release.\n \n3.2.4  Pair programming\nAnother innovative practice that was introduced in XP is that programmers work in \npairs to develop the software. The programming pair sits at the same computer to \ndevelop the software. However, the same pair do not always program together. \nRather, pairs are created dynamically so that all team members work with each other \nduring the development process.\nPair programming has a number of advantages.\n1. It supports the idea of collective ownership and responsibility for the system. \nThis reflects Weinberg\u2019s idea of egoless programming (Weinberg 1971) where \nthe software is owned by the team as a whole and individuals are not held \nresponsible for problems with the code. Instead, the team has collective respon-\nsibility for resolving these problems.\n2. \nIt acts as an informal review process because each line of code is looked at by at least \ntwo people. Code inspections and reviews (Chapter 24) are effective in discovering \na high percentage of software errors. However, they are time consuming to organize \nand, typically, introduce delays into the development process. Pair programming is a \nless formal process that probably doesn\u2019t find as many errors as code inspections. \nHowever, it is cheaper and easier to organize than formal program inspections.\n3. \nIt encourages refactoring to improve the software structure. The problem with ask-\ning programmers to refactor in a normal development environment is that effort \n\n\n84  Chapter 3 \u25a0 Agile software development\ninvolved is expended for long-term benefit. An developer who spends time refac-\ntoring may be judged to be less efficient than one who simply carries on developing \ncode. Where pair programming and collective ownership are used, others benefit \nimmediately from the refactoring so they are likely to support the process.\nYou might think that pair programming would be less efficient than individual \nprogramming. In a given time, a pair of developers would produce half as much code \nas two individuals working alone. Many companies that have adopted agile methods \nare suspicious of pair programming and do not use it. Other companies mix pair and \nindividual programming with an experienced programmer working with a less expe-\nrienced colleague when they have problems.\nFormal studies of the value of pair programming have had mixed results. Using \nstudent volunteers, Williams and her collaborators (Williams et al. 2000) found that \nproductivity with pair programming seems to be comparable to that of two people \nworking independently. The reasons suggested are that pairs discuss the software \nbefore development and so probably have fewer false starts and less rework. \nFurthermore, the number of errors avoided by the informal inspection is such that \nless time is spent repairing bugs discovered during the testing process.\nHowever, studies with more experienced programmers did not replicate these \nresults (Arisholm et al. 2007). They found that there was a significant loss of produc-\ntivity compared with two programmers working alone. There were some quality \nbenefits, but these did not fully compensate for the pair-programming overhead. \nNevertheless, the sharing of knowledge that happens during pair programming is \nvery important as it reduces the overall risks to a project when team members leave. \nIn itself, this may make pair programming worthwhile.\n \n3.3  Agile project management\nIn any software business, managers need to know what is going on and whether or not \na project is likely to meet its objectives and deliver the software on time with the pro-\nposed budget. Plan-driven approaches to software development evolved to meet this \nneed. As I discussed in Chapter 23, managers  draw up a plan for the project showing \nwhat should be delivered, when it should be delivered, and who will work on the devel-\nopment of the project deliverables. A plan-based approach requires a manager to have \na stable view of everything that has to be developed and the development processes.\nThe informal planning and project control that was proposed by the early adher-\nents of agile methods clashed with this business requirement for visibility. Teams \nwere self-organizing, did not produce documentation, and planned development in \nvery short cycles. While this can and does work for small companies developing \nsoftware products, it is inappropriate for larger companies who need to know what is \ngoing on in their organization.\nLike every other professional software development process, agile development \nhas to be managed so that the best use is made of the time and resources available to"}
{"query": "What are the challenges in ensuring complete test coverage in agile development?", "response": "Programmers may take shortcuts when writing tests, such as writing incomplete tests that do not check for all possible exceptions that may occur. Additionally, some tests can be difficult to write incrementally, especially for complex user interfaces. It is also difficult to judge the completeness of a set of tests, as crucial parts of the system may remain untested. Therefore, a large set of frequently executed tests may not necessarily indicate that the system is complete and correct. If tests are not reviewed and further tests are not written after development, undetected bugs may be delivered in the system release.", "context": "3.2  \u25a0 Agile development techniques  83\nAs testing is automated, there is always a set of tests that can be quickly and eas-\nily executed. Whenever any functionality is added to the system, the tests can be run \nand problems that the new code has introduced can be caught immediately.\nTest-first development and automated testing usually result in a large number of \ntests being written and executed. However, there are problems in ensuring that test \ncoverage is complete:\n1. Programmers prefer programming to testing, and sometimes they take shortcuts \nwhen writing tests. For example, they may write incomplete tests that do not \ncheck for all possible exceptions that may occur.\n2. Some tests can be very difficult to write incrementally. For example, in a com-\nplex user interface, it is often difficult to write unit tests for the code that imple-\nments the \u201cdisplay logic\u201d and workflow between screens.\nIt is difficult to judge the completeness of a set of tests. Although you may have a lot \nof system tests, your test set may not provide complete coverage. Crucial parts of \nthe\u00a0system may not be executed and so will remain untested. Therefore, although a \nlarge set of frequently executed tests may give the impression that the system is complete \nand correct, this may not be the case. If the tests are not reviewed and further tests are \nwritten after development, then undetected bugs may be delivered in the system release.\n \n3.2.4  Pair programming\nAnother innovative practice that was introduced in XP is that programmers work in \npairs to develop the software. The programming pair sits at the same computer to \ndevelop the software. However, the same pair do not always program together. \nRather, pairs are created dynamically so that all team members work with each other \nduring the development process.\nPair programming has a number of advantages.\n1. It supports the idea of collective ownership and responsibility for the system. \nThis reflects Weinberg\u2019s idea of egoless programming (Weinberg 1971) where \nthe software is owned by the team as a whole and individuals are not held \nresponsible for problems with the code. Instead, the team has collective respon-\nsibility for resolving these problems.\n2. \nIt acts as an informal review process because each line of code is looked at by at least \ntwo people. Code inspections and reviews (Chapter 24) are effective in discovering \na high percentage of software errors. However, they are time consuming to organize \nand, typically, introduce delays into the development process. Pair programming is a \nless formal process that probably doesn\u2019t find as many errors as code inspections. \nHowever, it is cheaper and easier to organize than formal program inspections.\n3. \nIt encourages refactoring to improve the software structure. The problem with ask-\ning programmers to refactor in a normal development environment is that effort \n\n\n84  Chapter 3 \u25a0 Agile software development\ninvolved is expended for long-term benefit. An developer who spends time refac-\ntoring may be judged to be less efficient than one who simply carries on developing \ncode. Where pair programming and collective ownership are used, others benefit \nimmediately from the refactoring so they are likely to support the process.\nYou might think that pair programming would be less efficient than individual \nprogramming. In a given time, a pair of developers would produce half as much code \nas two individuals working alone. Many companies that have adopted agile methods \nare suspicious of pair programming and do not use it. Other companies mix pair and \nindividual programming with an experienced programmer working with a less expe-\nrienced colleague when they have problems.\nFormal studies of the value of pair programming have had mixed results. Using \nstudent volunteers, Williams and her collaborators (Williams et al. 2000) found that \nproductivity with pair programming seems to be comparable to that of two people \nworking independently. The reasons suggested are that pairs discuss the software \nbefore development and so probably have fewer false starts and less rework. \nFurthermore, the number of errors avoided by the informal inspection is such that \nless time is spent repairing bugs discovered during the testing process.\nHowever, studies with more experienced programmers did not replicate these \nresults (Arisholm et al. 2007). They found that there was a significant loss of produc-\ntivity compared with two programmers working alone. There were some quality \nbenefits, but these did not fully compensate for the pair-programming overhead. \nNevertheless, the sharing of knowledge that happens during pair programming is \nvery important as it reduces the overall risks to a project when team members leave. \nIn itself, this may make pair programming worthwhile.\n \n3.3  Agile project management\nIn any software business, managers need to know what is going on and whether or not \na project is likely to meet its objectives and deliver the software on time with the pro-\nposed budget. Plan-driven approaches to software development evolved to meet this \nneed. As I discussed in Chapter 23, managers  draw up a plan for the project showing \nwhat should be delivered, when it should be delivered, and who will work on the devel-\nopment of the project deliverables. A plan-based approach requires a manager to have \na stable view of everything that has to be developed and the development processes.\nThe informal planning and project control that was proposed by the early adher-\nents of agile methods clashed with this business requirement for visibility. Teams \nwere self-organizing, did not produce documentation, and planned development in \nvery short cycles. While this can and does work for small companies developing \nsoftware products, it is inappropriate for larger companies who need to know what is \ngoing on in their organization.\nLike every other professional software development process, agile development \nhas to be managed so that the best use is made of the time and resources available to"}
{"query": "Why might programmers take shortcuts when writing tests in agile development?", "response": "Programmers might take shortcuts when writing tests in agile development because they prefer programming to testing. They may prioritize writing code over writing comprehensive tests, leading to incomplete tests that do not check for all possible exceptions that may occur.", "context": "3.2  \u25a0 Agile development techniques  83\nAs testing is automated, there is always a set of tests that can be quickly and eas-\nily executed. Whenever any functionality is added to the system, the tests can be run \nand problems that the new code has introduced can be caught immediately.\nTest-first development and automated testing usually result in a large number of \ntests being written and executed. However, there are problems in ensuring that test \ncoverage is complete:\n1. Programmers prefer programming to testing, and sometimes they take shortcuts \nwhen writing tests. For example, they may write incomplete tests that do not \ncheck for all possible exceptions that may occur.\n2. Some tests can be very difficult to write incrementally. For example, in a com-\nplex user interface, it is often difficult to write unit tests for the code that imple-\nments the \u201cdisplay logic\u201d and workflow between screens.\nIt is difficult to judge the completeness of a set of tests. Although you may have a lot \nof system tests, your test set may not provide complete coverage. Crucial parts of \nthe\u00a0system may not be executed and so will remain untested. Therefore, although a \nlarge set of frequently executed tests may give the impression that the system is complete \nand correct, this may not be the case. If the tests are not reviewed and further tests are \nwritten after development, then undetected bugs may be delivered in the system release.\n \n3.2.4  Pair programming\nAnother innovative practice that was introduced in XP is that programmers work in \npairs to develop the software. The programming pair sits at the same computer to \ndevelop the software. However, the same pair do not always program together. \nRather, pairs are created dynamically so that all team members work with each other \nduring the development process.\nPair programming has a number of advantages.\n1. It supports the idea of collective ownership and responsibility for the system. \nThis reflects Weinberg\u2019s idea of egoless programming (Weinberg 1971) where \nthe software is owned by the team as a whole and individuals are not held \nresponsible for problems with the code. Instead, the team has collective respon-\nsibility for resolving these problems.\n2. \nIt acts as an informal review process because each line of code is looked at by at least \ntwo people. Code inspections and reviews (Chapter 24) are effective in discovering \na high percentage of software errors. However, they are time consuming to organize \nand, typically, introduce delays into the development process. Pair programming is a \nless formal process that probably doesn\u2019t find as many errors as code inspections. \nHowever, it is cheaper and easier to organize than formal program inspections.\n3. \nIt encourages refactoring to improve the software structure. The problem with ask-\ning programmers to refactor in a normal development environment is that effort \n\n\n84  Chapter 3 \u25a0 Agile software development\ninvolved is expended for long-term benefit. An developer who spends time refac-\ntoring may be judged to be less efficient than one who simply carries on developing \ncode. Where pair programming and collective ownership are used, others benefit \nimmediately from the refactoring so they are likely to support the process.\nYou might think that pair programming would be less efficient than individual \nprogramming. In a given time, a pair of developers would produce half as much code \nas two individuals working alone. Many companies that have adopted agile methods \nare suspicious of pair programming and do not use it. Other companies mix pair and \nindividual programming with an experienced programmer working with a less expe-\nrienced colleague when they have problems.\nFormal studies of the value of pair programming have had mixed results. Using \nstudent volunteers, Williams and her collaborators (Williams et al. 2000) found that \nproductivity with pair programming seems to be comparable to that of two people \nworking independently. The reasons suggested are that pairs discuss the software \nbefore development and so probably have fewer false starts and less rework. \nFurthermore, the number of errors avoided by the informal inspection is such that \nless time is spent repairing bugs discovered during the testing process.\nHowever, studies with more experienced programmers did not replicate these \nresults (Arisholm et al. 2007). They found that there was a significant loss of produc-\ntivity compared with two programmers working alone. There were some quality \nbenefits, but these did not fully compensate for the pair-programming overhead. \nNevertheless, the sharing of knowledge that happens during pair programming is \nvery important as it reduces the overall risks to a project when team members leave. \nIn itself, this may make pair programming worthwhile.\n \n3.3  Agile project management\nIn any software business, managers need to know what is going on and whether or not \na project is likely to meet its objectives and deliver the software on time with the pro-\nposed budget. Plan-driven approaches to software development evolved to meet this \nneed. As I discussed in Chapter 23, managers  draw up a plan for the project showing \nwhat should be delivered, when it should be delivered, and who will work on the devel-\nopment of the project deliverables. A plan-based approach requires a manager to have \na stable view of everything that has to be developed and the development processes.\nThe informal planning and project control that was proposed by the early adher-\nents of agile methods clashed with this business requirement for visibility. Teams \nwere self-organizing, did not produce documentation, and planned development in \nvery short cycles. While this can and does work for small companies developing \nsoftware products, it is inappropriate for larger companies who need to know what is \ngoing on in their organization.\nLike every other professional software development process, agile development \nhas to be managed so that the best use is made of the time and resources available to"}
{"query": "What are some examples of tests that can be difficult to write incrementally?", "response": "Tests that can be difficult to write incrementally include tests for complex user interfaces, specifically the code that implements the \"display logic\" and workflow between screens.", "context": "3.2  \u25a0 Agile development techniques  83\nAs testing is automated, there is always a set of tests that can be quickly and eas-\nily executed. Whenever any functionality is added to the system, the tests can be run \nand problems that the new code has introduced can be caught immediately.\nTest-first development and automated testing usually result in a large number of \ntests being written and executed. However, there are problems in ensuring that test \ncoverage is complete:\n1. Programmers prefer programming to testing, and sometimes they take shortcuts \nwhen writing tests. For example, they may write incomplete tests that do not \ncheck for all possible exceptions that may occur.\n2. Some tests can be very difficult to write incrementally. For example, in a com-\nplex user interface, it is often difficult to write unit tests for the code that imple-\nments the \u201cdisplay logic\u201d and workflow between screens.\nIt is difficult to judge the completeness of a set of tests. Although you may have a lot \nof system tests, your test set may not provide complete coverage. Crucial parts of \nthe\u00a0system may not be executed and so will remain untested. Therefore, although a \nlarge set of frequently executed tests may give the impression that the system is complete \nand correct, this may not be the case. If the tests are not reviewed and further tests are \nwritten after development, then undetected bugs may be delivered in the system release.\n \n3.2.4  Pair programming\nAnother innovative practice that was introduced in XP is that programmers work in \npairs to develop the software. The programming pair sits at the same computer to \ndevelop the software. However, the same pair do not always program together. \nRather, pairs are created dynamically so that all team members work with each other \nduring the development process.\nPair programming has a number of advantages.\n1. It supports the idea of collective ownership and responsibility for the system. \nThis reflects Weinberg\u2019s idea of egoless programming (Weinberg 1971) where \nthe software is owned by the team as a whole and individuals are not held \nresponsible for problems with the code. Instead, the team has collective respon-\nsibility for resolving these problems.\n2. \nIt acts as an informal review process because each line of code is looked at by at least \ntwo people. Code inspections and reviews (Chapter 24) are effective in discovering \na high percentage of software errors. However, they are time consuming to organize \nand, typically, introduce delays into the development process. Pair programming is a \nless formal process that probably doesn\u2019t find as many errors as code inspections. \nHowever, it is cheaper and easier to organize than formal program inspections.\n3. \nIt encourages refactoring to improve the software structure. The problem with ask-\ning programmers to refactor in a normal development environment is that effort \n\n\n84  Chapter 3 \u25a0 Agile software development\ninvolved is expended for long-term benefit. An developer who spends time refac-\ntoring may be judged to be less efficient than one who simply carries on developing \ncode. Where pair programming and collective ownership are used, others benefit \nimmediately from the refactoring so they are likely to support the process.\nYou might think that pair programming would be less efficient than individual \nprogramming. In a given time, a pair of developers would produce half as much code \nas two individuals working alone. Many companies that have adopted agile methods \nare suspicious of pair programming and do not use it. Other companies mix pair and \nindividual programming with an experienced programmer working with a less expe-\nrienced colleague when they have problems.\nFormal studies of the value of pair programming have had mixed results. Using \nstudent volunteers, Williams and her collaborators (Williams et al. 2000) found that \nproductivity with pair programming seems to be comparable to that of two people \nworking independently. The reasons suggested are that pairs discuss the software \nbefore development and so probably have fewer false starts and less rework. \nFurthermore, the number of errors avoided by the informal inspection is such that \nless time is spent repairing bugs discovered during the testing process.\nHowever, studies with more experienced programmers did not replicate these \nresults (Arisholm et al. 2007). They found that there was a significant loss of produc-\ntivity compared with two programmers working alone. There were some quality \nbenefits, but these did not fully compensate for the pair-programming overhead. \nNevertheless, the sharing of knowledge that happens during pair programming is \nvery important as it reduces the overall risks to a project when team members leave. \nIn itself, this may make pair programming worthwhile.\n \n3.3  Agile project management\nIn any software business, managers need to know what is going on and whether or not \na project is likely to meet its objectives and deliver the software on time with the pro-\nposed budget. Plan-driven approaches to software development evolved to meet this \nneed. As I discussed in Chapter 23, managers  draw up a plan for the project showing \nwhat should be delivered, when it should be delivered, and who will work on the devel-\nopment of the project deliverables. A plan-based approach requires a manager to have \na stable view of everything that has to be developed and the development processes.\nThe informal planning and project control that was proposed by the early adher-\nents of agile methods clashed with this business requirement for visibility. Teams \nwere self-organizing, did not produce documentation, and planned development in \nvery short cycles. While this can and does work for small companies developing \nsoftware products, it is inappropriate for larger companies who need to know what is \ngoing on in their organization.\nLike every other professional software development process, agile development \nhas to be managed so that the best use is made of the time and resources available to"}
{"query": "How can the completeness of a set of tests be judged in agile development?", "response": "Judging the completeness of a set of tests in agile development can be challenging. While a large number of tests may be written and executed, there are still potential gaps in test coverage. Programmers may take shortcuts and write incomplete tests that do not check for all possible exceptions. Additionally, certain tests, such as those for complex user interfaces, may be difficult to write incrementally. Therefore, even if a large set of frequently executed tests gives the impression of completeness, it may not necessarily be the case. To ensure test coverage, it is important to review the tests and write additional tests after development. This helps to catch any undetected bugs that may be present in the system release.", "context": "3.2  \u25a0 Agile development techniques  83\nAs testing is automated, there is always a set of tests that can be quickly and eas-\nily executed. Whenever any functionality is added to the system, the tests can be run \nand problems that the new code has introduced can be caught immediately.\nTest-first development and automated testing usually result in a large number of \ntests being written and executed. However, there are problems in ensuring that test \ncoverage is complete:\n1. Programmers prefer programming to testing, and sometimes they take shortcuts \nwhen writing tests. For example, they may write incomplete tests that do not \ncheck for all possible exceptions that may occur.\n2. Some tests can be very difficult to write incrementally. For example, in a com-\nplex user interface, it is often difficult to write unit tests for the code that imple-\nments the \u201cdisplay logic\u201d and workflow between screens.\nIt is difficult to judge the completeness of a set of tests. Although you may have a lot \nof system tests, your test set may not provide complete coverage. Crucial parts of \nthe\u00a0system may not be executed and so will remain untested. Therefore, although a \nlarge set of frequently executed tests may give the impression that the system is complete \nand correct, this may not be the case. If the tests are not reviewed and further tests are \nwritten after development, then undetected bugs may be delivered in the system release.\n \n3.2.4  Pair programming\nAnother innovative practice that was introduced in XP is that programmers work in \npairs to develop the software. The programming pair sits at the same computer to \ndevelop the software. However, the same pair do not always program together. \nRather, pairs are created dynamically so that all team members work with each other \nduring the development process.\nPair programming has a number of advantages.\n1. It supports the idea of collective ownership and responsibility for the system. \nThis reflects Weinberg\u2019s idea of egoless programming (Weinberg 1971) where \nthe software is owned by the team as a whole and individuals are not held \nresponsible for problems with the code. Instead, the team has collective respon-\nsibility for resolving these problems.\n2. \nIt acts as an informal review process because each line of code is looked at by at least \ntwo people. Code inspections and reviews (Chapter 24) are effective in discovering \na high percentage of software errors. However, they are time consuming to organize \nand, typically, introduce delays into the development process. Pair programming is a \nless formal process that probably doesn\u2019t find as many errors as code inspections. \nHowever, it is cheaper and easier to organize than formal program inspections.\n3. \nIt encourages refactoring to improve the software structure. The problem with ask-\ning programmers to refactor in a normal development environment is that effort \n\n\n84  Chapter 3 \u25a0 Agile software development\ninvolved is expended for long-term benefit. An developer who spends time refac-\ntoring may be judged to be less efficient than one who simply carries on developing \ncode. Where pair programming and collective ownership are used, others benefit \nimmediately from the refactoring so they are likely to support the process.\nYou might think that pair programming would be less efficient than individual \nprogramming. In a given time, a pair of developers would produce half as much code \nas two individuals working alone. Many companies that have adopted agile methods \nare suspicious of pair programming and do not use it. Other companies mix pair and \nindividual programming with an experienced programmer working with a less expe-\nrienced colleague when they have problems.\nFormal studies of the value of pair programming have had mixed results. Using \nstudent volunteers, Williams and her collaborators (Williams et al. 2000) found that \nproductivity with pair programming seems to be comparable to that of two people \nworking independently. The reasons suggested are that pairs discuss the software \nbefore development and so probably have fewer false starts and less rework. \nFurthermore, the number of errors avoided by the informal inspection is such that \nless time is spent repairing bugs discovered during the testing process.\nHowever, studies with more experienced programmers did not replicate these \nresults (Arisholm et al. 2007). They found that there was a significant loss of produc-\ntivity compared with two programmers working alone. There were some quality \nbenefits, but these did not fully compensate for the pair-programming overhead. \nNevertheless, the sharing of knowledge that happens during pair programming is \nvery important as it reduces the overall risks to a project when team members leave. \nIn itself, this may make pair programming worthwhile.\n \n3.3  Agile project management\nIn any software business, managers need to know what is going on and whether or not \na project is likely to meet its objectives and deliver the software on time with the pro-\nposed budget. Plan-driven approaches to software development evolved to meet this \nneed. As I discussed in Chapter 23, managers  draw up a plan for the project showing \nwhat should be delivered, when it should be delivered, and who will work on the devel-\nopment of the project deliverables. A plan-based approach requires a manager to have \na stable view of everything that has to be developed and the development processes.\nThe informal planning and project control that was proposed by the early adher-\nents of agile methods clashed with this business requirement for visibility. Teams \nwere self-organizing, did not produce documentation, and planned development in \nvery short cycles. While this can and does work for small companies developing \nsoftware products, it is inappropriate for larger companies who need to know what is \ngoing on in their organization.\nLike every other professional software development process, agile development \nhas to be managed so that the best use is made of the time and resources available to"}
{"query": "What is the risk if tests are not reviewed and further tests are not written after development?", "response": "Undetected bugs may be delivered in the system release.", "context": "3.2  \u25a0 Agile development techniques  83\nAs testing is automated, there is always a set of tests that can be quickly and eas-\nily executed. Whenever any functionality is added to the system, the tests can be run \nand problems that the new code has introduced can be caught immediately.\nTest-first development and automated testing usually result in a large number of \ntests being written and executed. However, there are problems in ensuring that test \ncoverage is complete:\n1. Programmers prefer programming to testing, and sometimes they take shortcuts \nwhen writing tests. For example, they may write incomplete tests that do not \ncheck for all possible exceptions that may occur.\n2. Some tests can be very difficult to write incrementally. For example, in a com-\nplex user interface, it is often difficult to write unit tests for the code that imple-\nments the \u201cdisplay logic\u201d and workflow between screens.\nIt is difficult to judge the completeness of a set of tests. Although you may have a lot \nof system tests, your test set may not provide complete coverage. Crucial parts of \nthe\u00a0system may not be executed and so will remain untested. Therefore, although a \nlarge set of frequently executed tests may give the impression that the system is complete \nand correct, this may not be the case. If the tests are not reviewed and further tests are \nwritten after development, then undetected bugs may be delivered in the system release.\n \n3.2.4  Pair programming\nAnother innovative practice that was introduced in XP is that programmers work in \npairs to develop the software. The programming pair sits at the same computer to \ndevelop the software. However, the same pair do not always program together. \nRather, pairs are created dynamically so that all team members work with each other \nduring the development process.\nPair programming has a number of advantages.\n1. It supports the idea of collective ownership and responsibility for the system. \nThis reflects Weinberg\u2019s idea of egoless programming (Weinberg 1971) where \nthe software is owned by the team as a whole and individuals are not held \nresponsible for problems with the code. Instead, the team has collective respon-\nsibility for resolving these problems.\n2. \nIt acts as an informal review process because each line of code is looked at by at least \ntwo people. Code inspections and reviews (Chapter 24) are effective in discovering \na high percentage of software errors. However, they are time consuming to organize \nand, typically, introduce delays into the development process. Pair programming is a \nless formal process that probably doesn\u2019t find as many errors as code inspections. \nHowever, it is cheaper and easier to organize than formal program inspections.\n3. \nIt encourages refactoring to improve the software structure. The problem with ask-\ning programmers to refactor in a normal development environment is that effort \n\n\n84  Chapter 3 \u25a0 Agile software development\ninvolved is expended for long-term benefit. An developer who spends time refac-\ntoring may be judged to be less efficient than one who simply carries on developing \ncode. Where pair programming and collective ownership are used, others benefit \nimmediately from the refactoring so they are likely to support the process.\nYou might think that pair programming would be less efficient than individual \nprogramming. In a given time, a pair of developers would produce half as much code \nas two individuals working alone. Many companies that have adopted agile methods \nare suspicious of pair programming and do not use it. Other companies mix pair and \nindividual programming with an experienced programmer working with a less expe-\nrienced colleague when they have problems.\nFormal studies of the value of pair programming have had mixed results. Using \nstudent volunteers, Williams and her collaborators (Williams et al. 2000) found that \nproductivity with pair programming seems to be comparable to that of two people \nworking independently. The reasons suggested are that pairs discuss the software \nbefore development and so probably have fewer false starts and less rework. \nFurthermore, the number of errors avoided by the informal inspection is such that \nless time is spent repairing bugs discovered during the testing process.\nHowever, studies with more experienced programmers did not replicate these \nresults (Arisholm et al. 2007). They found that there was a significant loss of produc-\ntivity compared with two programmers working alone. There were some quality \nbenefits, but these did not fully compensate for the pair-programming overhead. \nNevertheless, the sharing of knowledge that happens during pair programming is \nvery important as it reduces the overall risks to a project when team members leave. \nIn itself, this may make pair programming worthwhile.\n \n3.3  Agile project management\nIn any software business, managers need to know what is going on and whether or not \na project is likely to meet its objectives and deliver the software on time with the pro-\nposed budget. Plan-driven approaches to software development evolved to meet this \nneed. As I discussed in Chapter 23, managers  draw up a plan for the project showing \nwhat should be delivered, when it should be delivered, and who will work on the devel-\nopment of the project deliverables. A plan-based approach requires a manager to have \na stable view of everything that has to be developed and the development processes.\nThe informal planning and project control that was proposed by the early adher-\nents of agile methods clashed with this business requirement for visibility. Teams \nwere self-organizing, did not produce documentation, and planned development in \nvery short cycles. While this can and does work for small companies developing \nsoftware products, it is inappropriate for larger companies who need to know what is \ngoing on in their organization.\nLike every other professional software development process, agile development \nhas to be managed so that the best use is made of the time and resources available to"}
{"query": "What is pair programming in the context of agile development?", "response": "Pair programming in the context of agile development is a practice where two programmers work together at the same computer to develop software. The pairs are dynamically created so that all team members work with each other during the development process. This practice supports the idea of collective ownership and responsibility for the system, where the software is owned by the team as a whole and individuals are not held solely responsible for problems with the code. Pair programming also acts as an informal review process, as each line of code is looked at by at least two people, helping to discover software errors. Additionally, it encourages refactoring to improve the software structure, as the benefits of refactoring are immediately shared among the pair. While there are mixed results from formal studies on the value of pair programming, it is believed that the sharing of knowledge during pair programming reduces overall project risks when team members leave.", "context": "3.2  \u25a0 Agile development techniques  83\nAs testing is automated, there is always a set of tests that can be quickly and eas-\nily executed. Whenever any functionality is added to the system, the tests can be run \nand problems that the new code has introduced can be caught immediately.\nTest-first development and automated testing usually result in a large number of \ntests being written and executed. However, there are problems in ensuring that test \ncoverage is complete:\n1. Programmers prefer programming to testing, and sometimes they take shortcuts \nwhen writing tests. For example, they may write incomplete tests that do not \ncheck for all possible exceptions that may occur.\n2. Some tests can be very difficult to write incrementally. For example, in a com-\nplex user interface, it is often difficult to write unit tests for the code that imple-\nments the \u201cdisplay logic\u201d and workflow between screens.\nIt is difficult to judge the completeness of a set of tests. Although you may have a lot \nof system tests, your test set may not provide complete coverage. Crucial parts of \nthe\u00a0system may not be executed and so will remain untested. Therefore, although a \nlarge set of frequently executed tests may give the impression that the system is complete \nand correct, this may not be the case. If the tests are not reviewed and further tests are \nwritten after development, then undetected bugs may be delivered in the system release.\n \n3.2.4  Pair programming\nAnother innovative practice that was introduced in XP is that programmers work in \npairs to develop the software. The programming pair sits at the same computer to \ndevelop the software. However, the same pair do not always program together. \nRather, pairs are created dynamically so that all team members work with each other \nduring the development process.\nPair programming has a number of advantages.\n1. It supports the idea of collective ownership and responsibility for the system. \nThis reflects Weinberg\u2019s idea of egoless programming (Weinberg 1971) where \nthe software is owned by the team as a whole and individuals are not held \nresponsible for problems with the code. Instead, the team has collective respon-\nsibility for resolving these problems.\n2. \nIt acts as an informal review process because each line of code is looked at by at least \ntwo people. Code inspections and reviews (Chapter 24) are effective in discovering \na high percentage of software errors. However, they are time consuming to organize \nand, typically, introduce delays into the development process. Pair programming is a \nless formal process that probably doesn\u2019t find as many errors as code inspections. \nHowever, it is cheaper and easier to organize than formal program inspections.\n3. \nIt encourages refactoring to improve the software structure. The problem with ask-\ning programmers to refactor in a normal development environment is that effort \n\n\n84  Chapter 3 \u25a0 Agile software development\ninvolved is expended for long-term benefit. An developer who spends time refac-\ntoring may be judged to be less efficient than one who simply carries on developing \ncode. Where pair programming and collective ownership are used, others benefit \nimmediately from the refactoring so they are likely to support the process.\nYou might think that pair programming would be less efficient than individual \nprogramming. In a given time, a pair of developers would produce half as much code \nas two individuals working alone. Many companies that have adopted agile methods \nare suspicious of pair programming and do not use it. Other companies mix pair and \nindividual programming with an experienced programmer working with a less expe-\nrienced colleague when they have problems.\nFormal studies of the value of pair programming have had mixed results. Using \nstudent volunteers, Williams and her collaborators (Williams et al. 2000) found that \nproductivity with pair programming seems to be comparable to that of two people \nworking independently. The reasons suggested are that pairs discuss the software \nbefore development and so probably have fewer false starts and less rework. \nFurthermore, the number of errors avoided by the informal inspection is such that \nless time is spent repairing bugs discovered during the testing process.\nHowever, studies with more experienced programmers did not replicate these \nresults (Arisholm et al. 2007). They found that there was a significant loss of produc-\ntivity compared with two programmers working alone. There were some quality \nbenefits, but these did not fully compensate for the pair-programming overhead. \nNevertheless, the sharing of knowledge that happens during pair programming is \nvery important as it reduces the overall risks to a project when team members leave. \nIn itself, this may make pair programming worthwhile.\n \n3.3  Agile project management\nIn any software business, managers need to know what is going on and whether or not \na project is likely to meet its objectives and deliver the software on time with the pro-\nposed budget. Plan-driven approaches to software development evolved to meet this \nneed. As I discussed in Chapter 23, managers  draw up a plan for the project showing \nwhat should be delivered, when it should be delivered, and who will work on the devel-\nopment of the project deliverables. A plan-based approach requires a manager to have \na stable view of everything that has to be developed and the development processes.\nThe informal planning and project control that was proposed by the early adher-\nents of agile methods clashed with this business requirement for visibility. Teams \nwere self-organizing, did not produce documentation, and planned development in \nvery short cycles. While this can and does work for small companies developing \nsoftware products, it is inappropriate for larger companies who need to know what is \ngoing on in their organization.\nLike every other professional software development process, agile development \nhas to be managed so that the best use is made of the time and resources available to"}
{"query": "How are programming pairs created in agile development?", "response": "Pairs are created dynamically in agile development so that all team members work with each other during the development process.", "context": "3.2  \u25a0 Agile development techniques  83\nAs testing is automated, there is always a set of tests that can be quickly and eas-\nily executed. Whenever any functionality is added to the system, the tests can be run \nand problems that the new code has introduced can be caught immediately.\nTest-first development and automated testing usually result in a large number of \ntests being written and executed. However, there are problems in ensuring that test \ncoverage is complete:\n1. Programmers prefer programming to testing, and sometimes they take shortcuts \nwhen writing tests. For example, they may write incomplete tests that do not \ncheck for all possible exceptions that may occur.\n2. Some tests can be very difficult to write incrementally. For example, in a com-\nplex user interface, it is often difficult to write unit tests for the code that imple-\nments the \u201cdisplay logic\u201d and workflow between screens.\nIt is difficult to judge the completeness of a set of tests. Although you may have a lot \nof system tests, your test set may not provide complete coverage. Crucial parts of \nthe\u00a0system may not be executed and so will remain untested. Therefore, although a \nlarge set of frequently executed tests may give the impression that the system is complete \nand correct, this may not be the case. If the tests are not reviewed and further tests are \nwritten after development, then undetected bugs may be delivered in the system release.\n \n3.2.4  Pair programming\nAnother innovative practice that was introduced in XP is that programmers work in \npairs to develop the software. The programming pair sits at the same computer to \ndevelop the software. However, the same pair do not always program together. \nRather, pairs are created dynamically so that all team members work with each other \nduring the development process.\nPair programming has a number of advantages.\n1. It supports the idea of collective ownership and responsibility for the system. \nThis reflects Weinberg\u2019s idea of egoless programming (Weinberg 1971) where \nthe software is owned by the team as a whole and individuals are not held \nresponsible for problems with the code. Instead, the team has collective respon-\nsibility for resolving these problems.\n2. \nIt acts as an informal review process because each line of code is looked at by at least \ntwo people. Code inspections and reviews (Chapter 24) are effective in discovering \na high percentage of software errors. However, they are time consuming to organize \nand, typically, introduce delays into the development process. Pair programming is a \nless formal process that probably doesn\u2019t find as many errors as code inspections. \nHowever, it is cheaper and easier to organize than formal program inspections.\n3. \nIt encourages refactoring to improve the software structure. The problem with ask-\ning programmers to refactor in a normal development environment is that effort \n\n\n84  Chapter 3 \u25a0 Agile software development\ninvolved is expended for long-term benefit. An developer who spends time refac-\ntoring may be judged to be less efficient than one who simply carries on developing \ncode. Where pair programming and collective ownership are used, others benefit \nimmediately from the refactoring so they are likely to support the process.\nYou might think that pair programming would be less efficient than individual \nprogramming. In a given time, a pair of developers would produce half as much code \nas two individuals working alone. Many companies that have adopted agile methods \nare suspicious of pair programming and do not use it. Other companies mix pair and \nindividual programming with an experienced programmer working with a less expe-\nrienced colleague when they have problems.\nFormal studies of the value of pair programming have had mixed results. Using \nstudent volunteers, Williams and her collaborators (Williams et al. 2000) found that \nproductivity with pair programming seems to be comparable to that of two people \nworking independently. The reasons suggested are that pairs discuss the software \nbefore development and so probably have fewer false starts and less rework. \nFurthermore, the number of errors avoided by the informal inspection is such that \nless time is spent repairing bugs discovered during the testing process.\nHowever, studies with more experienced programmers did not replicate these \nresults (Arisholm et al. 2007). They found that there was a significant loss of produc-\ntivity compared with two programmers working alone. There were some quality \nbenefits, but these did not fully compensate for the pair-programming overhead. \nNevertheless, the sharing of knowledge that happens during pair programming is \nvery important as it reduces the overall risks to a project when team members leave. \nIn itself, this may make pair programming worthwhile.\n \n3.3  Agile project management\nIn any software business, managers need to know what is going on and whether or not \na project is likely to meet its objectives and deliver the software on time with the pro-\nposed budget. Plan-driven approaches to software development evolved to meet this \nneed. As I discussed in Chapter 23, managers  draw up a plan for the project showing \nwhat should be delivered, when it should be delivered, and who will work on the devel-\nopment of the project deliverables. A plan-based approach requires a manager to have \na stable view of everything that has to be developed and the development processes.\nThe informal planning and project control that was proposed by the early adher-\nents of agile methods clashed with this business requirement for visibility. Teams \nwere self-organizing, did not produce documentation, and planned development in \nvery short cycles. While this can and does work for small companies developing \nsoftware products, it is inappropriate for larger companies who need to know what is \ngoing on in their organization.\nLike every other professional software development process, agile development \nhas to be managed so that the best use is made of the time and resources available to"}
{"query": "What are the advantages of pair programming in agile development?", "response": "Pair programming in agile development has several advantages. Firstly, it supports the idea of collective ownership and responsibility for the system, where the software is owned by the team as a whole and individuals are not held solely responsible for problems with the code. This promotes a sense of teamwork and collaboration.\n\nSecondly, pair programming acts as an informal review process. Each line of code is looked at by at least two people, which helps in discovering software errors. While it may not find as many errors as formal code inspections, pair programming is a cheaper and easier process to organize.\n\nLastly, pair programming encourages refactoring to improve the software structure. Refactoring is often seen as an effort that is expended for long-term benefit. However, in pair programming, others benefit immediately from the refactoring, making it more likely to be supported by the team.\n\nOverall, while formal studies have had mixed results, pair programming can be beneficial in terms of productivity, error avoidance, and knowledge sharing among team members.", "context": "3.2  \u25a0 Agile development techniques  83\nAs testing is automated, there is always a set of tests that can be quickly and eas-\nily executed. Whenever any functionality is added to the system, the tests can be run \nand problems that the new code has introduced can be caught immediately.\nTest-first development and automated testing usually result in a large number of \ntests being written and executed. However, there are problems in ensuring that test \ncoverage is complete:\n1. Programmers prefer programming to testing, and sometimes they take shortcuts \nwhen writing tests. For example, they may write incomplete tests that do not \ncheck for all possible exceptions that may occur.\n2. Some tests can be very difficult to write incrementally. For example, in a com-\nplex user interface, it is often difficult to write unit tests for the code that imple-\nments the \u201cdisplay logic\u201d and workflow between screens.\nIt is difficult to judge the completeness of a set of tests. Although you may have a lot \nof system tests, your test set may not provide complete coverage. Crucial parts of \nthe\u00a0system may not be executed and so will remain untested. Therefore, although a \nlarge set of frequently executed tests may give the impression that the system is complete \nand correct, this may not be the case. If the tests are not reviewed and further tests are \nwritten after development, then undetected bugs may be delivered in the system release.\n \n3.2.4  Pair programming\nAnother innovative practice that was introduced in XP is that programmers work in \npairs to develop the software. The programming pair sits at the same computer to \ndevelop the software. However, the same pair do not always program together. \nRather, pairs are created dynamically so that all team members work with each other \nduring the development process.\nPair programming has a number of advantages.\n1. It supports the idea of collective ownership and responsibility for the system. \nThis reflects Weinberg\u2019s idea of egoless programming (Weinberg 1971) where \nthe software is owned by the team as a whole and individuals are not held \nresponsible for problems with the code. Instead, the team has collective respon-\nsibility for resolving these problems.\n2. \nIt acts as an informal review process because each line of code is looked at by at least \ntwo people. Code inspections and reviews (Chapter 24) are effective in discovering \na high percentage of software errors. However, they are time consuming to organize \nand, typically, introduce delays into the development process. Pair programming is a \nless formal process that probably doesn\u2019t find as many errors as code inspections. \nHowever, it is cheaper and easier to organize than formal program inspections.\n3. \nIt encourages refactoring to improve the software structure. The problem with ask-\ning programmers to refactor in a normal development environment is that effort \n\n\n84  Chapter 3 \u25a0 Agile software development\ninvolved is expended for long-term benefit. An developer who spends time refac-\ntoring may be judged to be less efficient than one who simply carries on developing \ncode. Where pair programming and collective ownership are used, others benefit \nimmediately from the refactoring so they are likely to support the process.\nYou might think that pair programming would be less efficient than individual \nprogramming. In a given time, a pair of developers would produce half as much code \nas two individuals working alone. Many companies that have adopted agile methods \nare suspicious of pair programming and do not use it. Other companies mix pair and \nindividual programming with an experienced programmer working with a less expe-\nrienced colleague when they have problems.\nFormal studies of the value of pair programming have had mixed results. Using \nstudent volunteers, Williams and her collaborators (Williams et al. 2000) found that \nproductivity with pair programming seems to be comparable to that of two people \nworking independently. The reasons suggested are that pairs discuss the software \nbefore development and so probably have fewer false starts and less rework. \nFurthermore, the number of errors avoided by the informal inspection is such that \nless time is spent repairing bugs discovered during the testing process.\nHowever, studies with more experienced programmers did not replicate these \nresults (Arisholm et al. 2007). They found that there was a significant loss of produc-\ntivity compared with two programmers working alone. There were some quality \nbenefits, but these did not fully compensate for the pair-programming overhead. \nNevertheless, the sharing of knowledge that happens during pair programming is \nvery important as it reduces the overall risks to a project when team members leave. \nIn itself, this may make pair programming worthwhile.\n \n3.3  Agile project management\nIn any software business, managers need to know what is going on and whether or not \na project is likely to meet its objectives and deliver the software on time with the pro-\nposed budget. Plan-driven approaches to software development evolved to meet this \nneed. As I discussed in Chapter 23, managers  draw up a plan for the project showing \nwhat should be delivered, when it should be delivered, and who will work on the devel-\nopment of the project deliverables. A plan-based approach requires a manager to have \na stable view of everything that has to be developed and the development processes.\nThe informal planning and project control that was proposed by the early adher-\nents of agile methods clashed with this business requirement for visibility. Teams \nwere self-organizing, did not produce documentation, and planned development in \nvery short cycles. While this can and does work for small companies developing \nsoftware products, it is inappropriate for larger companies who need to know what is \ngoing on in their organization.\nLike every other professional software development process, agile development \nhas to be managed so that the best use is made of the time and resources available to"}
{"query": "How does pair programming support the idea of collective ownership and responsibility for the system?", "response": "Pair programming supports the idea of collective ownership and responsibility for the system by ensuring that all team members work together during the development process. This means that each line of code is looked at by at least two people, promoting a sense of shared responsibility for the software. Instead of individuals being held solely responsible for problems with the code, the entire team takes collective responsibility for resolving any issues. This fosters a collaborative and egoless programming environment, where the software is owned by the team as a whole.", "context": "3.2  \u25a0 Agile development techniques  83\nAs testing is automated, there is always a set of tests that can be quickly and eas-\nily executed. Whenever any functionality is added to the system, the tests can be run \nand problems that the new code has introduced can be caught immediately.\nTest-first development and automated testing usually result in a large number of \ntests being written and executed. However, there are problems in ensuring that test \ncoverage is complete:\n1. Programmers prefer programming to testing, and sometimes they take shortcuts \nwhen writing tests. For example, they may write incomplete tests that do not \ncheck for all possible exceptions that may occur.\n2. Some tests can be very difficult to write incrementally. For example, in a com-\nplex user interface, it is often difficult to write unit tests for the code that imple-\nments the \u201cdisplay logic\u201d and workflow between screens.\nIt is difficult to judge the completeness of a set of tests. Although you may have a lot \nof system tests, your test set may not provide complete coverage. Crucial parts of \nthe\u00a0system may not be executed and so will remain untested. Therefore, although a \nlarge set of frequently executed tests may give the impression that the system is complete \nand correct, this may not be the case. If the tests are not reviewed and further tests are \nwritten after development, then undetected bugs may be delivered in the system release.\n \n3.2.4  Pair programming\nAnother innovative practice that was introduced in XP is that programmers work in \npairs to develop the software. The programming pair sits at the same computer to \ndevelop the software. However, the same pair do not always program together. \nRather, pairs are created dynamically so that all team members work with each other \nduring the development process.\nPair programming has a number of advantages.\n1. It supports the idea of collective ownership and responsibility for the system. \nThis reflects Weinberg\u2019s idea of egoless programming (Weinberg 1971) where \nthe software is owned by the team as a whole and individuals are not held \nresponsible for problems with the code. Instead, the team has collective respon-\nsibility for resolving these problems.\n2. \nIt acts as an informal review process because each line of code is looked at by at least \ntwo people. Code inspections and reviews (Chapter 24) are effective in discovering \na high percentage of software errors. However, they are time consuming to organize \nand, typically, introduce delays into the development process. Pair programming is a \nless formal process that probably doesn\u2019t find as many errors as code inspections. \nHowever, it is cheaper and easier to organize than formal program inspections.\n3. \nIt encourages refactoring to improve the software structure. The problem with ask-\ning programmers to refactor in a normal development environment is that effort \n\n\n84  Chapter 3 \u25a0 Agile software development\ninvolved is expended for long-term benefit. An developer who spends time refac-\ntoring may be judged to be less efficient than one who simply carries on developing \ncode. Where pair programming and collective ownership are used, others benefit \nimmediately from the refactoring so they are likely to support the process.\nYou might think that pair programming would be less efficient than individual \nprogramming. In a given time, a pair of developers would produce half as much code \nas two individuals working alone. Many companies that have adopted agile methods \nare suspicious of pair programming and do not use it. Other companies mix pair and \nindividual programming with an experienced programmer working with a less expe-\nrienced colleague when they have problems.\nFormal studies of the value of pair programming have had mixed results. Using \nstudent volunteers, Williams and her collaborators (Williams et al. 2000) found that \nproductivity with pair programming seems to be comparable to that of two people \nworking independently. The reasons suggested are that pairs discuss the software \nbefore development and so probably have fewer false starts and less rework. \nFurthermore, the number of errors avoided by the informal inspection is such that \nless time is spent repairing bugs discovered during the testing process.\nHowever, studies with more experienced programmers did not replicate these \nresults (Arisholm et al. 2007). They found that there was a significant loss of produc-\ntivity compared with two programmers working alone. There were some quality \nbenefits, but these did not fully compensate for the pair-programming overhead. \nNevertheless, the sharing of knowledge that happens during pair programming is \nvery important as it reduces the overall risks to a project when team members leave. \nIn itself, this may make pair programming worthwhile.\n \n3.3  Agile project management\nIn any software business, managers need to know what is going on and whether or not \na project is likely to meet its objectives and deliver the software on time with the pro-\nposed budget. Plan-driven approaches to software development evolved to meet this \nneed. As I discussed in Chapter 23, managers  draw up a plan for the project showing \nwhat should be delivered, when it should be delivered, and who will work on the devel-\nopment of the project deliverables. A plan-based approach requires a manager to have \na stable view of everything that has to be developed and the development processes.\nThe informal planning and project control that was proposed by the early adher-\nents of agile methods clashed with this business requirement for visibility. Teams \nwere self-organizing, did not produce documentation, and planned development in \nvery short cycles. While this can and does work for small companies developing \nsoftware products, it is inappropriate for larger companies who need to know what is \ngoing on in their organization.\nLike every other professional software development process, agile development \nhas to be managed so that the best use is made of the time and resources available to"}
{"query": "How does pair programming act as an informal review process?", "response": "Pair programming acts as an informal review process because each line of code is looked at by at least two people. This informal review process helps in discovering a high percentage of software errors. While it may not find as many errors as formal code inspections, pair programming is a cheaper and easier process to organize.", "context": "3.2  \u25a0 Agile development techniques  83\nAs testing is automated, there is always a set of tests that can be quickly and eas-\nily executed. Whenever any functionality is added to the system, the tests can be run \nand problems that the new code has introduced can be caught immediately.\nTest-first development and automated testing usually result in a large number of \ntests being written and executed. However, there are problems in ensuring that test \ncoverage is complete:\n1. Programmers prefer programming to testing, and sometimes they take shortcuts \nwhen writing tests. For example, they may write incomplete tests that do not \ncheck for all possible exceptions that may occur.\n2. Some tests can be very difficult to write incrementally. For example, in a com-\nplex user interface, it is often difficult to write unit tests for the code that imple-\nments the \u201cdisplay logic\u201d and workflow between screens.\nIt is difficult to judge the completeness of a set of tests. Although you may have a lot \nof system tests, your test set may not provide complete coverage. Crucial parts of \nthe\u00a0system may not be executed and so will remain untested. Therefore, although a \nlarge set of frequently executed tests may give the impression that the system is complete \nand correct, this may not be the case. If the tests are not reviewed and further tests are \nwritten after development, then undetected bugs may be delivered in the system release.\n \n3.2.4  Pair programming\nAnother innovative practice that was introduced in XP is that programmers work in \npairs to develop the software. The programming pair sits at the same computer to \ndevelop the software. However, the same pair do not always program together. \nRather, pairs are created dynamically so that all team members work with each other \nduring the development process.\nPair programming has a number of advantages.\n1. It supports the idea of collective ownership and responsibility for the system. \nThis reflects Weinberg\u2019s idea of egoless programming (Weinberg 1971) where \nthe software is owned by the team as a whole and individuals are not held \nresponsible for problems with the code. Instead, the team has collective respon-\nsibility for resolving these problems.\n2. \nIt acts as an informal review process because each line of code is looked at by at least \ntwo people. Code inspections and reviews (Chapter 24) are effective in discovering \na high percentage of software errors. However, they are time consuming to organize \nand, typically, introduce delays into the development process. Pair programming is a \nless formal process that probably doesn\u2019t find as many errors as code inspections. \nHowever, it is cheaper and easier to organize than formal program inspections.\n3. \nIt encourages refactoring to improve the software structure. The problem with ask-\ning programmers to refactor in a normal development environment is that effort \n\n\n84  Chapter 3 \u25a0 Agile software development\ninvolved is expended for long-term benefit. An developer who spends time refac-\ntoring may be judged to be less efficient than one who simply carries on developing \ncode. Where pair programming and collective ownership are used, others benefit \nimmediately from the refactoring so they are likely to support the process.\nYou might think that pair programming would be less efficient than individual \nprogramming. In a given time, a pair of developers would produce half as much code \nas two individuals working alone. Many companies that have adopted agile methods \nare suspicious of pair programming and do not use it. Other companies mix pair and \nindividual programming with an experienced programmer working with a less expe-\nrienced colleague when they have problems.\nFormal studies of the value of pair programming have had mixed results. Using \nstudent volunteers, Williams and her collaborators (Williams et al. 2000) found that \nproductivity with pair programming seems to be comparable to that of two people \nworking independently. The reasons suggested are that pairs discuss the software \nbefore development and so probably have fewer false starts and less rework. \nFurthermore, the number of errors avoided by the informal inspection is such that \nless time is spent repairing bugs discovered during the testing process.\nHowever, studies with more experienced programmers did not replicate these \nresults (Arisholm et al. 2007). They found that there was a significant loss of produc-\ntivity compared with two programmers working alone. There were some quality \nbenefits, but these did not fully compensate for the pair-programming overhead. \nNevertheless, the sharing of knowledge that happens during pair programming is \nvery important as it reduces the overall risks to a project when team members leave. \nIn itself, this may make pair programming worthwhile.\n \n3.3  Agile project management\nIn any software business, managers need to know what is going on and whether or not \na project is likely to meet its objectives and deliver the software on time with the pro-\nposed budget. Plan-driven approaches to software development evolved to meet this \nneed. As I discussed in Chapter 23, managers  draw up a plan for the project showing \nwhat should be delivered, when it should be delivered, and who will work on the devel-\nopment of the project deliverables. A plan-based approach requires a manager to have \na stable view of everything that has to be developed and the development processes.\nThe informal planning and project control that was proposed by the early adher-\nents of agile methods clashed with this business requirement for visibility. Teams \nwere self-organizing, did not produce documentation, and planned development in \nvery short cycles. While this can and does work for small companies developing \nsoftware products, it is inappropriate for larger companies who need to know what is \ngoing on in their organization.\nLike every other professional software development process, agile development \nhas to be managed so that the best use is made of the time and resources available to"}
{"query": "How does pair programming encourage refactoring to improve the software structure?", "response": "Pair programming encourages refactoring to improve the software structure because when programmers work in pairs, others benefit immediately from the refactoring. This means that any improvements made to the software structure are immediately visible and usable by the other programmer in the pair. As a result, there is likely to be more support for the refactoring process, as it benefits the entire team.", "context": "3.2  \u25a0 Agile development techniques  83\nAs testing is automated, there is always a set of tests that can be quickly and eas-\nily executed. Whenever any functionality is added to the system, the tests can be run \nand problems that the new code has introduced can be caught immediately.\nTest-first development and automated testing usually result in a large number of \ntests being written and executed. However, there are problems in ensuring that test \ncoverage is complete:\n1. Programmers prefer programming to testing, and sometimes they take shortcuts \nwhen writing tests. For example, they may write incomplete tests that do not \ncheck for all possible exceptions that may occur.\n2. Some tests can be very difficult to write incrementally. For example, in a com-\nplex user interface, it is often difficult to write unit tests for the code that imple-\nments the \u201cdisplay logic\u201d and workflow between screens.\nIt is difficult to judge the completeness of a set of tests. Although you may have a lot \nof system tests, your test set may not provide complete coverage. Crucial parts of \nthe\u00a0system may not be executed and so will remain untested. Therefore, although a \nlarge set of frequently executed tests may give the impression that the system is complete \nand correct, this may not be the case. If the tests are not reviewed and further tests are \nwritten after development, then undetected bugs may be delivered in the system release.\n \n3.2.4  Pair programming\nAnother innovative practice that was introduced in XP is that programmers work in \npairs to develop the software. The programming pair sits at the same computer to \ndevelop the software. However, the same pair do not always program together. \nRather, pairs are created dynamically so that all team members work with each other \nduring the development process.\nPair programming has a number of advantages.\n1. It supports the idea of collective ownership and responsibility for the system. \nThis reflects Weinberg\u2019s idea of egoless programming (Weinberg 1971) where \nthe software is owned by the team as a whole and individuals are not held \nresponsible for problems with the code. Instead, the team has collective respon-\nsibility for resolving these problems.\n2. \nIt acts as an informal review process because each line of code is looked at by at least \ntwo people. Code inspections and reviews (Chapter 24) are effective in discovering \na high percentage of software errors. However, they are time consuming to organize \nand, typically, introduce delays into the development process. Pair programming is a \nless formal process that probably doesn\u2019t find as many errors as code inspections. \nHowever, it is cheaper and easier to organize than formal program inspections.\n3. \nIt encourages refactoring to improve the software structure. The problem with ask-\ning programmers to refactor in a normal development environment is that effort \n\n\n84  Chapter 3 \u25a0 Agile software development\ninvolved is expended for long-term benefit. An developer who spends time refac-\ntoring may be judged to be less efficient than one who simply carries on developing \ncode. Where pair programming and collective ownership are used, others benefit \nimmediately from the refactoring so they are likely to support the process.\nYou might think that pair programming would be less efficient than individual \nprogramming. In a given time, a pair of developers would produce half as much code \nas two individuals working alone. Many companies that have adopted agile methods \nare suspicious of pair programming and do not use it. Other companies mix pair and \nindividual programming with an experienced programmer working with a less expe-\nrienced colleague when they have problems.\nFormal studies of the value of pair programming have had mixed results. Using \nstudent volunteers, Williams and her collaborators (Williams et al. 2000) found that \nproductivity with pair programming seems to be comparable to that of two people \nworking independently. The reasons suggested are that pairs discuss the software \nbefore development and so probably have fewer false starts and less rework. \nFurthermore, the number of errors avoided by the informal inspection is such that \nless time is spent repairing bugs discovered during the testing process.\nHowever, studies with more experienced programmers did not replicate these \nresults (Arisholm et al. 2007). They found that there was a significant loss of produc-\ntivity compared with two programmers working alone. There were some quality \nbenefits, but these did not fully compensate for the pair-programming overhead. \nNevertheless, the sharing of knowledge that happens during pair programming is \nvery important as it reduces the overall risks to a project when team members leave. \nIn itself, this may make pair programming worthwhile.\n \n3.3  Agile project management\nIn any software business, managers need to know what is going on and whether or not \na project is likely to meet its objectives and deliver the software on time with the pro-\nposed budget. Plan-driven approaches to software development evolved to meet this \nneed. As I discussed in Chapter 23, managers  draw up a plan for the project showing \nwhat should be delivered, when it should be delivered, and who will work on the devel-\nopment of the project deliverables. A plan-based approach requires a manager to have \na stable view of everything that has to be developed and the development processes.\nThe informal planning and project control that was proposed by the early adher-\nents of agile methods clashed with this business requirement for visibility. Teams \nwere self-organizing, did not produce documentation, and planned development in \nvery short cycles. While this can and does work for small companies developing \nsoftware products, it is inappropriate for larger companies who need to know what is \ngoing on in their organization.\nLike every other professional software development process, agile development \nhas to be managed so that the best use is made of the time and resources available to"}
{"query": "Why might some companies be suspicious of pair programming?", "response": "Some companies might be suspicious of pair programming because they believe that it is less efficient than individual programming. They may think that a pair of developers would produce half as much code as two individuals working alone. Additionally, formal studies on the value of pair programming have had mixed results, with some studies suggesting a loss of productivity compared to two programmers working alone. However, it is important to note that the sharing of knowledge that happens during pair programming can reduce overall project risks when team members leave, which may make pair programming worthwhile.", "context": "3.2  \u25a0 Agile development techniques  83\nAs testing is automated, there is always a set of tests that can be quickly and eas-\nily executed. Whenever any functionality is added to the system, the tests can be run \nand problems that the new code has introduced can be caught immediately.\nTest-first development and automated testing usually result in a large number of \ntests being written and executed. However, there are problems in ensuring that test \ncoverage is complete:\n1. Programmers prefer programming to testing, and sometimes they take shortcuts \nwhen writing tests. For example, they may write incomplete tests that do not \ncheck for all possible exceptions that may occur.\n2. Some tests can be very difficult to write incrementally. For example, in a com-\nplex user interface, it is often difficult to write unit tests for the code that imple-\nments the \u201cdisplay logic\u201d and workflow between screens.\nIt is difficult to judge the completeness of a set of tests. Although you may have a lot \nof system tests, your test set may not provide complete coverage. Crucial parts of \nthe\u00a0system may not be executed and so will remain untested. Therefore, although a \nlarge set of frequently executed tests may give the impression that the system is complete \nand correct, this may not be the case. If the tests are not reviewed and further tests are \nwritten after development, then undetected bugs may be delivered in the system release.\n \n3.2.4  Pair programming\nAnother innovative practice that was introduced in XP is that programmers work in \npairs to develop the software. The programming pair sits at the same computer to \ndevelop the software. However, the same pair do not always program together. \nRather, pairs are created dynamically so that all team members work with each other \nduring the development process.\nPair programming has a number of advantages.\n1. It supports the idea of collective ownership and responsibility for the system. \nThis reflects Weinberg\u2019s idea of egoless programming (Weinberg 1971) where \nthe software is owned by the team as a whole and individuals are not held \nresponsible for problems with the code. Instead, the team has collective respon-\nsibility for resolving these problems.\n2. \nIt acts as an informal review process because each line of code is looked at by at least \ntwo people. Code inspections and reviews (Chapter 24) are effective in discovering \na high percentage of software errors. However, they are time consuming to organize \nand, typically, introduce delays into the development process. Pair programming is a \nless formal process that probably doesn\u2019t find as many errors as code inspections. \nHowever, it is cheaper and easier to organize than formal program inspections.\n3. \nIt encourages refactoring to improve the software structure. The problem with ask-\ning programmers to refactor in a normal development environment is that effort \n\n\n84  Chapter 3 \u25a0 Agile software development\ninvolved is expended for long-term benefit. An developer who spends time refac-\ntoring may be judged to be less efficient than one who simply carries on developing \ncode. Where pair programming and collective ownership are used, others benefit \nimmediately from the refactoring so they are likely to support the process.\nYou might think that pair programming would be less efficient than individual \nprogramming. In a given time, a pair of developers would produce half as much code \nas two individuals working alone. Many companies that have adopted agile methods \nare suspicious of pair programming and do not use it. Other companies mix pair and \nindividual programming with an experienced programmer working with a less expe-\nrienced colleague when they have problems.\nFormal studies of the value of pair programming have had mixed results. Using \nstudent volunteers, Williams and her collaborators (Williams et al. 2000) found that \nproductivity with pair programming seems to be comparable to that of two people \nworking independently. The reasons suggested are that pairs discuss the software \nbefore development and so probably have fewer false starts and less rework. \nFurthermore, the number of errors avoided by the informal inspection is such that \nless time is spent repairing bugs discovered during the testing process.\nHowever, studies with more experienced programmers did not replicate these \nresults (Arisholm et al. 2007). They found that there was a significant loss of produc-\ntivity compared with two programmers working alone. There were some quality \nbenefits, but these did not fully compensate for the pair-programming overhead. \nNevertheless, the sharing of knowledge that happens during pair programming is \nvery important as it reduces the overall risks to a project when team members leave. \nIn itself, this may make pair programming worthwhile.\n \n3.3  Agile project management\nIn any software business, managers need to know what is going on and whether or not \na project is likely to meet its objectives and deliver the software on time with the pro-\nposed budget. Plan-driven approaches to software development evolved to meet this \nneed. As I discussed in Chapter 23, managers  draw up a plan for the project showing \nwhat should be delivered, when it should be delivered, and who will work on the devel-\nopment of the project deliverables. A plan-based approach requires a manager to have \na stable view of everything that has to be developed and the development processes.\nThe informal planning and project control that was proposed by the early adher-\nents of agile methods clashed with this business requirement for visibility. Teams \nwere self-organizing, did not produce documentation, and planned development in \nvery short cycles. While this can and does work for small companies developing \nsoftware products, it is inappropriate for larger companies who need to know what is \ngoing on in their organization.\nLike every other professional software development process, agile development \nhas to be managed so that the best use is made of the time and resources available to"}
{"query": "What have formal studies of the value of pair programming shown?", "response": "Formal studies of the value of pair programming have shown mixed results. One study with student volunteers found that productivity with pair programming was comparable to that of two people working independently. This was attributed to pairs discussing the software before development, resulting in fewer false starts and less rework. Additionally, the informal inspection during pair programming helped avoid errors, reducing the time spent on bug repairs during testing. However, studies with more experienced programmers did not replicate these results. They found a significant loss of productivity compared to two programmers working alone, although there were some quality benefits. Nevertheless, the sharing of knowledge during pair programming is important for reducing overall project risks when team members leave, which may make pair programming worthwhile.", "context": "3.2  \u25a0 Agile development techniques  83\nAs testing is automated, there is always a set of tests that can be quickly and eas-\nily executed. Whenever any functionality is added to the system, the tests can be run \nand problems that the new code has introduced can be caught immediately.\nTest-first development and automated testing usually result in a large number of \ntests being written and executed. However, there are problems in ensuring that test \ncoverage is complete:\n1. Programmers prefer programming to testing, and sometimes they take shortcuts \nwhen writing tests. For example, they may write incomplete tests that do not \ncheck for all possible exceptions that may occur.\n2. Some tests can be very difficult to write incrementally. For example, in a com-\nplex user interface, it is often difficult to write unit tests for the code that imple-\nments the \u201cdisplay logic\u201d and workflow between screens.\nIt is difficult to judge the completeness of a set of tests. Although you may have a lot \nof system tests, your test set may not provide complete coverage. Crucial parts of \nthe\u00a0system may not be executed and so will remain untested. Therefore, although a \nlarge set of frequently executed tests may give the impression that the system is complete \nand correct, this may not be the case. If the tests are not reviewed and further tests are \nwritten after development, then undetected bugs may be delivered in the system release.\n \n3.2.4  Pair programming\nAnother innovative practice that was introduced in XP is that programmers work in \npairs to develop the software. The programming pair sits at the same computer to \ndevelop the software. However, the same pair do not always program together. \nRather, pairs are created dynamically so that all team members work with each other \nduring the development process.\nPair programming has a number of advantages.\n1. It supports the idea of collective ownership and responsibility for the system. \nThis reflects Weinberg\u2019s idea of egoless programming (Weinberg 1971) where \nthe software is owned by the team as a whole and individuals are not held \nresponsible for problems with the code. Instead, the team has collective respon-\nsibility for resolving these problems.\n2. \nIt acts as an informal review process because each line of code is looked at by at least \ntwo people. Code inspections and reviews (Chapter 24) are effective in discovering \na high percentage of software errors. However, they are time consuming to organize \nand, typically, introduce delays into the development process. Pair programming is a \nless formal process that probably doesn\u2019t find as many errors as code inspections. \nHowever, it is cheaper and easier to organize than formal program inspections.\n3. \nIt encourages refactoring to improve the software structure. The problem with ask-\ning programmers to refactor in a normal development environment is that effort \n\n\n84  Chapter 3 \u25a0 Agile software development\ninvolved is expended for long-term benefit. An developer who spends time refac-\ntoring may be judged to be less efficient than one who simply carries on developing \ncode. Where pair programming and collective ownership are used, others benefit \nimmediately from the refactoring so they are likely to support the process.\nYou might think that pair programming would be less efficient than individual \nprogramming. In a given time, a pair of developers would produce half as much code \nas two individuals working alone. Many companies that have adopted agile methods \nare suspicious of pair programming and do not use it. Other companies mix pair and \nindividual programming with an experienced programmer working with a less expe-\nrienced colleague when they have problems.\nFormal studies of the value of pair programming have had mixed results. Using \nstudent volunteers, Williams and her collaborators (Williams et al. 2000) found that \nproductivity with pair programming seems to be comparable to that of two people \nworking independently. The reasons suggested are that pairs discuss the software \nbefore development and so probably have fewer false starts and less rework. \nFurthermore, the number of errors avoided by the informal inspection is such that \nless time is spent repairing bugs discovered during the testing process.\nHowever, studies with more experienced programmers did not replicate these \nresults (Arisholm et al. 2007). They found that there was a significant loss of produc-\ntivity compared with two programmers working alone. There were some quality \nbenefits, but these did not fully compensate for the pair-programming overhead. \nNevertheless, the sharing of knowledge that happens during pair programming is \nvery important as it reduces the overall risks to a project when team members leave. \nIn itself, this may make pair programming worthwhile.\n \n3.3  Agile project management\nIn any software business, managers need to know what is going on and whether or not \na project is likely to meet its objectives and deliver the software on time with the pro-\nposed budget. Plan-driven approaches to software development evolved to meet this \nneed. As I discussed in Chapter 23, managers  draw up a plan for the project showing \nwhat should be delivered, when it should be delivered, and who will work on the devel-\nopment of the project deliverables. A plan-based approach requires a manager to have \na stable view of everything that has to be developed and the development processes.\nThe informal planning and project control that was proposed by the early adher-\nents of agile methods clashed with this business requirement for visibility. Teams \nwere self-organizing, did not produce documentation, and planned development in \nvery short cycles. While this can and does work for small companies developing \nsoftware products, it is inappropriate for larger companies who need to know what is \ngoing on in their organization.\nLike every other professional software development process, agile development \nhas to be managed so that the best use is made of the time and resources available to"}
{"query": "How does pair programming compare to individual programming in terms of efficiency?", "response": "Pair programming is often perceived as less efficient than individual programming because a pair of developers would produce half as much code as two individuals working alone. However, formal studies have shown mixed results. Some studies with student volunteers found that productivity with pair programming is comparable to that of two people working independently. This is because pairs discuss the software before development, resulting in fewer false starts and less rework. Additionally, the informal inspection during pair programming helps avoid errors, reducing the time spent on bug repairs during testing. However, studies with more experienced programmers did not replicate these results and found a significant loss of productivity compared to two programmers working alone. Despite this, the sharing of knowledge during pair programming is valuable in reducing overall project risks when team members leave, making pair programming worthwhile.", "context": "3.2  \u25a0 Agile development techniques  83\nAs testing is automated, there is always a set of tests that can be quickly and eas-\nily executed. Whenever any functionality is added to the system, the tests can be run \nand problems that the new code has introduced can be caught immediately.\nTest-first development and automated testing usually result in a large number of \ntests being written and executed. However, there are problems in ensuring that test \ncoverage is complete:\n1. Programmers prefer programming to testing, and sometimes they take shortcuts \nwhen writing tests. For example, they may write incomplete tests that do not \ncheck for all possible exceptions that may occur.\n2. Some tests can be very difficult to write incrementally. For example, in a com-\nplex user interface, it is often difficult to write unit tests for the code that imple-\nments the \u201cdisplay logic\u201d and workflow between screens.\nIt is difficult to judge the completeness of a set of tests. Although you may have a lot \nof system tests, your test set may not provide complete coverage. Crucial parts of \nthe\u00a0system may not be executed and so will remain untested. Therefore, although a \nlarge set of frequently executed tests may give the impression that the system is complete \nand correct, this may not be the case. If the tests are not reviewed and further tests are \nwritten after development, then undetected bugs may be delivered in the system release.\n \n3.2.4  Pair programming\nAnother innovative practice that was introduced in XP is that programmers work in \npairs to develop the software. The programming pair sits at the same computer to \ndevelop the software. However, the same pair do not always program together. \nRather, pairs are created dynamically so that all team members work with each other \nduring the development process.\nPair programming has a number of advantages.\n1. It supports the idea of collective ownership and responsibility for the system. \nThis reflects Weinberg\u2019s idea of egoless programming (Weinberg 1971) where \nthe software is owned by the team as a whole and individuals are not held \nresponsible for problems with the code. Instead, the team has collective respon-\nsibility for resolving these problems.\n2. \nIt acts as an informal review process because each line of code is looked at by at least \ntwo people. Code inspections and reviews (Chapter 24) are effective in discovering \na high percentage of software errors. However, they are time consuming to organize \nand, typically, introduce delays into the development process. Pair programming is a \nless formal process that probably doesn\u2019t find as many errors as code inspections. \nHowever, it is cheaper and easier to organize than formal program inspections.\n3. \nIt encourages refactoring to improve the software structure. The problem with ask-\ning programmers to refactor in a normal development environment is that effort \n\n\n84  Chapter 3 \u25a0 Agile software development\ninvolved is expended for long-term benefit. An developer who spends time refac-\ntoring may be judged to be less efficient than one who simply carries on developing \ncode. Where pair programming and collective ownership are used, others benefit \nimmediately from the refactoring so they are likely to support the process.\nYou might think that pair programming would be less efficient than individual \nprogramming. In a given time, a pair of developers would produce half as much code \nas two individuals working alone. Many companies that have adopted agile methods \nare suspicious of pair programming and do not use it. Other companies mix pair and \nindividual programming with an experienced programmer working with a less expe-\nrienced colleague when they have problems.\nFormal studies of the value of pair programming have had mixed results. Using \nstudent volunteers, Williams and her collaborators (Williams et al. 2000) found that \nproductivity with pair programming seems to be comparable to that of two people \nworking independently. The reasons suggested are that pairs discuss the software \nbefore development and so probably have fewer false starts and less rework. \nFurthermore, the number of errors avoided by the informal inspection is such that \nless time is spent repairing bugs discovered during the testing process.\nHowever, studies with more experienced programmers did not replicate these \nresults (Arisholm et al. 2007). They found that there was a significant loss of produc-\ntivity compared with two programmers working alone. There were some quality \nbenefits, but these did not fully compensate for the pair-programming overhead. \nNevertheless, the sharing of knowledge that happens during pair programming is \nvery important as it reduces the overall risks to a project when team members leave. \nIn itself, this may make pair programming worthwhile.\n \n3.3  Agile project management\nIn any software business, managers need to know what is going on and whether or not \na project is likely to meet its objectives and deliver the software on time with the pro-\nposed budget. Plan-driven approaches to software development evolved to meet this \nneed. As I discussed in Chapter 23, managers  draw up a plan for the project showing \nwhat should be delivered, when it should be delivered, and who will work on the devel-\nopment of the project deliverables. A plan-based approach requires a manager to have \na stable view of everything that has to be developed and the development processes.\nThe informal planning and project control that was proposed by the early adher-\nents of agile methods clashed with this business requirement for visibility. Teams \nwere self-organizing, did not produce documentation, and planned development in \nvery short cycles. While this can and does work for small companies developing \nsoftware products, it is inappropriate for larger companies who need to know what is \ngoing on in their organization.\nLike every other professional software development process, agile development \nhas to be managed so that the best use is made of the time and resources available to"}
{"query": "How does pair programming reduce the overall risks to a project when team members leave?", "response": "Pair programming reduces the overall risks to a project when team members leave by facilitating the sharing of knowledge among team members. When developers work in pairs, they constantly collaborate and discuss the software they are developing. This knowledge sharing ensures that multiple team members are familiar with different parts of the codebase. Therefore, if a team member leaves the project, the remaining team members have a better understanding of the code and can continue the development process without significant disruption. This reduces the risk of knowledge loss and minimizes the impact of team member turnover on the project.", "context": "3.2  \u25a0 Agile development techniques  83\nAs testing is automated, there is always a set of tests that can be quickly and eas-\nily executed. Whenever any functionality is added to the system, the tests can be run \nand problems that the new code has introduced can be caught immediately.\nTest-first development and automated testing usually result in a large number of \ntests being written and executed. However, there are problems in ensuring that test \ncoverage is complete:\n1. Programmers prefer programming to testing, and sometimes they take shortcuts \nwhen writing tests. For example, they may write incomplete tests that do not \ncheck for all possible exceptions that may occur.\n2. Some tests can be very difficult to write incrementally. For example, in a com-\nplex user interface, it is often difficult to write unit tests for the code that imple-\nments the \u201cdisplay logic\u201d and workflow between screens.\nIt is difficult to judge the completeness of a set of tests. Although you may have a lot \nof system tests, your test set may not provide complete coverage. Crucial parts of \nthe\u00a0system may not be executed and so will remain untested. Therefore, although a \nlarge set of frequently executed tests may give the impression that the system is complete \nand correct, this may not be the case. If the tests are not reviewed and further tests are \nwritten after development, then undetected bugs may be delivered in the system release.\n \n3.2.4  Pair programming\nAnother innovative practice that was introduced in XP is that programmers work in \npairs to develop the software. The programming pair sits at the same computer to \ndevelop the software. However, the same pair do not always program together. \nRather, pairs are created dynamically so that all team members work with each other \nduring the development process.\nPair programming has a number of advantages.\n1. It supports the idea of collective ownership and responsibility for the system. \nThis reflects Weinberg\u2019s idea of egoless programming (Weinberg 1971) where \nthe software is owned by the team as a whole and individuals are not held \nresponsible for problems with the code. Instead, the team has collective respon-\nsibility for resolving these problems.\n2. \nIt acts as an informal review process because each line of code is looked at by at least \ntwo people. Code inspections and reviews (Chapter 24) are effective in discovering \na high percentage of software errors. However, they are time consuming to organize \nand, typically, introduce delays into the development process. Pair programming is a \nless formal process that probably doesn\u2019t find as many errors as code inspections. \nHowever, it is cheaper and easier to organize than formal program inspections.\n3. \nIt encourages refactoring to improve the software structure. The problem with ask-\ning programmers to refactor in a normal development environment is that effort \n\n\n84  Chapter 3 \u25a0 Agile software development\ninvolved is expended for long-term benefit. An developer who spends time refac-\ntoring may be judged to be less efficient than one who simply carries on developing \ncode. Where pair programming and collective ownership are used, others benefit \nimmediately from the refactoring so they are likely to support the process.\nYou might think that pair programming would be less efficient than individual \nprogramming. In a given time, a pair of developers would produce half as much code \nas two individuals working alone. Many companies that have adopted agile methods \nare suspicious of pair programming and do not use it. Other companies mix pair and \nindividual programming with an experienced programmer working with a less expe-\nrienced colleague when they have problems.\nFormal studies of the value of pair programming have had mixed results. Using \nstudent volunteers, Williams and her collaborators (Williams et al. 2000) found that \nproductivity with pair programming seems to be comparable to that of two people \nworking independently. The reasons suggested are that pairs discuss the software \nbefore development and so probably have fewer false starts and less rework. \nFurthermore, the number of errors avoided by the informal inspection is such that \nless time is spent repairing bugs discovered during the testing process.\nHowever, studies with more experienced programmers did not replicate these \nresults (Arisholm et al. 2007). They found that there was a significant loss of produc-\ntivity compared with two programmers working alone. There were some quality \nbenefits, but these did not fully compensate for the pair-programming overhead. \nNevertheless, the sharing of knowledge that happens during pair programming is \nvery important as it reduces the overall risks to a project when team members leave. \nIn itself, this may make pair programming worthwhile.\n \n3.3  Agile project management\nIn any software business, managers need to know what is going on and whether or not \na project is likely to meet its objectives and deliver the software on time with the pro-\nposed budget. Plan-driven approaches to software development evolved to meet this \nneed. As I discussed in Chapter 23, managers  draw up a plan for the project showing \nwhat should be delivered, when it should be delivered, and who will work on the devel-\nopment of the project deliverables. A plan-based approach requires a manager to have \na stable view of everything that has to be developed and the development processes.\nThe informal planning and project control that was proposed by the early adher-\nents of agile methods clashed with this business requirement for visibility. Teams \nwere self-organizing, did not produce documentation, and planned development in \nvery short cycles. While this can and does work for small companies developing \nsoftware products, it is inappropriate for larger companies who need to know what is \ngoing on in their organization.\nLike every other professional software development process, agile development \nhas to be managed so that the best use is made of the time and resources available to"}
{"query": "What is the role of agile project management in a software business?", "response": "Agile project management plays a crucial role in a software business. It helps managers to have visibility into the progress of a project and determine whether it is on track to meet its objectives and deliver the software on time and within the proposed budget. Unlike plan-driven approaches, agile project management allows for flexibility and adaptability, as teams self-organize and plan development in short cycles. This approach is particularly effective for small companies developing software products. However, for larger companies, agile project management needs to be managed effectively to ensure that the time and resources available are utilized optimally.", "context": "3.2  \u25a0 Agile development techniques  83\nAs testing is automated, there is always a set of tests that can be quickly and eas-\nily executed. Whenever any functionality is added to the system, the tests can be run \nand problems that the new code has introduced can be caught immediately.\nTest-first development and automated testing usually result in a large number of \ntests being written and executed. However, there are problems in ensuring that test \ncoverage is complete:\n1. Programmers prefer programming to testing, and sometimes they take shortcuts \nwhen writing tests. For example, they may write incomplete tests that do not \ncheck for all possible exceptions that may occur.\n2. Some tests can be very difficult to write incrementally. For example, in a com-\nplex user interface, it is often difficult to write unit tests for the code that imple-\nments the \u201cdisplay logic\u201d and workflow between screens.\nIt is difficult to judge the completeness of a set of tests. Although you may have a lot \nof system tests, your test set may not provide complete coverage. Crucial parts of \nthe\u00a0system may not be executed and so will remain untested. Therefore, although a \nlarge set of frequently executed tests may give the impression that the system is complete \nand correct, this may not be the case. If the tests are not reviewed and further tests are \nwritten after development, then undetected bugs may be delivered in the system release.\n \n3.2.4  Pair programming\nAnother innovative practice that was introduced in XP is that programmers work in \npairs to develop the software. The programming pair sits at the same computer to \ndevelop the software. However, the same pair do not always program together. \nRather, pairs are created dynamically so that all team members work with each other \nduring the development process.\nPair programming has a number of advantages.\n1. It supports the idea of collective ownership and responsibility for the system. \nThis reflects Weinberg\u2019s idea of egoless programming (Weinberg 1971) where \nthe software is owned by the team as a whole and individuals are not held \nresponsible for problems with the code. Instead, the team has collective respon-\nsibility for resolving these problems.\n2. \nIt acts as an informal review process because each line of code is looked at by at least \ntwo people. Code inspections and reviews (Chapter 24) are effective in discovering \na high percentage of software errors. However, they are time consuming to organize \nand, typically, introduce delays into the development process. Pair programming is a \nless formal process that probably doesn\u2019t find as many errors as code inspections. \nHowever, it is cheaper and easier to organize than formal program inspections.\n3. \nIt encourages refactoring to improve the software structure. The problem with ask-\ning programmers to refactor in a normal development environment is that effort \n\n\n84  Chapter 3 \u25a0 Agile software development\ninvolved is expended for long-term benefit. An developer who spends time refac-\ntoring may be judged to be less efficient than one who simply carries on developing \ncode. Where pair programming and collective ownership are used, others benefit \nimmediately from the refactoring so they are likely to support the process.\nYou might think that pair programming would be less efficient than individual \nprogramming. In a given time, a pair of developers would produce half as much code \nas two individuals working alone. Many companies that have adopted agile methods \nare suspicious of pair programming and do not use it. Other companies mix pair and \nindividual programming with an experienced programmer working with a less expe-\nrienced colleague when they have problems.\nFormal studies of the value of pair programming have had mixed results. Using \nstudent volunteers, Williams and her collaborators (Williams et al. 2000) found that \nproductivity with pair programming seems to be comparable to that of two people \nworking independently. The reasons suggested are that pairs discuss the software \nbefore development and so probably have fewer false starts and less rework. \nFurthermore, the number of errors avoided by the informal inspection is such that \nless time is spent repairing bugs discovered during the testing process.\nHowever, studies with more experienced programmers did not replicate these \nresults (Arisholm et al. 2007). They found that there was a significant loss of produc-\ntivity compared with two programmers working alone. There were some quality \nbenefits, but these did not fully compensate for the pair-programming overhead. \nNevertheless, the sharing of knowledge that happens during pair programming is \nvery important as it reduces the overall risks to a project when team members leave. \nIn itself, this may make pair programming worthwhile.\n \n3.3  Agile project management\nIn any software business, managers need to know what is going on and whether or not \na project is likely to meet its objectives and deliver the software on time with the pro-\nposed budget. Plan-driven approaches to software development evolved to meet this \nneed. As I discussed in Chapter 23, managers  draw up a plan for the project showing \nwhat should be delivered, when it should be delivered, and who will work on the devel-\nopment of the project deliverables. A plan-based approach requires a manager to have \na stable view of everything that has to be developed and the development processes.\nThe informal planning and project control that was proposed by the early adher-\nents of agile methods clashed with this business requirement for visibility. Teams \nwere self-organizing, did not produce documentation, and planned development in \nvery short cycles. While this can and does work for small companies developing \nsoftware products, it is inappropriate for larger companies who need to know what is \ngoing on in their organization.\nLike every other professional software development process, agile development \nhas to be managed so that the best use is made of the time and resources available to"}
{"query": "How do plan-driven approaches to software development meet the need for project visibility?", "response": "Plan-driven approaches to software development meet the need for project visibility by requiring managers to have a stable view of everything that needs to be developed and the development processes. Managers draw up a plan for the project that outlines what should be delivered, when it should be delivered, and who will work on the development of the project deliverables. This allows managers to have a clear understanding of the project's progress and whether it is likely to meet its objectives and deliver the software on time with the proposed budget.", "context": "3.2  \u25a0 Agile development techniques  83\nAs testing is automated, there is always a set of tests that can be quickly and eas-\nily executed. Whenever any functionality is added to the system, the tests can be run \nand problems that the new code has introduced can be caught immediately.\nTest-first development and automated testing usually result in a large number of \ntests being written and executed. However, there are problems in ensuring that test \ncoverage is complete:\n1. Programmers prefer programming to testing, and sometimes they take shortcuts \nwhen writing tests. For example, they may write incomplete tests that do not \ncheck for all possible exceptions that may occur.\n2. Some tests can be very difficult to write incrementally. For example, in a com-\nplex user interface, it is often difficult to write unit tests for the code that imple-\nments the \u201cdisplay logic\u201d and workflow between screens.\nIt is difficult to judge the completeness of a set of tests. Although you may have a lot \nof system tests, your test set may not provide complete coverage. Crucial parts of \nthe\u00a0system may not be executed and so will remain untested. Therefore, although a \nlarge set of frequently executed tests may give the impression that the system is complete \nand correct, this may not be the case. If the tests are not reviewed and further tests are \nwritten after development, then undetected bugs may be delivered in the system release.\n \n3.2.4  Pair programming\nAnother innovative practice that was introduced in XP is that programmers work in \npairs to develop the software. The programming pair sits at the same computer to \ndevelop the software. However, the same pair do not always program together. \nRather, pairs are created dynamically so that all team members work with each other \nduring the development process.\nPair programming has a number of advantages.\n1. It supports the idea of collective ownership and responsibility for the system. \nThis reflects Weinberg\u2019s idea of egoless programming (Weinberg 1971) where \nthe software is owned by the team as a whole and individuals are not held \nresponsible for problems with the code. Instead, the team has collective respon-\nsibility for resolving these problems.\n2. \nIt acts as an informal review process because each line of code is looked at by at least \ntwo people. Code inspections and reviews (Chapter 24) are effective in discovering \na high percentage of software errors. However, they are time consuming to organize \nand, typically, introduce delays into the development process. Pair programming is a \nless formal process that probably doesn\u2019t find as many errors as code inspections. \nHowever, it is cheaper and easier to organize than formal program inspections.\n3. \nIt encourages refactoring to improve the software structure. The problem with ask-\ning programmers to refactor in a normal development environment is that effort \n\n\n84  Chapter 3 \u25a0 Agile software development\ninvolved is expended for long-term benefit. An developer who spends time refac-\ntoring may be judged to be less efficient than one who simply carries on developing \ncode. Where pair programming and collective ownership are used, others benefit \nimmediately from the refactoring so they are likely to support the process.\nYou might think that pair programming would be less efficient than individual \nprogramming. In a given time, a pair of developers would produce half as much code \nas two individuals working alone. Many companies that have adopted agile methods \nare suspicious of pair programming and do not use it. Other companies mix pair and \nindividual programming with an experienced programmer working with a less expe-\nrienced colleague when they have problems.\nFormal studies of the value of pair programming have had mixed results. Using \nstudent volunteers, Williams and her collaborators (Williams et al. 2000) found that \nproductivity with pair programming seems to be comparable to that of two people \nworking independently. The reasons suggested are that pairs discuss the software \nbefore development and so probably have fewer false starts and less rework. \nFurthermore, the number of errors avoided by the informal inspection is such that \nless time is spent repairing bugs discovered during the testing process.\nHowever, studies with more experienced programmers did not replicate these \nresults (Arisholm et al. 2007). They found that there was a significant loss of produc-\ntivity compared with two programmers working alone. There were some quality \nbenefits, but these did not fully compensate for the pair-programming overhead. \nNevertheless, the sharing of knowledge that happens during pair programming is \nvery important as it reduces the overall risks to a project when team members leave. \nIn itself, this may make pair programming worthwhile.\n \n3.3  Agile project management\nIn any software business, managers need to know what is going on and whether or not \na project is likely to meet its objectives and deliver the software on time with the pro-\nposed budget. Plan-driven approaches to software development evolved to meet this \nneed. As I discussed in Chapter 23, managers  draw up a plan for the project showing \nwhat should be delivered, when it should be delivered, and who will work on the devel-\nopment of the project deliverables. A plan-based approach requires a manager to have \na stable view of everything that has to be developed and the development processes.\nThe informal planning and project control that was proposed by the early adher-\nents of agile methods clashed with this business requirement for visibility. Teams \nwere self-organizing, did not produce documentation, and planned development in \nvery short cycles. While this can and does work for small companies developing \nsoftware products, it is inappropriate for larger companies who need to know what is \ngoing on in their organization.\nLike every other professional software development process, agile development \nhas to be managed so that the best use is made of the time and resources available to"}
{"query": "Why might the informal planning and project control proposed by early adherents of agile methods clash with business requirements?", "response": "The informal planning and project control proposed by early adherents of agile methods may clash with business requirements because it does not provide the visibility and stability that managers need. Agile teams are self-organizing, do not produce documentation, and plan development in short cycles, which may not be suitable for larger companies that require a clear understanding of what is happening in their organization. Business requirements often demand a stable view of the development process and a comprehensive plan for delivering the software on time and within budget.", "context": "3.2  \u25a0 Agile development techniques  83\nAs testing is automated, there is always a set of tests that can be quickly and eas-\nily executed. Whenever any functionality is added to the system, the tests can be run \nand problems that the new code has introduced can be caught immediately.\nTest-first development and automated testing usually result in a large number of \ntests being written and executed. However, there are problems in ensuring that test \ncoverage is complete:\n1. Programmers prefer programming to testing, and sometimes they take shortcuts \nwhen writing tests. For example, they may write incomplete tests that do not \ncheck for all possible exceptions that may occur.\n2. Some tests can be very difficult to write incrementally. For example, in a com-\nplex user interface, it is often difficult to write unit tests for the code that imple-\nments the \u201cdisplay logic\u201d and workflow between screens.\nIt is difficult to judge the completeness of a set of tests. Although you may have a lot \nof system tests, your test set may not provide complete coverage. Crucial parts of \nthe\u00a0system may not be executed and so will remain untested. Therefore, although a \nlarge set of frequently executed tests may give the impression that the system is complete \nand correct, this may not be the case. If the tests are not reviewed and further tests are \nwritten after development, then undetected bugs may be delivered in the system release.\n \n3.2.4  Pair programming\nAnother innovative practice that was introduced in XP is that programmers work in \npairs to develop the software. The programming pair sits at the same computer to \ndevelop the software. However, the same pair do not always program together. \nRather, pairs are created dynamically so that all team members work with each other \nduring the development process.\nPair programming has a number of advantages.\n1. It supports the idea of collective ownership and responsibility for the system. \nThis reflects Weinberg\u2019s idea of egoless programming (Weinberg 1971) where \nthe software is owned by the team as a whole and individuals are not held \nresponsible for problems with the code. Instead, the team has collective respon-\nsibility for resolving these problems.\n2. \nIt acts as an informal review process because each line of code is looked at by at least \ntwo people. Code inspections and reviews (Chapter 24) are effective in discovering \na high percentage of software errors. However, they are time consuming to organize \nand, typically, introduce delays into the development process. Pair programming is a \nless formal process that probably doesn\u2019t find as many errors as code inspections. \nHowever, it is cheaper and easier to organize than formal program inspections.\n3. \nIt encourages refactoring to improve the software structure. The problem with ask-\ning programmers to refactor in a normal development environment is that effort \n\n\n84  Chapter 3 \u25a0 Agile software development\ninvolved is expended for long-term benefit. An developer who spends time refac-\ntoring may be judged to be less efficient than one who simply carries on developing \ncode. Where pair programming and collective ownership are used, others benefit \nimmediately from the refactoring so they are likely to support the process.\nYou might think that pair programming would be less efficient than individual \nprogramming. In a given time, a pair of developers would produce half as much code \nas two individuals working alone. Many companies that have adopted agile methods \nare suspicious of pair programming and do not use it. Other companies mix pair and \nindividual programming with an experienced programmer working with a less expe-\nrienced colleague when they have problems.\nFormal studies of the value of pair programming have had mixed results. Using \nstudent volunteers, Williams and her collaborators (Williams et al. 2000) found that \nproductivity with pair programming seems to be comparable to that of two people \nworking independently. The reasons suggested are that pairs discuss the software \nbefore development and so probably have fewer false starts and less rework. \nFurthermore, the number of errors avoided by the informal inspection is such that \nless time is spent repairing bugs discovered during the testing process.\nHowever, studies with more experienced programmers did not replicate these \nresults (Arisholm et al. 2007). They found that there was a significant loss of produc-\ntivity compared with two programmers working alone. There were some quality \nbenefits, but these did not fully compensate for the pair-programming overhead. \nNevertheless, the sharing of knowledge that happens during pair programming is \nvery important as it reduces the overall risks to a project when team members leave. \nIn itself, this may make pair programming worthwhile.\n \n3.3  Agile project management\nIn any software business, managers need to know what is going on and whether or not \na project is likely to meet its objectives and deliver the software on time with the pro-\nposed budget. Plan-driven approaches to software development evolved to meet this \nneed. As I discussed in Chapter 23, managers  draw up a plan for the project showing \nwhat should be delivered, when it should be delivered, and who will work on the devel-\nopment of the project deliverables. A plan-based approach requires a manager to have \na stable view of everything that has to be developed and the development processes.\nThe informal planning and project control that was proposed by the early adher-\nents of agile methods clashed with this business requirement for visibility. Teams \nwere self-organizing, did not produce documentation, and planned development in \nvery short cycles. While this can and does work for small companies developing \nsoftware products, it is inappropriate for larger companies who need to know what is \ngoing on in their organization.\nLike every other professional software development process, agile development \nhas to be managed so that the best use is made of the time and resources available to"}
{"query": "Why might agile methods be inappropriate for larger companies?", "response": "Agile methods might be inappropriate for larger companies because they clash with the business requirement for visibility. Agile teams are self-organizing, do not produce documentation, and plan development in very short cycles. This informal planning and project control may not provide the level of visibility and control that larger companies need to know what is going on in their organization. Therefore, agile methods may not be suitable for larger companies that require a more structured and documented approach to software development.", "context": "3.2  \u25a0 Agile development techniques  83\nAs testing is automated, there is always a set of tests that can be quickly and eas-\nily executed. Whenever any functionality is added to the system, the tests can be run \nand problems that the new code has introduced can be caught immediately.\nTest-first development and automated testing usually result in a large number of \ntests being written and executed. However, there are problems in ensuring that test \ncoverage is complete:\n1. Programmers prefer programming to testing, and sometimes they take shortcuts \nwhen writing tests. For example, they may write incomplete tests that do not \ncheck for all possible exceptions that may occur.\n2. Some tests can be very difficult to write incrementally. For example, in a com-\nplex user interface, it is often difficult to write unit tests for the code that imple-\nments the \u201cdisplay logic\u201d and workflow between screens.\nIt is difficult to judge the completeness of a set of tests. Although you may have a lot \nof system tests, your test set may not provide complete coverage. Crucial parts of \nthe\u00a0system may not be executed and so will remain untested. Therefore, although a \nlarge set of frequently executed tests may give the impression that the system is complete \nand correct, this may not be the case. If the tests are not reviewed and further tests are \nwritten after development, then undetected bugs may be delivered in the system release.\n \n3.2.4  Pair programming\nAnother innovative practice that was introduced in XP is that programmers work in \npairs to develop the software. The programming pair sits at the same computer to \ndevelop the software. However, the same pair do not always program together. \nRather, pairs are created dynamically so that all team members work with each other \nduring the development process.\nPair programming has a number of advantages.\n1. It supports the idea of collective ownership and responsibility for the system. \nThis reflects Weinberg\u2019s idea of egoless programming (Weinberg 1971) where \nthe software is owned by the team as a whole and individuals are not held \nresponsible for problems with the code. Instead, the team has collective respon-\nsibility for resolving these problems.\n2. \nIt acts as an informal review process because each line of code is looked at by at least \ntwo people. Code inspections and reviews (Chapter 24) are effective in discovering \na high percentage of software errors. However, they are time consuming to organize \nand, typically, introduce delays into the development process. Pair programming is a \nless formal process that probably doesn\u2019t find as many errors as code inspections. \nHowever, it is cheaper and easier to organize than formal program inspections.\n3. \nIt encourages refactoring to improve the software structure. The problem with ask-\ning programmers to refactor in a normal development environment is that effort \n\n\n84  Chapter 3 \u25a0 Agile software development\ninvolved is expended for long-term benefit. An developer who spends time refac-\ntoring may be judged to be less efficient than one who simply carries on developing \ncode. Where pair programming and collective ownership are used, others benefit \nimmediately from the refactoring so they are likely to support the process.\nYou might think that pair programming would be less efficient than individual \nprogramming. In a given time, a pair of developers would produce half as much code \nas two individuals working alone. Many companies that have adopted agile methods \nare suspicious of pair programming and do not use it. Other companies mix pair and \nindividual programming with an experienced programmer working with a less expe-\nrienced colleague when they have problems.\nFormal studies of the value of pair programming have had mixed results. Using \nstudent volunteers, Williams and her collaborators (Williams et al. 2000) found that \nproductivity with pair programming seems to be comparable to that of two people \nworking independently. The reasons suggested are that pairs discuss the software \nbefore development and so probably have fewer false starts and less rework. \nFurthermore, the number of errors avoided by the informal inspection is such that \nless time is spent repairing bugs discovered during the testing process.\nHowever, studies with more experienced programmers did not replicate these \nresults (Arisholm et al. 2007). They found that there was a significant loss of produc-\ntivity compared with two programmers working alone. There were some quality \nbenefits, but these did not fully compensate for the pair-programming overhead. \nNevertheless, the sharing of knowledge that happens during pair programming is \nvery important as it reduces the overall risks to a project when team members leave. \nIn itself, this may make pair programming worthwhile.\n \n3.3  Agile project management\nIn any software business, managers need to know what is going on and whether or not \na project is likely to meet its objectives and deliver the software on time with the pro-\nposed budget. Plan-driven approaches to software development evolved to meet this \nneed. As I discussed in Chapter 23, managers  draw up a plan for the project showing \nwhat should be delivered, when it should be delivered, and who will work on the devel-\nopment of the project deliverables. A plan-based approach requires a manager to have \na stable view of everything that has to be developed and the development processes.\nThe informal planning and project control that was proposed by the early adher-\nents of agile methods clashed with this business requirement for visibility. Teams \nwere self-organizing, did not produce documentation, and planned development in \nvery short cycles. While this can and does work for small companies developing \nsoftware products, it is inappropriate for larger companies who need to know what is \ngoing on in their organization.\nLike every other professional software development process, agile development \nhas to be managed so that the best use is made of the time and resources available to"}
{"query": "How can agile development be managed to make the best use of time and resources?", "response": "Agile development can be managed to make the best use of time and resources by implementing certain practices. One such practice is test-first development and automated testing, which allows for quick and easy execution of tests whenever new functionality is added to the system. This helps catch any problems introduced by the new code immediately. However, it is important to ensure that test coverage is complete and that programmers do not take shortcuts when writing tests. Another practice is pair programming, where programmers work in pairs to develop the software. This promotes collective ownership and responsibility for the system, acts as an informal review process, and encourages refactoring to improve the software structure. While pair programming may seem less efficient than individual programming, studies have shown mixed results in terms of productivity. However, the sharing of knowledge during pair programming reduces overall project risks when team members leave. Overall, effective management of agile development involves ensuring complete test coverage, promoting collective ownership, and leveraging the benefits of pair programming.", "context": "3.2  \u25a0 Agile development techniques  83\nAs testing is automated, there is always a set of tests that can be quickly and eas-\nily executed. Whenever any functionality is added to the system, the tests can be run \nand problems that the new code has introduced can be caught immediately.\nTest-first development and automated testing usually result in a large number of \ntests being written and executed. However, there are problems in ensuring that test \ncoverage is complete:\n1. Programmers prefer programming to testing, and sometimes they take shortcuts \nwhen writing tests. For example, they may write incomplete tests that do not \ncheck for all possible exceptions that may occur.\n2. Some tests can be very difficult to write incrementally. For example, in a com-\nplex user interface, it is often difficult to write unit tests for the code that imple-\nments the \u201cdisplay logic\u201d and workflow between screens.\nIt is difficult to judge the completeness of a set of tests. Although you may have a lot \nof system tests, your test set may not provide complete coverage. Crucial parts of \nthe\u00a0system may not be executed and so will remain untested. Therefore, although a \nlarge set of frequently executed tests may give the impression that the system is complete \nand correct, this may not be the case. If the tests are not reviewed and further tests are \nwritten after development, then undetected bugs may be delivered in the system release.\n \n3.2.4  Pair programming\nAnother innovative practice that was introduced in XP is that programmers work in \npairs to develop the software. The programming pair sits at the same computer to \ndevelop the software. However, the same pair do not always program together. \nRather, pairs are created dynamically so that all team members work with each other \nduring the development process.\nPair programming has a number of advantages.\n1. It supports the idea of collective ownership and responsibility for the system. \nThis reflects Weinberg\u2019s idea of egoless programming (Weinberg 1971) where \nthe software is owned by the team as a whole and individuals are not held \nresponsible for problems with the code. Instead, the team has collective respon-\nsibility for resolving these problems.\n2. \nIt acts as an informal review process because each line of code is looked at by at least \ntwo people. Code inspections and reviews (Chapter 24) are effective in discovering \na high percentage of software errors. However, they are time consuming to organize \nand, typically, introduce delays into the development process. Pair programming is a \nless formal process that probably doesn\u2019t find as many errors as code inspections. \nHowever, it is cheaper and easier to organize than formal program inspections.\n3. \nIt encourages refactoring to improve the software structure. The problem with ask-\ning programmers to refactor in a normal development environment is that effort \n\n\n84  Chapter 3 \u25a0 Agile software development\ninvolved is expended for long-term benefit. An developer who spends time refac-\ntoring may be judged to be less efficient than one who simply carries on developing \ncode. Where pair programming and collective ownership are used, others benefit \nimmediately from the refactoring so they are likely to support the process.\nYou might think that pair programming would be less efficient than individual \nprogramming. In a given time, a pair of developers would produce half as much code \nas two individuals working alone. Many companies that have adopted agile methods \nare suspicious of pair programming and do not use it. Other companies mix pair and \nindividual programming with an experienced programmer working with a less expe-\nrienced colleague when they have problems.\nFormal studies of the value of pair programming have had mixed results. Using \nstudent volunteers, Williams and her collaborators (Williams et al. 2000) found that \nproductivity with pair programming seems to be comparable to that of two people \nworking independently. The reasons suggested are that pairs discuss the software \nbefore development and so probably have fewer false starts and less rework. \nFurthermore, the number of errors avoided by the informal inspection is such that \nless time is spent repairing bugs discovered during the testing process.\nHowever, studies with more experienced programmers did not replicate these \nresults (Arisholm et al. 2007). They found that there was a significant loss of produc-\ntivity compared with two programmers working alone. There were some quality \nbenefits, but these did not fully compensate for the pair-programming overhead. \nNevertheless, the sharing of knowledge that happens during pair programming is \nvery important as it reduces the overall risks to a project when team members leave. \nIn itself, this may make pair programming worthwhile.\n \n3.3  Agile project management\nIn any software business, managers need to know what is going on and whether or not \na project is likely to meet its objectives and deliver the software on time with the pro-\nposed budget. Plan-driven approaches to software development evolved to meet this \nneed. As I discussed in Chapter 23, managers  draw up a plan for the project showing \nwhat should be delivered, when it should be delivered, and who will work on the devel-\nopment of the project deliverables. A plan-based approach requires a manager to have \na stable view of everything that has to be developed and the development processes.\nThe informal planning and project control that was proposed by the early adher-\nents of agile methods clashed with this business requirement for visibility. Teams \nwere self-organizing, did not produce documentation, and planned development in \nvery short cycles. While this can and does work for small companies developing \nsoftware products, it is inappropriate for larger companies who need to know what is \ngoing on in their organization.\nLike every other professional software development process, agile development \nhas to be managed so that the best use is made of the time and resources available to"}
{"query": "How does pair programming reflect Weinberg\u2019s idea of egoless programming?", "response": "Pair programming reflects Weinberg's idea of egoless programming by promoting collective ownership and responsibility for the system. In egoless programming, the software is owned by the team as a whole, and individuals are not held solely responsible for problems with the code. Instead, the team collectively takes responsibility for resolving these problems. Pair programming allows for continuous collaboration and knowledge sharing between team members, reducing the focus on individual ego and emphasizing the importance of the team's success over individual achievements.", "context": "3.2  \u25a0 Agile development techniques  83\nAs testing is automated, there is always a set of tests that can be quickly and eas-\nily executed. Whenever any functionality is added to the system, the tests can be run \nand problems that the new code has introduced can be caught immediately.\nTest-first development and automated testing usually result in a large number of \ntests being written and executed. However, there are problems in ensuring that test \ncoverage is complete:\n1. Programmers prefer programming to testing, and sometimes they take shortcuts \nwhen writing tests. For example, they may write incomplete tests that do not \ncheck for all possible exceptions that may occur.\n2. Some tests can be very difficult to write incrementally. For example, in a com-\nplex user interface, it is often difficult to write unit tests for the code that imple-\nments the \u201cdisplay logic\u201d and workflow between screens.\nIt is difficult to judge the completeness of a set of tests. Although you may have a lot \nof system tests, your test set may not provide complete coverage. Crucial parts of \nthe\u00a0system may not be executed and so will remain untested. Therefore, although a \nlarge set of frequently executed tests may give the impression that the system is complete \nand correct, this may not be the case. If the tests are not reviewed and further tests are \nwritten after development, then undetected bugs may be delivered in the system release.\n \n3.2.4  Pair programming\nAnother innovative practice that was introduced in XP is that programmers work in \npairs to develop the software. The programming pair sits at the same computer to \ndevelop the software. However, the same pair do not always program together. \nRather, pairs are created dynamically so that all team members work with each other \nduring the development process.\nPair programming has a number of advantages.\n1. It supports the idea of collective ownership and responsibility for the system. \nThis reflects Weinberg\u2019s idea of egoless programming (Weinberg 1971) where \nthe software is owned by the team as a whole and individuals are not held \nresponsible for problems with the code. Instead, the team has collective respon-\nsibility for resolving these problems.\n2. \nIt acts as an informal review process because each line of code is looked at by at least \ntwo people. Code inspections and reviews (Chapter 24) are effective in discovering \na high percentage of software errors. However, they are time consuming to organize \nand, typically, introduce delays into the development process. Pair programming is a \nless formal process that probably doesn\u2019t find as many errors as code inspections. \nHowever, it is cheaper and easier to organize than formal program inspections.\n3. \nIt encourages refactoring to improve the software structure. The problem with ask-\ning programmers to refactor in a normal development environment is that effort \n\n\n84  Chapter 3 \u25a0 Agile software development\ninvolved is expended for long-term benefit. An developer who spends time refac-\ntoring may be judged to be less efficient than one who simply carries on developing \ncode. Where pair programming and collective ownership are used, others benefit \nimmediately from the refactoring so they are likely to support the process.\nYou might think that pair programming would be less efficient than individual \nprogramming. In a given time, a pair of developers would produce half as much code \nas two individuals working alone. Many companies that have adopted agile methods \nare suspicious of pair programming and do not use it. Other companies mix pair and \nindividual programming with an experienced programmer working with a less expe-\nrienced colleague when they have problems.\nFormal studies of the value of pair programming have had mixed results. Using \nstudent volunteers, Williams and her collaborators (Williams et al. 2000) found that \nproductivity with pair programming seems to be comparable to that of two people \nworking independently. The reasons suggested are that pairs discuss the software \nbefore development and so probably have fewer false starts and less rework. \nFurthermore, the number of errors avoided by the informal inspection is such that \nless time is spent repairing bugs discovered during the testing process.\nHowever, studies with more experienced programmers did not replicate these \nresults (Arisholm et al. 2007). They found that there was a significant loss of produc-\ntivity compared with two programmers working alone. There were some quality \nbenefits, but these did not fully compensate for the pair-programming overhead. \nNevertheless, the sharing of knowledge that happens during pair programming is \nvery important as it reduces the overall risks to a project when team members leave. \nIn itself, this may make pair programming worthwhile.\n \n3.3  Agile project management\nIn any software business, managers need to know what is going on and whether or not \na project is likely to meet its objectives and deliver the software on time with the pro-\nposed budget. Plan-driven approaches to software development evolved to meet this \nneed. As I discussed in Chapter 23, managers  draw up a plan for the project showing \nwhat should be delivered, when it should be delivered, and who will work on the devel-\nopment of the project deliverables. A plan-based approach requires a manager to have \na stable view of everything that has to be developed and the development processes.\nThe informal planning and project control that was proposed by the early adher-\nents of agile methods clashed with this business requirement for visibility. Teams \nwere self-organizing, did not produce documentation, and planned development in \nvery short cycles. While this can and does work for small companies developing \nsoftware products, it is inappropriate for larger companies who need to know what is \ngoing on in their organization.\nLike every other professional software development process, agile development \nhas to be managed so that the best use is made of the time and resources available to"}
{"query": "What is the impact of pair programming on the software error discovery process?", "response": "Pair programming acts as an informal review process because each line of code is looked at by at least two people. While it may not find as many errors as formal code inspections, it is cheaper and easier to organize. The sharing of knowledge that happens during pair programming is also important as it reduces overall risks to a project when team members leave.", "context": "3.2  \u25a0 Agile development techniques  83\nAs testing is automated, there is always a set of tests that can be quickly and eas-\nily executed. Whenever any functionality is added to the system, the tests can be run \nand problems that the new code has introduced can be caught immediately.\nTest-first development and automated testing usually result in a large number of \ntests being written and executed. However, there are problems in ensuring that test \ncoverage is complete:\n1. Programmers prefer programming to testing, and sometimes they take shortcuts \nwhen writing tests. For example, they may write incomplete tests that do not \ncheck for all possible exceptions that may occur.\n2. Some tests can be very difficult to write incrementally. For example, in a com-\nplex user interface, it is often difficult to write unit tests for the code that imple-\nments the \u201cdisplay logic\u201d and workflow between screens.\nIt is difficult to judge the completeness of a set of tests. Although you may have a lot \nof system tests, your test set may not provide complete coverage. Crucial parts of \nthe\u00a0system may not be executed and so will remain untested. Therefore, although a \nlarge set of frequently executed tests may give the impression that the system is complete \nand correct, this may not be the case. If the tests are not reviewed and further tests are \nwritten after development, then undetected bugs may be delivered in the system release.\n \n3.2.4  Pair programming\nAnother innovative practice that was introduced in XP is that programmers work in \npairs to develop the software. The programming pair sits at the same computer to \ndevelop the software. However, the same pair do not always program together. \nRather, pairs are created dynamically so that all team members work with each other \nduring the development process.\nPair programming has a number of advantages.\n1. It supports the idea of collective ownership and responsibility for the system. \nThis reflects Weinberg\u2019s idea of egoless programming (Weinberg 1971) where \nthe software is owned by the team as a whole and individuals are not held \nresponsible for problems with the code. Instead, the team has collective respon-\nsibility for resolving these problems.\n2. \nIt acts as an informal review process because each line of code is looked at by at least \ntwo people. Code inspections and reviews (Chapter 24) are effective in discovering \na high percentage of software errors. However, they are time consuming to organize \nand, typically, introduce delays into the development process. Pair programming is a \nless formal process that probably doesn\u2019t find as many errors as code inspections. \nHowever, it is cheaper and easier to organize than formal program inspections.\n3. \nIt encourages refactoring to improve the software structure. The problem with ask-\ning programmers to refactor in a normal development environment is that effort \n\n\n84  Chapter 3 \u25a0 Agile software development\ninvolved is expended for long-term benefit. An developer who spends time refac-\ntoring may be judged to be less efficient than one who simply carries on developing \ncode. Where pair programming and collective ownership are used, others benefit \nimmediately from the refactoring so they are likely to support the process.\nYou might think that pair programming would be less efficient than individual \nprogramming. In a given time, a pair of developers would produce half as much code \nas two individuals working alone. Many companies that have adopted agile methods \nare suspicious of pair programming and do not use it. Other companies mix pair and \nindividual programming with an experienced programmer working with a less expe-\nrienced colleague when they have problems.\nFormal studies of the value of pair programming have had mixed results. Using \nstudent volunteers, Williams and her collaborators (Williams et al. 2000) found that \nproductivity with pair programming seems to be comparable to that of two people \nworking independently. The reasons suggested are that pairs discuss the software \nbefore development and so probably have fewer false starts and less rework. \nFurthermore, the number of errors avoided by the informal inspection is such that \nless time is spent repairing bugs discovered during the testing process.\nHowever, studies with more experienced programmers did not replicate these \nresults (Arisholm et al. 2007). They found that there was a significant loss of produc-\ntivity compared with two programmers working alone. There were some quality \nbenefits, but these did not fully compensate for the pair-programming overhead. \nNevertheless, the sharing of knowledge that happens during pair programming is \nvery important as it reduces the overall risks to a project when team members leave. \nIn itself, this may make pair programming worthwhile.\n \n3.3  Agile project management\nIn any software business, managers need to know what is going on and whether or not \na project is likely to meet its objectives and deliver the software on time with the pro-\nposed budget. Plan-driven approaches to software development evolved to meet this \nneed. As I discussed in Chapter 23, managers  draw up a plan for the project showing \nwhat should be delivered, when it should be delivered, and who will work on the devel-\nopment of the project deliverables. A plan-based approach requires a manager to have \na stable view of everything that has to be developed and the development processes.\nThe informal planning and project control that was proposed by the early adher-\nents of agile methods clashed with this business requirement for visibility. Teams \nwere self-organizing, did not produce documentation, and planned development in \nvery short cycles. While this can and does work for small companies developing \nsoftware products, it is inappropriate for larger companies who need to know what is \ngoing on in their organization.\nLike every other professional software development process, agile development \nhas to be managed so that the best use is made of the time and resources available to"}
{"query": "What is the relationship between pair programming and code inspections?", "response": "Pair programming and code inspections are both practices that can be used to improve the quality of software development. While code inspections involve a formal process of reviewing code to identify errors and improve its quality, pair programming is a more informal process where two programmers work together at the same computer to develop software. \n\nOne of the advantages of pair programming is that it acts as an informal review process, as each line of code is looked at by at least two people. While code inspections are more effective in discovering software errors, they can be time-consuming and introduce delays into the development process. On the other hand, pair programming is a less formal process that may not find as many errors as code inspections, but it is cheaper and easier to organize. \n\nTherefore, while pair programming may not fully replicate the benefits of code inspections in terms of error detection, it provides a more efficient and cost-effective way to review code and improve its quality during the development process.", "context": "3.2  \u25a0 Agile development techniques  83\nAs testing is automated, there is always a set of tests that can be quickly and eas-\nily executed. Whenever any functionality is added to the system, the tests can be run \nand problems that the new code has introduced can be caught immediately.\nTest-first development and automated testing usually result in a large number of \ntests being written and executed. However, there are problems in ensuring that test \ncoverage is complete:\n1. Programmers prefer programming to testing, and sometimes they take shortcuts \nwhen writing tests. For example, they may write incomplete tests that do not \ncheck for all possible exceptions that may occur.\n2. Some tests can be very difficult to write incrementally. For example, in a com-\nplex user interface, it is often difficult to write unit tests for the code that imple-\nments the \u201cdisplay logic\u201d and workflow between screens.\nIt is difficult to judge the completeness of a set of tests. Although you may have a lot \nof system tests, your test set may not provide complete coverage. Crucial parts of \nthe\u00a0system may not be executed and so will remain untested. Therefore, although a \nlarge set of frequently executed tests may give the impression that the system is complete \nand correct, this may not be the case. If the tests are not reviewed and further tests are \nwritten after development, then undetected bugs may be delivered in the system release.\n \n3.2.4  Pair programming\nAnother innovative practice that was introduced in XP is that programmers work in \npairs to develop the software. The programming pair sits at the same computer to \ndevelop the software. However, the same pair do not always program together. \nRather, pairs are created dynamically so that all team members work with each other \nduring the development process.\nPair programming has a number of advantages.\n1. It supports the idea of collective ownership and responsibility for the system. \nThis reflects Weinberg\u2019s idea of egoless programming (Weinberg 1971) where \nthe software is owned by the team as a whole and individuals are not held \nresponsible for problems with the code. Instead, the team has collective respon-\nsibility for resolving these problems.\n2. \nIt acts as an informal review process because each line of code is looked at by at least \ntwo people. Code inspections and reviews (Chapter 24) are effective in discovering \na high percentage of software errors. However, they are time consuming to organize \nand, typically, introduce delays into the development process. Pair programming is a \nless formal process that probably doesn\u2019t find as many errors as code inspections. \nHowever, it is cheaper and easier to organize than formal program inspections.\n3. \nIt encourages refactoring to improve the software structure. The problem with ask-\ning programmers to refactor in a normal development environment is that effort \n\n\n84  Chapter 3 \u25a0 Agile software development\ninvolved is expended for long-term benefit. An developer who spends time refac-\ntoring may be judged to be less efficient than one who simply carries on developing \ncode. Where pair programming and collective ownership are used, others benefit \nimmediately from the refactoring so they are likely to support the process.\nYou might think that pair programming would be less efficient than individual \nprogramming. In a given time, a pair of developers would produce half as much code \nas two individuals working alone. Many companies that have adopted agile methods \nare suspicious of pair programming and do not use it. Other companies mix pair and \nindividual programming with an experienced programmer working with a less expe-\nrienced colleague when they have problems.\nFormal studies of the value of pair programming have had mixed results. Using \nstudent volunteers, Williams and her collaborators (Williams et al. 2000) found that \nproductivity with pair programming seems to be comparable to that of two people \nworking independently. The reasons suggested are that pairs discuss the software \nbefore development and so probably have fewer false starts and less rework. \nFurthermore, the number of errors avoided by the informal inspection is such that \nless time is spent repairing bugs discovered during the testing process.\nHowever, studies with more experienced programmers did not replicate these \nresults (Arisholm et al. 2007). They found that there was a significant loss of produc-\ntivity compared with two programmers working alone. There were some quality \nbenefits, but these did not fully compensate for the pair-programming overhead. \nNevertheless, the sharing of knowledge that happens during pair programming is \nvery important as it reduces the overall risks to a project when team members leave. \nIn itself, this may make pair programming worthwhile.\n \n3.3  Agile project management\nIn any software business, managers need to know what is going on and whether or not \na project is likely to meet its objectives and deliver the software on time with the pro-\nposed budget. Plan-driven approaches to software development evolved to meet this \nneed. As I discussed in Chapter 23, managers  draw up a plan for the project showing \nwhat should be delivered, when it should be delivered, and who will work on the devel-\nopment of the project deliverables. A plan-based approach requires a manager to have \na stable view of everything that has to be developed and the development processes.\nThe informal planning and project control that was proposed by the early adher-\nents of agile methods clashed with this business requirement for visibility. Teams \nwere self-organizing, did not produce documentation, and planned development in \nvery short cycles. While this can and does work for small companies developing \nsoftware products, it is inappropriate for larger companies who need to know what is \ngoing on in their organization.\nLike every other professional software development process, agile development \nhas to be managed so that the best use is made of the time and resources available to"}
{"query": "What is the impact of pair programming on the software refactoring process?", "response": "Pair programming encourages refactoring to improve the software structure. In a normal development environment, asking programmers to refactor can be challenging because the effort involved is expended for long-term benefit. However, in pair programming, others benefit immediately from the refactoring, so they are likely to support the process. Therefore, pair programming has a positive impact on the software refactoring process.", "context": "3.2  \u25a0 Agile development techniques  83\nAs testing is automated, there is always a set of tests that can be quickly and eas-\nily executed. Whenever any functionality is added to the system, the tests can be run \nand problems that the new code has introduced can be caught immediately.\nTest-first development and automated testing usually result in a large number of \ntests being written and executed. However, there are problems in ensuring that test \ncoverage is complete:\n1. Programmers prefer programming to testing, and sometimes they take shortcuts \nwhen writing tests. For example, they may write incomplete tests that do not \ncheck for all possible exceptions that may occur.\n2. Some tests can be very difficult to write incrementally. For example, in a com-\nplex user interface, it is often difficult to write unit tests for the code that imple-\nments the \u201cdisplay logic\u201d and workflow between screens.\nIt is difficult to judge the completeness of a set of tests. Although you may have a lot \nof system tests, your test set may not provide complete coverage. Crucial parts of \nthe\u00a0system may not be executed and so will remain untested. Therefore, although a \nlarge set of frequently executed tests may give the impression that the system is complete \nand correct, this may not be the case. If the tests are not reviewed and further tests are \nwritten after development, then undetected bugs may be delivered in the system release.\n \n3.2.4  Pair programming\nAnother innovative practice that was introduced in XP is that programmers work in \npairs to develop the software. The programming pair sits at the same computer to \ndevelop the software. However, the same pair do not always program together. \nRather, pairs are created dynamically so that all team members work with each other \nduring the development process.\nPair programming has a number of advantages.\n1. It supports the idea of collective ownership and responsibility for the system. \nThis reflects Weinberg\u2019s idea of egoless programming (Weinberg 1971) where \nthe software is owned by the team as a whole and individuals are not held \nresponsible for problems with the code. Instead, the team has collective respon-\nsibility for resolving these problems.\n2. \nIt acts as an informal review process because each line of code is looked at by at least \ntwo people. Code inspections and reviews (Chapter 24) are effective in discovering \na high percentage of software errors. However, they are time consuming to organize \nand, typically, introduce delays into the development process. Pair programming is a \nless formal process that probably doesn\u2019t find as many errors as code inspections. \nHowever, it is cheaper and easier to organize than formal program inspections.\n3. \nIt encourages refactoring to improve the software structure. The problem with ask-\ning programmers to refactor in a normal development environment is that effort \n\n\n84  Chapter 3 \u25a0 Agile software development\ninvolved is expended for long-term benefit. An developer who spends time refac-\ntoring may be judged to be less efficient than one who simply carries on developing \ncode. Where pair programming and collective ownership are used, others benefit \nimmediately from the refactoring so they are likely to support the process.\nYou might think that pair programming would be less efficient than individual \nprogramming. In a given time, a pair of developers would produce half as much code \nas two individuals working alone. Many companies that have adopted agile methods \nare suspicious of pair programming and do not use it. Other companies mix pair and \nindividual programming with an experienced programmer working with a less expe-\nrienced colleague when they have problems.\nFormal studies of the value of pair programming have had mixed results. Using \nstudent volunteers, Williams and her collaborators (Williams et al. 2000) found that \nproductivity with pair programming seems to be comparable to that of two people \nworking independently. The reasons suggested are that pairs discuss the software \nbefore development and so probably have fewer false starts and less rework. \nFurthermore, the number of errors avoided by the informal inspection is such that \nless time is spent repairing bugs discovered during the testing process.\nHowever, studies with more experienced programmers did not replicate these \nresults (Arisholm et al. 2007). They found that there was a significant loss of produc-\ntivity compared with two programmers working alone. There were some quality \nbenefits, but these did not fully compensate for the pair-programming overhead. \nNevertheless, the sharing of knowledge that happens during pair programming is \nvery important as it reduces the overall risks to a project when team members leave. \nIn itself, this may make pair programming worthwhile.\n \n3.3  Agile project management\nIn any software business, managers need to know what is going on and whether or not \na project is likely to meet its objectives and deliver the software on time with the pro-\nposed budget. Plan-driven approaches to software development evolved to meet this \nneed. As I discussed in Chapter 23, managers  draw up a plan for the project showing \nwhat should be delivered, when it should be delivered, and who will work on the devel-\nopment of the project deliverables. A plan-based approach requires a manager to have \na stable view of everything that has to be developed and the development processes.\nThe informal planning and project control that was proposed by the early adher-\nents of agile methods clashed with this business requirement for visibility. Teams \nwere self-organizing, did not produce documentation, and planned development in \nvery short cycles. While this can and does work for small companies developing \nsoftware products, it is inappropriate for larger companies who need to know what is \ngoing on in their organization.\nLike every other professional software development process, agile development \nhas to be managed so that the best use is made of the time and resources available to"}
{"query": "How does pair programming affect the productivity of a software development team?", "response": "Pair programming can have mixed effects on the productivity of a software development team. Some studies have shown that pair programming can be as productive as two individuals working independently. This is because pairs discuss the software before development, resulting in fewer false starts and less rework. Additionally, the informal inspection that occurs during pair programming helps to identify and avoid errors, reducing the time spent on bug fixing during the testing process.\n\nHowever, other studies with more experienced programmers have found that pair programming can lead to a significant loss of productivity compared to two programmers working alone. While there may be some quality benefits, they may not fully compensate for the overhead of pair programming.\n\nDespite the potential productivity trade-offs, pair programming offers the advantage of knowledge sharing among team members. This can be valuable in reducing overall project risks when team members leave. Therefore, the benefits of pair programming may outweigh the potential productivity drawbacks, making it a worthwhile practice for some software development teams.", "context": "3.2  \u25a0 Agile development techniques  83\nAs testing is automated, there is always a set of tests that can be quickly and eas-\nily executed. Whenever any functionality is added to the system, the tests can be run \nand problems that the new code has introduced can be caught immediately.\nTest-first development and automated testing usually result in a large number of \ntests being written and executed. However, there are problems in ensuring that test \ncoverage is complete:\n1. Programmers prefer programming to testing, and sometimes they take shortcuts \nwhen writing tests. For example, they may write incomplete tests that do not \ncheck for all possible exceptions that may occur.\n2. Some tests can be very difficult to write incrementally. For example, in a com-\nplex user interface, it is often difficult to write unit tests for the code that imple-\nments the \u201cdisplay logic\u201d and workflow between screens.\nIt is difficult to judge the completeness of a set of tests. Although you may have a lot \nof system tests, your test set may not provide complete coverage. Crucial parts of \nthe\u00a0system may not be executed and so will remain untested. Therefore, although a \nlarge set of frequently executed tests may give the impression that the system is complete \nand correct, this may not be the case. If the tests are not reviewed and further tests are \nwritten after development, then undetected bugs may be delivered in the system release.\n \n3.2.4  Pair programming\nAnother innovative practice that was introduced in XP is that programmers work in \npairs to develop the software. The programming pair sits at the same computer to \ndevelop the software. However, the same pair do not always program together. \nRather, pairs are created dynamically so that all team members work with each other \nduring the development process.\nPair programming has a number of advantages.\n1. It supports the idea of collective ownership and responsibility for the system. \nThis reflects Weinberg\u2019s idea of egoless programming (Weinberg 1971) where \nthe software is owned by the team as a whole and individuals are not held \nresponsible for problems with the code. Instead, the team has collective respon-\nsibility for resolving these problems.\n2. \nIt acts as an informal review process because each line of code is looked at by at least \ntwo people. Code inspections and reviews (Chapter 24) are effective in discovering \na high percentage of software errors. However, they are time consuming to organize \nand, typically, introduce delays into the development process. Pair programming is a \nless formal process that probably doesn\u2019t find as many errors as code inspections. \nHowever, it is cheaper and easier to organize than formal program inspections.\n3. \nIt encourages refactoring to improve the software structure. The problem with ask-\ning programmers to refactor in a normal development environment is that effort \n\n\n84  Chapter 3 \u25a0 Agile software development\ninvolved is expended for long-term benefit. An developer who spends time refac-\ntoring may be judged to be less efficient than one who simply carries on developing \ncode. Where pair programming and collective ownership are used, others benefit \nimmediately from the refactoring so they are likely to support the process.\nYou might think that pair programming would be less efficient than individual \nprogramming. In a given time, a pair of developers would produce half as much code \nas two individuals working alone. Many companies that have adopted agile methods \nare suspicious of pair programming and do not use it. Other companies mix pair and \nindividual programming with an experienced programmer working with a less expe-\nrienced colleague when they have problems.\nFormal studies of the value of pair programming have had mixed results. Using \nstudent volunteers, Williams and her collaborators (Williams et al. 2000) found that \nproductivity with pair programming seems to be comparable to that of two people \nworking independently. The reasons suggested are that pairs discuss the software \nbefore development and so probably have fewer false starts and less rework. \nFurthermore, the number of errors avoided by the informal inspection is such that \nless time is spent repairing bugs discovered during the testing process.\nHowever, studies with more experienced programmers did not replicate these \nresults (Arisholm et al. 2007). They found that there was a significant loss of produc-\ntivity compared with two programmers working alone. There were some quality \nbenefits, but these did not fully compensate for the pair-programming overhead. \nNevertheless, the sharing of knowledge that happens during pair programming is \nvery important as it reduces the overall risks to a project when team members leave. \nIn itself, this may make pair programming worthwhile.\n \n3.3  Agile project management\nIn any software business, managers need to know what is going on and whether or not \na project is likely to meet its objectives and deliver the software on time with the pro-\nposed budget. Plan-driven approaches to software development evolved to meet this \nneed. As I discussed in Chapter 23, managers  draw up a plan for the project showing \nwhat should be delivered, when it should be delivered, and who will work on the devel-\nopment of the project deliverables. A plan-based approach requires a manager to have \na stable view of everything that has to be developed and the development processes.\nThe informal planning and project control that was proposed by the early adher-\nents of agile methods clashed with this business requirement for visibility. Teams \nwere self-organizing, did not produce documentation, and planned development in \nvery short cycles. While this can and does work for small companies developing \nsoftware products, it is inappropriate for larger companies who need to know what is \ngoing on in their organization.\nLike every other professional software development process, agile development \nhas to be managed so that the best use is made of the time and resources available to"}
{"query": "What are the potential quality benefits of pair programming?", "response": "Pair programming has several potential quality benefits. First, it acts as an informal review process because each line of code is looked at by at least two people. This can help in discovering software errors and improving the overall quality of the code. Second, it encourages refactoring to improve the software structure. Refactoring is the process of restructuring existing code without changing its external behavior, and it can lead to better maintainability and extensibility of the software. Finally, the sharing of knowledge that happens during pair programming reduces the overall risks to a project when team members leave, which can contribute to the long-term quality and stability of the software.", "context": "3.2  \u25a0 Agile development techniques  83\nAs testing is automated, there is always a set of tests that can be quickly and eas-\nily executed. Whenever any functionality is added to the system, the tests can be run \nand problems that the new code has introduced can be caught immediately.\nTest-first development and automated testing usually result in a large number of \ntests being written and executed. However, there are problems in ensuring that test \ncoverage is complete:\n1. Programmers prefer programming to testing, and sometimes they take shortcuts \nwhen writing tests. For example, they may write incomplete tests that do not \ncheck for all possible exceptions that may occur.\n2. Some tests can be very difficult to write incrementally. For example, in a com-\nplex user interface, it is often difficult to write unit tests for the code that imple-\nments the \u201cdisplay logic\u201d and workflow between screens.\nIt is difficult to judge the completeness of a set of tests. Although you may have a lot \nof system tests, your test set may not provide complete coverage. Crucial parts of \nthe\u00a0system may not be executed and so will remain untested. Therefore, although a \nlarge set of frequently executed tests may give the impression that the system is complete \nand correct, this may not be the case. If the tests are not reviewed and further tests are \nwritten after development, then undetected bugs may be delivered in the system release.\n \n3.2.4  Pair programming\nAnother innovative practice that was introduced in XP is that programmers work in \npairs to develop the software. The programming pair sits at the same computer to \ndevelop the software. However, the same pair do not always program together. \nRather, pairs are created dynamically so that all team members work with each other \nduring the development process.\nPair programming has a number of advantages.\n1. It supports the idea of collective ownership and responsibility for the system. \nThis reflects Weinberg\u2019s idea of egoless programming (Weinberg 1971) where \nthe software is owned by the team as a whole and individuals are not held \nresponsible for problems with the code. Instead, the team has collective respon-\nsibility for resolving these problems.\n2. \nIt acts as an informal review process because each line of code is looked at by at least \ntwo people. Code inspections and reviews (Chapter 24) are effective in discovering \na high percentage of software errors. However, they are time consuming to organize \nand, typically, introduce delays into the development process. Pair programming is a \nless formal process that probably doesn\u2019t find as many errors as code inspections. \nHowever, it is cheaper and easier to organize than formal program inspections.\n3. \nIt encourages refactoring to improve the software structure. The problem with ask-\ning programmers to refactor in a normal development environment is that effort \n\n\n84  Chapter 3 \u25a0 Agile software development\ninvolved is expended for long-term benefit. An developer who spends time refac-\ntoring may be judged to be less efficient than one who simply carries on developing \ncode. Where pair programming and collective ownership are used, others benefit \nimmediately from the refactoring so they are likely to support the process.\nYou might think that pair programming would be less efficient than individual \nprogramming. In a given time, a pair of developers would produce half as much code \nas two individuals working alone. Many companies that have adopted agile methods \nare suspicious of pair programming and do not use it. Other companies mix pair and \nindividual programming with an experienced programmer working with a less expe-\nrienced colleague when they have problems.\nFormal studies of the value of pair programming have had mixed results. Using \nstudent volunteers, Williams and her collaborators (Williams et al. 2000) found that \nproductivity with pair programming seems to be comparable to that of two people \nworking independently. The reasons suggested are that pairs discuss the software \nbefore development and so probably have fewer false starts and less rework. \nFurthermore, the number of errors avoided by the informal inspection is such that \nless time is spent repairing bugs discovered during the testing process.\nHowever, studies with more experienced programmers did not replicate these \nresults (Arisholm et al. 2007). They found that there was a significant loss of produc-\ntivity compared with two programmers working alone. There were some quality \nbenefits, but these did not fully compensate for the pair-programming overhead. \nNevertheless, the sharing of knowledge that happens during pair programming is \nvery important as it reduces the overall risks to a project when team members leave. \nIn itself, this may make pair programming worthwhile.\n \n3.3  Agile project management\nIn any software business, managers need to know what is going on and whether or not \na project is likely to meet its objectives and deliver the software on time with the pro-\nposed budget. Plan-driven approaches to software development evolved to meet this \nneed. As I discussed in Chapter 23, managers  draw up a plan for the project showing \nwhat should be delivered, when it should be delivered, and who will work on the devel-\nopment of the project deliverables. A plan-based approach requires a manager to have \na stable view of everything that has to be developed and the development processes.\nThe informal planning and project control that was proposed by the early adher-\nents of agile methods clashed with this business requirement for visibility. Teams \nwere self-organizing, did not produce documentation, and planned development in \nvery short cycles. While this can and does work for small companies developing \nsoftware products, it is inappropriate for larger companies who need to know what is \ngoing on in their organization.\nLike every other professional software development process, agile development \nhas to be managed so that the best use is made of the time and resources available to"}
{"query": "How does pair programming contribute to knowledge sharing within a software development team?", "response": "Pair programming contributes to knowledge sharing within a software development team by allowing developers to work together and share their expertise. When two programmers work together, they have the opportunity to discuss and collaborate on the software before development, which helps in making better decisions and reducing false starts and rework. Additionally, the informal inspection that occurs during pair programming helps in identifying and avoiding errors, leading to less time spent on bug fixing during the testing process. The sharing of knowledge during pair programming also reduces the overall risks to a project when team members leave, making it a valuable practice for knowledge transfer within the team.", "context": "3.2  \u25a0 Agile development techniques  83\nAs testing is automated, there is always a set of tests that can be quickly and eas-\nily executed. Whenever any functionality is added to the system, the tests can be run \nand problems that the new code has introduced can be caught immediately.\nTest-first development and automated testing usually result in a large number of \ntests being written and executed. However, there are problems in ensuring that test \ncoverage is complete:\n1. Programmers prefer programming to testing, and sometimes they take shortcuts \nwhen writing tests. For example, they may write incomplete tests that do not \ncheck for all possible exceptions that may occur.\n2. Some tests can be very difficult to write incrementally. For example, in a com-\nplex user interface, it is often difficult to write unit tests for the code that imple-\nments the \u201cdisplay logic\u201d and workflow between screens.\nIt is difficult to judge the completeness of a set of tests. Although you may have a lot \nof system tests, your test set may not provide complete coverage. Crucial parts of \nthe\u00a0system may not be executed and so will remain untested. Therefore, although a \nlarge set of frequently executed tests may give the impression that the system is complete \nand correct, this may not be the case. If the tests are not reviewed and further tests are \nwritten after development, then undetected bugs may be delivered in the system release.\n \n3.2.4  Pair programming\nAnother innovative practice that was introduced in XP is that programmers work in \npairs to develop the software. The programming pair sits at the same computer to \ndevelop the software. However, the same pair do not always program together. \nRather, pairs are created dynamically so that all team members work with each other \nduring the development process.\nPair programming has a number of advantages.\n1. It supports the idea of collective ownership and responsibility for the system. \nThis reflects Weinberg\u2019s idea of egoless programming (Weinberg 1971) where \nthe software is owned by the team as a whole and individuals are not held \nresponsible for problems with the code. Instead, the team has collective respon-\nsibility for resolving these problems.\n2. \nIt acts as an informal review process because each line of code is looked at by at least \ntwo people. Code inspections and reviews (Chapter 24) are effective in discovering \na high percentage of software errors. However, they are time consuming to organize \nand, typically, introduce delays into the development process. Pair programming is a \nless formal process that probably doesn\u2019t find as many errors as code inspections. \nHowever, it is cheaper and easier to organize than formal program inspections.\n3. \nIt encourages refactoring to improve the software structure. The problem with ask-\ning programmers to refactor in a normal development environment is that effort \n\n\n84  Chapter 3 \u25a0 Agile software development\ninvolved is expended for long-term benefit. An developer who spends time refac-\ntoring may be judged to be less efficient than one who simply carries on developing \ncode. Where pair programming and collective ownership are used, others benefit \nimmediately from the refactoring so they are likely to support the process.\nYou might think that pair programming would be less efficient than individual \nprogramming. In a given time, a pair of developers would produce half as much code \nas two individuals working alone. Many companies that have adopted agile methods \nare suspicious of pair programming and do not use it. Other companies mix pair and \nindividual programming with an experienced programmer working with a less expe-\nrienced colleague when they have problems.\nFormal studies of the value of pair programming have had mixed results. Using \nstudent volunteers, Williams and her collaborators (Williams et al. 2000) found that \nproductivity with pair programming seems to be comparable to that of two people \nworking independently. The reasons suggested are that pairs discuss the software \nbefore development and so probably have fewer false starts and less rework. \nFurthermore, the number of errors avoided by the informal inspection is such that \nless time is spent repairing bugs discovered during the testing process.\nHowever, studies with more experienced programmers did not replicate these \nresults (Arisholm et al. 2007). They found that there was a significant loss of produc-\ntivity compared with two programmers working alone. There were some quality \nbenefits, but these did not fully compensate for the pair-programming overhead. \nNevertheless, the sharing of knowledge that happens during pair programming is \nvery important as it reduces the overall risks to a project when team members leave. \nIn itself, this may make pair programming worthwhile.\n \n3.3  Agile project management\nIn any software business, managers need to know what is going on and whether or not \na project is likely to meet its objectives and deliver the software on time with the pro-\nposed budget. Plan-driven approaches to software development evolved to meet this \nneed. As I discussed in Chapter 23, managers  draw up a plan for the project showing \nwhat should be delivered, when it should be delivered, and who will work on the devel-\nopment of the project deliverables. A plan-based approach requires a manager to have \na stable view of everything that has to be developed and the development processes.\nThe informal planning and project control that was proposed by the early adher-\nents of agile methods clashed with this business requirement for visibility. Teams \nwere self-organizing, did not produce documentation, and planned development in \nvery short cycles. While this can and does work for small companies developing \nsoftware products, it is inappropriate for larger companies who need to know what is \ngoing on in their organization.\nLike every other professional software development process, agile development \nhas to be managed so that the best use is made of the time and resources available to"}
{"query": "How does agile project management approach differ from plan-driven approaches?", "response": "Agile project management approaches differ from plan-driven approaches in several ways. In plan-driven approaches, managers create a detailed plan for the project, specifying what needs to be delivered, when it should be delivered, and who will work on it. This plan is based on a stable view of the project and its development processes. On the other hand, agile project management is more informal and flexible. Agile teams are self-organizing and work in short cycles, focusing on delivering working software incrementally. Agile project management emphasizes adaptability and responsiveness to change, rather than following a rigid plan. It allows for continuous feedback and collaboration between team members, enabling them to adjust their approach based on evolving requirements and feedback from stakeholders. Agile project management also promotes transparency and visibility, ensuring that managers have a clear understanding of the project's progress and can make informed decisions.", "context": "3.2  \u25a0 Agile development techniques  83\nAs testing is automated, there is always a set of tests that can be quickly and eas-\nily executed. Whenever any functionality is added to the system, the tests can be run \nand problems that the new code has introduced can be caught immediately.\nTest-first development and automated testing usually result in a large number of \ntests being written and executed. However, there are problems in ensuring that test \ncoverage is complete:\n1. Programmers prefer programming to testing, and sometimes they take shortcuts \nwhen writing tests. For example, they may write incomplete tests that do not \ncheck for all possible exceptions that may occur.\n2. Some tests can be very difficult to write incrementally. For example, in a com-\nplex user interface, it is often difficult to write unit tests for the code that imple-\nments the \u201cdisplay logic\u201d and workflow between screens.\nIt is difficult to judge the completeness of a set of tests. Although you may have a lot \nof system tests, your test set may not provide complete coverage. Crucial parts of \nthe\u00a0system may not be executed and so will remain untested. Therefore, although a \nlarge set of frequently executed tests may give the impression that the system is complete \nand correct, this may not be the case. If the tests are not reviewed and further tests are \nwritten after development, then undetected bugs may be delivered in the system release.\n \n3.2.4  Pair programming\nAnother innovative practice that was introduced in XP is that programmers work in \npairs to develop the software. The programming pair sits at the same computer to \ndevelop the software. However, the same pair do not always program together. \nRather, pairs are created dynamically so that all team members work with each other \nduring the development process.\nPair programming has a number of advantages.\n1. It supports the idea of collective ownership and responsibility for the system. \nThis reflects Weinberg\u2019s idea of egoless programming (Weinberg 1971) where \nthe software is owned by the team as a whole and individuals are not held \nresponsible for problems with the code. Instead, the team has collective respon-\nsibility for resolving these problems.\n2. \nIt acts as an informal review process because each line of code is looked at by at least \ntwo people. Code inspections and reviews (Chapter 24) are effective in discovering \na high percentage of software errors. However, they are time consuming to organize \nand, typically, introduce delays into the development process. Pair programming is a \nless formal process that probably doesn\u2019t find as many errors as code inspections. \nHowever, it is cheaper and easier to organize than formal program inspections.\n3. \nIt encourages refactoring to improve the software structure. The problem with ask-\ning programmers to refactor in a normal development environment is that effort \n\n\n84  Chapter 3 \u25a0 Agile software development\ninvolved is expended for long-term benefit. An developer who spends time refac-\ntoring may be judged to be less efficient than one who simply carries on developing \ncode. Where pair programming and collective ownership are used, others benefit \nimmediately from the refactoring so they are likely to support the process.\nYou might think that pair programming would be less efficient than individual \nprogramming. In a given time, a pair of developers would produce half as much code \nas two individuals working alone. Many companies that have adopted agile methods \nare suspicious of pair programming and do not use it. Other companies mix pair and \nindividual programming with an experienced programmer working with a less expe-\nrienced colleague when they have problems.\nFormal studies of the value of pair programming have had mixed results. Using \nstudent volunteers, Williams and her collaborators (Williams et al. 2000) found that \nproductivity with pair programming seems to be comparable to that of two people \nworking independently. The reasons suggested are that pairs discuss the software \nbefore development and so probably have fewer false starts and less rework. \nFurthermore, the number of errors avoided by the informal inspection is such that \nless time is spent repairing bugs discovered during the testing process.\nHowever, studies with more experienced programmers did not replicate these \nresults (Arisholm et al. 2007). They found that there was a significant loss of produc-\ntivity compared with two programmers working alone. There were some quality \nbenefits, but these did not fully compensate for the pair-programming overhead. \nNevertheless, the sharing of knowledge that happens during pair programming is \nvery important as it reduces the overall risks to a project when team members leave. \nIn itself, this may make pair programming worthwhile.\n \n3.3  Agile project management\nIn any software business, managers need to know what is going on and whether or not \na project is likely to meet its objectives and deliver the software on time with the pro-\nposed budget. Plan-driven approaches to software development evolved to meet this \nneed. As I discussed in Chapter 23, managers  draw up a plan for the project showing \nwhat should be delivered, when it should be delivered, and who will work on the devel-\nopment of the project deliverables. A plan-based approach requires a manager to have \na stable view of everything that has to be developed and the development processes.\nThe informal planning and project control that was proposed by the early adher-\nents of agile methods clashed with this business requirement for visibility. Teams \nwere self-organizing, did not produce documentation, and planned development in \nvery short cycles. While this can and does work for small companies developing \nsoftware products, it is inappropriate for larger companies who need to know what is \ngoing on in their organization.\nLike every other professional software development process, agile development \nhas to be managed so that the best use is made of the time and resources available to"}
{"query": "What are the challenges faced by larger companies in adopting agile methods?", "response": "Larger companies face challenges in adopting agile methods due to the clash between the informal planning and project control of agile methods and the need for visibility and documentation in larger organizations. Agile methods rely on self-organizing teams and short development cycles, which may not provide the level of visibility and control that larger companies require. Additionally, the preference for collective ownership and responsibility in agile methods may conflict with the individual accountability often found in larger organizations. These challenges make it difficult for larger companies to fully embrace and implement agile methods.", "context": "3.2  \u25a0 Agile development techniques  83\nAs testing is automated, there is always a set of tests that can be quickly and eas-\nily executed. Whenever any functionality is added to the system, the tests can be run \nand problems that the new code has introduced can be caught immediately.\nTest-first development and automated testing usually result in a large number of \ntests being written and executed. However, there are problems in ensuring that test \ncoverage is complete:\n1. Programmers prefer programming to testing, and sometimes they take shortcuts \nwhen writing tests. For example, they may write incomplete tests that do not \ncheck for all possible exceptions that may occur.\n2. Some tests can be very difficult to write incrementally. For example, in a com-\nplex user interface, it is often difficult to write unit tests for the code that imple-\nments the \u201cdisplay logic\u201d and workflow between screens.\nIt is difficult to judge the completeness of a set of tests. Although you may have a lot \nof system tests, your test set may not provide complete coverage. Crucial parts of \nthe\u00a0system may not be executed and so will remain untested. Therefore, although a \nlarge set of frequently executed tests may give the impression that the system is complete \nand correct, this may not be the case. If the tests are not reviewed and further tests are \nwritten after development, then undetected bugs may be delivered in the system release.\n \n3.2.4  Pair programming\nAnother innovative practice that was introduced in XP is that programmers work in \npairs to develop the software. The programming pair sits at the same computer to \ndevelop the software. However, the same pair do not always program together. \nRather, pairs are created dynamically so that all team members work with each other \nduring the development process.\nPair programming has a number of advantages.\n1. It supports the idea of collective ownership and responsibility for the system. \nThis reflects Weinberg\u2019s idea of egoless programming (Weinberg 1971) where \nthe software is owned by the team as a whole and individuals are not held \nresponsible for problems with the code. Instead, the team has collective respon-\nsibility for resolving these problems.\n2. \nIt acts as an informal review process because each line of code is looked at by at least \ntwo people. Code inspections and reviews (Chapter 24) are effective in discovering \na high percentage of software errors. However, they are time consuming to organize \nand, typically, introduce delays into the development process. Pair programming is a \nless formal process that probably doesn\u2019t find as many errors as code inspections. \nHowever, it is cheaper and easier to organize than formal program inspections.\n3. \nIt encourages refactoring to improve the software structure. The problem with ask-\ning programmers to refactor in a normal development environment is that effort \n\n\n84  Chapter 3 \u25a0 Agile software development\ninvolved is expended for long-term benefit. An developer who spends time refac-\ntoring may be judged to be less efficient than one who simply carries on developing \ncode. Where pair programming and collective ownership are used, others benefit \nimmediately from the refactoring so they are likely to support the process.\nYou might think that pair programming would be less efficient than individual \nprogramming. In a given time, a pair of developers would produce half as much code \nas two individuals working alone. Many companies that have adopted agile methods \nare suspicious of pair programming and do not use it. Other companies mix pair and \nindividual programming with an experienced programmer working with a less expe-\nrienced colleague when they have problems.\nFormal studies of the value of pair programming have had mixed results. Using \nstudent volunteers, Williams and her collaborators (Williams et al. 2000) found that \nproductivity with pair programming seems to be comparable to that of two people \nworking independently. The reasons suggested are that pairs discuss the software \nbefore development and so probably have fewer false starts and less rework. \nFurthermore, the number of errors avoided by the informal inspection is such that \nless time is spent repairing bugs discovered during the testing process.\nHowever, studies with more experienced programmers did not replicate these \nresults (Arisholm et al. 2007). They found that there was a significant loss of produc-\ntivity compared with two programmers working alone. There were some quality \nbenefits, but these did not fully compensate for the pair-programming overhead. \nNevertheless, the sharing of knowledge that happens during pair programming is \nvery important as it reduces the overall risks to a project when team members leave. \nIn itself, this may make pair programming worthwhile.\n \n3.3  Agile project management\nIn any software business, managers need to know what is going on and whether or not \na project is likely to meet its objectives and deliver the software on time with the pro-\nposed budget. Plan-driven approaches to software development evolved to meet this \nneed. As I discussed in Chapter 23, managers  draw up a plan for the project showing \nwhat should be delivered, when it should be delivered, and who will work on the devel-\nopment of the project deliverables. A plan-based approach requires a manager to have \na stable view of everything that has to be developed and the development processes.\nThe informal planning and project control that was proposed by the early adher-\nents of agile methods clashed with this business requirement for visibility. Teams \nwere self-organizing, did not produce documentation, and planned development in \nvery short cycles. While this can and does work for small companies developing \nsoftware products, it is inappropriate for larger companies who need to know what is \ngoing on in their organization.\nLike every other professional software development process, agile development \nhas to be managed so that the best use is made of the time and resources available to"}
{"query": "What is the Scrum agile method?", "response": "The Scrum agile method is a framework for organizing agile projects. It provides a structure for agile project organization and aims to provide external visibility of the project's progress. Scrum follows the principles of the agile manifesto and focuses on self-organizing development teams. It introduces new terminology, such as ScrumMaster, to replace traditional project management roles. The Scrum process involves iterations called sprints, which typically last between 2 and 4 weeks. The input to the process is the product backlog, which is a list of items that the Scrum team must tackle. The team selects and prioritizes items from the backlog for each sprint and aims to deliver a potentially shippable product increment at the end of each sprint. The ScrumMaster is responsible for ensuring that the Scrum process is followed and guides the team in the effective use of Scrum.", "context": "3.3  \u25a0 Agile project management  85\nthe team. To address this issue, the Scrum agile method was developed (Schwaber \nand Beedle 2001; Rubin 2013) to provide a framework for organizing agile projects \nand, to some extent at least, provide external visibility of what is going on. The devel-\nopers of Scrum wished to make clear that Scrum was not a method for project man-\nagement in the conventional sense, so they deliberately invented new terminology, \nsuch as ScrumMaster, which replaced names such as project manager. Figure 3.8 \nsummarizes Scrum terminology and what it means.\nScrum is an agile method insofar as it follows the principles from the agile mani-\nfesto, which I showed in Figure 3.2. However, it focuses on providing a framework \nfor agile project organization, and it does not mandate the use of specific development \nScrum term\nDefinition\nDevelopment team\nA self-organizing group of software developers, which should be no \nmore than seven people. They are responsible for developing the \nsoftware and other essential project documents.\nPotentially shippable product \nincrement\nThe software increment that is delivered from a sprint. The idea is that \nthis should be \u201cpotentially shippable,\u201d which means that it is in a \nfinished state and no further work, such as testing, is needed to \nincorporate it into the final product. In practice, this is not always \nachievable.\nProduct backlog\nThis is a list of \u201cto do\u201d items that the Scrum team must tackle. They \nmay be feature definitions for the software, software requirements, user \nstories, or descriptions of supplementary tasks that are needed, such as \narchitecture definition or user documentation.\nProduct owner\nAn individual (or possibly a small group) whose job is to identify \nproduct features or requirements, prioritize these for development, and \ncontinuously review the product backlog to ensure that the project \ncontinues to meet critical business needs. The Product Owner can be a \ncustomer but might also be a product manager in a software company \nor other stakeholder representative.\nScrum\nA daily meeting of the Scrum team that reviews progress and prioritizes \nwork to be done that day. Ideally, this should be a short face-to-face \nmeeting that includes the whole team.\nScrumMaster\nThe ScrumMaster is responsible for ensuring that the Scrum process is \nfollowed and guides the team in the effective use of Scrum. He or she \nis responsible for interfacing with the rest of the company and for \nensuring that the Scrum team is not diverted by outside interference. \nThe Scrum developers are adamant that the ScrumMaster should not \nbe thought of as a project manager. Others, however, may not always \nfind it easy to see the difference.\nSprint\nA development iteration. Sprints are usually 2 to 4 weeks long.\nVelocity\nAn estimate of how much product backlog effort a team can cover in a \nsingle sprint. Understanding a team\u2019s velocity helps them estimate what \ncan be covered in a sprint and provides a basis for measuring \nimproving performance.\nFigure 3.8 Scrum \nterminology\n\n\n86  Chapter 3 \u25a0 Agile software development\npractices such as pair programming and test-first development. This means that it \ncan be more easily integrated with existing practice in a company. Consequently, as \nagile methods have become a mainstream approach to software development, Scrum \nhas emerged as the most widely used method.\nThe Scrum process or sprint cycle is shown in Figure 3.9. The input to the process \nis the product backlog. Each process iteration produces a product increment that \ncould be delivered to customers.\nThe starting point for the Scrum sprint cycle is the product backlog\u2014the list of \nitems such as product features, requirements, and engineering improvement that \nhave to be worked on by the Scrum team. The initial version of the product backlog \nmay be derived from a requirements document, a list of user stories, or other descrip-\ntion of the software to be developed.\nWhile the majority of entries in the product backlog are concerned with the imple-\nmentation of system features, other activities may also be included. Sometimes, when \nplanning an iteration, questions that cannot be easily answered come to light and addi-\ntional work is required to explore possible solutions. The team may carry out some pro-\ntotyping or trial development to understand the problem and solution. There may also be \nbacklog items to design the system architecture or to develop system documentation.\nThe product backlog may be specified at varying levels of detail, and it is the \nresponsibility of the Product Owner to ensure that the level of detail in the specifica-\ntion is appropriate for the work to be done. For example, a backlog item could be a \ncomplete user story such as that shown in Figure 3.5, or it could simply be an instruc-\ntion such as \u201cRefactor user interface code\u201d that leaves it up to the team to decide on \nthe refactoring to be done.\nEach sprint cycle lasts a fixed length of time, which is usually between 2 and 4 weeks. \nAt the beginning of each cycle, the Product Owner prioritizes the items on the product \nbacklog to define which are the most important items to be developed in that cycle. \nSprints are never extended to take account of unfinished work. Items are returned to the \nproduct backlog if these cannot be completed within the allocated time for the sprint.\nThe whole team is then involved in selecting which of the highest priority items \nthey believe can be completed. They then estimate the time required to complete \nthese items. To make these estimates, they use the velocity attained in previous \nReview work \nto be done\nSelect \nitems\nPlan\nsprint\nReview\nsprint\nSprint\nScrum\nProduct\nbacklog\nSprint\nbacklog\nPotentially\nshippable\nsoftware\nFigure 3.9 The Scrum \nsprint cycle"}
{"query": "What is the purpose of the Scrum agile method?", "response": "The purpose of the Scrum agile method is to provide a framework for organizing agile projects and to provide external visibility of the project progress. It focuses on agile project organization and does not mandate the use of specific development practices, making it easily integrated with existing practices in a company.", "context": "3.3  \u25a0 Agile project management  85\nthe team. To address this issue, the Scrum agile method was developed (Schwaber \nand Beedle 2001; Rubin 2013) to provide a framework for organizing agile projects \nand, to some extent at least, provide external visibility of what is going on. The devel-\nopers of Scrum wished to make clear that Scrum was not a method for project man-\nagement in the conventional sense, so they deliberately invented new terminology, \nsuch as ScrumMaster, which replaced names such as project manager. Figure 3.8 \nsummarizes Scrum terminology and what it means.\nScrum is an agile method insofar as it follows the principles from the agile mani-\nfesto, which I showed in Figure 3.2. However, it focuses on providing a framework \nfor agile project organization, and it does not mandate the use of specific development \nScrum term\nDefinition\nDevelopment team\nA self-organizing group of software developers, which should be no \nmore than seven people. They are responsible for developing the \nsoftware and other essential project documents.\nPotentially shippable product \nincrement\nThe software increment that is delivered from a sprint. The idea is that \nthis should be \u201cpotentially shippable,\u201d which means that it is in a \nfinished state and no further work, such as testing, is needed to \nincorporate it into the final product. In practice, this is not always \nachievable.\nProduct backlog\nThis is a list of \u201cto do\u201d items that the Scrum team must tackle. They \nmay be feature definitions for the software, software requirements, user \nstories, or descriptions of supplementary tasks that are needed, such as \narchitecture definition or user documentation.\nProduct owner\nAn individual (or possibly a small group) whose job is to identify \nproduct features or requirements, prioritize these for development, and \ncontinuously review the product backlog to ensure that the project \ncontinues to meet critical business needs. The Product Owner can be a \ncustomer but might also be a product manager in a software company \nor other stakeholder representative.\nScrum\nA daily meeting of the Scrum team that reviews progress and prioritizes \nwork to be done that day. Ideally, this should be a short face-to-face \nmeeting that includes the whole team.\nScrumMaster\nThe ScrumMaster is responsible for ensuring that the Scrum process is \nfollowed and guides the team in the effective use of Scrum. He or she \nis responsible for interfacing with the rest of the company and for \nensuring that the Scrum team is not diverted by outside interference. \nThe Scrum developers are adamant that the ScrumMaster should not \nbe thought of as a project manager. Others, however, may not always \nfind it easy to see the difference.\nSprint\nA development iteration. Sprints are usually 2 to 4 weeks long.\nVelocity\nAn estimate of how much product backlog effort a team can cover in a \nsingle sprint. Understanding a team\u2019s velocity helps them estimate what \ncan be covered in a sprint and provides a basis for measuring \nimproving performance.\nFigure 3.8 Scrum \nterminology\n\n\n86  Chapter 3 \u25a0 Agile software development\npractices such as pair programming and test-first development. This means that it \ncan be more easily integrated with existing practice in a company. Consequently, as \nagile methods have become a mainstream approach to software development, Scrum \nhas emerged as the most widely used method.\nThe Scrum process or sprint cycle is shown in Figure 3.9. The input to the process \nis the product backlog. Each process iteration produces a product increment that \ncould be delivered to customers.\nThe starting point for the Scrum sprint cycle is the product backlog\u2014the list of \nitems such as product features, requirements, and engineering improvement that \nhave to be worked on by the Scrum team. The initial version of the product backlog \nmay be derived from a requirements document, a list of user stories, or other descrip-\ntion of the software to be developed.\nWhile the majority of entries in the product backlog are concerned with the imple-\nmentation of system features, other activities may also be included. Sometimes, when \nplanning an iteration, questions that cannot be easily answered come to light and addi-\ntional work is required to explore possible solutions. The team may carry out some pro-\ntotyping or trial development to understand the problem and solution. There may also be \nbacklog items to design the system architecture or to develop system documentation.\nThe product backlog may be specified at varying levels of detail, and it is the \nresponsibility of the Product Owner to ensure that the level of detail in the specifica-\ntion is appropriate for the work to be done. For example, a backlog item could be a \ncomplete user story such as that shown in Figure 3.5, or it could simply be an instruc-\ntion such as \u201cRefactor user interface code\u201d that leaves it up to the team to decide on \nthe refactoring to be done.\nEach sprint cycle lasts a fixed length of time, which is usually between 2 and 4 weeks. \nAt the beginning of each cycle, the Product Owner prioritizes the items on the product \nbacklog to define which are the most important items to be developed in that cycle. \nSprints are never extended to take account of unfinished work. Items are returned to the \nproduct backlog if these cannot be completed within the allocated time for the sprint.\nThe whole team is then involved in selecting which of the highest priority items \nthey believe can be completed. They then estimate the time required to complete \nthese items. To make these estimates, they use the velocity attained in previous \nReview work \nto be done\nSelect \nitems\nPlan\nsprint\nReview\nsprint\nSprint\nScrum\nProduct\nbacklog\nSprint\nbacklog\nPotentially\nshippable\nsoftware\nFigure 3.9 The Scrum \nsprint cycle"}
{"query": "What is the ScrumMaster's role in the Scrum agile method?", "response": "The ScrumMaster's role in the Scrum agile method is to ensure that the Scrum process is followed and to guide the team in the effective use of Scrum. They are responsible for interfacing with the rest of the company and for ensuring that the Scrum team is not diverted by outside interference. The ScrumMaster is not considered a project manager, but rather a facilitator of the Scrum process.", "context": "3.3  \u25a0 Agile project management  85\nthe team. To address this issue, the Scrum agile method was developed (Schwaber \nand Beedle 2001; Rubin 2013) to provide a framework for organizing agile projects \nand, to some extent at least, provide external visibility of what is going on. The devel-\nopers of Scrum wished to make clear that Scrum was not a method for project man-\nagement in the conventional sense, so they deliberately invented new terminology, \nsuch as ScrumMaster, which replaced names such as project manager. Figure 3.8 \nsummarizes Scrum terminology and what it means.\nScrum is an agile method insofar as it follows the principles from the agile mani-\nfesto, which I showed in Figure 3.2. However, it focuses on providing a framework \nfor agile project organization, and it does not mandate the use of specific development \nScrum term\nDefinition\nDevelopment team\nA self-organizing group of software developers, which should be no \nmore than seven people. They are responsible for developing the \nsoftware and other essential project documents.\nPotentially shippable product \nincrement\nThe software increment that is delivered from a sprint. The idea is that \nthis should be \u201cpotentially shippable,\u201d which means that it is in a \nfinished state and no further work, such as testing, is needed to \nincorporate it into the final product. In practice, this is not always \nachievable.\nProduct backlog\nThis is a list of \u201cto do\u201d items that the Scrum team must tackle. They \nmay be feature definitions for the software, software requirements, user \nstories, or descriptions of supplementary tasks that are needed, such as \narchitecture definition or user documentation.\nProduct owner\nAn individual (or possibly a small group) whose job is to identify \nproduct features or requirements, prioritize these for development, and \ncontinuously review the product backlog to ensure that the project \ncontinues to meet critical business needs. The Product Owner can be a \ncustomer but might also be a product manager in a software company \nor other stakeholder representative.\nScrum\nA daily meeting of the Scrum team that reviews progress and prioritizes \nwork to be done that day. Ideally, this should be a short face-to-face \nmeeting that includes the whole team.\nScrumMaster\nThe ScrumMaster is responsible for ensuring that the Scrum process is \nfollowed and guides the team in the effective use of Scrum. He or she \nis responsible for interfacing with the rest of the company and for \nensuring that the Scrum team is not diverted by outside interference. \nThe Scrum developers are adamant that the ScrumMaster should not \nbe thought of as a project manager. Others, however, may not always \nfind it easy to see the difference.\nSprint\nA development iteration. Sprints are usually 2 to 4 weeks long.\nVelocity\nAn estimate of how much product backlog effort a team can cover in a \nsingle sprint. Understanding a team\u2019s velocity helps them estimate what \ncan be covered in a sprint and provides a basis for measuring \nimproving performance.\nFigure 3.8 Scrum \nterminology\n\n\n86  Chapter 3 \u25a0 Agile software development\npractices such as pair programming and test-first development. This means that it \ncan be more easily integrated with existing practice in a company. Consequently, as \nagile methods have become a mainstream approach to software development, Scrum \nhas emerged as the most widely used method.\nThe Scrum process or sprint cycle is shown in Figure 3.9. The input to the process \nis the product backlog. Each process iteration produces a product increment that \ncould be delivered to customers.\nThe starting point for the Scrum sprint cycle is the product backlog\u2014the list of \nitems such as product features, requirements, and engineering improvement that \nhave to be worked on by the Scrum team. The initial version of the product backlog \nmay be derived from a requirements document, a list of user stories, or other descrip-\ntion of the software to be developed.\nWhile the majority of entries in the product backlog are concerned with the imple-\nmentation of system features, other activities may also be included. Sometimes, when \nplanning an iteration, questions that cannot be easily answered come to light and addi-\ntional work is required to explore possible solutions. The team may carry out some pro-\ntotyping or trial development to understand the problem and solution. There may also be \nbacklog items to design the system architecture or to develop system documentation.\nThe product backlog may be specified at varying levels of detail, and it is the \nresponsibility of the Product Owner to ensure that the level of detail in the specifica-\ntion is appropriate for the work to be done. For example, a backlog item could be a \ncomplete user story such as that shown in Figure 3.5, or it could simply be an instruc-\ntion such as \u201cRefactor user interface code\u201d that leaves it up to the team to decide on \nthe refactoring to be done.\nEach sprint cycle lasts a fixed length of time, which is usually between 2 and 4 weeks. \nAt the beginning of each cycle, the Product Owner prioritizes the items on the product \nbacklog to define which are the most important items to be developed in that cycle. \nSprints are never extended to take account of unfinished work. Items are returned to the \nproduct backlog if these cannot be completed within the allocated time for the sprint.\nThe whole team is then involved in selecting which of the highest priority items \nthey believe can be completed. They then estimate the time required to complete \nthese items. To make these estimates, they use the velocity attained in previous \nReview work \nto be done\nSelect \nitems\nPlan\nsprint\nReview\nsprint\nSprint\nScrum\nProduct\nbacklog\nSprint\nbacklog\nPotentially\nshippable\nsoftware\nFigure 3.9 The Scrum \nsprint cycle"}
{"query": "What is the difference between a ScrumMaster and a traditional project manager?", "response": "The ScrumMaster and a traditional project manager have different roles and responsibilities. While a traditional project manager is responsible for managing the overall project, the ScrumMaster's role is to ensure that the Scrum process is followed effectively. The ScrumMaster guides the team in the use of Scrum and ensures that the team is not distracted by external interference. Unlike a project manager, the ScrumMaster does not have authority over the team and does not make decisions on behalf of the team. Instead, the ScrumMaster facilitates the team's self-organization and helps remove any obstacles that may hinder the team's progress.", "context": "3.3  \u25a0 Agile project management  85\nthe team. To address this issue, the Scrum agile method was developed (Schwaber \nand Beedle 2001; Rubin 2013) to provide a framework for organizing agile projects \nand, to some extent at least, provide external visibility of what is going on. The devel-\nopers of Scrum wished to make clear that Scrum was not a method for project man-\nagement in the conventional sense, so they deliberately invented new terminology, \nsuch as ScrumMaster, which replaced names such as project manager. Figure 3.8 \nsummarizes Scrum terminology and what it means.\nScrum is an agile method insofar as it follows the principles from the agile mani-\nfesto, which I showed in Figure 3.2. However, it focuses on providing a framework \nfor agile project organization, and it does not mandate the use of specific development \nScrum term\nDefinition\nDevelopment team\nA self-organizing group of software developers, which should be no \nmore than seven people. They are responsible for developing the \nsoftware and other essential project documents.\nPotentially shippable product \nincrement\nThe software increment that is delivered from a sprint. The idea is that \nthis should be \u201cpotentially shippable,\u201d which means that it is in a \nfinished state and no further work, such as testing, is needed to \nincorporate it into the final product. In practice, this is not always \nachievable.\nProduct backlog\nThis is a list of \u201cto do\u201d items that the Scrum team must tackle. They \nmay be feature definitions for the software, software requirements, user \nstories, or descriptions of supplementary tasks that are needed, such as \narchitecture definition or user documentation.\nProduct owner\nAn individual (or possibly a small group) whose job is to identify \nproduct features or requirements, prioritize these for development, and \ncontinuously review the product backlog to ensure that the project \ncontinues to meet critical business needs. The Product Owner can be a \ncustomer but might also be a product manager in a software company \nor other stakeholder representative.\nScrum\nA daily meeting of the Scrum team that reviews progress and prioritizes \nwork to be done that day. Ideally, this should be a short face-to-face \nmeeting that includes the whole team.\nScrumMaster\nThe ScrumMaster is responsible for ensuring that the Scrum process is \nfollowed and guides the team in the effective use of Scrum. He or she \nis responsible for interfacing with the rest of the company and for \nensuring that the Scrum team is not diverted by outside interference. \nThe Scrum developers are adamant that the ScrumMaster should not \nbe thought of as a project manager. Others, however, may not always \nfind it easy to see the difference.\nSprint\nA development iteration. Sprints are usually 2 to 4 weeks long.\nVelocity\nAn estimate of how much product backlog effort a team can cover in a \nsingle sprint. Understanding a team\u2019s velocity helps them estimate what \ncan be covered in a sprint and provides a basis for measuring \nimproving performance.\nFigure 3.8 Scrum \nterminology\n\n\n86  Chapter 3 \u25a0 Agile software development\npractices such as pair programming and test-first development. This means that it \ncan be more easily integrated with existing practice in a company. Consequently, as \nagile methods have become a mainstream approach to software development, Scrum \nhas emerged as the most widely used method.\nThe Scrum process or sprint cycle is shown in Figure 3.9. The input to the process \nis the product backlog. Each process iteration produces a product increment that \ncould be delivered to customers.\nThe starting point for the Scrum sprint cycle is the product backlog\u2014the list of \nitems such as product features, requirements, and engineering improvement that \nhave to be worked on by the Scrum team. The initial version of the product backlog \nmay be derived from a requirements document, a list of user stories, or other descrip-\ntion of the software to be developed.\nWhile the majority of entries in the product backlog are concerned with the imple-\nmentation of system features, other activities may also be included. Sometimes, when \nplanning an iteration, questions that cannot be easily answered come to light and addi-\ntional work is required to explore possible solutions. The team may carry out some pro-\ntotyping or trial development to understand the problem and solution. There may also be \nbacklog items to design the system architecture or to develop system documentation.\nThe product backlog may be specified at varying levels of detail, and it is the \nresponsibility of the Product Owner to ensure that the level of detail in the specifica-\ntion is appropriate for the work to be done. For example, a backlog item could be a \ncomplete user story such as that shown in Figure 3.5, or it could simply be an instruc-\ntion such as \u201cRefactor user interface code\u201d that leaves it up to the team to decide on \nthe refactoring to be done.\nEach sprint cycle lasts a fixed length of time, which is usually between 2 and 4 weeks. \nAt the beginning of each cycle, the Product Owner prioritizes the items on the product \nbacklog to define which are the most important items to be developed in that cycle. \nSprints are never extended to take account of unfinished work. Items are returned to the \nproduct backlog if these cannot be completed within the allocated time for the sprint.\nThe whole team is then involved in selecting which of the highest priority items \nthey believe can be completed. They then estimate the time required to complete \nthese items. To make these estimates, they use the velocity attained in previous \nReview work \nto be done\nSelect \nitems\nPlan\nsprint\nReview\nsprint\nSprint\nScrum\nProduct\nbacklog\nSprint\nbacklog\nPotentially\nshippable\nsoftware\nFigure 3.9 The Scrum \nsprint cycle"}
{"query": "What is the purpose of the daily Scrum meeting?", "response": "The purpose of the daily Scrum meeting is to review progress and prioritize work to be done that day. It is a short face-to-face meeting that includes the whole team.", "context": "3.3  \u25a0 Agile project management  85\nthe team. To address this issue, the Scrum agile method was developed (Schwaber \nand Beedle 2001; Rubin 2013) to provide a framework for organizing agile projects \nand, to some extent at least, provide external visibility of what is going on. The devel-\nopers of Scrum wished to make clear that Scrum was not a method for project man-\nagement in the conventional sense, so they deliberately invented new terminology, \nsuch as ScrumMaster, which replaced names such as project manager. Figure 3.8 \nsummarizes Scrum terminology and what it means.\nScrum is an agile method insofar as it follows the principles from the agile mani-\nfesto, which I showed in Figure 3.2. However, it focuses on providing a framework \nfor agile project organization, and it does not mandate the use of specific development \nScrum term\nDefinition\nDevelopment team\nA self-organizing group of software developers, which should be no \nmore than seven people. They are responsible for developing the \nsoftware and other essential project documents.\nPotentially shippable product \nincrement\nThe software increment that is delivered from a sprint. The idea is that \nthis should be \u201cpotentially shippable,\u201d which means that it is in a \nfinished state and no further work, such as testing, is needed to \nincorporate it into the final product. In practice, this is not always \nachievable.\nProduct backlog\nThis is a list of \u201cto do\u201d items that the Scrum team must tackle. They \nmay be feature definitions for the software, software requirements, user \nstories, or descriptions of supplementary tasks that are needed, such as \narchitecture definition or user documentation.\nProduct owner\nAn individual (or possibly a small group) whose job is to identify \nproduct features or requirements, prioritize these for development, and \ncontinuously review the product backlog to ensure that the project \ncontinues to meet critical business needs. The Product Owner can be a \ncustomer but might also be a product manager in a software company \nor other stakeholder representative.\nScrum\nA daily meeting of the Scrum team that reviews progress and prioritizes \nwork to be done that day. Ideally, this should be a short face-to-face \nmeeting that includes the whole team.\nScrumMaster\nThe ScrumMaster is responsible for ensuring that the Scrum process is \nfollowed and guides the team in the effective use of Scrum. He or she \nis responsible for interfacing with the rest of the company and for \nensuring that the Scrum team is not diverted by outside interference. \nThe Scrum developers are adamant that the ScrumMaster should not \nbe thought of as a project manager. Others, however, may not always \nfind it easy to see the difference.\nSprint\nA development iteration. Sprints are usually 2 to 4 weeks long.\nVelocity\nAn estimate of how much product backlog effort a team can cover in a \nsingle sprint. Understanding a team\u2019s velocity helps them estimate what \ncan be covered in a sprint and provides a basis for measuring \nimproving performance.\nFigure 3.8 Scrum \nterminology\n\n\n86  Chapter 3 \u25a0 Agile software development\npractices such as pair programming and test-first development. This means that it \ncan be more easily integrated with existing practice in a company. Consequently, as \nagile methods have become a mainstream approach to software development, Scrum \nhas emerged as the most widely used method.\nThe Scrum process or sprint cycle is shown in Figure 3.9. The input to the process \nis the product backlog. Each process iteration produces a product increment that \ncould be delivered to customers.\nThe starting point for the Scrum sprint cycle is the product backlog\u2014the list of \nitems such as product features, requirements, and engineering improvement that \nhave to be worked on by the Scrum team. The initial version of the product backlog \nmay be derived from a requirements document, a list of user stories, or other descrip-\ntion of the software to be developed.\nWhile the majority of entries in the product backlog are concerned with the imple-\nmentation of system features, other activities may also be included. Sometimes, when \nplanning an iteration, questions that cannot be easily answered come to light and addi-\ntional work is required to explore possible solutions. The team may carry out some pro-\ntotyping or trial development to understand the problem and solution. There may also be \nbacklog items to design the system architecture or to develop system documentation.\nThe product backlog may be specified at varying levels of detail, and it is the \nresponsibility of the Product Owner to ensure that the level of detail in the specifica-\ntion is appropriate for the work to be done. For example, a backlog item could be a \ncomplete user story such as that shown in Figure 3.5, or it could simply be an instruc-\ntion such as \u201cRefactor user interface code\u201d that leaves it up to the team to decide on \nthe refactoring to be done.\nEach sprint cycle lasts a fixed length of time, which is usually between 2 and 4 weeks. \nAt the beginning of each cycle, the Product Owner prioritizes the items on the product \nbacklog to define which are the most important items to be developed in that cycle. \nSprints are never extended to take account of unfinished work. Items are returned to the \nproduct backlog if these cannot be completed within the allocated time for the sprint.\nThe whole team is then involved in selecting which of the highest priority items \nthey believe can be completed. They then estimate the time required to complete \nthese items. To make these estimates, they use the velocity attained in previous \nReview work \nto be done\nSelect \nitems\nPlan\nsprint\nReview\nsprint\nSprint\nScrum\nProduct\nbacklog\nSprint\nbacklog\nPotentially\nshippable\nsoftware\nFigure 3.9 The Scrum \nsprint cycle"}
{"query": "What is the definition of a 'sprint' in the Scrum agile method?", "response": "A 'sprint' in the Scrum agile method refers to a development iteration that typically lasts between 2 and 4 weeks. It is a time-boxed period during which the Scrum team works on a set of prioritized items from the product backlog. At the beginning of each sprint, the Product Owner determines the most important items to be developed, and the team estimates the time required to complete them. The goal of a sprint is to deliver a potentially shippable product increment at the end of the iteration.", "context": "3.3  \u25a0 Agile project management  85\nthe team. To address this issue, the Scrum agile method was developed (Schwaber \nand Beedle 2001; Rubin 2013) to provide a framework for organizing agile projects \nand, to some extent at least, provide external visibility of what is going on. The devel-\nopers of Scrum wished to make clear that Scrum was not a method for project man-\nagement in the conventional sense, so they deliberately invented new terminology, \nsuch as ScrumMaster, which replaced names such as project manager. Figure 3.8 \nsummarizes Scrum terminology and what it means.\nScrum is an agile method insofar as it follows the principles from the agile mani-\nfesto, which I showed in Figure 3.2. However, it focuses on providing a framework \nfor agile project organization, and it does not mandate the use of specific development \nScrum term\nDefinition\nDevelopment team\nA self-organizing group of software developers, which should be no \nmore than seven people. They are responsible for developing the \nsoftware and other essential project documents.\nPotentially shippable product \nincrement\nThe software increment that is delivered from a sprint. The idea is that \nthis should be \u201cpotentially shippable,\u201d which means that it is in a \nfinished state and no further work, such as testing, is needed to \nincorporate it into the final product. In practice, this is not always \nachievable.\nProduct backlog\nThis is a list of \u201cto do\u201d items that the Scrum team must tackle. They \nmay be feature definitions for the software, software requirements, user \nstories, or descriptions of supplementary tasks that are needed, such as \narchitecture definition or user documentation.\nProduct owner\nAn individual (or possibly a small group) whose job is to identify \nproduct features or requirements, prioritize these for development, and \ncontinuously review the product backlog to ensure that the project \ncontinues to meet critical business needs. The Product Owner can be a \ncustomer but might also be a product manager in a software company \nor other stakeholder representative.\nScrum\nA daily meeting of the Scrum team that reviews progress and prioritizes \nwork to be done that day. Ideally, this should be a short face-to-face \nmeeting that includes the whole team.\nScrumMaster\nThe ScrumMaster is responsible for ensuring that the Scrum process is \nfollowed and guides the team in the effective use of Scrum. He or she \nis responsible for interfacing with the rest of the company and for \nensuring that the Scrum team is not diverted by outside interference. \nThe Scrum developers are adamant that the ScrumMaster should not \nbe thought of as a project manager. Others, however, may not always \nfind it easy to see the difference.\nSprint\nA development iteration. Sprints are usually 2 to 4 weeks long.\nVelocity\nAn estimate of how much product backlog effort a team can cover in a \nsingle sprint. Understanding a team\u2019s velocity helps them estimate what \ncan be covered in a sprint and provides a basis for measuring \nimproving performance.\nFigure 3.8 Scrum \nterminology\n\n\n86  Chapter 3 \u25a0 Agile software development\npractices such as pair programming and test-first development. This means that it \ncan be more easily integrated with existing practice in a company. Consequently, as \nagile methods have become a mainstream approach to software development, Scrum \nhas emerged as the most widely used method.\nThe Scrum process or sprint cycle is shown in Figure 3.9. The input to the process \nis the product backlog. Each process iteration produces a product increment that \ncould be delivered to customers.\nThe starting point for the Scrum sprint cycle is the product backlog\u2014the list of \nitems such as product features, requirements, and engineering improvement that \nhave to be worked on by the Scrum team. The initial version of the product backlog \nmay be derived from a requirements document, a list of user stories, or other descrip-\ntion of the software to be developed.\nWhile the majority of entries in the product backlog are concerned with the imple-\nmentation of system features, other activities may also be included. Sometimes, when \nplanning an iteration, questions that cannot be easily answered come to light and addi-\ntional work is required to explore possible solutions. The team may carry out some pro-\ntotyping or trial development to understand the problem and solution. There may also be \nbacklog items to design the system architecture or to develop system documentation.\nThe product backlog may be specified at varying levels of detail, and it is the \nresponsibility of the Product Owner to ensure that the level of detail in the specifica-\ntion is appropriate for the work to be done. For example, a backlog item could be a \ncomplete user story such as that shown in Figure 3.5, or it could simply be an instruc-\ntion such as \u201cRefactor user interface code\u201d that leaves it up to the team to decide on \nthe refactoring to be done.\nEach sprint cycle lasts a fixed length of time, which is usually between 2 and 4 weeks. \nAt the beginning of each cycle, the Product Owner prioritizes the items on the product \nbacklog to define which are the most important items to be developed in that cycle. \nSprints are never extended to take account of unfinished work. Items are returned to the \nproduct backlog if these cannot be completed within the allocated time for the sprint.\nThe whole team is then involved in selecting which of the highest priority items \nthey believe can be completed. They then estimate the time required to complete \nthese items. To make these estimates, they use the velocity attained in previous \nReview work \nto be done\nSelect \nitems\nPlan\nsprint\nReview\nsprint\nSprint\nScrum\nProduct\nbacklog\nSprint\nbacklog\nPotentially\nshippable\nsoftware\nFigure 3.9 The Scrum \nsprint cycle"}
{"query": "What is the purpose of the product backlog in the Scrum agile method?", "response": "The purpose of the product backlog in the Scrum agile method is to provide a list of \"to do\" items that the Scrum team must tackle. These items can include feature definitions, software requirements, user stories, or descriptions of supplementary tasks. The product backlog is used by the Product Owner to prioritize the items and ensure that the project continues to meet critical business needs. It serves as a guide for the Scrum team to determine which items to work on in each sprint cycle.", "context": "3.3  \u25a0 Agile project management  85\nthe team. To address this issue, the Scrum agile method was developed (Schwaber \nand Beedle 2001; Rubin 2013) to provide a framework for organizing agile projects \nand, to some extent at least, provide external visibility of what is going on. The devel-\nopers of Scrum wished to make clear that Scrum was not a method for project man-\nagement in the conventional sense, so they deliberately invented new terminology, \nsuch as ScrumMaster, which replaced names such as project manager. Figure 3.8 \nsummarizes Scrum terminology and what it means.\nScrum is an agile method insofar as it follows the principles from the agile mani-\nfesto, which I showed in Figure 3.2. However, it focuses on providing a framework \nfor agile project organization, and it does not mandate the use of specific development \nScrum term\nDefinition\nDevelopment team\nA self-organizing group of software developers, which should be no \nmore than seven people. They are responsible for developing the \nsoftware and other essential project documents.\nPotentially shippable product \nincrement\nThe software increment that is delivered from a sprint. The idea is that \nthis should be \u201cpotentially shippable,\u201d which means that it is in a \nfinished state and no further work, such as testing, is needed to \nincorporate it into the final product. In practice, this is not always \nachievable.\nProduct backlog\nThis is a list of \u201cto do\u201d items that the Scrum team must tackle. They \nmay be feature definitions for the software, software requirements, user \nstories, or descriptions of supplementary tasks that are needed, such as \narchitecture definition or user documentation.\nProduct owner\nAn individual (or possibly a small group) whose job is to identify \nproduct features or requirements, prioritize these for development, and \ncontinuously review the product backlog to ensure that the project \ncontinues to meet critical business needs. The Product Owner can be a \ncustomer but might also be a product manager in a software company \nor other stakeholder representative.\nScrum\nA daily meeting of the Scrum team that reviews progress and prioritizes \nwork to be done that day. Ideally, this should be a short face-to-face \nmeeting that includes the whole team.\nScrumMaster\nThe ScrumMaster is responsible for ensuring that the Scrum process is \nfollowed and guides the team in the effective use of Scrum. He or she \nis responsible for interfacing with the rest of the company and for \nensuring that the Scrum team is not diverted by outside interference. \nThe Scrum developers are adamant that the ScrumMaster should not \nbe thought of as a project manager. Others, however, may not always \nfind it easy to see the difference.\nSprint\nA development iteration. Sprints are usually 2 to 4 weeks long.\nVelocity\nAn estimate of how much product backlog effort a team can cover in a \nsingle sprint. Understanding a team\u2019s velocity helps them estimate what \ncan be covered in a sprint and provides a basis for measuring \nimproving performance.\nFigure 3.8 Scrum \nterminology\n\n\n86  Chapter 3 \u25a0 Agile software development\npractices such as pair programming and test-first development. This means that it \ncan be more easily integrated with existing practice in a company. Consequently, as \nagile methods have become a mainstream approach to software development, Scrum \nhas emerged as the most widely used method.\nThe Scrum process or sprint cycle is shown in Figure 3.9. The input to the process \nis the product backlog. Each process iteration produces a product increment that \ncould be delivered to customers.\nThe starting point for the Scrum sprint cycle is the product backlog\u2014the list of \nitems such as product features, requirements, and engineering improvement that \nhave to be worked on by the Scrum team. The initial version of the product backlog \nmay be derived from a requirements document, a list of user stories, or other descrip-\ntion of the software to be developed.\nWhile the majority of entries in the product backlog are concerned with the imple-\nmentation of system features, other activities may also be included. Sometimes, when \nplanning an iteration, questions that cannot be easily answered come to light and addi-\ntional work is required to explore possible solutions. The team may carry out some pro-\ntotyping or trial development to understand the problem and solution. There may also be \nbacklog items to design the system architecture or to develop system documentation.\nThe product backlog may be specified at varying levels of detail, and it is the \nresponsibility of the Product Owner to ensure that the level of detail in the specifica-\ntion is appropriate for the work to be done. For example, a backlog item could be a \ncomplete user story such as that shown in Figure 3.5, or it could simply be an instruc-\ntion such as \u201cRefactor user interface code\u201d that leaves it up to the team to decide on \nthe refactoring to be done.\nEach sprint cycle lasts a fixed length of time, which is usually between 2 and 4 weeks. \nAt the beginning of each cycle, the Product Owner prioritizes the items on the product \nbacklog to define which are the most important items to be developed in that cycle. \nSprints are never extended to take account of unfinished work. Items are returned to the \nproduct backlog if these cannot be completed within the allocated time for the sprint.\nThe whole team is then involved in selecting which of the highest priority items \nthey believe can be completed. They then estimate the time required to complete \nthese items. To make these estimates, they use the velocity attained in previous \nReview work \nto be done\nSelect \nitems\nPlan\nsprint\nReview\nsprint\nSprint\nScrum\nProduct\nbacklog\nSprint\nbacklog\nPotentially\nshippable\nsoftware\nFigure 3.9 The Scrum \nsprint cycle"}
{"query": "Who is responsible for identifying product features or requirements in the Scrum agile method?", "response": "The Product Owner is responsible for identifying product features or requirements in the Scrum agile method.", "context": "3.3  \u25a0 Agile project management  85\nthe team. To address this issue, the Scrum agile method was developed (Schwaber \nand Beedle 2001; Rubin 2013) to provide a framework for organizing agile projects \nand, to some extent at least, provide external visibility of what is going on. The devel-\nopers of Scrum wished to make clear that Scrum was not a method for project man-\nagement in the conventional sense, so they deliberately invented new terminology, \nsuch as ScrumMaster, which replaced names such as project manager. Figure 3.8 \nsummarizes Scrum terminology and what it means.\nScrum is an agile method insofar as it follows the principles from the agile mani-\nfesto, which I showed in Figure 3.2. However, it focuses on providing a framework \nfor agile project organization, and it does not mandate the use of specific development \nScrum term\nDefinition\nDevelopment team\nA self-organizing group of software developers, which should be no \nmore than seven people. They are responsible for developing the \nsoftware and other essential project documents.\nPotentially shippable product \nincrement\nThe software increment that is delivered from a sprint. The idea is that \nthis should be \u201cpotentially shippable,\u201d which means that it is in a \nfinished state and no further work, such as testing, is needed to \nincorporate it into the final product. In practice, this is not always \nachievable.\nProduct backlog\nThis is a list of \u201cto do\u201d items that the Scrum team must tackle. They \nmay be feature definitions for the software, software requirements, user \nstories, or descriptions of supplementary tasks that are needed, such as \narchitecture definition or user documentation.\nProduct owner\nAn individual (or possibly a small group) whose job is to identify \nproduct features or requirements, prioritize these for development, and \ncontinuously review the product backlog to ensure that the project \ncontinues to meet critical business needs. The Product Owner can be a \ncustomer but might also be a product manager in a software company \nor other stakeholder representative.\nScrum\nA daily meeting of the Scrum team that reviews progress and prioritizes \nwork to be done that day. Ideally, this should be a short face-to-face \nmeeting that includes the whole team.\nScrumMaster\nThe ScrumMaster is responsible for ensuring that the Scrum process is \nfollowed and guides the team in the effective use of Scrum. He or she \nis responsible for interfacing with the rest of the company and for \nensuring that the Scrum team is not diverted by outside interference. \nThe Scrum developers are adamant that the ScrumMaster should not \nbe thought of as a project manager. Others, however, may not always \nfind it easy to see the difference.\nSprint\nA development iteration. Sprints are usually 2 to 4 weeks long.\nVelocity\nAn estimate of how much product backlog effort a team can cover in a \nsingle sprint. Understanding a team\u2019s velocity helps them estimate what \ncan be covered in a sprint and provides a basis for measuring \nimproving performance.\nFigure 3.8 Scrum \nterminology\n\n\n86  Chapter 3 \u25a0 Agile software development\npractices such as pair programming and test-first development. This means that it \ncan be more easily integrated with existing practice in a company. Consequently, as \nagile methods have become a mainstream approach to software development, Scrum \nhas emerged as the most widely used method.\nThe Scrum process or sprint cycle is shown in Figure 3.9. The input to the process \nis the product backlog. Each process iteration produces a product increment that \ncould be delivered to customers.\nThe starting point for the Scrum sprint cycle is the product backlog\u2014the list of \nitems such as product features, requirements, and engineering improvement that \nhave to be worked on by the Scrum team. The initial version of the product backlog \nmay be derived from a requirements document, a list of user stories, or other descrip-\ntion of the software to be developed.\nWhile the majority of entries in the product backlog are concerned with the imple-\nmentation of system features, other activities may also be included. Sometimes, when \nplanning an iteration, questions that cannot be easily answered come to light and addi-\ntional work is required to explore possible solutions. The team may carry out some pro-\ntotyping or trial development to understand the problem and solution. There may also be \nbacklog items to design the system architecture or to develop system documentation.\nThe product backlog may be specified at varying levels of detail, and it is the \nresponsibility of the Product Owner to ensure that the level of detail in the specifica-\ntion is appropriate for the work to be done. For example, a backlog item could be a \ncomplete user story such as that shown in Figure 3.5, or it could simply be an instruc-\ntion such as \u201cRefactor user interface code\u201d that leaves it up to the team to decide on \nthe refactoring to be done.\nEach sprint cycle lasts a fixed length of time, which is usually between 2 and 4 weeks. \nAt the beginning of each cycle, the Product Owner prioritizes the items on the product \nbacklog to define which are the most important items to be developed in that cycle. \nSprints are never extended to take account of unfinished work. Items are returned to the \nproduct backlog if these cannot be completed within the allocated time for the sprint.\nThe whole team is then involved in selecting which of the highest priority items \nthey believe can be completed. They then estimate the time required to complete \nthese items. To make these estimates, they use the velocity attained in previous \nReview work \nto be done\nSelect \nitems\nPlan\nsprint\nReview\nsprint\nSprint\nScrum\nProduct\nbacklog\nSprint\nbacklog\nPotentially\nshippable\nsoftware\nFigure 3.9 The Scrum \nsprint cycle"}
{"query": "What does the term 'velocity' refer to in the context of the Scrum agile method?", "response": "The term 'velocity' in the context of the Scrum agile method refers to an estimate of how much effort a team can cover from the product backlog in a single sprint. It helps the team to estimate what can be accomplished in a sprint and provides a basis for measuring and improving performance.", "context": "3.3  \u25a0 Agile project management  85\nthe team. To address this issue, the Scrum agile method was developed (Schwaber \nand Beedle 2001; Rubin 2013) to provide a framework for organizing agile projects \nand, to some extent at least, provide external visibility of what is going on. The devel-\nopers of Scrum wished to make clear that Scrum was not a method for project man-\nagement in the conventional sense, so they deliberately invented new terminology, \nsuch as ScrumMaster, which replaced names such as project manager. Figure 3.8 \nsummarizes Scrum terminology and what it means.\nScrum is an agile method insofar as it follows the principles from the agile mani-\nfesto, which I showed in Figure 3.2. However, it focuses on providing a framework \nfor agile project organization, and it does not mandate the use of specific development \nScrum term\nDefinition\nDevelopment team\nA self-organizing group of software developers, which should be no \nmore than seven people. They are responsible for developing the \nsoftware and other essential project documents.\nPotentially shippable product \nincrement\nThe software increment that is delivered from a sprint. The idea is that \nthis should be \u201cpotentially shippable,\u201d which means that it is in a \nfinished state and no further work, such as testing, is needed to \nincorporate it into the final product. In practice, this is not always \nachievable.\nProduct backlog\nThis is a list of \u201cto do\u201d items that the Scrum team must tackle. They \nmay be feature definitions for the software, software requirements, user \nstories, or descriptions of supplementary tasks that are needed, such as \narchitecture definition or user documentation.\nProduct owner\nAn individual (or possibly a small group) whose job is to identify \nproduct features or requirements, prioritize these for development, and \ncontinuously review the product backlog to ensure that the project \ncontinues to meet critical business needs. The Product Owner can be a \ncustomer but might also be a product manager in a software company \nor other stakeholder representative.\nScrum\nA daily meeting of the Scrum team that reviews progress and prioritizes \nwork to be done that day. Ideally, this should be a short face-to-face \nmeeting that includes the whole team.\nScrumMaster\nThe ScrumMaster is responsible for ensuring that the Scrum process is \nfollowed and guides the team in the effective use of Scrum. He or she \nis responsible for interfacing with the rest of the company and for \nensuring that the Scrum team is not diverted by outside interference. \nThe Scrum developers are adamant that the ScrumMaster should not \nbe thought of as a project manager. Others, however, may not always \nfind it easy to see the difference.\nSprint\nA development iteration. Sprints are usually 2 to 4 weeks long.\nVelocity\nAn estimate of how much product backlog effort a team can cover in a \nsingle sprint. Understanding a team\u2019s velocity helps them estimate what \ncan be covered in a sprint and provides a basis for measuring \nimproving performance.\nFigure 3.8 Scrum \nterminology\n\n\n86  Chapter 3 \u25a0 Agile software development\npractices such as pair programming and test-first development. This means that it \ncan be more easily integrated with existing practice in a company. Consequently, as \nagile methods have become a mainstream approach to software development, Scrum \nhas emerged as the most widely used method.\nThe Scrum process or sprint cycle is shown in Figure 3.9. The input to the process \nis the product backlog. Each process iteration produces a product increment that \ncould be delivered to customers.\nThe starting point for the Scrum sprint cycle is the product backlog\u2014the list of \nitems such as product features, requirements, and engineering improvement that \nhave to be worked on by the Scrum team. The initial version of the product backlog \nmay be derived from a requirements document, a list of user stories, or other descrip-\ntion of the software to be developed.\nWhile the majority of entries in the product backlog are concerned with the imple-\nmentation of system features, other activities may also be included. Sometimes, when \nplanning an iteration, questions that cannot be easily answered come to light and addi-\ntional work is required to explore possible solutions. The team may carry out some pro-\ntotyping or trial development to understand the problem and solution. There may also be \nbacklog items to design the system architecture or to develop system documentation.\nThe product backlog may be specified at varying levels of detail, and it is the \nresponsibility of the Product Owner to ensure that the level of detail in the specifica-\ntion is appropriate for the work to be done. For example, a backlog item could be a \ncomplete user story such as that shown in Figure 3.5, or it could simply be an instruc-\ntion such as \u201cRefactor user interface code\u201d that leaves it up to the team to decide on \nthe refactoring to be done.\nEach sprint cycle lasts a fixed length of time, which is usually between 2 and 4 weeks. \nAt the beginning of each cycle, the Product Owner prioritizes the items on the product \nbacklog to define which are the most important items to be developed in that cycle. \nSprints are never extended to take account of unfinished work. Items are returned to the \nproduct backlog if these cannot be completed within the allocated time for the sprint.\nThe whole team is then involved in selecting which of the highest priority items \nthey believe can be completed. They then estimate the time required to complete \nthese items. To make these estimates, they use the velocity attained in previous \nReview work \nto be done\nSelect \nitems\nPlan\nsprint\nReview\nsprint\nSprint\nScrum\nProduct\nbacklog\nSprint\nbacklog\nPotentially\nshippable\nsoftware\nFigure 3.9 The Scrum \nsprint cycle"}
{"query": "How does the Scrum agile method align with the principles of the agile manifesto?", "response": "The Scrum agile method aligns with the principles of the agile manifesto by providing a framework for agile project organization. It follows the principles of the agile manifesto, which emphasize individuals and interactions, working software, customer collaboration, and responding to change. Scrum focuses on self-organizing teams, delivering potentially shippable product increments, and continuous review of the product backlog to ensure that the project meets critical business needs. It also emphasizes regular communication and collaboration through daily Scrum meetings.", "context": "3.3  \u25a0 Agile project management  85\nthe team. To address this issue, the Scrum agile method was developed (Schwaber \nand Beedle 2001; Rubin 2013) to provide a framework for organizing agile projects \nand, to some extent at least, provide external visibility of what is going on. The devel-\nopers of Scrum wished to make clear that Scrum was not a method for project man-\nagement in the conventional sense, so they deliberately invented new terminology, \nsuch as ScrumMaster, which replaced names such as project manager. Figure 3.8 \nsummarizes Scrum terminology and what it means.\nScrum is an agile method insofar as it follows the principles from the agile mani-\nfesto, which I showed in Figure 3.2. However, it focuses on providing a framework \nfor agile project organization, and it does not mandate the use of specific development \nScrum term\nDefinition\nDevelopment team\nA self-organizing group of software developers, which should be no \nmore than seven people. They are responsible for developing the \nsoftware and other essential project documents.\nPotentially shippable product \nincrement\nThe software increment that is delivered from a sprint. The idea is that \nthis should be \u201cpotentially shippable,\u201d which means that it is in a \nfinished state and no further work, such as testing, is needed to \nincorporate it into the final product. In practice, this is not always \nachievable.\nProduct backlog\nThis is a list of \u201cto do\u201d items that the Scrum team must tackle. They \nmay be feature definitions for the software, software requirements, user \nstories, or descriptions of supplementary tasks that are needed, such as \narchitecture definition or user documentation.\nProduct owner\nAn individual (or possibly a small group) whose job is to identify \nproduct features or requirements, prioritize these for development, and \ncontinuously review the product backlog to ensure that the project \ncontinues to meet critical business needs. The Product Owner can be a \ncustomer but might also be a product manager in a software company \nor other stakeholder representative.\nScrum\nA daily meeting of the Scrum team that reviews progress and prioritizes \nwork to be done that day. Ideally, this should be a short face-to-face \nmeeting that includes the whole team.\nScrumMaster\nThe ScrumMaster is responsible for ensuring that the Scrum process is \nfollowed and guides the team in the effective use of Scrum. He or she \nis responsible for interfacing with the rest of the company and for \nensuring that the Scrum team is not diverted by outside interference. \nThe Scrum developers are adamant that the ScrumMaster should not \nbe thought of as a project manager. Others, however, may not always \nfind it easy to see the difference.\nSprint\nA development iteration. Sprints are usually 2 to 4 weeks long.\nVelocity\nAn estimate of how much product backlog effort a team can cover in a \nsingle sprint. Understanding a team\u2019s velocity helps them estimate what \ncan be covered in a sprint and provides a basis for measuring \nimproving performance.\nFigure 3.8 Scrum \nterminology\n\n\n86  Chapter 3 \u25a0 Agile software development\npractices such as pair programming and test-first development. This means that it \ncan be more easily integrated with existing practice in a company. Consequently, as \nagile methods have become a mainstream approach to software development, Scrum \nhas emerged as the most widely used method.\nThe Scrum process or sprint cycle is shown in Figure 3.9. The input to the process \nis the product backlog. Each process iteration produces a product increment that \ncould be delivered to customers.\nThe starting point for the Scrum sprint cycle is the product backlog\u2014the list of \nitems such as product features, requirements, and engineering improvement that \nhave to be worked on by the Scrum team. The initial version of the product backlog \nmay be derived from a requirements document, a list of user stories, or other descrip-\ntion of the software to be developed.\nWhile the majority of entries in the product backlog are concerned with the imple-\nmentation of system features, other activities may also be included. Sometimes, when \nplanning an iteration, questions that cannot be easily answered come to light and addi-\ntional work is required to explore possible solutions. The team may carry out some pro-\ntotyping or trial development to understand the problem and solution. There may also be \nbacklog items to design the system architecture or to develop system documentation.\nThe product backlog may be specified at varying levels of detail, and it is the \nresponsibility of the Product Owner to ensure that the level of detail in the specifica-\ntion is appropriate for the work to be done. For example, a backlog item could be a \ncomplete user story such as that shown in Figure 3.5, or it could simply be an instruc-\ntion such as \u201cRefactor user interface code\u201d that leaves it up to the team to decide on \nthe refactoring to be done.\nEach sprint cycle lasts a fixed length of time, which is usually between 2 and 4 weeks. \nAt the beginning of each cycle, the Product Owner prioritizes the items on the product \nbacklog to define which are the most important items to be developed in that cycle. \nSprints are never extended to take account of unfinished work. Items are returned to the \nproduct backlog if these cannot be completed within the allocated time for the sprint.\nThe whole team is then involved in selecting which of the highest priority items \nthey believe can be completed. They then estimate the time required to complete \nthese items. To make these estimates, they use the velocity attained in previous \nReview work \nto be done\nSelect \nitems\nPlan\nsprint\nReview\nsprint\nSprint\nScrum\nProduct\nbacklog\nSprint\nbacklog\nPotentially\nshippable\nsoftware\nFigure 3.9 The Scrum \nsprint cycle"}
{"query": "What is the role of the development team in the Scrum agile method?", "response": "The development team in the Scrum agile method is responsible for developing the software and other essential project documents. They are a self-organizing group of software developers and should ideally consist of no more than seven people.", "context": "3.3  \u25a0 Agile project management  85\nthe team. To address this issue, the Scrum agile method was developed (Schwaber \nand Beedle 2001; Rubin 2013) to provide a framework for organizing agile projects \nand, to some extent at least, provide external visibility of what is going on. The devel-\nopers of Scrum wished to make clear that Scrum was not a method for project man-\nagement in the conventional sense, so they deliberately invented new terminology, \nsuch as ScrumMaster, which replaced names such as project manager. Figure 3.8 \nsummarizes Scrum terminology and what it means.\nScrum is an agile method insofar as it follows the principles from the agile mani-\nfesto, which I showed in Figure 3.2. However, it focuses on providing a framework \nfor agile project organization, and it does not mandate the use of specific development \nScrum term\nDefinition\nDevelopment team\nA self-organizing group of software developers, which should be no \nmore than seven people. They are responsible for developing the \nsoftware and other essential project documents.\nPotentially shippable product \nincrement\nThe software increment that is delivered from a sprint. The idea is that \nthis should be \u201cpotentially shippable,\u201d which means that it is in a \nfinished state and no further work, such as testing, is needed to \nincorporate it into the final product. In practice, this is not always \nachievable.\nProduct backlog\nThis is a list of \u201cto do\u201d items that the Scrum team must tackle. They \nmay be feature definitions for the software, software requirements, user \nstories, or descriptions of supplementary tasks that are needed, such as \narchitecture definition or user documentation.\nProduct owner\nAn individual (or possibly a small group) whose job is to identify \nproduct features or requirements, prioritize these for development, and \ncontinuously review the product backlog to ensure that the project \ncontinues to meet critical business needs. The Product Owner can be a \ncustomer but might also be a product manager in a software company \nor other stakeholder representative.\nScrum\nA daily meeting of the Scrum team that reviews progress and prioritizes \nwork to be done that day. Ideally, this should be a short face-to-face \nmeeting that includes the whole team.\nScrumMaster\nThe ScrumMaster is responsible for ensuring that the Scrum process is \nfollowed and guides the team in the effective use of Scrum. He or she \nis responsible for interfacing with the rest of the company and for \nensuring that the Scrum team is not diverted by outside interference. \nThe Scrum developers are adamant that the ScrumMaster should not \nbe thought of as a project manager. Others, however, may not always \nfind it easy to see the difference.\nSprint\nA development iteration. Sprints are usually 2 to 4 weeks long.\nVelocity\nAn estimate of how much product backlog effort a team can cover in a \nsingle sprint. Understanding a team\u2019s velocity helps them estimate what \ncan be covered in a sprint and provides a basis for measuring \nimproving performance.\nFigure 3.8 Scrum \nterminology\n\n\n86  Chapter 3 \u25a0 Agile software development\npractices such as pair programming and test-first development. This means that it \ncan be more easily integrated with existing practice in a company. Consequently, as \nagile methods have become a mainstream approach to software development, Scrum \nhas emerged as the most widely used method.\nThe Scrum process or sprint cycle is shown in Figure 3.9. The input to the process \nis the product backlog. Each process iteration produces a product increment that \ncould be delivered to customers.\nThe starting point for the Scrum sprint cycle is the product backlog\u2014the list of \nitems such as product features, requirements, and engineering improvement that \nhave to be worked on by the Scrum team. The initial version of the product backlog \nmay be derived from a requirements document, a list of user stories, or other descrip-\ntion of the software to be developed.\nWhile the majority of entries in the product backlog are concerned with the imple-\nmentation of system features, other activities may also be included. Sometimes, when \nplanning an iteration, questions that cannot be easily answered come to light and addi-\ntional work is required to explore possible solutions. The team may carry out some pro-\ntotyping or trial development to understand the problem and solution. There may also be \nbacklog items to design the system architecture or to develop system documentation.\nThe product backlog may be specified at varying levels of detail, and it is the \nresponsibility of the Product Owner to ensure that the level of detail in the specifica-\ntion is appropriate for the work to be done. For example, a backlog item could be a \ncomplete user story such as that shown in Figure 3.5, or it could simply be an instruc-\ntion such as \u201cRefactor user interface code\u201d that leaves it up to the team to decide on \nthe refactoring to be done.\nEach sprint cycle lasts a fixed length of time, which is usually between 2 and 4 weeks. \nAt the beginning of each cycle, the Product Owner prioritizes the items on the product \nbacklog to define which are the most important items to be developed in that cycle. \nSprints are never extended to take account of unfinished work. Items are returned to the \nproduct backlog if these cannot be completed within the allocated time for the sprint.\nThe whole team is then involved in selecting which of the highest priority items \nthey believe can be completed. They then estimate the time required to complete \nthese items. To make these estimates, they use the velocity attained in previous \nReview work \nto be done\nSelect \nitems\nPlan\nsprint\nReview\nsprint\nSprint\nScrum\nProduct\nbacklog\nSprint\nbacklog\nPotentially\nshippable\nsoftware\nFigure 3.9 The Scrum \nsprint cycle"}
{"query": "What is meant by a 'potentially shippable product increment' in the Scrum agile method?", "response": "A 'potentially shippable product increment' in the Scrum agile method refers to the software increment that is delivered from a sprint. It is expected to be in a finished state and should not require any further work, such as testing, to be incorporated into the final product. However, it is acknowledged that achieving a truly 'potentially shippable' state may not always be possible in practice.", "context": "3.3  \u25a0 Agile project management  85\nthe team. To address this issue, the Scrum agile method was developed (Schwaber \nand Beedle 2001; Rubin 2013) to provide a framework for organizing agile projects \nand, to some extent at least, provide external visibility of what is going on. The devel-\nopers of Scrum wished to make clear that Scrum was not a method for project man-\nagement in the conventional sense, so they deliberately invented new terminology, \nsuch as ScrumMaster, which replaced names such as project manager. Figure 3.8 \nsummarizes Scrum terminology and what it means.\nScrum is an agile method insofar as it follows the principles from the agile mani-\nfesto, which I showed in Figure 3.2. However, it focuses on providing a framework \nfor agile project organization, and it does not mandate the use of specific development \nScrum term\nDefinition\nDevelopment team\nA self-organizing group of software developers, which should be no \nmore than seven people. They are responsible for developing the \nsoftware and other essential project documents.\nPotentially shippable product \nincrement\nThe software increment that is delivered from a sprint. The idea is that \nthis should be \u201cpotentially shippable,\u201d which means that it is in a \nfinished state and no further work, such as testing, is needed to \nincorporate it into the final product. In practice, this is not always \nachievable.\nProduct backlog\nThis is a list of \u201cto do\u201d items that the Scrum team must tackle. They \nmay be feature definitions for the software, software requirements, user \nstories, or descriptions of supplementary tasks that are needed, such as \narchitecture definition or user documentation.\nProduct owner\nAn individual (or possibly a small group) whose job is to identify \nproduct features or requirements, prioritize these for development, and \ncontinuously review the product backlog to ensure that the project \ncontinues to meet critical business needs. The Product Owner can be a \ncustomer but might also be a product manager in a software company \nor other stakeholder representative.\nScrum\nA daily meeting of the Scrum team that reviews progress and prioritizes \nwork to be done that day. Ideally, this should be a short face-to-face \nmeeting that includes the whole team.\nScrumMaster\nThe ScrumMaster is responsible for ensuring that the Scrum process is \nfollowed and guides the team in the effective use of Scrum. He or she \nis responsible for interfacing with the rest of the company and for \nensuring that the Scrum team is not diverted by outside interference. \nThe Scrum developers are adamant that the ScrumMaster should not \nbe thought of as a project manager. Others, however, may not always \nfind it easy to see the difference.\nSprint\nA development iteration. Sprints are usually 2 to 4 weeks long.\nVelocity\nAn estimate of how much product backlog effort a team can cover in a \nsingle sprint. Understanding a team\u2019s velocity helps them estimate what \ncan be covered in a sprint and provides a basis for measuring \nimproving performance.\nFigure 3.8 Scrum \nterminology\n\n\n86  Chapter 3 \u25a0 Agile software development\npractices such as pair programming and test-first development. This means that it \ncan be more easily integrated with existing practice in a company. Consequently, as \nagile methods have become a mainstream approach to software development, Scrum \nhas emerged as the most widely used method.\nThe Scrum process or sprint cycle is shown in Figure 3.9. The input to the process \nis the product backlog. Each process iteration produces a product increment that \ncould be delivered to customers.\nThe starting point for the Scrum sprint cycle is the product backlog\u2014the list of \nitems such as product features, requirements, and engineering improvement that \nhave to be worked on by the Scrum team. The initial version of the product backlog \nmay be derived from a requirements document, a list of user stories, or other descrip-\ntion of the software to be developed.\nWhile the majority of entries in the product backlog are concerned with the imple-\nmentation of system features, other activities may also be included. Sometimes, when \nplanning an iteration, questions that cannot be easily answered come to light and addi-\ntional work is required to explore possible solutions. The team may carry out some pro-\ntotyping or trial development to understand the problem and solution. There may also be \nbacklog items to design the system architecture or to develop system documentation.\nThe product backlog may be specified at varying levels of detail, and it is the \nresponsibility of the Product Owner to ensure that the level of detail in the specifica-\ntion is appropriate for the work to be done. For example, a backlog item could be a \ncomplete user story such as that shown in Figure 3.5, or it could simply be an instruc-\ntion such as \u201cRefactor user interface code\u201d that leaves it up to the team to decide on \nthe refactoring to be done.\nEach sprint cycle lasts a fixed length of time, which is usually between 2 and 4 weeks. \nAt the beginning of each cycle, the Product Owner prioritizes the items on the product \nbacklog to define which are the most important items to be developed in that cycle. \nSprints are never extended to take account of unfinished work. Items are returned to the \nproduct backlog if these cannot be completed within the allocated time for the sprint.\nThe whole team is then involved in selecting which of the highest priority items \nthey believe can be completed. They then estimate the time required to complete \nthese items. To make these estimates, they use the velocity attained in previous \nReview work \nto be done\nSelect \nitems\nPlan\nsprint\nReview\nsprint\nSprint\nScrum\nProduct\nbacklog\nSprint\nbacklog\nPotentially\nshippable\nsoftware\nFigure 3.9 The Scrum \nsprint cycle"}
{"query": "How is the product backlog used in the Scrum process or sprint cycle?", "response": "The product backlog is used in the Scrum process or sprint cycle to define the list of items that need to be worked on by the Scrum team. These items can include product features, requirements, and engineering improvements. The Product Owner is responsible for prioritizing the items on the product backlog and determining which are the most important to be developed in the current sprint cycle. The team then selects the highest priority items they believe they can complete and estimates the time required to complete them. The product backlog serves as a guide for the team throughout the sprint cycle, ensuring that they are working on the most important tasks and delivering a potentially shippable product increment at the end of each sprint.", "context": "3.3  \u25a0 Agile project management  85\nthe team. To address this issue, the Scrum agile method was developed (Schwaber \nand Beedle 2001; Rubin 2013) to provide a framework for organizing agile projects \nand, to some extent at least, provide external visibility of what is going on. The devel-\nopers of Scrum wished to make clear that Scrum was not a method for project man-\nagement in the conventional sense, so they deliberately invented new terminology, \nsuch as ScrumMaster, which replaced names such as project manager. Figure 3.8 \nsummarizes Scrum terminology and what it means.\nScrum is an agile method insofar as it follows the principles from the agile mani-\nfesto, which I showed in Figure 3.2. However, it focuses on providing a framework \nfor agile project organization, and it does not mandate the use of specific development \nScrum term\nDefinition\nDevelopment team\nA self-organizing group of software developers, which should be no \nmore than seven people. They are responsible for developing the \nsoftware and other essential project documents.\nPotentially shippable product \nincrement\nThe software increment that is delivered from a sprint. The idea is that \nthis should be \u201cpotentially shippable,\u201d which means that it is in a \nfinished state and no further work, such as testing, is needed to \nincorporate it into the final product. In practice, this is not always \nachievable.\nProduct backlog\nThis is a list of \u201cto do\u201d items that the Scrum team must tackle. They \nmay be feature definitions for the software, software requirements, user \nstories, or descriptions of supplementary tasks that are needed, such as \narchitecture definition or user documentation.\nProduct owner\nAn individual (or possibly a small group) whose job is to identify \nproduct features or requirements, prioritize these for development, and \ncontinuously review the product backlog to ensure that the project \ncontinues to meet critical business needs. The Product Owner can be a \ncustomer but might also be a product manager in a software company \nor other stakeholder representative.\nScrum\nA daily meeting of the Scrum team that reviews progress and prioritizes \nwork to be done that day. Ideally, this should be a short face-to-face \nmeeting that includes the whole team.\nScrumMaster\nThe ScrumMaster is responsible for ensuring that the Scrum process is \nfollowed and guides the team in the effective use of Scrum. He or she \nis responsible for interfacing with the rest of the company and for \nensuring that the Scrum team is not diverted by outside interference. \nThe Scrum developers are adamant that the ScrumMaster should not \nbe thought of as a project manager. Others, however, may not always \nfind it easy to see the difference.\nSprint\nA development iteration. Sprints are usually 2 to 4 weeks long.\nVelocity\nAn estimate of how much product backlog effort a team can cover in a \nsingle sprint. Understanding a team\u2019s velocity helps them estimate what \ncan be covered in a sprint and provides a basis for measuring \nimproving performance.\nFigure 3.8 Scrum \nterminology\n\n\n86  Chapter 3 \u25a0 Agile software development\npractices such as pair programming and test-first development. This means that it \ncan be more easily integrated with existing practice in a company. Consequently, as \nagile methods have become a mainstream approach to software development, Scrum \nhas emerged as the most widely used method.\nThe Scrum process or sprint cycle is shown in Figure 3.9. The input to the process \nis the product backlog. Each process iteration produces a product increment that \ncould be delivered to customers.\nThe starting point for the Scrum sprint cycle is the product backlog\u2014the list of \nitems such as product features, requirements, and engineering improvement that \nhave to be worked on by the Scrum team. The initial version of the product backlog \nmay be derived from a requirements document, a list of user stories, or other descrip-\ntion of the software to be developed.\nWhile the majority of entries in the product backlog are concerned with the imple-\nmentation of system features, other activities may also be included. Sometimes, when \nplanning an iteration, questions that cannot be easily answered come to light and addi-\ntional work is required to explore possible solutions. The team may carry out some pro-\ntotyping or trial development to understand the problem and solution. There may also be \nbacklog items to design the system architecture or to develop system documentation.\nThe product backlog may be specified at varying levels of detail, and it is the \nresponsibility of the Product Owner to ensure that the level of detail in the specifica-\ntion is appropriate for the work to be done. For example, a backlog item could be a \ncomplete user story such as that shown in Figure 3.5, or it could simply be an instruc-\ntion such as \u201cRefactor user interface code\u201d that leaves it up to the team to decide on \nthe refactoring to be done.\nEach sprint cycle lasts a fixed length of time, which is usually between 2 and 4 weeks. \nAt the beginning of each cycle, the Product Owner prioritizes the items on the product \nbacklog to define which are the most important items to be developed in that cycle. \nSprints are never extended to take account of unfinished work. Items are returned to the \nproduct backlog if these cannot be completed within the allocated time for the sprint.\nThe whole team is then involved in selecting which of the highest priority items \nthey believe can be completed. They then estimate the time required to complete \nthese items. To make these estimates, they use the velocity attained in previous \nReview work \nto be done\nSelect \nitems\nPlan\nsprint\nReview\nsprint\nSprint\nScrum\nProduct\nbacklog\nSprint\nbacklog\nPotentially\nshippable\nsoftware\nFigure 3.9 The Scrum \nsprint cycle"}
{"query": "What is the duration of a sprint cycle in the Scrum agile method?", "response": "The duration of a sprint cycle in the Scrum agile method is usually between 2 and 4 weeks.", "context": "3.3  \u25a0 Agile project management  85\nthe team. To address this issue, the Scrum agile method was developed (Schwaber \nand Beedle 2001; Rubin 2013) to provide a framework for organizing agile projects \nand, to some extent at least, provide external visibility of what is going on. The devel-\nopers of Scrum wished to make clear that Scrum was not a method for project man-\nagement in the conventional sense, so they deliberately invented new terminology, \nsuch as ScrumMaster, which replaced names such as project manager. Figure 3.8 \nsummarizes Scrum terminology and what it means.\nScrum is an agile method insofar as it follows the principles from the agile mani-\nfesto, which I showed in Figure 3.2. However, it focuses on providing a framework \nfor agile project organization, and it does not mandate the use of specific development \nScrum term\nDefinition\nDevelopment team\nA self-organizing group of software developers, which should be no \nmore than seven people. They are responsible for developing the \nsoftware and other essential project documents.\nPotentially shippable product \nincrement\nThe software increment that is delivered from a sprint. The idea is that \nthis should be \u201cpotentially shippable,\u201d which means that it is in a \nfinished state and no further work, such as testing, is needed to \nincorporate it into the final product. In practice, this is not always \nachievable.\nProduct backlog\nThis is a list of \u201cto do\u201d items that the Scrum team must tackle. They \nmay be feature definitions for the software, software requirements, user \nstories, or descriptions of supplementary tasks that are needed, such as \narchitecture definition or user documentation.\nProduct owner\nAn individual (or possibly a small group) whose job is to identify \nproduct features or requirements, prioritize these for development, and \ncontinuously review the product backlog to ensure that the project \ncontinues to meet critical business needs. The Product Owner can be a \ncustomer but might also be a product manager in a software company \nor other stakeholder representative.\nScrum\nA daily meeting of the Scrum team that reviews progress and prioritizes \nwork to be done that day. Ideally, this should be a short face-to-face \nmeeting that includes the whole team.\nScrumMaster\nThe ScrumMaster is responsible for ensuring that the Scrum process is \nfollowed and guides the team in the effective use of Scrum. He or she \nis responsible for interfacing with the rest of the company and for \nensuring that the Scrum team is not diverted by outside interference. \nThe Scrum developers are adamant that the ScrumMaster should not \nbe thought of as a project manager. Others, however, may not always \nfind it easy to see the difference.\nSprint\nA development iteration. Sprints are usually 2 to 4 weeks long.\nVelocity\nAn estimate of how much product backlog effort a team can cover in a \nsingle sprint. Understanding a team\u2019s velocity helps them estimate what \ncan be covered in a sprint and provides a basis for measuring \nimproving performance.\nFigure 3.8 Scrum \nterminology\n\n\n86  Chapter 3 \u25a0 Agile software development\npractices such as pair programming and test-first development. This means that it \ncan be more easily integrated with existing practice in a company. Consequently, as \nagile methods have become a mainstream approach to software development, Scrum \nhas emerged as the most widely used method.\nThe Scrum process or sprint cycle is shown in Figure 3.9. The input to the process \nis the product backlog. Each process iteration produces a product increment that \ncould be delivered to customers.\nThe starting point for the Scrum sprint cycle is the product backlog\u2014the list of \nitems such as product features, requirements, and engineering improvement that \nhave to be worked on by the Scrum team. The initial version of the product backlog \nmay be derived from a requirements document, a list of user stories, or other descrip-\ntion of the software to be developed.\nWhile the majority of entries in the product backlog are concerned with the imple-\nmentation of system features, other activities may also be included. Sometimes, when \nplanning an iteration, questions that cannot be easily answered come to light and addi-\ntional work is required to explore possible solutions. The team may carry out some pro-\ntotyping or trial development to understand the problem and solution. There may also be \nbacklog items to design the system architecture or to develop system documentation.\nThe product backlog may be specified at varying levels of detail, and it is the \nresponsibility of the Product Owner to ensure that the level of detail in the specifica-\ntion is appropriate for the work to be done. For example, a backlog item could be a \ncomplete user story such as that shown in Figure 3.5, or it could simply be an instruc-\ntion such as \u201cRefactor user interface code\u201d that leaves it up to the team to decide on \nthe refactoring to be done.\nEach sprint cycle lasts a fixed length of time, which is usually between 2 and 4 weeks. \nAt the beginning of each cycle, the Product Owner prioritizes the items on the product \nbacklog to define which are the most important items to be developed in that cycle. \nSprints are never extended to take account of unfinished work. Items are returned to the \nproduct backlog if these cannot be completed within the allocated time for the sprint.\nThe whole team is then involved in selecting which of the highest priority items \nthey believe can be completed. They then estimate the time required to complete \nthese items. To make these estimates, they use the velocity attained in previous \nReview work \nto be done\nSelect \nitems\nPlan\nsprint\nReview\nsprint\nSprint\nScrum\nProduct\nbacklog\nSprint\nbacklog\nPotentially\nshippable\nsoftware\nFigure 3.9 The Scrum \nsprint cycle"}
{"query": "What happens to unfinished work at the end of a sprint cycle in the Scrum agile method?", "response": "Items that are not completed within the allocated time for the sprint are returned to the product backlog.", "context": "3.3  \u25a0 Agile project management  85\nthe team. To address this issue, the Scrum agile method was developed (Schwaber \nand Beedle 2001; Rubin 2013) to provide a framework for organizing agile projects \nand, to some extent at least, provide external visibility of what is going on. The devel-\nopers of Scrum wished to make clear that Scrum was not a method for project man-\nagement in the conventional sense, so they deliberately invented new terminology, \nsuch as ScrumMaster, which replaced names such as project manager. Figure 3.8 \nsummarizes Scrum terminology and what it means.\nScrum is an agile method insofar as it follows the principles from the agile mani-\nfesto, which I showed in Figure 3.2. However, it focuses on providing a framework \nfor agile project organization, and it does not mandate the use of specific development \nScrum term\nDefinition\nDevelopment team\nA self-organizing group of software developers, which should be no \nmore than seven people. They are responsible for developing the \nsoftware and other essential project documents.\nPotentially shippable product \nincrement\nThe software increment that is delivered from a sprint. The idea is that \nthis should be \u201cpotentially shippable,\u201d which means that it is in a \nfinished state and no further work, such as testing, is needed to \nincorporate it into the final product. In practice, this is not always \nachievable.\nProduct backlog\nThis is a list of \u201cto do\u201d items that the Scrum team must tackle. They \nmay be feature definitions for the software, software requirements, user \nstories, or descriptions of supplementary tasks that are needed, such as \narchitecture definition or user documentation.\nProduct owner\nAn individual (or possibly a small group) whose job is to identify \nproduct features or requirements, prioritize these for development, and \ncontinuously review the product backlog to ensure that the project \ncontinues to meet critical business needs. The Product Owner can be a \ncustomer but might also be a product manager in a software company \nor other stakeholder representative.\nScrum\nA daily meeting of the Scrum team that reviews progress and prioritizes \nwork to be done that day. Ideally, this should be a short face-to-face \nmeeting that includes the whole team.\nScrumMaster\nThe ScrumMaster is responsible for ensuring that the Scrum process is \nfollowed and guides the team in the effective use of Scrum. He or she \nis responsible for interfacing with the rest of the company and for \nensuring that the Scrum team is not diverted by outside interference. \nThe Scrum developers are adamant that the ScrumMaster should not \nbe thought of as a project manager. Others, however, may not always \nfind it easy to see the difference.\nSprint\nA development iteration. Sprints are usually 2 to 4 weeks long.\nVelocity\nAn estimate of how much product backlog effort a team can cover in a \nsingle sprint. Understanding a team\u2019s velocity helps them estimate what \ncan be covered in a sprint and provides a basis for measuring \nimproving performance.\nFigure 3.8 Scrum \nterminology\n\n\n86  Chapter 3 \u25a0 Agile software development\npractices such as pair programming and test-first development. This means that it \ncan be more easily integrated with existing practice in a company. Consequently, as \nagile methods have become a mainstream approach to software development, Scrum \nhas emerged as the most widely used method.\nThe Scrum process or sprint cycle is shown in Figure 3.9. The input to the process \nis the product backlog. Each process iteration produces a product increment that \ncould be delivered to customers.\nThe starting point for the Scrum sprint cycle is the product backlog\u2014the list of \nitems such as product features, requirements, and engineering improvement that \nhave to be worked on by the Scrum team. The initial version of the product backlog \nmay be derived from a requirements document, a list of user stories, or other descrip-\ntion of the software to be developed.\nWhile the majority of entries in the product backlog are concerned with the imple-\nmentation of system features, other activities may also be included. Sometimes, when \nplanning an iteration, questions that cannot be easily answered come to light and addi-\ntional work is required to explore possible solutions. The team may carry out some pro-\ntotyping or trial development to understand the problem and solution. There may also be \nbacklog items to design the system architecture or to develop system documentation.\nThe product backlog may be specified at varying levels of detail, and it is the \nresponsibility of the Product Owner to ensure that the level of detail in the specifica-\ntion is appropriate for the work to be done. For example, a backlog item could be a \ncomplete user story such as that shown in Figure 3.5, or it could simply be an instruc-\ntion such as \u201cRefactor user interface code\u201d that leaves it up to the team to decide on \nthe refactoring to be done.\nEach sprint cycle lasts a fixed length of time, which is usually between 2 and 4 weeks. \nAt the beginning of each cycle, the Product Owner prioritizes the items on the product \nbacklog to define which are the most important items to be developed in that cycle. \nSprints are never extended to take account of unfinished work. Items are returned to the \nproduct backlog if these cannot be completed within the allocated time for the sprint.\nThe whole team is then involved in selecting which of the highest priority items \nthey believe can be completed. They then estimate the time required to complete \nthese items. To make these estimates, they use the velocity attained in previous \nReview work \nto be done\nSelect \nitems\nPlan\nsprint\nReview\nsprint\nSprint\nScrum\nProduct\nbacklog\nSprint\nbacklog\nPotentially\nshippable\nsoftware\nFigure 3.9 The Scrum \nsprint cycle"}
{"query": "How does the team estimate the time required to complete items in the Scrum agile method?", "response": "The team estimates the time required to complete items in the Scrum agile method by using the velocity attained in previous sprints.", "context": "3.3  \u25a0 Agile project management  85\nthe team. To address this issue, the Scrum agile method was developed (Schwaber \nand Beedle 2001; Rubin 2013) to provide a framework for organizing agile projects \nand, to some extent at least, provide external visibility of what is going on. The devel-\nopers of Scrum wished to make clear that Scrum was not a method for project man-\nagement in the conventional sense, so they deliberately invented new terminology, \nsuch as ScrumMaster, which replaced names such as project manager. Figure 3.8 \nsummarizes Scrum terminology and what it means.\nScrum is an agile method insofar as it follows the principles from the agile mani-\nfesto, which I showed in Figure 3.2. However, it focuses on providing a framework \nfor agile project organization, and it does not mandate the use of specific development \nScrum term\nDefinition\nDevelopment team\nA self-organizing group of software developers, which should be no \nmore than seven people. They are responsible for developing the \nsoftware and other essential project documents.\nPotentially shippable product \nincrement\nThe software increment that is delivered from a sprint. The idea is that \nthis should be \u201cpotentially shippable,\u201d which means that it is in a \nfinished state and no further work, such as testing, is needed to \nincorporate it into the final product. In practice, this is not always \nachievable.\nProduct backlog\nThis is a list of \u201cto do\u201d items that the Scrum team must tackle. They \nmay be feature definitions for the software, software requirements, user \nstories, or descriptions of supplementary tasks that are needed, such as \narchitecture definition or user documentation.\nProduct owner\nAn individual (or possibly a small group) whose job is to identify \nproduct features or requirements, prioritize these for development, and \ncontinuously review the product backlog to ensure that the project \ncontinues to meet critical business needs. The Product Owner can be a \ncustomer but might also be a product manager in a software company \nor other stakeholder representative.\nScrum\nA daily meeting of the Scrum team that reviews progress and prioritizes \nwork to be done that day. Ideally, this should be a short face-to-face \nmeeting that includes the whole team.\nScrumMaster\nThe ScrumMaster is responsible for ensuring that the Scrum process is \nfollowed and guides the team in the effective use of Scrum. He or she \nis responsible for interfacing with the rest of the company and for \nensuring that the Scrum team is not diverted by outside interference. \nThe Scrum developers are adamant that the ScrumMaster should not \nbe thought of as a project manager. Others, however, may not always \nfind it easy to see the difference.\nSprint\nA development iteration. Sprints are usually 2 to 4 weeks long.\nVelocity\nAn estimate of how much product backlog effort a team can cover in a \nsingle sprint. Understanding a team\u2019s velocity helps them estimate what \ncan be covered in a sprint and provides a basis for measuring \nimproving performance.\nFigure 3.8 Scrum \nterminology\n\n\n86  Chapter 3 \u25a0 Agile software development\npractices such as pair programming and test-first development. This means that it \ncan be more easily integrated with existing practice in a company. Consequently, as \nagile methods have become a mainstream approach to software development, Scrum \nhas emerged as the most widely used method.\nThe Scrum process or sprint cycle is shown in Figure 3.9. The input to the process \nis the product backlog. Each process iteration produces a product increment that \ncould be delivered to customers.\nThe starting point for the Scrum sprint cycle is the product backlog\u2014the list of \nitems such as product features, requirements, and engineering improvement that \nhave to be worked on by the Scrum team. The initial version of the product backlog \nmay be derived from a requirements document, a list of user stories, or other descrip-\ntion of the software to be developed.\nWhile the majority of entries in the product backlog are concerned with the imple-\nmentation of system features, other activities may also be included. Sometimes, when \nplanning an iteration, questions that cannot be easily answered come to light and addi-\ntional work is required to explore possible solutions. The team may carry out some pro-\ntotyping or trial development to understand the problem and solution. There may also be \nbacklog items to design the system architecture or to develop system documentation.\nThe product backlog may be specified at varying levels of detail, and it is the \nresponsibility of the Product Owner to ensure that the level of detail in the specifica-\ntion is appropriate for the work to be done. For example, a backlog item could be a \ncomplete user story such as that shown in Figure 3.5, or it could simply be an instruc-\ntion such as \u201cRefactor user interface code\u201d that leaves it up to the team to decide on \nthe refactoring to be done.\nEach sprint cycle lasts a fixed length of time, which is usually between 2 and 4 weeks. \nAt the beginning of each cycle, the Product Owner prioritizes the items on the product \nbacklog to define which are the most important items to be developed in that cycle. \nSprints are never extended to take account of unfinished work. Items are returned to the \nproduct backlog if these cannot be completed within the allocated time for the sprint.\nThe whole team is then involved in selecting which of the highest priority items \nthey believe can be completed. They then estimate the time required to complete \nthese items. To make these estimates, they use the velocity attained in previous \nReview work \nto be done\nSelect \nitems\nPlan\nsprint\nReview\nsprint\nSprint\nScrum\nProduct\nbacklog\nSprint\nbacklog\nPotentially\nshippable\nsoftware\nFigure 3.9 The Scrum \nsprint cycle"}
{"query": "What is the role of the Product Owner in prioritizing items on the product backlog?", "response": "The Product Owner is responsible for prioritizing items on the product backlog. They determine which items are the most important and should be developed in the current sprint cycle.", "context": "3.3  \u25a0 Agile project management  85\nthe team. To address this issue, the Scrum agile method was developed (Schwaber \nand Beedle 2001; Rubin 2013) to provide a framework for organizing agile projects \nand, to some extent at least, provide external visibility of what is going on. The devel-\nopers of Scrum wished to make clear that Scrum was not a method for project man-\nagement in the conventional sense, so they deliberately invented new terminology, \nsuch as ScrumMaster, which replaced names such as project manager. Figure 3.8 \nsummarizes Scrum terminology and what it means.\nScrum is an agile method insofar as it follows the principles from the agile mani-\nfesto, which I showed in Figure 3.2. However, it focuses on providing a framework \nfor agile project organization, and it does not mandate the use of specific development \nScrum term\nDefinition\nDevelopment team\nA self-organizing group of software developers, which should be no \nmore than seven people. They are responsible for developing the \nsoftware and other essential project documents.\nPotentially shippable product \nincrement\nThe software increment that is delivered from a sprint. The idea is that \nthis should be \u201cpotentially shippable,\u201d which means that it is in a \nfinished state and no further work, such as testing, is needed to \nincorporate it into the final product. In practice, this is not always \nachievable.\nProduct backlog\nThis is a list of \u201cto do\u201d items that the Scrum team must tackle. They \nmay be feature definitions for the software, software requirements, user \nstories, or descriptions of supplementary tasks that are needed, such as \narchitecture definition or user documentation.\nProduct owner\nAn individual (or possibly a small group) whose job is to identify \nproduct features or requirements, prioritize these for development, and \ncontinuously review the product backlog to ensure that the project \ncontinues to meet critical business needs. The Product Owner can be a \ncustomer but might also be a product manager in a software company \nor other stakeholder representative.\nScrum\nA daily meeting of the Scrum team that reviews progress and prioritizes \nwork to be done that day. Ideally, this should be a short face-to-face \nmeeting that includes the whole team.\nScrumMaster\nThe ScrumMaster is responsible for ensuring that the Scrum process is \nfollowed and guides the team in the effective use of Scrum. He or she \nis responsible for interfacing with the rest of the company and for \nensuring that the Scrum team is not diverted by outside interference. \nThe Scrum developers are adamant that the ScrumMaster should not \nbe thought of as a project manager. Others, however, may not always \nfind it easy to see the difference.\nSprint\nA development iteration. Sprints are usually 2 to 4 weeks long.\nVelocity\nAn estimate of how much product backlog effort a team can cover in a \nsingle sprint. Understanding a team\u2019s velocity helps them estimate what \ncan be covered in a sprint and provides a basis for measuring \nimproving performance.\nFigure 3.8 Scrum \nterminology\n\n\n86  Chapter 3 \u25a0 Agile software development\npractices such as pair programming and test-first development. This means that it \ncan be more easily integrated with existing practice in a company. Consequently, as \nagile methods have become a mainstream approach to software development, Scrum \nhas emerged as the most widely used method.\nThe Scrum process or sprint cycle is shown in Figure 3.9. The input to the process \nis the product backlog. Each process iteration produces a product increment that \ncould be delivered to customers.\nThe starting point for the Scrum sprint cycle is the product backlog\u2014the list of \nitems such as product features, requirements, and engineering improvement that \nhave to be worked on by the Scrum team. The initial version of the product backlog \nmay be derived from a requirements document, a list of user stories, or other descrip-\ntion of the software to be developed.\nWhile the majority of entries in the product backlog are concerned with the imple-\nmentation of system features, other activities may also be included. Sometimes, when \nplanning an iteration, questions that cannot be easily answered come to light and addi-\ntional work is required to explore possible solutions. The team may carry out some pro-\ntotyping or trial development to understand the problem and solution. There may also be \nbacklog items to design the system architecture or to develop system documentation.\nThe product backlog may be specified at varying levels of detail, and it is the \nresponsibility of the Product Owner to ensure that the level of detail in the specifica-\ntion is appropriate for the work to be done. For example, a backlog item could be a \ncomplete user story such as that shown in Figure 3.5, or it could simply be an instruc-\ntion such as \u201cRefactor user interface code\u201d that leaves it up to the team to decide on \nthe refactoring to be done.\nEach sprint cycle lasts a fixed length of time, which is usually between 2 and 4 weeks. \nAt the beginning of each cycle, the Product Owner prioritizes the items on the product \nbacklog to define which are the most important items to be developed in that cycle. \nSprints are never extended to take account of unfinished work. Items are returned to the \nproduct backlog if these cannot be completed within the allocated time for the sprint.\nThe whole team is then involved in selecting which of the highest priority items \nthey believe can be completed. They then estimate the time required to complete \nthese items. To make these estimates, they use the velocity attained in previous \nReview work \nto be done\nSelect \nitems\nPlan\nsprint\nReview\nsprint\nSprint\nScrum\nProduct\nbacklog\nSprint\nbacklog\nPotentially\nshippable\nsoftware\nFigure 3.9 The Scrum \nsprint cycle"}
{"query": "How does the Scrum agile method integrate with existing practices in a company?", "response": "The Scrum agile method can be easily integrated with existing practices in a company. Unlike other agile methods, Scrum does not mandate the use of specific development practices such as pair programming or test-first development. This flexibility allows Scrum to be more easily integrated into existing practices, making it a popular choice for companies adopting agile methods.", "context": "3.3  \u25a0 Agile project management  85\nthe team. To address this issue, the Scrum agile method was developed (Schwaber \nand Beedle 2001; Rubin 2013) to provide a framework for organizing agile projects \nand, to some extent at least, provide external visibility of what is going on. The devel-\nopers of Scrum wished to make clear that Scrum was not a method for project man-\nagement in the conventional sense, so they deliberately invented new terminology, \nsuch as ScrumMaster, which replaced names such as project manager. Figure 3.8 \nsummarizes Scrum terminology and what it means.\nScrum is an agile method insofar as it follows the principles from the agile mani-\nfesto, which I showed in Figure 3.2. However, it focuses on providing a framework \nfor agile project organization, and it does not mandate the use of specific development \nScrum term\nDefinition\nDevelopment team\nA self-organizing group of software developers, which should be no \nmore than seven people. They are responsible for developing the \nsoftware and other essential project documents.\nPotentially shippable product \nincrement\nThe software increment that is delivered from a sprint. The idea is that \nthis should be \u201cpotentially shippable,\u201d which means that it is in a \nfinished state and no further work, such as testing, is needed to \nincorporate it into the final product. In practice, this is not always \nachievable.\nProduct backlog\nThis is a list of \u201cto do\u201d items that the Scrum team must tackle. They \nmay be feature definitions for the software, software requirements, user \nstories, or descriptions of supplementary tasks that are needed, such as \narchitecture definition or user documentation.\nProduct owner\nAn individual (or possibly a small group) whose job is to identify \nproduct features or requirements, prioritize these for development, and \ncontinuously review the product backlog to ensure that the project \ncontinues to meet critical business needs. The Product Owner can be a \ncustomer but might also be a product manager in a software company \nor other stakeholder representative.\nScrum\nA daily meeting of the Scrum team that reviews progress and prioritizes \nwork to be done that day. Ideally, this should be a short face-to-face \nmeeting that includes the whole team.\nScrumMaster\nThe ScrumMaster is responsible for ensuring that the Scrum process is \nfollowed and guides the team in the effective use of Scrum. He or she \nis responsible for interfacing with the rest of the company and for \nensuring that the Scrum team is not diverted by outside interference. \nThe Scrum developers are adamant that the ScrumMaster should not \nbe thought of as a project manager. Others, however, may not always \nfind it easy to see the difference.\nSprint\nA development iteration. Sprints are usually 2 to 4 weeks long.\nVelocity\nAn estimate of how much product backlog effort a team can cover in a \nsingle sprint. Understanding a team\u2019s velocity helps them estimate what \ncan be covered in a sprint and provides a basis for measuring \nimproving performance.\nFigure 3.8 Scrum \nterminology\n\n\n86  Chapter 3 \u25a0 Agile software development\npractices such as pair programming and test-first development. This means that it \ncan be more easily integrated with existing practice in a company. Consequently, as \nagile methods have become a mainstream approach to software development, Scrum \nhas emerged as the most widely used method.\nThe Scrum process or sprint cycle is shown in Figure 3.9. The input to the process \nis the product backlog. Each process iteration produces a product increment that \ncould be delivered to customers.\nThe starting point for the Scrum sprint cycle is the product backlog\u2014the list of \nitems such as product features, requirements, and engineering improvement that \nhave to be worked on by the Scrum team. The initial version of the product backlog \nmay be derived from a requirements document, a list of user stories, or other descrip-\ntion of the software to be developed.\nWhile the majority of entries in the product backlog are concerned with the imple-\nmentation of system features, other activities may also be included. Sometimes, when \nplanning an iteration, questions that cannot be easily answered come to light and addi-\ntional work is required to explore possible solutions. The team may carry out some pro-\ntotyping or trial development to understand the problem and solution. There may also be \nbacklog items to design the system architecture or to develop system documentation.\nThe product backlog may be specified at varying levels of detail, and it is the \nresponsibility of the Product Owner to ensure that the level of detail in the specifica-\ntion is appropriate for the work to be done. For example, a backlog item could be a \ncomplete user story such as that shown in Figure 3.5, or it could simply be an instruc-\ntion such as \u201cRefactor user interface code\u201d that leaves it up to the team to decide on \nthe refactoring to be done.\nEach sprint cycle lasts a fixed length of time, which is usually between 2 and 4 weeks. \nAt the beginning of each cycle, the Product Owner prioritizes the items on the product \nbacklog to define which are the most important items to be developed in that cycle. \nSprints are never extended to take account of unfinished work. Items are returned to the \nproduct backlog if these cannot be completed within the allocated time for the sprint.\nThe whole team is then involved in selecting which of the highest priority items \nthey believe can be completed. They then estimate the time required to complete \nthese items. To make these estimates, they use the velocity attained in previous \nReview work \nto be done\nSelect \nitems\nPlan\nsprint\nReview\nsprint\nSprint\nScrum\nProduct\nbacklog\nSprint\nbacklog\nPotentially\nshippable\nsoftware\nFigure 3.9 The Scrum \nsprint cycle"}
{"query": "Why has Scrum emerged as the most widely used method in agile software development?", "response": "Scrum has emerged as the most widely used method in agile software development because it provides a framework for organizing agile projects and can be easily integrated with existing practices in a company. Unlike other agile methods, Scrum does not mandate the use of specific development practices, such as pair programming or test-first development, making it more adaptable to different environments. Additionally, Scrum focuses on providing a framework for agile project organization and does not replace traditional project management roles, which may make it more appealing to organizations.", "context": "3.3  \u25a0 Agile project management  85\nthe team. To address this issue, the Scrum agile method was developed (Schwaber \nand Beedle 2001; Rubin 2013) to provide a framework for organizing agile projects \nand, to some extent at least, provide external visibility of what is going on. The devel-\nopers of Scrum wished to make clear that Scrum was not a method for project man-\nagement in the conventional sense, so they deliberately invented new terminology, \nsuch as ScrumMaster, which replaced names such as project manager. Figure 3.8 \nsummarizes Scrum terminology and what it means.\nScrum is an agile method insofar as it follows the principles from the agile mani-\nfesto, which I showed in Figure 3.2. However, it focuses on providing a framework \nfor agile project organization, and it does not mandate the use of specific development \nScrum term\nDefinition\nDevelopment team\nA self-organizing group of software developers, which should be no \nmore than seven people. They are responsible for developing the \nsoftware and other essential project documents.\nPotentially shippable product \nincrement\nThe software increment that is delivered from a sprint. The idea is that \nthis should be \u201cpotentially shippable,\u201d which means that it is in a \nfinished state and no further work, such as testing, is needed to \nincorporate it into the final product. In practice, this is not always \nachievable.\nProduct backlog\nThis is a list of \u201cto do\u201d items that the Scrum team must tackle. They \nmay be feature definitions for the software, software requirements, user \nstories, or descriptions of supplementary tasks that are needed, such as \narchitecture definition or user documentation.\nProduct owner\nAn individual (or possibly a small group) whose job is to identify \nproduct features or requirements, prioritize these for development, and \ncontinuously review the product backlog to ensure that the project \ncontinues to meet critical business needs. The Product Owner can be a \ncustomer but might also be a product manager in a software company \nor other stakeholder representative.\nScrum\nA daily meeting of the Scrum team that reviews progress and prioritizes \nwork to be done that day. Ideally, this should be a short face-to-face \nmeeting that includes the whole team.\nScrumMaster\nThe ScrumMaster is responsible for ensuring that the Scrum process is \nfollowed and guides the team in the effective use of Scrum. He or she \nis responsible for interfacing with the rest of the company and for \nensuring that the Scrum team is not diverted by outside interference. \nThe Scrum developers are adamant that the ScrumMaster should not \nbe thought of as a project manager. Others, however, may not always \nfind it easy to see the difference.\nSprint\nA development iteration. Sprints are usually 2 to 4 weeks long.\nVelocity\nAn estimate of how much product backlog effort a team can cover in a \nsingle sprint. Understanding a team\u2019s velocity helps them estimate what \ncan be covered in a sprint and provides a basis for measuring \nimproving performance.\nFigure 3.8 Scrum \nterminology\n\n\n86  Chapter 3 \u25a0 Agile software development\npractices such as pair programming and test-first development. This means that it \ncan be more easily integrated with existing practice in a company. Consequently, as \nagile methods have become a mainstream approach to software development, Scrum \nhas emerged as the most widely used method.\nThe Scrum process or sprint cycle is shown in Figure 3.9. The input to the process \nis the product backlog. Each process iteration produces a product increment that \ncould be delivered to customers.\nThe starting point for the Scrum sprint cycle is the product backlog\u2014the list of \nitems such as product features, requirements, and engineering improvement that \nhave to be worked on by the Scrum team. The initial version of the product backlog \nmay be derived from a requirements document, a list of user stories, or other descrip-\ntion of the software to be developed.\nWhile the majority of entries in the product backlog are concerned with the imple-\nmentation of system features, other activities may also be included. Sometimes, when \nplanning an iteration, questions that cannot be easily answered come to light and addi-\ntional work is required to explore possible solutions. The team may carry out some pro-\ntotyping or trial development to understand the problem and solution. There may also be \nbacklog items to design the system architecture or to develop system documentation.\nThe product backlog may be specified at varying levels of detail, and it is the \nresponsibility of the Product Owner to ensure that the level of detail in the specifica-\ntion is appropriate for the work to be done. For example, a backlog item could be a \ncomplete user story such as that shown in Figure 3.5, or it could simply be an instruc-\ntion such as \u201cRefactor user interface code\u201d that leaves it up to the team to decide on \nthe refactoring to be done.\nEach sprint cycle lasts a fixed length of time, which is usually between 2 and 4 weeks. \nAt the beginning of each cycle, the Product Owner prioritizes the items on the product \nbacklog to define which are the most important items to be developed in that cycle. \nSprints are never extended to take account of unfinished work. Items are returned to the \nproduct backlog if these cannot be completed within the allocated time for the sprint.\nThe whole team is then involved in selecting which of the highest priority items \nthey believe can be completed. They then estimate the time required to complete \nthese items. To make these estimates, they use the velocity attained in previous \nReview work \nto be done\nSelect \nitems\nPlan\nsprint\nReview\nsprint\nSprint\nScrum\nProduct\nbacklog\nSprint\nbacklog\nPotentially\nshippable\nsoftware\nFigure 3.9 The Scrum \nsprint cycle"}
{"query": "What types of items can be included in the product backlog in the Scrum agile method?", "response": "The product backlog in the Scrum agile method can include various types of items such as product features, software requirements, user stories, and descriptions of supplementary tasks like architecture definition or user documentation.", "context": "3.3  \u25a0 Agile project management  85\nthe team. To address this issue, the Scrum agile method was developed (Schwaber \nand Beedle 2001; Rubin 2013) to provide a framework for organizing agile projects \nand, to some extent at least, provide external visibility of what is going on. The devel-\nopers of Scrum wished to make clear that Scrum was not a method for project man-\nagement in the conventional sense, so they deliberately invented new terminology, \nsuch as ScrumMaster, which replaced names such as project manager. Figure 3.8 \nsummarizes Scrum terminology and what it means.\nScrum is an agile method insofar as it follows the principles from the agile mani-\nfesto, which I showed in Figure 3.2. However, it focuses on providing a framework \nfor agile project organization, and it does not mandate the use of specific development \nScrum term\nDefinition\nDevelopment team\nA self-organizing group of software developers, which should be no \nmore than seven people. They are responsible for developing the \nsoftware and other essential project documents.\nPotentially shippable product \nincrement\nThe software increment that is delivered from a sprint. The idea is that \nthis should be \u201cpotentially shippable,\u201d which means that it is in a \nfinished state and no further work, such as testing, is needed to \nincorporate it into the final product. In practice, this is not always \nachievable.\nProduct backlog\nThis is a list of \u201cto do\u201d items that the Scrum team must tackle. They \nmay be feature definitions for the software, software requirements, user \nstories, or descriptions of supplementary tasks that are needed, such as \narchitecture definition or user documentation.\nProduct owner\nAn individual (or possibly a small group) whose job is to identify \nproduct features or requirements, prioritize these for development, and \ncontinuously review the product backlog to ensure that the project \ncontinues to meet critical business needs. The Product Owner can be a \ncustomer but might also be a product manager in a software company \nor other stakeholder representative.\nScrum\nA daily meeting of the Scrum team that reviews progress and prioritizes \nwork to be done that day. Ideally, this should be a short face-to-face \nmeeting that includes the whole team.\nScrumMaster\nThe ScrumMaster is responsible for ensuring that the Scrum process is \nfollowed and guides the team in the effective use of Scrum. He or she \nis responsible for interfacing with the rest of the company and for \nensuring that the Scrum team is not diverted by outside interference. \nThe Scrum developers are adamant that the ScrumMaster should not \nbe thought of as a project manager. Others, however, may not always \nfind it easy to see the difference.\nSprint\nA development iteration. Sprints are usually 2 to 4 weeks long.\nVelocity\nAn estimate of how much product backlog effort a team can cover in a \nsingle sprint. Understanding a team\u2019s velocity helps them estimate what \ncan be covered in a sprint and provides a basis for measuring \nimproving performance.\nFigure 3.8 Scrum \nterminology\n\n\n86  Chapter 3 \u25a0 Agile software development\npractices such as pair programming and test-first development. This means that it \ncan be more easily integrated with existing practice in a company. Consequently, as \nagile methods have become a mainstream approach to software development, Scrum \nhas emerged as the most widely used method.\nThe Scrum process or sprint cycle is shown in Figure 3.9. The input to the process \nis the product backlog. Each process iteration produces a product increment that \ncould be delivered to customers.\nThe starting point for the Scrum sprint cycle is the product backlog\u2014the list of \nitems such as product features, requirements, and engineering improvement that \nhave to be worked on by the Scrum team. The initial version of the product backlog \nmay be derived from a requirements document, a list of user stories, or other descrip-\ntion of the software to be developed.\nWhile the majority of entries in the product backlog are concerned with the imple-\nmentation of system features, other activities may also be included. Sometimes, when \nplanning an iteration, questions that cannot be easily answered come to light and addi-\ntional work is required to explore possible solutions. The team may carry out some pro-\ntotyping or trial development to understand the problem and solution. There may also be \nbacklog items to design the system architecture or to develop system documentation.\nThe product backlog may be specified at varying levels of detail, and it is the \nresponsibility of the Product Owner to ensure that the level of detail in the specifica-\ntion is appropriate for the work to be done. For example, a backlog item could be a \ncomplete user story such as that shown in Figure 3.5, or it could simply be an instruc-\ntion such as \u201cRefactor user interface code\u201d that leaves it up to the team to decide on \nthe refactoring to be done.\nEach sprint cycle lasts a fixed length of time, which is usually between 2 and 4 weeks. \nAt the beginning of each cycle, the Product Owner prioritizes the items on the product \nbacklog to define which are the most important items to be developed in that cycle. \nSprints are never extended to take account of unfinished work. Items are returned to the \nproduct backlog if these cannot be completed within the allocated time for the sprint.\nThe whole team is then involved in selecting which of the highest priority items \nthey believe can be completed. They then estimate the time required to complete \nthese items. To make these estimates, they use the velocity attained in previous \nReview work \nto be done\nSelect \nitems\nPlan\nsprint\nReview\nsprint\nSprint\nScrum\nProduct\nbacklog\nSprint\nbacklog\nPotentially\nshippable\nsoftware\nFigure 3.9 The Scrum \nsprint cycle"}
{"query": "What is the responsibility of the Product Owner in relation to the product backlog?", "response": "The responsibility of the Product Owner in relation to the product backlog is to identify product features or requirements, prioritize them for development, and continuously review the product backlog to ensure that the project continues to meet critical business needs.", "context": "3.3  \u25a0 Agile project management  85\nthe team. To address this issue, the Scrum agile method was developed (Schwaber \nand Beedle 2001; Rubin 2013) to provide a framework for organizing agile projects \nand, to some extent at least, provide external visibility of what is going on. The devel-\nopers of Scrum wished to make clear that Scrum was not a method for project man-\nagement in the conventional sense, so they deliberately invented new terminology, \nsuch as ScrumMaster, which replaced names such as project manager. Figure 3.8 \nsummarizes Scrum terminology and what it means.\nScrum is an agile method insofar as it follows the principles from the agile mani-\nfesto, which I showed in Figure 3.2. However, it focuses on providing a framework \nfor agile project organization, and it does not mandate the use of specific development \nScrum term\nDefinition\nDevelopment team\nA self-organizing group of software developers, which should be no \nmore than seven people. They are responsible for developing the \nsoftware and other essential project documents.\nPotentially shippable product \nincrement\nThe software increment that is delivered from a sprint. The idea is that \nthis should be \u201cpotentially shippable,\u201d which means that it is in a \nfinished state and no further work, such as testing, is needed to \nincorporate it into the final product. In practice, this is not always \nachievable.\nProduct backlog\nThis is a list of \u201cto do\u201d items that the Scrum team must tackle. They \nmay be feature definitions for the software, software requirements, user \nstories, or descriptions of supplementary tasks that are needed, such as \narchitecture definition or user documentation.\nProduct owner\nAn individual (or possibly a small group) whose job is to identify \nproduct features or requirements, prioritize these for development, and \ncontinuously review the product backlog to ensure that the project \ncontinues to meet critical business needs. The Product Owner can be a \ncustomer but might also be a product manager in a software company \nor other stakeholder representative.\nScrum\nA daily meeting of the Scrum team that reviews progress and prioritizes \nwork to be done that day. Ideally, this should be a short face-to-face \nmeeting that includes the whole team.\nScrumMaster\nThe ScrumMaster is responsible for ensuring that the Scrum process is \nfollowed and guides the team in the effective use of Scrum. He or she \nis responsible for interfacing with the rest of the company and for \nensuring that the Scrum team is not diverted by outside interference. \nThe Scrum developers are adamant that the ScrumMaster should not \nbe thought of as a project manager. Others, however, may not always \nfind it easy to see the difference.\nSprint\nA development iteration. Sprints are usually 2 to 4 weeks long.\nVelocity\nAn estimate of how much product backlog effort a team can cover in a \nsingle sprint. Understanding a team\u2019s velocity helps them estimate what \ncan be covered in a sprint and provides a basis for measuring \nimproving performance.\nFigure 3.8 Scrum \nterminology\n\n\n86  Chapter 3 \u25a0 Agile software development\npractices such as pair programming and test-first development. This means that it \ncan be more easily integrated with existing practice in a company. Consequently, as \nagile methods have become a mainstream approach to software development, Scrum \nhas emerged as the most widely used method.\nThe Scrum process or sprint cycle is shown in Figure 3.9. The input to the process \nis the product backlog. Each process iteration produces a product increment that \ncould be delivered to customers.\nThe starting point for the Scrum sprint cycle is the product backlog\u2014the list of \nitems such as product features, requirements, and engineering improvement that \nhave to be worked on by the Scrum team. The initial version of the product backlog \nmay be derived from a requirements document, a list of user stories, or other descrip-\ntion of the software to be developed.\nWhile the majority of entries in the product backlog are concerned with the imple-\nmentation of system features, other activities may also be included. Sometimes, when \nplanning an iteration, questions that cannot be easily answered come to light and addi-\ntional work is required to explore possible solutions. The team may carry out some pro-\ntotyping or trial development to understand the problem and solution. There may also be \nbacklog items to design the system architecture or to develop system documentation.\nThe product backlog may be specified at varying levels of detail, and it is the \nresponsibility of the Product Owner to ensure that the level of detail in the specifica-\ntion is appropriate for the work to be done. For example, a backlog item could be a \ncomplete user story such as that shown in Figure 3.5, or it could simply be an instruc-\ntion such as \u201cRefactor user interface code\u201d that leaves it up to the team to decide on \nthe refactoring to be done.\nEach sprint cycle lasts a fixed length of time, which is usually between 2 and 4 weeks. \nAt the beginning of each cycle, the Product Owner prioritizes the items on the product \nbacklog to define which are the most important items to be developed in that cycle. \nSprints are never extended to take account of unfinished work. Items are returned to the \nproduct backlog if these cannot be completed within the allocated time for the sprint.\nThe whole team is then involved in selecting which of the highest priority items \nthey believe can be completed. They then estimate the time required to complete \nthese items. To make these estimates, they use the velocity attained in previous \nReview work \nto be done\nSelect \nitems\nPlan\nsprint\nReview\nsprint\nSprint\nScrum\nProduct\nbacklog\nSprint\nbacklog\nPotentially\nshippable\nsoftware\nFigure 3.9 The Scrum \nsprint cycle"}
{"query": "How is the level of detail in the product backlog determined in the Scrum agile method?", "response": "The level of detail in the product backlog in the Scrum agile method is determined by the Product Owner. It is the responsibility of the Product Owner to ensure that the level of detail in the specification is appropriate for the work to be done. The product backlog may be specified at varying levels of detail, ranging from complete user stories to more general instructions.", "context": "3.3  \u25a0 Agile project management  85\nthe team. To address this issue, the Scrum agile method was developed (Schwaber \nand Beedle 2001; Rubin 2013) to provide a framework for organizing agile projects \nand, to some extent at least, provide external visibility of what is going on. The devel-\nopers of Scrum wished to make clear that Scrum was not a method for project man-\nagement in the conventional sense, so they deliberately invented new terminology, \nsuch as ScrumMaster, which replaced names such as project manager. Figure 3.8 \nsummarizes Scrum terminology and what it means.\nScrum is an agile method insofar as it follows the principles from the agile mani-\nfesto, which I showed in Figure 3.2. However, it focuses on providing a framework \nfor agile project organization, and it does not mandate the use of specific development \nScrum term\nDefinition\nDevelopment team\nA self-organizing group of software developers, which should be no \nmore than seven people. They are responsible for developing the \nsoftware and other essential project documents.\nPotentially shippable product \nincrement\nThe software increment that is delivered from a sprint. The idea is that \nthis should be \u201cpotentially shippable,\u201d which means that it is in a \nfinished state and no further work, such as testing, is needed to \nincorporate it into the final product. In practice, this is not always \nachievable.\nProduct backlog\nThis is a list of \u201cto do\u201d items that the Scrum team must tackle. They \nmay be feature definitions for the software, software requirements, user \nstories, or descriptions of supplementary tasks that are needed, such as \narchitecture definition or user documentation.\nProduct owner\nAn individual (or possibly a small group) whose job is to identify \nproduct features or requirements, prioritize these for development, and \ncontinuously review the product backlog to ensure that the project \ncontinues to meet critical business needs. The Product Owner can be a \ncustomer but might also be a product manager in a software company \nor other stakeholder representative.\nScrum\nA daily meeting of the Scrum team that reviews progress and prioritizes \nwork to be done that day. Ideally, this should be a short face-to-face \nmeeting that includes the whole team.\nScrumMaster\nThe ScrumMaster is responsible for ensuring that the Scrum process is \nfollowed and guides the team in the effective use of Scrum. He or she \nis responsible for interfacing with the rest of the company and for \nensuring that the Scrum team is not diverted by outside interference. \nThe Scrum developers are adamant that the ScrumMaster should not \nbe thought of as a project manager. Others, however, may not always \nfind it easy to see the difference.\nSprint\nA development iteration. Sprints are usually 2 to 4 weeks long.\nVelocity\nAn estimate of how much product backlog effort a team can cover in a \nsingle sprint. Understanding a team\u2019s velocity helps them estimate what \ncan be covered in a sprint and provides a basis for measuring \nimproving performance.\nFigure 3.8 Scrum \nterminology\n\n\n86  Chapter 3 \u25a0 Agile software development\npractices such as pair programming and test-first development. This means that it \ncan be more easily integrated with existing practice in a company. Consequently, as \nagile methods have become a mainstream approach to software development, Scrum \nhas emerged as the most widely used method.\nThe Scrum process or sprint cycle is shown in Figure 3.9. The input to the process \nis the product backlog. Each process iteration produces a product increment that \ncould be delivered to customers.\nThe starting point for the Scrum sprint cycle is the product backlog\u2014the list of \nitems such as product features, requirements, and engineering improvement that \nhave to be worked on by the Scrum team. The initial version of the product backlog \nmay be derived from a requirements document, a list of user stories, or other descrip-\ntion of the software to be developed.\nWhile the majority of entries in the product backlog are concerned with the imple-\nmentation of system features, other activities may also be included. Sometimes, when \nplanning an iteration, questions that cannot be easily answered come to light and addi-\ntional work is required to explore possible solutions. The team may carry out some pro-\ntotyping or trial development to understand the problem and solution. There may also be \nbacklog items to design the system architecture or to develop system documentation.\nThe product backlog may be specified at varying levels of detail, and it is the \nresponsibility of the Product Owner to ensure that the level of detail in the specifica-\ntion is appropriate for the work to be done. For example, a backlog item could be a \ncomplete user story such as that shown in Figure 3.5, or it could simply be an instruc-\ntion such as \u201cRefactor user interface code\u201d that leaves it up to the team to decide on \nthe refactoring to be done.\nEach sprint cycle lasts a fixed length of time, which is usually between 2 and 4 weeks. \nAt the beginning of each cycle, the Product Owner prioritizes the items on the product \nbacklog to define which are the most important items to be developed in that cycle. \nSprints are never extended to take account of unfinished work. Items are returned to the \nproduct backlog if these cannot be completed within the allocated time for the sprint.\nThe whole team is then involved in selecting which of the highest priority items \nthey believe can be completed. They then estimate the time required to complete \nthese items. To make these estimates, they use the velocity attained in previous \nReview work \nto be done\nSelect \nitems\nPlan\nsprint\nReview\nsprint\nSprint\nScrum\nProduct\nbacklog\nSprint\nbacklog\nPotentially\nshippable\nsoftware\nFigure 3.9 The Scrum \nsprint cycle"}
{"query": "How does the team decide which items can be completed in a sprint cycle in the Scrum agile method?", "response": "The team in the Scrum agile method decides which items can be completed in a sprint cycle by selecting the highest priority items from the product backlog. They then estimate the time required to complete these items based on the velocity attained in previous sprints.", "context": "3.3  \u25a0 Agile project management  85\nthe team. To address this issue, the Scrum agile method was developed (Schwaber \nand Beedle 2001; Rubin 2013) to provide a framework for organizing agile projects \nand, to some extent at least, provide external visibility of what is going on. The devel-\nopers of Scrum wished to make clear that Scrum was not a method for project man-\nagement in the conventional sense, so they deliberately invented new terminology, \nsuch as ScrumMaster, which replaced names such as project manager. Figure 3.8 \nsummarizes Scrum terminology and what it means.\nScrum is an agile method insofar as it follows the principles from the agile mani-\nfesto, which I showed in Figure 3.2. However, it focuses on providing a framework \nfor agile project organization, and it does not mandate the use of specific development \nScrum term\nDefinition\nDevelopment team\nA self-organizing group of software developers, which should be no \nmore than seven people. They are responsible for developing the \nsoftware and other essential project documents.\nPotentially shippable product \nincrement\nThe software increment that is delivered from a sprint. The idea is that \nthis should be \u201cpotentially shippable,\u201d which means that it is in a \nfinished state and no further work, such as testing, is needed to \nincorporate it into the final product. In practice, this is not always \nachievable.\nProduct backlog\nThis is a list of \u201cto do\u201d items that the Scrum team must tackle. They \nmay be feature definitions for the software, software requirements, user \nstories, or descriptions of supplementary tasks that are needed, such as \narchitecture definition or user documentation.\nProduct owner\nAn individual (or possibly a small group) whose job is to identify \nproduct features or requirements, prioritize these for development, and \ncontinuously review the product backlog to ensure that the project \ncontinues to meet critical business needs. The Product Owner can be a \ncustomer but might also be a product manager in a software company \nor other stakeholder representative.\nScrum\nA daily meeting of the Scrum team that reviews progress and prioritizes \nwork to be done that day. Ideally, this should be a short face-to-face \nmeeting that includes the whole team.\nScrumMaster\nThe ScrumMaster is responsible for ensuring that the Scrum process is \nfollowed and guides the team in the effective use of Scrum. He or she \nis responsible for interfacing with the rest of the company and for \nensuring that the Scrum team is not diverted by outside interference. \nThe Scrum developers are adamant that the ScrumMaster should not \nbe thought of as a project manager. Others, however, may not always \nfind it easy to see the difference.\nSprint\nA development iteration. Sprints are usually 2 to 4 weeks long.\nVelocity\nAn estimate of how much product backlog effort a team can cover in a \nsingle sprint. Understanding a team\u2019s velocity helps them estimate what \ncan be covered in a sprint and provides a basis for measuring \nimproving performance.\nFigure 3.8 Scrum \nterminology\n\n\n86  Chapter 3 \u25a0 Agile software development\npractices such as pair programming and test-first development. This means that it \ncan be more easily integrated with existing practice in a company. Consequently, as \nagile methods have become a mainstream approach to software development, Scrum \nhas emerged as the most widely used method.\nThe Scrum process or sprint cycle is shown in Figure 3.9. The input to the process \nis the product backlog. Each process iteration produces a product increment that \ncould be delivered to customers.\nThe starting point for the Scrum sprint cycle is the product backlog\u2014the list of \nitems such as product features, requirements, and engineering improvement that \nhave to be worked on by the Scrum team. The initial version of the product backlog \nmay be derived from a requirements document, a list of user stories, or other descrip-\ntion of the software to be developed.\nWhile the majority of entries in the product backlog are concerned with the imple-\nmentation of system features, other activities may also be included. Sometimes, when \nplanning an iteration, questions that cannot be easily answered come to light and addi-\ntional work is required to explore possible solutions. The team may carry out some pro-\ntotyping or trial development to understand the problem and solution. There may also be \nbacklog items to design the system architecture or to develop system documentation.\nThe product backlog may be specified at varying levels of detail, and it is the \nresponsibility of the Product Owner to ensure that the level of detail in the specifica-\ntion is appropriate for the work to be done. For example, a backlog item could be a \ncomplete user story such as that shown in Figure 3.5, or it could simply be an instruc-\ntion such as \u201cRefactor user interface code\u201d that leaves it up to the team to decide on \nthe refactoring to be done.\nEach sprint cycle lasts a fixed length of time, which is usually between 2 and 4 weeks. \nAt the beginning of each cycle, the Product Owner prioritizes the items on the product \nbacklog to define which are the most important items to be developed in that cycle. \nSprints are never extended to take account of unfinished work. Items are returned to the \nproduct backlog if these cannot be completed within the allocated time for the sprint.\nThe whole team is then involved in selecting which of the highest priority items \nthey believe can be completed. They then estimate the time required to complete \nthese items. To make these estimates, they use the velocity attained in previous \nReview work \nto be done\nSelect \nitems\nPlan\nsprint\nReview\nsprint\nSprint\nScrum\nProduct\nbacklog\nSprint\nbacklog\nPotentially\nshippable\nsoftware\nFigure 3.9 The Scrum \nsprint cycle"}
{"query": "What happens to items that cannot be completed within the allocated time for the sprint?", "response": "Items that cannot be completed within the allocated time for the sprint are returned to the product backlog.", "context": "3.3  \u25a0 Agile project management  85\nthe team. To address this issue, the Scrum agile method was developed (Schwaber \nand Beedle 2001; Rubin 2013) to provide a framework for organizing agile projects \nand, to some extent at least, provide external visibility of what is going on. The devel-\nopers of Scrum wished to make clear that Scrum was not a method for project man-\nagement in the conventional sense, so they deliberately invented new terminology, \nsuch as ScrumMaster, which replaced names such as project manager. Figure 3.8 \nsummarizes Scrum terminology and what it means.\nScrum is an agile method insofar as it follows the principles from the agile mani-\nfesto, which I showed in Figure 3.2. However, it focuses on providing a framework \nfor agile project organization, and it does not mandate the use of specific development \nScrum term\nDefinition\nDevelopment team\nA self-organizing group of software developers, which should be no \nmore than seven people. They are responsible for developing the \nsoftware and other essential project documents.\nPotentially shippable product \nincrement\nThe software increment that is delivered from a sprint. The idea is that \nthis should be \u201cpotentially shippable,\u201d which means that it is in a \nfinished state and no further work, such as testing, is needed to \nincorporate it into the final product. In practice, this is not always \nachievable.\nProduct backlog\nThis is a list of \u201cto do\u201d items that the Scrum team must tackle. They \nmay be feature definitions for the software, software requirements, user \nstories, or descriptions of supplementary tasks that are needed, such as \narchitecture definition or user documentation.\nProduct owner\nAn individual (or possibly a small group) whose job is to identify \nproduct features or requirements, prioritize these for development, and \ncontinuously review the product backlog to ensure that the project \ncontinues to meet critical business needs. The Product Owner can be a \ncustomer but might also be a product manager in a software company \nor other stakeholder representative.\nScrum\nA daily meeting of the Scrum team that reviews progress and prioritizes \nwork to be done that day. Ideally, this should be a short face-to-face \nmeeting that includes the whole team.\nScrumMaster\nThe ScrumMaster is responsible for ensuring that the Scrum process is \nfollowed and guides the team in the effective use of Scrum. He or she \nis responsible for interfacing with the rest of the company and for \nensuring that the Scrum team is not diverted by outside interference. \nThe Scrum developers are adamant that the ScrumMaster should not \nbe thought of as a project manager. Others, however, may not always \nfind it easy to see the difference.\nSprint\nA development iteration. Sprints are usually 2 to 4 weeks long.\nVelocity\nAn estimate of how much product backlog effort a team can cover in a \nsingle sprint. Understanding a team\u2019s velocity helps them estimate what \ncan be covered in a sprint and provides a basis for measuring \nimproving performance.\nFigure 3.8 Scrum \nterminology\n\n\n86  Chapter 3 \u25a0 Agile software development\npractices such as pair programming and test-first development. This means that it \ncan be more easily integrated with existing practice in a company. Consequently, as \nagile methods have become a mainstream approach to software development, Scrum \nhas emerged as the most widely used method.\nThe Scrum process or sprint cycle is shown in Figure 3.9. The input to the process \nis the product backlog. Each process iteration produces a product increment that \ncould be delivered to customers.\nThe starting point for the Scrum sprint cycle is the product backlog\u2014the list of \nitems such as product features, requirements, and engineering improvement that \nhave to be worked on by the Scrum team. The initial version of the product backlog \nmay be derived from a requirements document, a list of user stories, or other descrip-\ntion of the software to be developed.\nWhile the majority of entries in the product backlog are concerned with the imple-\nmentation of system features, other activities may also be included. Sometimes, when \nplanning an iteration, questions that cannot be easily answered come to light and addi-\ntional work is required to explore possible solutions. The team may carry out some pro-\ntotyping or trial development to understand the problem and solution. There may also be \nbacklog items to design the system architecture or to develop system documentation.\nThe product backlog may be specified at varying levels of detail, and it is the \nresponsibility of the Product Owner to ensure that the level of detail in the specifica-\ntion is appropriate for the work to be done. For example, a backlog item could be a \ncomplete user story such as that shown in Figure 3.5, or it could simply be an instruc-\ntion such as \u201cRefactor user interface code\u201d that leaves it up to the team to decide on \nthe refactoring to be done.\nEach sprint cycle lasts a fixed length of time, which is usually between 2 and 4 weeks. \nAt the beginning of each cycle, the Product Owner prioritizes the items on the product \nbacklog to define which are the most important items to be developed in that cycle. \nSprints are never extended to take account of unfinished work. Items are returned to the \nproduct backlog if these cannot be completed within the allocated time for the sprint.\nThe whole team is then involved in selecting which of the highest priority items \nthey believe can be completed. They then estimate the time required to complete \nthese items. To make these estimates, they use the velocity attained in previous \nReview work \nto be done\nSelect \nitems\nPlan\nsprint\nReview\nsprint\nSprint\nScrum\nProduct\nbacklog\nSprint\nbacklog\nPotentially\nshippable\nsoftware\nFigure 3.9 The Scrum \nsprint cycle"}
{"query": "How is the velocity used in estimating the time required to complete items in the Scrum agile method?", "response": "Velocity is used in estimating the time required to complete items in the Scrum agile method by providing a basis for measuring and improving performance. Understanding a team's velocity helps them estimate what can be covered in a sprint. The team uses the velocity attained in previous sprints to make estimates for the time required to complete items in the current sprint.", "context": "3.3  \u25a0 Agile project management  85\nthe team. To address this issue, the Scrum agile method was developed (Schwaber \nand Beedle 2001; Rubin 2013) to provide a framework for organizing agile projects \nand, to some extent at least, provide external visibility of what is going on. The devel-\nopers of Scrum wished to make clear that Scrum was not a method for project man-\nagement in the conventional sense, so they deliberately invented new terminology, \nsuch as ScrumMaster, which replaced names such as project manager. Figure 3.8 \nsummarizes Scrum terminology and what it means.\nScrum is an agile method insofar as it follows the principles from the agile mani-\nfesto, which I showed in Figure 3.2. However, it focuses on providing a framework \nfor agile project organization, and it does not mandate the use of specific development \nScrum term\nDefinition\nDevelopment team\nA self-organizing group of software developers, which should be no \nmore than seven people. They are responsible for developing the \nsoftware and other essential project documents.\nPotentially shippable product \nincrement\nThe software increment that is delivered from a sprint. The idea is that \nthis should be \u201cpotentially shippable,\u201d which means that it is in a \nfinished state and no further work, such as testing, is needed to \nincorporate it into the final product. In practice, this is not always \nachievable.\nProduct backlog\nThis is a list of \u201cto do\u201d items that the Scrum team must tackle. They \nmay be feature definitions for the software, software requirements, user \nstories, or descriptions of supplementary tasks that are needed, such as \narchitecture definition or user documentation.\nProduct owner\nAn individual (or possibly a small group) whose job is to identify \nproduct features or requirements, prioritize these for development, and \ncontinuously review the product backlog to ensure that the project \ncontinues to meet critical business needs. The Product Owner can be a \ncustomer but might also be a product manager in a software company \nor other stakeholder representative.\nScrum\nA daily meeting of the Scrum team that reviews progress and prioritizes \nwork to be done that day. Ideally, this should be a short face-to-face \nmeeting that includes the whole team.\nScrumMaster\nThe ScrumMaster is responsible for ensuring that the Scrum process is \nfollowed and guides the team in the effective use of Scrum. He or she \nis responsible for interfacing with the rest of the company and for \nensuring that the Scrum team is not diverted by outside interference. \nThe Scrum developers are adamant that the ScrumMaster should not \nbe thought of as a project manager. Others, however, may not always \nfind it easy to see the difference.\nSprint\nA development iteration. Sprints are usually 2 to 4 weeks long.\nVelocity\nAn estimate of how much product backlog effort a team can cover in a \nsingle sprint. Understanding a team\u2019s velocity helps them estimate what \ncan be covered in a sprint and provides a basis for measuring \nimproving performance.\nFigure 3.8 Scrum \nterminology\n\n\n86  Chapter 3 \u25a0 Agile software development\npractices such as pair programming and test-first development. This means that it \ncan be more easily integrated with existing practice in a company. Consequently, as \nagile methods have become a mainstream approach to software development, Scrum \nhas emerged as the most widely used method.\nThe Scrum process or sprint cycle is shown in Figure 3.9. The input to the process \nis the product backlog. Each process iteration produces a product increment that \ncould be delivered to customers.\nThe starting point for the Scrum sprint cycle is the product backlog\u2014the list of \nitems such as product features, requirements, and engineering improvement that \nhave to be worked on by the Scrum team. The initial version of the product backlog \nmay be derived from a requirements document, a list of user stories, or other descrip-\ntion of the software to be developed.\nWhile the majority of entries in the product backlog are concerned with the imple-\nmentation of system features, other activities may also be included. Sometimes, when \nplanning an iteration, questions that cannot be easily answered come to light and addi-\ntional work is required to explore possible solutions. The team may carry out some pro-\ntotyping or trial development to understand the problem and solution. There may also be \nbacklog items to design the system architecture or to develop system documentation.\nThe product backlog may be specified at varying levels of detail, and it is the \nresponsibility of the Product Owner to ensure that the level of detail in the specifica-\ntion is appropriate for the work to be done. For example, a backlog item could be a \ncomplete user story such as that shown in Figure 3.5, or it could simply be an instruc-\ntion such as \u201cRefactor user interface code\u201d that leaves it up to the team to decide on \nthe refactoring to be done.\nEach sprint cycle lasts a fixed length of time, which is usually between 2 and 4 weeks. \nAt the beginning of each cycle, the Product Owner prioritizes the items on the product \nbacklog to define which are the most important items to be developed in that cycle. \nSprints are never extended to take account of unfinished work. Items are returned to the \nproduct backlog if these cannot be completed within the allocated time for the sprint.\nThe whole team is then involved in selecting which of the highest priority items \nthey believe can be completed. They then estimate the time required to complete \nthese items. To make these estimates, they use the velocity attained in previous \nReview work \nto be done\nSelect \nitems\nPlan\nsprint\nReview\nsprint\nSprint\nScrum\nProduct\nbacklog\nSprint\nbacklog\nPotentially\nshippable\nsoftware\nFigure 3.9 The Scrum \nsprint cycle"}
{"query": "What happens at the beginning of each sprint cycle in the Scrum agile method?", "response": "At the beginning of each sprint cycle in the Scrum agile method, the Product Owner prioritizes the items on the product backlog to define which are the most important items to be developed in that cycle. The whole team is then involved in selecting which of the highest priority items they believe can be completed and they estimate the time required to complete these items.", "context": "3.3  \u25a0 Agile project management  85\nthe team. To address this issue, the Scrum agile method was developed (Schwaber \nand Beedle 2001; Rubin 2013) to provide a framework for organizing agile projects \nand, to some extent at least, provide external visibility of what is going on. The devel-\nopers of Scrum wished to make clear that Scrum was not a method for project man-\nagement in the conventional sense, so they deliberately invented new terminology, \nsuch as ScrumMaster, which replaced names such as project manager. Figure 3.8 \nsummarizes Scrum terminology and what it means.\nScrum is an agile method insofar as it follows the principles from the agile mani-\nfesto, which I showed in Figure 3.2. However, it focuses on providing a framework \nfor agile project organization, and it does not mandate the use of specific development \nScrum term\nDefinition\nDevelopment team\nA self-organizing group of software developers, which should be no \nmore than seven people. They are responsible for developing the \nsoftware and other essential project documents.\nPotentially shippable product \nincrement\nThe software increment that is delivered from a sprint. The idea is that \nthis should be \u201cpotentially shippable,\u201d which means that it is in a \nfinished state and no further work, such as testing, is needed to \nincorporate it into the final product. In practice, this is not always \nachievable.\nProduct backlog\nThis is a list of \u201cto do\u201d items that the Scrum team must tackle. They \nmay be feature definitions for the software, software requirements, user \nstories, or descriptions of supplementary tasks that are needed, such as \narchitecture definition or user documentation.\nProduct owner\nAn individual (or possibly a small group) whose job is to identify \nproduct features or requirements, prioritize these for development, and \ncontinuously review the product backlog to ensure that the project \ncontinues to meet critical business needs. The Product Owner can be a \ncustomer but might also be a product manager in a software company \nor other stakeholder representative.\nScrum\nA daily meeting of the Scrum team that reviews progress and prioritizes \nwork to be done that day. Ideally, this should be a short face-to-face \nmeeting that includes the whole team.\nScrumMaster\nThe ScrumMaster is responsible for ensuring that the Scrum process is \nfollowed and guides the team in the effective use of Scrum. He or she \nis responsible for interfacing with the rest of the company and for \nensuring that the Scrum team is not diverted by outside interference. \nThe Scrum developers are adamant that the ScrumMaster should not \nbe thought of as a project manager. Others, however, may not always \nfind it easy to see the difference.\nSprint\nA development iteration. Sprints are usually 2 to 4 weeks long.\nVelocity\nAn estimate of how much product backlog effort a team can cover in a \nsingle sprint. Understanding a team\u2019s velocity helps them estimate what \ncan be covered in a sprint and provides a basis for measuring \nimproving performance.\nFigure 3.8 Scrum \nterminology\n\n\n86  Chapter 3 \u25a0 Agile software development\npractices such as pair programming and test-first development. This means that it \ncan be more easily integrated with existing practice in a company. Consequently, as \nagile methods have become a mainstream approach to software development, Scrum \nhas emerged as the most widely used method.\nThe Scrum process or sprint cycle is shown in Figure 3.9. The input to the process \nis the product backlog. Each process iteration produces a product increment that \ncould be delivered to customers.\nThe starting point for the Scrum sprint cycle is the product backlog\u2014the list of \nitems such as product features, requirements, and engineering improvement that \nhave to be worked on by the Scrum team. The initial version of the product backlog \nmay be derived from a requirements document, a list of user stories, or other descrip-\ntion of the software to be developed.\nWhile the majority of entries in the product backlog are concerned with the imple-\nmentation of system features, other activities may also be included. Sometimes, when \nplanning an iteration, questions that cannot be easily answered come to light and addi-\ntional work is required to explore possible solutions. The team may carry out some pro-\ntotyping or trial development to understand the problem and solution. There may also be \nbacklog items to design the system architecture or to develop system documentation.\nThe product backlog may be specified at varying levels of detail, and it is the \nresponsibility of the Product Owner to ensure that the level of detail in the specifica-\ntion is appropriate for the work to be done. For example, a backlog item could be a \ncomplete user story such as that shown in Figure 3.5, or it could simply be an instruc-\ntion such as \u201cRefactor user interface code\u201d that leaves it up to the team to decide on \nthe refactoring to be done.\nEach sprint cycle lasts a fixed length of time, which is usually between 2 and 4 weeks. \nAt the beginning of each cycle, the Product Owner prioritizes the items on the product \nbacklog to define which are the most important items to be developed in that cycle. \nSprints are never extended to take account of unfinished work. Items are returned to the \nproduct backlog if these cannot be completed within the allocated time for the sprint.\nThe whole team is then involved in selecting which of the highest priority items \nthey believe can be completed. They then estimate the time required to complete \nthese items. To make these estimates, they use the velocity attained in previous \nReview work \nto be done\nSelect \nitems\nPlan\nsprint\nReview\nsprint\nSprint\nScrum\nProduct\nbacklog\nSprint\nbacklog\nPotentially\nshippable\nsoftware\nFigure 3.9 The Scrum \nsprint cycle"}
{"query": "What is the purpose of the sprint backlog in the Scrum agile method?", "response": "The purpose of the sprint backlog in the Scrum agile method is to define the specific items that will be developed and completed during a sprint cycle. It is created by the Scrum team at the beginning of each cycle, based on the prioritized items from the product backlog. The sprint backlog helps the team to plan and track their progress during the sprint, ensuring that they are working on the most important items and that they can deliver a potentially shippable product increment at the end of the sprint.", "context": "3.3  \u25a0 Agile project management  85\nthe team. To address this issue, the Scrum agile method was developed (Schwaber \nand Beedle 2001; Rubin 2013) to provide a framework for organizing agile projects \nand, to some extent at least, provide external visibility of what is going on. The devel-\nopers of Scrum wished to make clear that Scrum was not a method for project man-\nagement in the conventional sense, so they deliberately invented new terminology, \nsuch as ScrumMaster, which replaced names such as project manager. Figure 3.8 \nsummarizes Scrum terminology and what it means.\nScrum is an agile method insofar as it follows the principles from the agile mani-\nfesto, which I showed in Figure 3.2. However, it focuses on providing a framework \nfor agile project organization, and it does not mandate the use of specific development \nScrum term\nDefinition\nDevelopment team\nA self-organizing group of software developers, which should be no \nmore than seven people. They are responsible for developing the \nsoftware and other essential project documents.\nPotentially shippable product \nincrement\nThe software increment that is delivered from a sprint. The idea is that \nthis should be \u201cpotentially shippable,\u201d which means that it is in a \nfinished state and no further work, such as testing, is needed to \nincorporate it into the final product. In practice, this is not always \nachievable.\nProduct backlog\nThis is a list of \u201cto do\u201d items that the Scrum team must tackle. They \nmay be feature definitions for the software, software requirements, user \nstories, or descriptions of supplementary tasks that are needed, such as \narchitecture definition or user documentation.\nProduct owner\nAn individual (or possibly a small group) whose job is to identify \nproduct features or requirements, prioritize these for development, and \ncontinuously review the product backlog to ensure that the project \ncontinues to meet critical business needs. The Product Owner can be a \ncustomer but might also be a product manager in a software company \nor other stakeholder representative.\nScrum\nA daily meeting of the Scrum team that reviews progress and prioritizes \nwork to be done that day. Ideally, this should be a short face-to-face \nmeeting that includes the whole team.\nScrumMaster\nThe ScrumMaster is responsible for ensuring that the Scrum process is \nfollowed and guides the team in the effective use of Scrum. He or she \nis responsible for interfacing with the rest of the company and for \nensuring that the Scrum team is not diverted by outside interference. \nThe Scrum developers are adamant that the ScrumMaster should not \nbe thought of as a project manager. Others, however, may not always \nfind it easy to see the difference.\nSprint\nA development iteration. Sprints are usually 2 to 4 weeks long.\nVelocity\nAn estimate of how much product backlog effort a team can cover in a \nsingle sprint. Understanding a team\u2019s velocity helps them estimate what \ncan be covered in a sprint and provides a basis for measuring \nimproving performance.\nFigure 3.8 Scrum \nterminology\n\n\n86  Chapter 3 \u25a0 Agile software development\npractices such as pair programming and test-first development. This means that it \ncan be more easily integrated with existing practice in a company. Consequently, as \nagile methods have become a mainstream approach to software development, Scrum \nhas emerged as the most widely used method.\nThe Scrum process or sprint cycle is shown in Figure 3.9. The input to the process \nis the product backlog. Each process iteration produces a product increment that \ncould be delivered to customers.\nThe starting point for the Scrum sprint cycle is the product backlog\u2014the list of \nitems such as product features, requirements, and engineering improvement that \nhave to be worked on by the Scrum team. The initial version of the product backlog \nmay be derived from a requirements document, a list of user stories, or other descrip-\ntion of the software to be developed.\nWhile the majority of entries in the product backlog are concerned with the imple-\nmentation of system features, other activities may also be included. Sometimes, when \nplanning an iteration, questions that cannot be easily answered come to light and addi-\ntional work is required to explore possible solutions. The team may carry out some pro-\ntotyping or trial development to understand the problem and solution. There may also be \nbacklog items to design the system architecture or to develop system documentation.\nThe product backlog may be specified at varying levels of detail, and it is the \nresponsibility of the Product Owner to ensure that the level of detail in the specifica-\ntion is appropriate for the work to be done. For example, a backlog item could be a \ncomplete user story such as that shown in Figure 3.5, or it could simply be an instruc-\ntion such as \u201cRefactor user interface code\u201d that leaves it up to the team to decide on \nthe refactoring to be done.\nEach sprint cycle lasts a fixed length of time, which is usually between 2 and 4 weeks. \nAt the beginning of each cycle, the Product Owner prioritizes the items on the product \nbacklog to define which are the most important items to be developed in that cycle. \nSprints are never extended to take account of unfinished work. Items are returned to the \nproduct backlog if these cannot be completed within the allocated time for the sprint.\nThe whole team is then involved in selecting which of the highest priority items \nthey believe can be completed. They then estimate the time required to complete \nthese items. To make these estimates, they use the velocity attained in previous \nReview work \nto be done\nSelect \nitems\nPlan\nsprint\nReview\nsprint\nSprint\nScrum\nProduct\nbacklog\nSprint\nbacklog\nPotentially\nshippable\nsoftware\nFigure 3.9 The Scrum \nsprint cycle"}
{"query": "What is the purpose of the review sprint in the Scrum agile method?", "response": "The purpose of the review sprint in the Scrum agile method is to review the progress made during the sprint and prioritize the work to be done for the next sprint.", "context": "3.3  \u25a0 Agile project management  85\nthe team. To address this issue, the Scrum agile method was developed (Schwaber \nand Beedle 2001; Rubin 2013) to provide a framework for organizing agile projects \nand, to some extent at least, provide external visibility of what is going on. The devel-\nopers of Scrum wished to make clear that Scrum was not a method for project man-\nagement in the conventional sense, so they deliberately invented new terminology, \nsuch as ScrumMaster, which replaced names such as project manager. Figure 3.8 \nsummarizes Scrum terminology and what it means.\nScrum is an agile method insofar as it follows the principles from the agile mani-\nfesto, which I showed in Figure 3.2. However, it focuses on providing a framework \nfor agile project organization, and it does not mandate the use of specific development \nScrum term\nDefinition\nDevelopment team\nA self-organizing group of software developers, which should be no \nmore than seven people. They are responsible for developing the \nsoftware and other essential project documents.\nPotentially shippable product \nincrement\nThe software increment that is delivered from a sprint. The idea is that \nthis should be \u201cpotentially shippable,\u201d which means that it is in a \nfinished state and no further work, such as testing, is needed to \nincorporate it into the final product. In practice, this is not always \nachievable.\nProduct backlog\nThis is a list of \u201cto do\u201d items that the Scrum team must tackle. They \nmay be feature definitions for the software, software requirements, user \nstories, or descriptions of supplementary tasks that are needed, such as \narchitecture definition or user documentation.\nProduct owner\nAn individual (or possibly a small group) whose job is to identify \nproduct features or requirements, prioritize these for development, and \ncontinuously review the product backlog to ensure that the project \ncontinues to meet critical business needs. The Product Owner can be a \ncustomer but might also be a product manager in a software company \nor other stakeholder representative.\nScrum\nA daily meeting of the Scrum team that reviews progress and prioritizes \nwork to be done that day. Ideally, this should be a short face-to-face \nmeeting that includes the whole team.\nScrumMaster\nThe ScrumMaster is responsible for ensuring that the Scrum process is \nfollowed and guides the team in the effective use of Scrum. He or she \nis responsible for interfacing with the rest of the company and for \nensuring that the Scrum team is not diverted by outside interference. \nThe Scrum developers are adamant that the ScrumMaster should not \nbe thought of as a project manager. Others, however, may not always \nfind it easy to see the difference.\nSprint\nA development iteration. Sprints are usually 2 to 4 weeks long.\nVelocity\nAn estimate of how much product backlog effort a team can cover in a \nsingle sprint. Understanding a team\u2019s velocity helps them estimate what \ncan be covered in a sprint and provides a basis for measuring \nimproving performance.\nFigure 3.8 Scrum \nterminology\n\n\n86  Chapter 3 \u25a0 Agile software development\npractices such as pair programming and test-first development. This means that it \ncan be more easily integrated with existing practice in a company. Consequently, as \nagile methods have become a mainstream approach to software development, Scrum \nhas emerged as the most widely used method.\nThe Scrum process or sprint cycle is shown in Figure 3.9. The input to the process \nis the product backlog. Each process iteration produces a product increment that \ncould be delivered to customers.\nThe starting point for the Scrum sprint cycle is the product backlog\u2014the list of \nitems such as product features, requirements, and engineering improvement that \nhave to be worked on by the Scrum team. The initial version of the product backlog \nmay be derived from a requirements document, a list of user stories, or other descrip-\ntion of the software to be developed.\nWhile the majority of entries in the product backlog are concerned with the imple-\nmentation of system features, other activities may also be included. Sometimes, when \nplanning an iteration, questions that cannot be easily answered come to light and addi-\ntional work is required to explore possible solutions. The team may carry out some pro-\ntotyping or trial development to understand the problem and solution. There may also be \nbacklog items to design the system architecture or to develop system documentation.\nThe product backlog may be specified at varying levels of detail, and it is the \nresponsibility of the Product Owner to ensure that the level of detail in the specifica-\ntion is appropriate for the work to be done. For example, a backlog item could be a \ncomplete user story such as that shown in Figure 3.5, or it could simply be an instruc-\ntion such as \u201cRefactor user interface code\u201d that leaves it up to the team to decide on \nthe refactoring to be done.\nEach sprint cycle lasts a fixed length of time, which is usually between 2 and 4 weeks. \nAt the beginning of each cycle, the Product Owner prioritizes the items on the product \nbacklog to define which are the most important items to be developed in that cycle. \nSprints are never extended to take account of unfinished work. Items are returned to the \nproduct backlog if these cannot be completed within the allocated time for the sprint.\nThe whole team is then involved in selecting which of the highest priority items \nthey believe can be completed. They then estimate the time required to complete \nthese items. To make these estimates, they use the velocity attained in previous \nReview work \nto be done\nSelect \nitems\nPlan\nsprint\nReview\nsprint\nSprint\nScrum\nProduct\nbacklog\nSprint\nbacklog\nPotentially\nshippable\nsoftware\nFigure 3.9 The Scrum \nsprint cycle"}
{"query": "How is the potentially shippable software produced in the Scrum agile method?", "response": "The potentially shippable software is produced in the Scrum agile method through the sprint cycle. At the beginning of each sprint cycle, the Product Owner prioritizes the items on the product backlog to define which are the most important items to be developed in that cycle. The team then selects the highest priority items they believe can be completed and estimates the time required to complete them. During the sprint, the team works on developing these items, and at the end of the sprint, they produce a product increment that is potentially shippable. This means that the software is in a finished state and no further work, such as testing, is needed to incorporate it into the final product.", "context": "3.3  \u25a0 Agile project management  85\nthe team. To address this issue, the Scrum agile method was developed (Schwaber \nand Beedle 2001; Rubin 2013) to provide a framework for organizing agile projects \nand, to some extent at least, provide external visibility of what is going on. The devel-\nopers of Scrum wished to make clear that Scrum was not a method for project man-\nagement in the conventional sense, so they deliberately invented new terminology, \nsuch as ScrumMaster, which replaced names such as project manager. Figure 3.8 \nsummarizes Scrum terminology and what it means.\nScrum is an agile method insofar as it follows the principles from the agile mani-\nfesto, which I showed in Figure 3.2. However, it focuses on providing a framework \nfor agile project organization, and it does not mandate the use of specific development \nScrum term\nDefinition\nDevelopment team\nA self-organizing group of software developers, which should be no \nmore than seven people. They are responsible for developing the \nsoftware and other essential project documents.\nPotentially shippable product \nincrement\nThe software increment that is delivered from a sprint. The idea is that \nthis should be \u201cpotentially shippable,\u201d which means that it is in a \nfinished state and no further work, such as testing, is needed to \nincorporate it into the final product. In practice, this is not always \nachievable.\nProduct backlog\nThis is a list of \u201cto do\u201d items that the Scrum team must tackle. They \nmay be feature definitions for the software, software requirements, user \nstories, or descriptions of supplementary tasks that are needed, such as \narchitecture definition or user documentation.\nProduct owner\nAn individual (or possibly a small group) whose job is to identify \nproduct features or requirements, prioritize these for development, and \ncontinuously review the product backlog to ensure that the project \ncontinues to meet critical business needs. The Product Owner can be a \ncustomer but might also be a product manager in a software company \nor other stakeholder representative.\nScrum\nA daily meeting of the Scrum team that reviews progress and prioritizes \nwork to be done that day. Ideally, this should be a short face-to-face \nmeeting that includes the whole team.\nScrumMaster\nThe ScrumMaster is responsible for ensuring that the Scrum process is \nfollowed and guides the team in the effective use of Scrum. He or she \nis responsible for interfacing with the rest of the company and for \nensuring that the Scrum team is not diverted by outside interference. \nThe Scrum developers are adamant that the ScrumMaster should not \nbe thought of as a project manager. Others, however, may not always \nfind it easy to see the difference.\nSprint\nA development iteration. Sprints are usually 2 to 4 weeks long.\nVelocity\nAn estimate of how much product backlog effort a team can cover in a \nsingle sprint. Understanding a team\u2019s velocity helps them estimate what \ncan be covered in a sprint and provides a basis for measuring \nimproving performance.\nFigure 3.8 Scrum \nterminology\n\n\n86  Chapter 3 \u25a0 Agile software development\npractices such as pair programming and test-first development. This means that it \ncan be more easily integrated with existing practice in a company. Consequently, as \nagile methods have become a mainstream approach to software development, Scrum \nhas emerged as the most widely used method.\nThe Scrum process or sprint cycle is shown in Figure 3.9. The input to the process \nis the product backlog. Each process iteration produces a product increment that \ncould be delivered to customers.\nThe starting point for the Scrum sprint cycle is the product backlog\u2014the list of \nitems such as product features, requirements, and engineering improvement that \nhave to be worked on by the Scrum team. The initial version of the product backlog \nmay be derived from a requirements document, a list of user stories, or other descrip-\ntion of the software to be developed.\nWhile the majority of entries in the product backlog are concerned with the imple-\nmentation of system features, other activities may also be included. Sometimes, when \nplanning an iteration, questions that cannot be easily answered come to light and addi-\ntional work is required to explore possible solutions. The team may carry out some pro-\ntotyping or trial development to understand the problem and solution. There may also be \nbacklog items to design the system architecture or to develop system documentation.\nThe product backlog may be specified at varying levels of detail, and it is the \nresponsibility of the Product Owner to ensure that the level of detail in the specifica-\ntion is appropriate for the work to be done. For example, a backlog item could be a \ncomplete user story such as that shown in Figure 3.5, or it could simply be an instruc-\ntion such as \u201cRefactor user interface code\u201d that leaves it up to the team to decide on \nthe refactoring to be done.\nEach sprint cycle lasts a fixed length of time, which is usually between 2 and 4 weeks. \nAt the beginning of each cycle, the Product Owner prioritizes the items on the product \nbacklog to define which are the most important items to be developed in that cycle. \nSprints are never extended to take account of unfinished work. Items are returned to the \nproduct backlog if these cannot be completed within the allocated time for the sprint.\nThe whole team is then involved in selecting which of the highest priority items \nthey believe can be completed. They then estimate the time required to complete \nthese items. To make these estimates, they use the velocity attained in previous \nReview work \nto be done\nSelect \nitems\nPlan\nsprint\nReview\nsprint\nSprint\nScrum\nProduct\nbacklog\nSprint\nbacklog\nPotentially\nshippable\nsoftware\nFigure 3.9 The Scrum \nsprint cycle"}
{"query": "How does the Scrum agile method handle unfinished work at the end of a sprint cycle?", "response": "Items that are not completed within the allocated time for the sprint are returned to the product backlog. The Scrum agile method does not extend sprints to accommodate unfinished work.", "context": "3.3  \u25a0 Agile project management  85\nthe team. To address this issue, the Scrum agile method was developed (Schwaber \nand Beedle 2001; Rubin 2013) to provide a framework for organizing agile projects \nand, to some extent at least, provide external visibility of what is going on. The devel-\nopers of Scrum wished to make clear that Scrum was not a method for project man-\nagement in the conventional sense, so they deliberately invented new terminology, \nsuch as ScrumMaster, which replaced names such as project manager. Figure 3.8 \nsummarizes Scrum terminology and what it means.\nScrum is an agile method insofar as it follows the principles from the agile mani-\nfesto, which I showed in Figure 3.2. However, it focuses on providing a framework \nfor agile project organization, and it does not mandate the use of specific development \nScrum term\nDefinition\nDevelopment team\nA self-organizing group of software developers, which should be no \nmore than seven people. They are responsible for developing the \nsoftware and other essential project documents.\nPotentially shippable product \nincrement\nThe software increment that is delivered from a sprint. The idea is that \nthis should be \u201cpotentially shippable,\u201d which means that it is in a \nfinished state and no further work, such as testing, is needed to \nincorporate it into the final product. In practice, this is not always \nachievable.\nProduct backlog\nThis is a list of \u201cto do\u201d items that the Scrum team must tackle. They \nmay be feature definitions for the software, software requirements, user \nstories, or descriptions of supplementary tasks that are needed, such as \narchitecture definition or user documentation.\nProduct owner\nAn individual (or possibly a small group) whose job is to identify \nproduct features or requirements, prioritize these for development, and \ncontinuously review the product backlog to ensure that the project \ncontinues to meet critical business needs. The Product Owner can be a \ncustomer but might also be a product manager in a software company \nor other stakeholder representative.\nScrum\nA daily meeting of the Scrum team that reviews progress and prioritizes \nwork to be done that day. Ideally, this should be a short face-to-face \nmeeting that includes the whole team.\nScrumMaster\nThe ScrumMaster is responsible for ensuring that the Scrum process is \nfollowed and guides the team in the effective use of Scrum. He or she \nis responsible for interfacing with the rest of the company and for \nensuring that the Scrum team is not diverted by outside interference. \nThe Scrum developers are adamant that the ScrumMaster should not \nbe thought of as a project manager. Others, however, may not always \nfind it easy to see the difference.\nSprint\nA development iteration. Sprints are usually 2 to 4 weeks long.\nVelocity\nAn estimate of how much product backlog effort a team can cover in a \nsingle sprint. Understanding a team\u2019s velocity helps them estimate what \ncan be covered in a sprint and provides a basis for measuring \nimproving performance.\nFigure 3.8 Scrum \nterminology\n\n\n86  Chapter 3 \u25a0 Agile software development\npractices such as pair programming and test-first development. This means that it \ncan be more easily integrated with existing practice in a company. Consequently, as \nagile methods have become a mainstream approach to software development, Scrum \nhas emerged as the most widely used method.\nThe Scrum process or sprint cycle is shown in Figure 3.9. The input to the process \nis the product backlog. Each process iteration produces a product increment that \ncould be delivered to customers.\nThe starting point for the Scrum sprint cycle is the product backlog\u2014the list of \nitems such as product features, requirements, and engineering improvement that \nhave to be worked on by the Scrum team. The initial version of the product backlog \nmay be derived from a requirements document, a list of user stories, or other descrip-\ntion of the software to be developed.\nWhile the majority of entries in the product backlog are concerned with the imple-\nmentation of system features, other activities may also be included. Sometimes, when \nplanning an iteration, questions that cannot be easily answered come to light and addi-\ntional work is required to explore possible solutions. The team may carry out some pro-\ntotyping or trial development to understand the problem and solution. There may also be \nbacklog items to design the system architecture or to develop system documentation.\nThe product backlog may be specified at varying levels of detail, and it is the \nresponsibility of the Product Owner to ensure that the level of detail in the specifica-\ntion is appropriate for the work to be done. For example, a backlog item could be a \ncomplete user story such as that shown in Figure 3.5, or it could simply be an instruc-\ntion such as \u201cRefactor user interface code\u201d that leaves it up to the team to decide on \nthe refactoring to be done.\nEach sprint cycle lasts a fixed length of time, which is usually between 2 and 4 weeks. \nAt the beginning of each cycle, the Product Owner prioritizes the items on the product \nbacklog to define which are the most important items to be developed in that cycle. \nSprints are never extended to take account of unfinished work. Items are returned to the \nproduct backlog if these cannot be completed within the allocated time for the sprint.\nThe whole team is then involved in selecting which of the highest priority items \nthey believe can be completed. They then estimate the time required to complete \nthese items. To make these estimates, they use the velocity attained in previous \nReview work \nto be done\nSelect \nitems\nPlan\nsprint\nReview\nsprint\nSprint\nScrum\nProduct\nbacklog\nSprint\nbacklog\nPotentially\nshippable\nsoftware\nFigure 3.9 The Scrum \nsprint cycle"}
{"query": "What is a sprint in the context of agile project management?", "response": "A sprint in the context of agile project management refers to a time-boxed period during which a team works on a set of tasks from the backlog. It is a short iteration, typically lasting between one to four weeks, in which the team focuses on completing a specific set of work. The sprint begins with the creation of a sprint backlog, which outlines the tasks to be accomplished during that sprint. Throughout the sprint, the team holds daily meetings to review progress, address any issues, and plan for the following day. At the end of the sprint, there is a review meeting to reflect on the team's work and make improvements for future sprints.", "context": "3.3  \u25a0 Agile project management  87\nsprints, that is, how much of the backlog could be covered in a single sprint. This \nleads to the creation of a sprint backlog\u2014the work to be done during that sprint. The \nteam self-organizes to decide who will work on what, and the sprint begins.\nDuring the sprint, the team holds short daily meetings (Scrums) to review pro-\ngress and, where necessary, to re-prioritize work. During the Scrum, all team mem-\nbers share information, describe their progress since the last meeting, bring up \nproblems that have arisen, and state what is planned for the following day. Thus, \neveryone on the team knows what is going on and, if problems arise, can re-plan \nshort-term work to cope with them. Everyone participates in this short-term plan-\nning; there is no top-down direction from the ScrumMaster.\nThe daily interactions among Scrum teams may be coordinated using a Scrum \nboard. This is an office whiteboard that includes information and post-it notes about \nthe Sprint backlog, work done, unavailability of staff, and so on. This is a shared \nresource for the whole team, and anyone can change or move items on the board. It \nmeans that any team member can, at a glance, see what others are doing and what \nwork remains to be done.\nAt the end of each sprint, there is a review meeting, which involves the whole \nteam. This meeting has two purposes. First, it is a means of process improvement. \nThe team reviews the way they have worked and reflects on how things could have \nbeen done better. Second, it provides input on the product and the product state for \nthe product backlog review that precedes the next sprint.\nWhile the ScrumMaster is not formally a project manager, in practice ScrumMasters \ntake this role in many organizations that have a conventional management structure. \nThey report on progress to senior management and are involved in longer-term plan-\nning and project budgeting. They may be involved in project administration (agreeing \non holidays for staff, liaising with HR, etc.) and hardware and software purchases.\nIn various Scrum success stories (Schatz and Abdelshafi 2005; Mulder and van \nVliet 2008; Bellouiti 2009), the things that users like about the Scrum method are:\n1. The product is broken down into a set of manageable and understandable chunks \nthat stakeholders can relate to.\n2. Unstable requirements do not hold up progress.\n3. The whole team has visibility of everything, and consequently team communi-\ncation and morale are improved.\n4. Customers see on-time delivery of increments and gain feedback on how the \nproduct works. They are not faced with last-minute surprises when a team \nannounces that software will not be delivered as expected.\n5. Trust between customers and developers is established, and a positive culture is \ncreated in which everyone expects the project to succeed.\nScrum, as originally designed, was intended for use with co-located teams where \nall team members could get together every day in stand-up meetings. However, \nmuch software development now involves distributed teams, with team members \nlocated in different places around the world. This allows companies to take advantage \n\n\n88  Chapter 3 \u25a0 Agile software development\nof lower cost staff in other countries, makes access to specialist skills possible, and \nallows for 24-hour development, with work going on in different time zones.\nConsequently, there have been developments of Scrum for distributed development \nenvironments and multi-team working. Typically, for offshore development, the prod-\nuct owner is in a different country from the development team, which may also be \ndistributed. Figure 3.10 shows the requirements for Distributed Scrum (Deemer 2011).\n \n3.4  Scaling agile methods\nAgile methods were developed for use by small programming teams that could work \ntogether in the same room and communicate informally. They were originally used \nby for the development of small and medium-sized systems and software products. \nSmall companies, without formal processes or bureaucracy, were enthusiastic initial \nadopters of these methods.\nOf course, the need for faster delivery of software, which is more suited to cus-\ntomer needs, also applies to both larger systems and larger companies. Consequently, \nover the past few years, a lot of work has been put into evolving agile methods for \nboth large software systems and for use in large companies.\nScaling agile methods has closely related facets:\n1. Scaling up these methods to handle the development of large systems that are \ntoo big to be developed by a single small team.\n2. \nScaling out these methods from specialized development teams to more widespread \nuse in a large company that has many years of software development experience.\nVideoconferencing \nbetween the product \nowner and the \ndevelopment team\nDistributed Scrum\nThe ScrumMaster \nshould be located with \nthe development team \nso that he or she is \naware of everyday \nproblems.\nThe Product Owner \nshould visit the \ndevelopers and try to \nestablish a good \nrelationship with them. \nIt is essential that they \ntrust each other.\nReal-time communica-\ntions between team \nmembers for informal \ncommunication, \nparticularly instant \nmessaging and video \ncalls.\nContinuous integration, \nso that all team \nmembers can be aware \nof the state of the \nproduct at any time.\nA common development \nenvironment for all teams\nFigure 3.10 Distributed \nScrum"}
{"query": "How is a sprint backlog created in agile project management?", "response": "The creation of a sprint backlog in agile project management involves determining how much of the backlog can be covered in a single sprint. The team self-organizes to decide who will work on what tasks during the sprint. This sprint backlog represents the work that will be done during that specific sprint.", "context": "3.3  \u25a0 Agile project management  87\nsprints, that is, how much of the backlog could be covered in a single sprint. This \nleads to the creation of a sprint backlog\u2014the work to be done during that sprint. The \nteam self-organizes to decide who will work on what, and the sprint begins.\nDuring the sprint, the team holds short daily meetings (Scrums) to review pro-\ngress and, where necessary, to re-prioritize work. During the Scrum, all team mem-\nbers share information, describe their progress since the last meeting, bring up \nproblems that have arisen, and state what is planned for the following day. Thus, \neveryone on the team knows what is going on and, if problems arise, can re-plan \nshort-term work to cope with them. Everyone participates in this short-term plan-\nning; there is no top-down direction from the ScrumMaster.\nThe daily interactions among Scrum teams may be coordinated using a Scrum \nboard. This is an office whiteboard that includes information and post-it notes about \nthe Sprint backlog, work done, unavailability of staff, and so on. This is a shared \nresource for the whole team, and anyone can change or move items on the board. It \nmeans that any team member can, at a glance, see what others are doing and what \nwork remains to be done.\nAt the end of each sprint, there is a review meeting, which involves the whole \nteam. This meeting has two purposes. First, it is a means of process improvement. \nThe team reviews the way they have worked and reflects on how things could have \nbeen done better. Second, it provides input on the product and the product state for \nthe product backlog review that precedes the next sprint.\nWhile the ScrumMaster is not formally a project manager, in practice ScrumMasters \ntake this role in many organizations that have a conventional management structure. \nThey report on progress to senior management and are involved in longer-term plan-\nning and project budgeting. They may be involved in project administration (agreeing \non holidays for staff, liaising with HR, etc.) and hardware and software purchases.\nIn various Scrum success stories (Schatz and Abdelshafi 2005; Mulder and van \nVliet 2008; Bellouiti 2009), the things that users like about the Scrum method are:\n1. The product is broken down into a set of manageable and understandable chunks \nthat stakeholders can relate to.\n2. Unstable requirements do not hold up progress.\n3. The whole team has visibility of everything, and consequently team communi-\ncation and morale are improved.\n4. Customers see on-time delivery of increments and gain feedback on how the \nproduct works. They are not faced with last-minute surprises when a team \nannounces that software will not be delivered as expected.\n5. Trust between customers and developers is established, and a positive culture is \ncreated in which everyone expects the project to succeed.\nScrum, as originally designed, was intended for use with co-located teams where \nall team members could get together every day in stand-up meetings. However, \nmuch software development now involves distributed teams, with team members \nlocated in different places around the world. This allows companies to take advantage \n\n\n88  Chapter 3 \u25a0 Agile software development\nof lower cost staff in other countries, makes access to specialist skills possible, and \nallows for 24-hour development, with work going on in different time zones.\nConsequently, there have been developments of Scrum for distributed development \nenvironments and multi-team working. Typically, for offshore development, the prod-\nuct owner is in a different country from the development team, which may also be \ndistributed. Figure 3.10 shows the requirements for Distributed Scrum (Deemer 2011).\n \n3.4  Scaling agile methods\nAgile methods were developed for use by small programming teams that could work \ntogether in the same room and communicate informally. They were originally used \nby for the development of small and medium-sized systems and software products. \nSmall companies, without formal processes or bureaucracy, were enthusiastic initial \nadopters of these methods.\nOf course, the need for faster delivery of software, which is more suited to cus-\ntomer needs, also applies to both larger systems and larger companies. Consequently, \nover the past few years, a lot of work has been put into evolving agile methods for \nboth large software systems and for use in large companies.\nScaling agile methods has closely related facets:\n1. Scaling up these methods to handle the development of large systems that are \ntoo big to be developed by a single small team.\n2. \nScaling out these methods from specialized development teams to more widespread \nuse in a large company that has many years of software development experience.\nVideoconferencing \nbetween the product \nowner and the \ndevelopment team\nDistributed Scrum\nThe ScrumMaster \nshould be located with \nthe development team \nso that he or she is \naware of everyday \nproblems.\nThe Product Owner \nshould visit the \ndevelopers and try to \nestablish a good \nrelationship with them. \nIt is essential that they \ntrust each other.\nReal-time communica-\ntions between team \nmembers for informal \ncommunication, \nparticularly instant \nmessaging and video \ncalls.\nContinuous integration, \nso that all team \nmembers can be aware \nof the state of the \nproduct at any time.\nA common development \nenvironment for all teams\nFigure 3.10 Distributed \nScrum"}
{"query": "What is the purpose of daily meetings or Scrums in agile project management?", "response": "The purpose of daily meetings or Scrums in agile project management is to review progress, share information, discuss any problems that have arisen, and plan for the following day. These meetings allow all team members to stay informed about the project's status and make any necessary adjustments to their short-term plans.", "context": "3.3  \u25a0 Agile project management  87\nsprints, that is, how much of the backlog could be covered in a single sprint. This \nleads to the creation of a sprint backlog\u2014the work to be done during that sprint. The \nteam self-organizes to decide who will work on what, and the sprint begins.\nDuring the sprint, the team holds short daily meetings (Scrums) to review pro-\ngress and, where necessary, to re-prioritize work. During the Scrum, all team mem-\nbers share information, describe their progress since the last meeting, bring up \nproblems that have arisen, and state what is planned for the following day. Thus, \neveryone on the team knows what is going on and, if problems arise, can re-plan \nshort-term work to cope with them. Everyone participates in this short-term plan-\nning; there is no top-down direction from the ScrumMaster.\nThe daily interactions among Scrum teams may be coordinated using a Scrum \nboard. This is an office whiteboard that includes information and post-it notes about \nthe Sprint backlog, work done, unavailability of staff, and so on. This is a shared \nresource for the whole team, and anyone can change or move items on the board. It \nmeans that any team member can, at a glance, see what others are doing and what \nwork remains to be done.\nAt the end of each sprint, there is a review meeting, which involves the whole \nteam. This meeting has two purposes. First, it is a means of process improvement. \nThe team reviews the way they have worked and reflects on how things could have \nbeen done better. Second, it provides input on the product and the product state for \nthe product backlog review that precedes the next sprint.\nWhile the ScrumMaster is not formally a project manager, in practice ScrumMasters \ntake this role in many organizations that have a conventional management structure. \nThey report on progress to senior management and are involved in longer-term plan-\nning and project budgeting. They may be involved in project administration (agreeing \non holidays for staff, liaising with HR, etc.) and hardware and software purchases.\nIn various Scrum success stories (Schatz and Abdelshafi 2005; Mulder and van \nVliet 2008; Bellouiti 2009), the things that users like about the Scrum method are:\n1. The product is broken down into a set of manageable and understandable chunks \nthat stakeholders can relate to.\n2. Unstable requirements do not hold up progress.\n3. The whole team has visibility of everything, and consequently team communi-\ncation and morale are improved.\n4. Customers see on-time delivery of increments and gain feedback on how the \nproduct works. They are not faced with last-minute surprises when a team \nannounces that software will not be delivered as expected.\n5. Trust between customers and developers is established, and a positive culture is \ncreated in which everyone expects the project to succeed.\nScrum, as originally designed, was intended for use with co-located teams where \nall team members could get together every day in stand-up meetings. However, \nmuch software development now involves distributed teams, with team members \nlocated in different places around the world. This allows companies to take advantage \n\n\n88  Chapter 3 \u25a0 Agile software development\nof lower cost staff in other countries, makes access to specialist skills possible, and \nallows for 24-hour development, with work going on in different time zones.\nConsequently, there have been developments of Scrum for distributed development \nenvironments and multi-team working. Typically, for offshore development, the prod-\nuct owner is in a different country from the development team, which may also be \ndistributed. Figure 3.10 shows the requirements for Distributed Scrum (Deemer 2011).\n \n3.4  Scaling agile methods\nAgile methods were developed for use by small programming teams that could work \ntogether in the same room and communicate informally. They were originally used \nby for the development of small and medium-sized systems and software products. \nSmall companies, without formal processes or bureaucracy, were enthusiastic initial \nadopters of these methods.\nOf course, the need for faster delivery of software, which is more suited to cus-\ntomer needs, also applies to both larger systems and larger companies. Consequently, \nover the past few years, a lot of work has been put into evolving agile methods for \nboth large software systems and for use in large companies.\nScaling agile methods has closely related facets:\n1. Scaling up these methods to handle the development of large systems that are \ntoo big to be developed by a single small team.\n2. \nScaling out these methods from specialized development teams to more widespread \nuse in a large company that has many years of software development experience.\nVideoconferencing \nbetween the product \nowner and the \ndevelopment team\nDistributed Scrum\nThe ScrumMaster \nshould be located with \nthe development team \nso that he or she is \naware of everyday \nproblems.\nThe Product Owner \nshould visit the \ndevelopers and try to \nestablish a good \nrelationship with them. \nIt is essential that they \ntrust each other.\nReal-time communica-\ntions between team \nmembers for informal \ncommunication, \nparticularly instant \nmessaging and video \ncalls.\nContinuous integration, \nso that all team \nmembers can be aware \nof the state of the \nproduct at any time.\nA common development \nenvironment for all teams\nFigure 3.10 Distributed \nScrum"}
{"query": "What is the role of a ScrumMaster in agile project management?", "response": "The ScrumMaster in agile project management plays a crucial role in facilitating the Scrum process. They are responsible for ensuring that the Scrum team adheres to the principles and practices of Scrum. The ScrumMaster acts as a servant-leader, supporting the team and removing any obstacles or impediments that may hinder their progress. They also facilitate the daily Scrum meetings, where team members share progress, discuss any issues, and plan for the following day. Additionally, the ScrumMaster may take on project management responsibilities, such as reporting progress to senior management, participating in long-term planning, and managing project administration tasks.", "context": "3.3  \u25a0 Agile project management  87\nsprints, that is, how much of the backlog could be covered in a single sprint. This \nleads to the creation of a sprint backlog\u2014the work to be done during that sprint. The \nteam self-organizes to decide who will work on what, and the sprint begins.\nDuring the sprint, the team holds short daily meetings (Scrums) to review pro-\ngress and, where necessary, to re-prioritize work. During the Scrum, all team mem-\nbers share information, describe their progress since the last meeting, bring up \nproblems that have arisen, and state what is planned for the following day. Thus, \neveryone on the team knows what is going on and, if problems arise, can re-plan \nshort-term work to cope with them. Everyone participates in this short-term plan-\nning; there is no top-down direction from the ScrumMaster.\nThe daily interactions among Scrum teams may be coordinated using a Scrum \nboard. This is an office whiteboard that includes information and post-it notes about \nthe Sprint backlog, work done, unavailability of staff, and so on. This is a shared \nresource for the whole team, and anyone can change or move items on the board. It \nmeans that any team member can, at a glance, see what others are doing and what \nwork remains to be done.\nAt the end of each sprint, there is a review meeting, which involves the whole \nteam. This meeting has two purposes. First, it is a means of process improvement. \nThe team reviews the way they have worked and reflects on how things could have \nbeen done better. Second, it provides input on the product and the product state for \nthe product backlog review that precedes the next sprint.\nWhile the ScrumMaster is not formally a project manager, in practice ScrumMasters \ntake this role in many organizations that have a conventional management structure. \nThey report on progress to senior management and are involved in longer-term plan-\nning and project budgeting. They may be involved in project administration (agreeing \non holidays for staff, liaising with HR, etc.) and hardware and software purchases.\nIn various Scrum success stories (Schatz and Abdelshafi 2005; Mulder and van \nVliet 2008; Bellouiti 2009), the things that users like about the Scrum method are:\n1. The product is broken down into a set of manageable and understandable chunks \nthat stakeholders can relate to.\n2. Unstable requirements do not hold up progress.\n3. The whole team has visibility of everything, and consequently team communi-\ncation and morale are improved.\n4. Customers see on-time delivery of increments and gain feedback on how the \nproduct works. They are not faced with last-minute surprises when a team \nannounces that software will not be delivered as expected.\n5. Trust between customers and developers is established, and a positive culture is \ncreated in which everyone expects the project to succeed.\nScrum, as originally designed, was intended for use with co-located teams where \nall team members could get together every day in stand-up meetings. However, \nmuch software development now involves distributed teams, with team members \nlocated in different places around the world. This allows companies to take advantage \n\n\n88  Chapter 3 \u25a0 Agile software development\nof lower cost staff in other countries, makes access to specialist skills possible, and \nallows for 24-hour development, with work going on in different time zones.\nConsequently, there have been developments of Scrum for distributed development \nenvironments and multi-team working. Typically, for offshore development, the prod-\nuct owner is in a different country from the development team, which may also be \ndistributed. Figure 3.10 shows the requirements for Distributed Scrum (Deemer 2011).\n \n3.4  Scaling agile methods\nAgile methods were developed for use by small programming teams that could work \ntogether in the same room and communicate informally. They were originally used \nby for the development of small and medium-sized systems and software products. \nSmall companies, without formal processes or bureaucracy, were enthusiastic initial \nadopters of these methods.\nOf course, the need for faster delivery of software, which is more suited to cus-\ntomer needs, also applies to both larger systems and larger companies. Consequently, \nover the past few years, a lot of work has been put into evolving agile methods for \nboth large software systems and for use in large companies.\nScaling agile methods has closely related facets:\n1. Scaling up these methods to handle the development of large systems that are \ntoo big to be developed by a single small team.\n2. \nScaling out these methods from specialized development teams to more widespread \nuse in a large company that has many years of software development experience.\nVideoconferencing \nbetween the product \nowner and the \ndevelopment team\nDistributed Scrum\nThe ScrumMaster \nshould be located with \nthe development team \nso that he or she is \naware of everyday \nproblems.\nThe Product Owner \nshould visit the \ndevelopers and try to \nestablish a good \nrelationship with them. \nIt is essential that they \ntrust each other.\nReal-time communica-\ntions between team \nmembers for informal \ncommunication, \nparticularly instant \nmessaging and video \ncalls.\nContinuous integration, \nso that all team \nmembers can be aware \nof the state of the \nproduct at any time.\nA common development \nenvironment for all teams\nFigure 3.10 Distributed \nScrum"}
{"query": "What is a Scrum board and how is it used in agile project management?", "response": "A Scrum board is an office whiteboard that is used in agile project management. It serves as a shared resource for the whole team and includes information and post-it notes about the sprint backlog, work done, unavailability of staff, and other relevant details. The Scrum board allows team members to have visibility into what others are doing and what work remains to be done. It facilitates communication and collaboration within the team, as anyone can change or move items on the board. This visual representation helps the team to track progress, identify bottlenecks, and make informed decisions during the sprint.", "context": "3.3  \u25a0 Agile project management  87\nsprints, that is, how much of the backlog could be covered in a single sprint. This \nleads to the creation of a sprint backlog\u2014the work to be done during that sprint. The \nteam self-organizes to decide who will work on what, and the sprint begins.\nDuring the sprint, the team holds short daily meetings (Scrums) to review pro-\ngress and, where necessary, to re-prioritize work. During the Scrum, all team mem-\nbers share information, describe their progress since the last meeting, bring up \nproblems that have arisen, and state what is planned for the following day. Thus, \neveryone on the team knows what is going on and, if problems arise, can re-plan \nshort-term work to cope with them. Everyone participates in this short-term plan-\nning; there is no top-down direction from the ScrumMaster.\nThe daily interactions among Scrum teams may be coordinated using a Scrum \nboard. This is an office whiteboard that includes information and post-it notes about \nthe Sprint backlog, work done, unavailability of staff, and so on. This is a shared \nresource for the whole team, and anyone can change or move items on the board. It \nmeans that any team member can, at a glance, see what others are doing and what \nwork remains to be done.\nAt the end of each sprint, there is a review meeting, which involves the whole \nteam. This meeting has two purposes. First, it is a means of process improvement. \nThe team reviews the way they have worked and reflects on how things could have \nbeen done better. Second, it provides input on the product and the product state for \nthe product backlog review that precedes the next sprint.\nWhile the ScrumMaster is not formally a project manager, in practice ScrumMasters \ntake this role in many organizations that have a conventional management structure. \nThey report on progress to senior management and are involved in longer-term plan-\nning and project budgeting. They may be involved in project administration (agreeing \non holidays for staff, liaising with HR, etc.) and hardware and software purchases.\nIn various Scrum success stories (Schatz and Abdelshafi 2005; Mulder and van \nVliet 2008; Bellouiti 2009), the things that users like about the Scrum method are:\n1. The product is broken down into a set of manageable and understandable chunks \nthat stakeholders can relate to.\n2. Unstable requirements do not hold up progress.\n3. The whole team has visibility of everything, and consequently team communi-\ncation and morale are improved.\n4. Customers see on-time delivery of increments and gain feedback on how the \nproduct works. They are not faced with last-minute surprises when a team \nannounces that software will not be delivered as expected.\n5. Trust between customers and developers is established, and a positive culture is \ncreated in which everyone expects the project to succeed.\nScrum, as originally designed, was intended for use with co-located teams where \nall team members could get together every day in stand-up meetings. However, \nmuch software development now involves distributed teams, with team members \nlocated in different places around the world. This allows companies to take advantage \n\n\n88  Chapter 3 \u25a0 Agile software development\nof lower cost staff in other countries, makes access to specialist skills possible, and \nallows for 24-hour development, with work going on in different time zones.\nConsequently, there have been developments of Scrum for distributed development \nenvironments and multi-team working. Typically, for offshore development, the prod-\nuct owner is in a different country from the development team, which may also be \ndistributed. Figure 3.10 shows the requirements for Distributed Scrum (Deemer 2011).\n \n3.4  Scaling agile methods\nAgile methods were developed for use by small programming teams that could work \ntogether in the same room and communicate informally. They were originally used \nby for the development of small and medium-sized systems and software products. \nSmall companies, without formal processes or bureaucracy, were enthusiastic initial \nadopters of these methods.\nOf course, the need for faster delivery of software, which is more suited to cus-\ntomer needs, also applies to both larger systems and larger companies. Consequently, \nover the past few years, a lot of work has been put into evolving agile methods for \nboth large software systems and for use in large companies.\nScaling agile methods has closely related facets:\n1. Scaling up these methods to handle the development of large systems that are \ntoo big to be developed by a single small team.\n2. \nScaling out these methods from specialized development teams to more widespread \nuse in a large company that has many years of software development experience.\nVideoconferencing \nbetween the product \nowner and the \ndevelopment team\nDistributed Scrum\nThe ScrumMaster \nshould be located with \nthe development team \nso that he or she is \naware of everyday \nproblems.\nThe Product Owner \nshould visit the \ndevelopers and try to \nestablish a good \nrelationship with them. \nIt is essential that they \ntrust each other.\nReal-time communica-\ntions between team \nmembers for informal \ncommunication, \nparticularly instant \nmessaging and video \ncalls.\nContinuous integration, \nso that all team \nmembers can be aware \nof the state of the \nproduct at any time.\nA common development \nenvironment for all teams\nFigure 3.10 Distributed \nScrum"}
{"query": "What are the two purposes of a review meeting at the end of each sprint in agile project management?", "response": "The two purposes of a review meeting at the end of each sprint in agile project management are process improvement and providing input on the product and the product state for the product backlog review that precedes the next sprint.", "context": "3.3  \u25a0 Agile project management  87\nsprints, that is, how much of the backlog could be covered in a single sprint. This \nleads to the creation of a sprint backlog\u2014the work to be done during that sprint. The \nteam self-organizes to decide who will work on what, and the sprint begins.\nDuring the sprint, the team holds short daily meetings (Scrums) to review pro-\ngress and, where necessary, to re-prioritize work. During the Scrum, all team mem-\nbers share information, describe their progress since the last meeting, bring up \nproblems that have arisen, and state what is planned for the following day. Thus, \neveryone on the team knows what is going on and, if problems arise, can re-plan \nshort-term work to cope with them. Everyone participates in this short-term plan-\nning; there is no top-down direction from the ScrumMaster.\nThe daily interactions among Scrum teams may be coordinated using a Scrum \nboard. This is an office whiteboard that includes information and post-it notes about \nthe Sprint backlog, work done, unavailability of staff, and so on. This is a shared \nresource for the whole team, and anyone can change or move items on the board. It \nmeans that any team member can, at a glance, see what others are doing and what \nwork remains to be done.\nAt the end of each sprint, there is a review meeting, which involves the whole \nteam. This meeting has two purposes. First, it is a means of process improvement. \nThe team reviews the way they have worked and reflects on how things could have \nbeen done better. Second, it provides input on the product and the product state for \nthe product backlog review that precedes the next sprint.\nWhile the ScrumMaster is not formally a project manager, in practice ScrumMasters \ntake this role in many organizations that have a conventional management structure. \nThey report on progress to senior management and are involved in longer-term plan-\nning and project budgeting. They may be involved in project administration (agreeing \non holidays for staff, liaising with HR, etc.) and hardware and software purchases.\nIn various Scrum success stories (Schatz and Abdelshafi 2005; Mulder and van \nVliet 2008; Bellouiti 2009), the things that users like about the Scrum method are:\n1. The product is broken down into a set of manageable and understandable chunks \nthat stakeholders can relate to.\n2. Unstable requirements do not hold up progress.\n3. The whole team has visibility of everything, and consequently team communi-\ncation and morale are improved.\n4. Customers see on-time delivery of increments and gain feedback on how the \nproduct works. They are not faced with last-minute surprises when a team \nannounces that software will not be delivered as expected.\n5. Trust between customers and developers is established, and a positive culture is \ncreated in which everyone expects the project to succeed.\nScrum, as originally designed, was intended for use with co-located teams where \nall team members could get together every day in stand-up meetings. However, \nmuch software development now involves distributed teams, with team members \nlocated in different places around the world. This allows companies to take advantage \n\n\n88  Chapter 3 \u25a0 Agile software development\nof lower cost staff in other countries, makes access to specialist skills possible, and \nallows for 24-hour development, with work going on in different time zones.\nConsequently, there have been developments of Scrum for distributed development \nenvironments and multi-team working. Typically, for offshore development, the prod-\nuct owner is in a different country from the development team, which may also be \ndistributed. Figure 3.10 shows the requirements for Distributed Scrum (Deemer 2011).\n \n3.4  Scaling agile methods\nAgile methods were developed for use by small programming teams that could work \ntogether in the same room and communicate informally. They were originally used \nby for the development of small and medium-sized systems and software products. \nSmall companies, without formal processes or bureaucracy, were enthusiastic initial \nadopters of these methods.\nOf course, the need for faster delivery of software, which is more suited to cus-\ntomer needs, also applies to both larger systems and larger companies. Consequently, \nover the past few years, a lot of work has been put into evolving agile methods for \nboth large software systems and for use in large companies.\nScaling agile methods has closely related facets:\n1. Scaling up these methods to handle the development of large systems that are \ntoo big to be developed by a single small team.\n2. \nScaling out these methods from specialized development teams to more widespread \nuse in a large company that has many years of software development experience.\nVideoconferencing \nbetween the product \nowner and the \ndevelopment team\nDistributed Scrum\nThe ScrumMaster \nshould be located with \nthe development team \nso that he or she is \naware of everyday \nproblems.\nThe Product Owner \nshould visit the \ndevelopers and try to \nestablish a good \nrelationship with them. \nIt is essential that they \ntrust each other.\nReal-time communica-\ntions between team \nmembers for informal \ncommunication, \nparticularly instant \nmessaging and video \ncalls.\nContinuous integration, \nso that all team \nmembers can be aware \nof the state of the \nproduct at any time.\nA common development \nenvironment for all teams\nFigure 3.10 Distributed \nScrum"}
{"query": "How does the Scrum method improve team communication and morale?", "response": "The Scrum method improves team communication and morale by providing the whole team with visibility of everything. This means that team members can easily see what others are doing and what work remains to be done. As a result, team communication is enhanced as everyone knows what is going on and can collaborate effectively. Additionally, this visibility fosters a positive culture within the team, where everyone expects the project to succeed. This positive culture helps to boost team morale and create a sense of trust and camaraderie among team members.", "context": "3.3  \u25a0 Agile project management  87\nsprints, that is, how much of the backlog could be covered in a single sprint. This \nleads to the creation of a sprint backlog\u2014the work to be done during that sprint. The \nteam self-organizes to decide who will work on what, and the sprint begins.\nDuring the sprint, the team holds short daily meetings (Scrums) to review pro-\ngress and, where necessary, to re-prioritize work. During the Scrum, all team mem-\nbers share information, describe their progress since the last meeting, bring up \nproblems that have arisen, and state what is planned for the following day. Thus, \neveryone on the team knows what is going on and, if problems arise, can re-plan \nshort-term work to cope with them. Everyone participates in this short-term plan-\nning; there is no top-down direction from the ScrumMaster.\nThe daily interactions among Scrum teams may be coordinated using a Scrum \nboard. This is an office whiteboard that includes information and post-it notes about \nthe Sprint backlog, work done, unavailability of staff, and so on. This is a shared \nresource for the whole team, and anyone can change or move items on the board. It \nmeans that any team member can, at a glance, see what others are doing and what \nwork remains to be done.\nAt the end of each sprint, there is a review meeting, which involves the whole \nteam. This meeting has two purposes. First, it is a means of process improvement. \nThe team reviews the way they have worked and reflects on how things could have \nbeen done better. Second, it provides input on the product and the product state for \nthe product backlog review that precedes the next sprint.\nWhile the ScrumMaster is not formally a project manager, in practice ScrumMasters \ntake this role in many organizations that have a conventional management structure. \nThey report on progress to senior management and are involved in longer-term plan-\nning and project budgeting. They may be involved in project administration (agreeing \non holidays for staff, liaising with HR, etc.) and hardware and software purchases.\nIn various Scrum success stories (Schatz and Abdelshafi 2005; Mulder and van \nVliet 2008; Bellouiti 2009), the things that users like about the Scrum method are:\n1. The product is broken down into a set of manageable and understandable chunks \nthat stakeholders can relate to.\n2. Unstable requirements do not hold up progress.\n3. The whole team has visibility of everything, and consequently team communi-\ncation and morale are improved.\n4. Customers see on-time delivery of increments and gain feedback on how the \nproduct works. They are not faced with last-minute surprises when a team \nannounces that software will not be delivered as expected.\n5. Trust between customers and developers is established, and a positive culture is \ncreated in which everyone expects the project to succeed.\nScrum, as originally designed, was intended for use with co-located teams where \nall team members could get together every day in stand-up meetings. However, \nmuch software development now involves distributed teams, with team members \nlocated in different places around the world. This allows companies to take advantage \n\n\n88  Chapter 3 \u25a0 Agile software development\nof lower cost staff in other countries, makes access to specialist skills possible, and \nallows for 24-hour development, with work going on in different time zones.\nConsequently, there have been developments of Scrum for distributed development \nenvironments and multi-team working. Typically, for offshore development, the prod-\nuct owner is in a different country from the development team, which may also be \ndistributed. Figure 3.10 shows the requirements for Distributed Scrum (Deemer 2011).\n \n3.4  Scaling agile methods\nAgile methods were developed for use by small programming teams that could work \ntogether in the same room and communicate informally. They were originally used \nby for the development of small and medium-sized systems and software products. \nSmall companies, without formal processes or bureaucracy, were enthusiastic initial \nadopters of these methods.\nOf course, the need for faster delivery of software, which is more suited to cus-\ntomer needs, also applies to both larger systems and larger companies. Consequently, \nover the past few years, a lot of work has been put into evolving agile methods for \nboth large software systems and for use in large companies.\nScaling agile methods has closely related facets:\n1. Scaling up these methods to handle the development of large systems that are \ntoo big to be developed by a single small team.\n2. \nScaling out these methods from specialized development teams to more widespread \nuse in a large company that has many years of software development experience.\nVideoconferencing \nbetween the product \nowner and the \ndevelopment team\nDistributed Scrum\nThe ScrumMaster \nshould be located with \nthe development team \nso that he or she is \naware of everyday \nproblems.\nThe Product Owner \nshould visit the \ndevelopers and try to \nestablish a good \nrelationship with them. \nIt is essential that they \ntrust each other.\nReal-time communica-\ntions between team \nmembers for informal \ncommunication, \nparticularly instant \nmessaging and video \ncalls.\nContinuous integration, \nso that all team \nmembers can be aware \nof the state of the \nproduct at any time.\nA common development \nenvironment for all teams\nFigure 3.10 Distributed \nScrum"}
{"query": "How does the Scrum method help in establishing trust between customers and developers?", "response": "The Scrum method helps in establishing trust between customers and developers by providing transparency and visibility throughout the project. With Scrum, the whole team has visibility of everything, including the progress of the project and the work that remains to be done. This transparency allows customers to see on-time delivery of increments and gain feedback on how the product works. They are not faced with last-minute surprises when a team announces that software will not be delivered as expected. This transparency and predictability build trust between customers and developers, creating a positive culture in which everyone expects the project to succeed.", "context": "3.3  \u25a0 Agile project management  87\nsprints, that is, how much of the backlog could be covered in a single sprint. This \nleads to the creation of a sprint backlog\u2014the work to be done during that sprint. The \nteam self-organizes to decide who will work on what, and the sprint begins.\nDuring the sprint, the team holds short daily meetings (Scrums) to review pro-\ngress and, where necessary, to re-prioritize work. During the Scrum, all team mem-\nbers share information, describe their progress since the last meeting, bring up \nproblems that have arisen, and state what is planned for the following day. Thus, \neveryone on the team knows what is going on and, if problems arise, can re-plan \nshort-term work to cope with them. Everyone participates in this short-term plan-\nning; there is no top-down direction from the ScrumMaster.\nThe daily interactions among Scrum teams may be coordinated using a Scrum \nboard. This is an office whiteboard that includes information and post-it notes about \nthe Sprint backlog, work done, unavailability of staff, and so on. This is a shared \nresource for the whole team, and anyone can change or move items on the board. It \nmeans that any team member can, at a glance, see what others are doing and what \nwork remains to be done.\nAt the end of each sprint, there is a review meeting, which involves the whole \nteam. This meeting has two purposes. First, it is a means of process improvement. \nThe team reviews the way they have worked and reflects on how things could have \nbeen done better. Second, it provides input on the product and the product state for \nthe product backlog review that precedes the next sprint.\nWhile the ScrumMaster is not formally a project manager, in practice ScrumMasters \ntake this role in many organizations that have a conventional management structure. \nThey report on progress to senior management and are involved in longer-term plan-\nning and project budgeting. They may be involved in project administration (agreeing \non holidays for staff, liaising with HR, etc.) and hardware and software purchases.\nIn various Scrum success stories (Schatz and Abdelshafi 2005; Mulder and van \nVliet 2008; Bellouiti 2009), the things that users like about the Scrum method are:\n1. The product is broken down into a set of manageable and understandable chunks \nthat stakeholders can relate to.\n2. Unstable requirements do not hold up progress.\n3. The whole team has visibility of everything, and consequently team communi-\ncation and morale are improved.\n4. Customers see on-time delivery of increments and gain feedback on how the \nproduct works. They are not faced with last-minute surprises when a team \nannounces that software will not be delivered as expected.\n5. Trust between customers and developers is established, and a positive culture is \ncreated in which everyone expects the project to succeed.\nScrum, as originally designed, was intended for use with co-located teams where \nall team members could get together every day in stand-up meetings. However, \nmuch software development now involves distributed teams, with team members \nlocated in different places around the world. This allows companies to take advantage \n\n\n88  Chapter 3 \u25a0 Agile software development\nof lower cost staff in other countries, makes access to specialist skills possible, and \nallows for 24-hour development, with work going on in different time zones.\nConsequently, there have been developments of Scrum for distributed development \nenvironments and multi-team working. Typically, for offshore development, the prod-\nuct owner is in a different country from the development team, which may also be \ndistributed. Figure 3.10 shows the requirements for Distributed Scrum (Deemer 2011).\n \n3.4  Scaling agile methods\nAgile methods were developed for use by small programming teams that could work \ntogether in the same room and communicate informally. They were originally used \nby for the development of small and medium-sized systems and software products. \nSmall companies, without formal processes or bureaucracy, were enthusiastic initial \nadopters of these methods.\nOf course, the need for faster delivery of software, which is more suited to cus-\ntomer needs, also applies to both larger systems and larger companies. Consequently, \nover the past few years, a lot of work has been put into evolving agile methods for \nboth large software systems and for use in large companies.\nScaling agile methods has closely related facets:\n1. Scaling up these methods to handle the development of large systems that are \ntoo big to be developed by a single small team.\n2. \nScaling out these methods from specialized development teams to more widespread \nuse in a large company that has many years of software development experience.\nVideoconferencing \nbetween the product \nowner and the \ndevelopment team\nDistributed Scrum\nThe ScrumMaster \nshould be located with \nthe development team \nso that he or she is \naware of everyday \nproblems.\nThe Product Owner \nshould visit the \ndevelopers and try to \nestablish a good \nrelationship with them. \nIt is essential that they \ntrust each other.\nReal-time communica-\ntions between team \nmembers for informal \ncommunication, \nparticularly instant \nmessaging and video \ncalls.\nContinuous integration, \nso that all team \nmembers can be aware \nof the state of the \nproduct at any time.\nA common development \nenvironment for all teams\nFigure 3.10 Distributed \nScrum"}
{"query": "What are some of the reasons companies use distributed teams in software development?", "response": "Companies use distributed teams in software development for several reasons. One reason is to take advantage of lower cost staff in other countries. This allows companies to reduce costs while still maintaining a productive development team. Another reason is to access specialist skills that may not be available locally. By having team members located in different places around the world, companies can tap into a global talent pool and bring in expertise that may not be available in their local area. Additionally, distributed teams allow for 24-hour development, with work going on in different time zones. This can lead to faster development cycles and quicker delivery of software.", "context": "3.3  \u25a0 Agile project management  87\nsprints, that is, how much of the backlog could be covered in a single sprint. This \nleads to the creation of a sprint backlog\u2014the work to be done during that sprint. The \nteam self-organizes to decide who will work on what, and the sprint begins.\nDuring the sprint, the team holds short daily meetings (Scrums) to review pro-\ngress and, where necessary, to re-prioritize work. During the Scrum, all team mem-\nbers share information, describe their progress since the last meeting, bring up \nproblems that have arisen, and state what is planned for the following day. Thus, \neveryone on the team knows what is going on and, if problems arise, can re-plan \nshort-term work to cope with them. Everyone participates in this short-term plan-\nning; there is no top-down direction from the ScrumMaster.\nThe daily interactions among Scrum teams may be coordinated using a Scrum \nboard. This is an office whiteboard that includes information and post-it notes about \nthe Sprint backlog, work done, unavailability of staff, and so on. This is a shared \nresource for the whole team, and anyone can change or move items on the board. It \nmeans that any team member can, at a glance, see what others are doing and what \nwork remains to be done.\nAt the end of each sprint, there is a review meeting, which involves the whole \nteam. This meeting has two purposes. First, it is a means of process improvement. \nThe team reviews the way they have worked and reflects on how things could have \nbeen done better. Second, it provides input on the product and the product state for \nthe product backlog review that precedes the next sprint.\nWhile the ScrumMaster is not formally a project manager, in practice ScrumMasters \ntake this role in many organizations that have a conventional management structure. \nThey report on progress to senior management and are involved in longer-term plan-\nning and project budgeting. They may be involved in project administration (agreeing \non holidays for staff, liaising with HR, etc.) and hardware and software purchases.\nIn various Scrum success stories (Schatz and Abdelshafi 2005; Mulder and van \nVliet 2008; Bellouiti 2009), the things that users like about the Scrum method are:\n1. The product is broken down into a set of manageable and understandable chunks \nthat stakeholders can relate to.\n2. Unstable requirements do not hold up progress.\n3. The whole team has visibility of everything, and consequently team communi-\ncation and morale are improved.\n4. Customers see on-time delivery of increments and gain feedback on how the \nproduct works. They are not faced with last-minute surprises when a team \nannounces that software will not be delivered as expected.\n5. Trust between customers and developers is established, and a positive culture is \ncreated in which everyone expects the project to succeed.\nScrum, as originally designed, was intended for use with co-located teams where \nall team members could get together every day in stand-up meetings. However, \nmuch software development now involves distributed teams, with team members \nlocated in different places around the world. This allows companies to take advantage \n\n\n88  Chapter 3 \u25a0 Agile software development\nof lower cost staff in other countries, makes access to specialist skills possible, and \nallows for 24-hour development, with work going on in different time zones.\nConsequently, there have been developments of Scrum for distributed development \nenvironments and multi-team working. Typically, for offshore development, the prod-\nuct owner is in a different country from the development team, which may also be \ndistributed. Figure 3.10 shows the requirements for Distributed Scrum (Deemer 2011).\n \n3.4  Scaling agile methods\nAgile methods were developed for use by small programming teams that could work \ntogether in the same room and communicate informally. They were originally used \nby for the development of small and medium-sized systems and software products. \nSmall companies, without formal processes or bureaucracy, were enthusiastic initial \nadopters of these methods.\nOf course, the need for faster delivery of software, which is more suited to cus-\ntomer needs, also applies to both larger systems and larger companies. Consequently, \nover the past few years, a lot of work has been put into evolving agile methods for \nboth large software systems and for use in large companies.\nScaling agile methods has closely related facets:\n1. Scaling up these methods to handle the development of large systems that are \ntoo big to be developed by a single small team.\n2. \nScaling out these methods from specialized development teams to more widespread \nuse in a large company that has many years of software development experience.\nVideoconferencing \nbetween the product \nowner and the \ndevelopment team\nDistributed Scrum\nThe ScrumMaster \nshould be located with \nthe development team \nso that he or she is \naware of everyday \nproblems.\nThe Product Owner \nshould visit the \ndevelopers and try to \nestablish a good \nrelationship with them. \nIt is essential that they \ntrust each other.\nReal-time communica-\ntions between team \nmembers for informal \ncommunication, \nparticularly instant \nmessaging and video \ncalls.\nContinuous integration, \nso that all team \nmembers can be aware \nof the state of the \nproduct at any time.\nA common development \nenvironment for all teams\nFigure 3.10 Distributed \nScrum"}
{"query": "How has Scrum been adapted for distributed development environments and multi-team working?", "response": "Scrum has been adapted for distributed development environments and multi-team working by introducing certain practices and tools. One adaptation is the use of videoconferencing for communication between the product owner and the development team. This allows for real-time communication and helps establish a good relationship between the two parties. Additionally, continuous integration is implemented to ensure that all team members are aware of the state of the product at any time. A common development environment is also established for all teams involved in the project. These adaptations aim to facilitate effective communication and collaboration among distributed teams and enable them to work together efficiently.", "context": "3.3  \u25a0 Agile project management  87\nsprints, that is, how much of the backlog could be covered in a single sprint. This \nleads to the creation of a sprint backlog\u2014the work to be done during that sprint. The \nteam self-organizes to decide who will work on what, and the sprint begins.\nDuring the sprint, the team holds short daily meetings (Scrums) to review pro-\ngress and, where necessary, to re-prioritize work. During the Scrum, all team mem-\nbers share information, describe their progress since the last meeting, bring up \nproblems that have arisen, and state what is planned for the following day. Thus, \neveryone on the team knows what is going on and, if problems arise, can re-plan \nshort-term work to cope with them. Everyone participates in this short-term plan-\nning; there is no top-down direction from the ScrumMaster.\nThe daily interactions among Scrum teams may be coordinated using a Scrum \nboard. This is an office whiteboard that includes information and post-it notes about \nthe Sprint backlog, work done, unavailability of staff, and so on. This is a shared \nresource for the whole team, and anyone can change or move items on the board. It \nmeans that any team member can, at a glance, see what others are doing and what \nwork remains to be done.\nAt the end of each sprint, there is a review meeting, which involves the whole \nteam. This meeting has two purposes. First, it is a means of process improvement. \nThe team reviews the way they have worked and reflects on how things could have \nbeen done better. Second, it provides input on the product and the product state for \nthe product backlog review that precedes the next sprint.\nWhile the ScrumMaster is not formally a project manager, in practice ScrumMasters \ntake this role in many organizations that have a conventional management structure. \nThey report on progress to senior management and are involved in longer-term plan-\nning and project budgeting. They may be involved in project administration (agreeing \non holidays for staff, liaising with HR, etc.) and hardware and software purchases.\nIn various Scrum success stories (Schatz and Abdelshafi 2005; Mulder and van \nVliet 2008; Bellouiti 2009), the things that users like about the Scrum method are:\n1. The product is broken down into a set of manageable and understandable chunks \nthat stakeholders can relate to.\n2. Unstable requirements do not hold up progress.\n3. The whole team has visibility of everything, and consequently team communi-\ncation and morale are improved.\n4. Customers see on-time delivery of increments and gain feedback on how the \nproduct works. They are not faced with last-minute surprises when a team \nannounces that software will not be delivered as expected.\n5. Trust between customers and developers is established, and a positive culture is \ncreated in which everyone expects the project to succeed.\nScrum, as originally designed, was intended for use with co-located teams where \nall team members could get together every day in stand-up meetings. However, \nmuch software development now involves distributed teams, with team members \nlocated in different places around the world. This allows companies to take advantage \n\n\n88  Chapter 3 \u25a0 Agile software development\nof lower cost staff in other countries, makes access to specialist skills possible, and \nallows for 24-hour development, with work going on in different time zones.\nConsequently, there have been developments of Scrum for distributed development \nenvironments and multi-team working. Typically, for offshore development, the prod-\nuct owner is in a different country from the development team, which may also be \ndistributed. Figure 3.10 shows the requirements for Distributed Scrum (Deemer 2011).\n \n3.4  Scaling agile methods\nAgile methods were developed for use by small programming teams that could work \ntogether in the same room and communicate informally. They were originally used \nby for the development of small and medium-sized systems and software products. \nSmall companies, without formal processes or bureaucracy, were enthusiastic initial \nadopters of these methods.\nOf course, the need for faster delivery of software, which is more suited to cus-\ntomer needs, also applies to both larger systems and larger companies. Consequently, \nover the past few years, a lot of work has been put into evolving agile methods for \nboth large software systems and for use in large companies.\nScaling agile methods has closely related facets:\n1. Scaling up these methods to handle the development of large systems that are \ntoo big to be developed by a single small team.\n2. \nScaling out these methods from specialized development teams to more widespread \nuse in a large company that has many years of software development experience.\nVideoconferencing \nbetween the product \nowner and the \ndevelopment team\nDistributed Scrum\nThe ScrumMaster \nshould be located with \nthe development team \nso that he or she is \naware of everyday \nproblems.\nThe Product Owner \nshould visit the \ndevelopers and try to \nestablish a good \nrelationship with them. \nIt is essential that they \ntrust each other.\nReal-time communica-\ntions between team \nmembers for informal \ncommunication, \nparticularly instant \nmessaging and video \ncalls.\nContinuous integration, \nso that all team \nmembers can be aware \nof the state of the \nproduct at any time.\nA common development \nenvironment for all teams\nFigure 3.10 Distributed \nScrum"}
{"query": "What is the concept of scaling agile methods?", "response": "The concept of scaling agile methods refers to the process of adapting and extending agile practices to handle the development of large systems that are too big to be developed by a single small team. It also involves expanding the use of agile methods from specialized development teams to more widespread use in large companies with extensive software development experience. Scaling agile methods aims to maintain the agility and flexibility of the agile approach while addressing the challenges and complexities that arise when working on larger projects or within larger organizations.", "context": "3.3  \u25a0 Agile project management  87\nsprints, that is, how much of the backlog could be covered in a single sprint. This \nleads to the creation of a sprint backlog\u2014the work to be done during that sprint. The \nteam self-organizes to decide who will work on what, and the sprint begins.\nDuring the sprint, the team holds short daily meetings (Scrums) to review pro-\ngress and, where necessary, to re-prioritize work. During the Scrum, all team mem-\nbers share information, describe their progress since the last meeting, bring up \nproblems that have arisen, and state what is planned for the following day. Thus, \neveryone on the team knows what is going on and, if problems arise, can re-plan \nshort-term work to cope with them. Everyone participates in this short-term plan-\nning; there is no top-down direction from the ScrumMaster.\nThe daily interactions among Scrum teams may be coordinated using a Scrum \nboard. This is an office whiteboard that includes information and post-it notes about \nthe Sprint backlog, work done, unavailability of staff, and so on. This is a shared \nresource for the whole team, and anyone can change or move items on the board. It \nmeans that any team member can, at a glance, see what others are doing and what \nwork remains to be done.\nAt the end of each sprint, there is a review meeting, which involves the whole \nteam. This meeting has two purposes. First, it is a means of process improvement. \nThe team reviews the way they have worked and reflects on how things could have \nbeen done better. Second, it provides input on the product and the product state for \nthe product backlog review that precedes the next sprint.\nWhile the ScrumMaster is not formally a project manager, in practice ScrumMasters \ntake this role in many organizations that have a conventional management structure. \nThey report on progress to senior management and are involved in longer-term plan-\nning and project budgeting. They may be involved in project administration (agreeing \non holidays for staff, liaising with HR, etc.) and hardware and software purchases.\nIn various Scrum success stories (Schatz and Abdelshafi 2005; Mulder and van \nVliet 2008; Bellouiti 2009), the things that users like about the Scrum method are:\n1. The product is broken down into a set of manageable and understandable chunks \nthat stakeholders can relate to.\n2. Unstable requirements do not hold up progress.\n3. The whole team has visibility of everything, and consequently team communi-\ncation and morale are improved.\n4. Customers see on-time delivery of increments and gain feedback on how the \nproduct works. They are not faced with last-minute surprises when a team \nannounces that software will not be delivered as expected.\n5. Trust between customers and developers is established, and a positive culture is \ncreated in which everyone expects the project to succeed.\nScrum, as originally designed, was intended for use with co-located teams where \nall team members could get together every day in stand-up meetings. However, \nmuch software development now involves distributed teams, with team members \nlocated in different places around the world. This allows companies to take advantage \n\n\n88  Chapter 3 \u25a0 Agile software development\nof lower cost staff in other countries, makes access to specialist skills possible, and \nallows for 24-hour development, with work going on in different time zones.\nConsequently, there have been developments of Scrum for distributed development \nenvironments and multi-team working. Typically, for offshore development, the prod-\nuct owner is in a different country from the development team, which may also be \ndistributed. Figure 3.10 shows the requirements for Distributed Scrum (Deemer 2011).\n \n3.4  Scaling agile methods\nAgile methods were developed for use by small programming teams that could work \ntogether in the same room and communicate informally. They were originally used \nby for the development of small and medium-sized systems and software products. \nSmall companies, without formal processes or bureaucracy, were enthusiastic initial \nadopters of these methods.\nOf course, the need for faster delivery of software, which is more suited to cus-\ntomer needs, also applies to both larger systems and larger companies. Consequently, \nover the past few years, a lot of work has been put into evolving agile methods for \nboth large software systems and for use in large companies.\nScaling agile methods has closely related facets:\n1. Scaling up these methods to handle the development of large systems that are \ntoo big to be developed by a single small team.\n2. \nScaling out these methods from specialized development teams to more widespread \nuse in a large company that has many years of software development experience.\nVideoconferencing \nbetween the product \nowner and the \ndevelopment team\nDistributed Scrum\nThe ScrumMaster \nshould be located with \nthe development team \nso that he or she is \naware of everyday \nproblems.\nThe Product Owner \nshould visit the \ndevelopers and try to \nestablish a good \nrelationship with them. \nIt is essential that they \ntrust each other.\nReal-time communica-\ntions between team \nmembers for informal \ncommunication, \nparticularly instant \nmessaging and video \ncalls.\nContinuous integration, \nso that all team \nmembers can be aware \nof the state of the \nproduct at any time.\nA common development \nenvironment for all teams\nFigure 3.10 Distributed \nScrum"}
{"query": "What are the two facets of scaling agile methods?", "response": "The two facets of scaling agile methods are scaling up these methods to handle the development of large systems that are too big to be developed by a single small team, and scaling out these methods from specialized development teams to more widespread use in a large company that has many years of software development experience.", "context": "3.3  \u25a0 Agile project management  87\nsprints, that is, how much of the backlog could be covered in a single sprint. This \nleads to the creation of a sprint backlog\u2014the work to be done during that sprint. The \nteam self-organizes to decide who will work on what, and the sprint begins.\nDuring the sprint, the team holds short daily meetings (Scrums) to review pro-\ngress and, where necessary, to re-prioritize work. During the Scrum, all team mem-\nbers share information, describe their progress since the last meeting, bring up \nproblems that have arisen, and state what is planned for the following day. Thus, \neveryone on the team knows what is going on and, if problems arise, can re-plan \nshort-term work to cope with them. Everyone participates in this short-term plan-\nning; there is no top-down direction from the ScrumMaster.\nThe daily interactions among Scrum teams may be coordinated using a Scrum \nboard. This is an office whiteboard that includes information and post-it notes about \nthe Sprint backlog, work done, unavailability of staff, and so on. This is a shared \nresource for the whole team, and anyone can change or move items on the board. It \nmeans that any team member can, at a glance, see what others are doing and what \nwork remains to be done.\nAt the end of each sprint, there is a review meeting, which involves the whole \nteam. This meeting has two purposes. First, it is a means of process improvement. \nThe team reviews the way they have worked and reflects on how things could have \nbeen done better. Second, it provides input on the product and the product state for \nthe product backlog review that precedes the next sprint.\nWhile the ScrumMaster is not formally a project manager, in practice ScrumMasters \ntake this role in many organizations that have a conventional management structure. \nThey report on progress to senior management and are involved in longer-term plan-\nning and project budgeting. They may be involved in project administration (agreeing \non holidays for staff, liaising with HR, etc.) and hardware and software purchases.\nIn various Scrum success stories (Schatz and Abdelshafi 2005; Mulder and van \nVliet 2008; Bellouiti 2009), the things that users like about the Scrum method are:\n1. The product is broken down into a set of manageable and understandable chunks \nthat stakeholders can relate to.\n2. Unstable requirements do not hold up progress.\n3. The whole team has visibility of everything, and consequently team communi-\ncation and morale are improved.\n4. Customers see on-time delivery of increments and gain feedback on how the \nproduct works. They are not faced with last-minute surprises when a team \nannounces that software will not be delivered as expected.\n5. Trust between customers and developers is established, and a positive culture is \ncreated in which everyone expects the project to succeed.\nScrum, as originally designed, was intended for use with co-located teams where \nall team members could get together every day in stand-up meetings. However, \nmuch software development now involves distributed teams, with team members \nlocated in different places around the world. This allows companies to take advantage \n\n\n88  Chapter 3 \u25a0 Agile software development\nof lower cost staff in other countries, makes access to specialist skills possible, and \nallows for 24-hour development, with work going on in different time zones.\nConsequently, there have been developments of Scrum for distributed development \nenvironments and multi-team working. Typically, for offshore development, the prod-\nuct owner is in a different country from the development team, which may also be \ndistributed. Figure 3.10 shows the requirements for Distributed Scrum (Deemer 2011).\n \n3.4  Scaling agile methods\nAgile methods were developed for use by small programming teams that could work \ntogether in the same room and communicate informally. They were originally used \nby for the development of small and medium-sized systems and software products. \nSmall companies, without formal processes or bureaucracy, were enthusiastic initial \nadopters of these methods.\nOf course, the need for faster delivery of software, which is more suited to cus-\ntomer needs, also applies to both larger systems and larger companies. Consequently, \nover the past few years, a lot of work has been put into evolving agile methods for \nboth large software systems and for use in large companies.\nScaling agile methods has closely related facets:\n1. Scaling up these methods to handle the development of large systems that are \ntoo big to be developed by a single small team.\n2. \nScaling out these methods from specialized development teams to more widespread \nuse in a large company that has many years of software development experience.\nVideoconferencing \nbetween the product \nowner and the \ndevelopment team\nDistributed Scrum\nThe ScrumMaster \nshould be located with \nthe development team \nso that he or she is \naware of everyday \nproblems.\nThe Product Owner \nshould visit the \ndevelopers and try to \nestablish a good \nrelationship with them. \nIt is essential that they \ntrust each other.\nReal-time communica-\ntions between team \nmembers for informal \ncommunication, \nparticularly instant \nmessaging and video \ncalls.\nContinuous integration, \nso that all team \nmembers can be aware \nof the state of the \nproduct at any time.\nA common development \nenvironment for all teams\nFigure 3.10 Distributed \nScrum"}
{"query": "How can agile methods be scaled up to handle the development of large systems?", "response": "Agile methods can be scaled up to handle the development of large systems by breaking down the system into manageable and understandable chunks that stakeholders can relate to. This allows for better visibility and communication among the team members. Additionally, continuous integration and a common development environment for all teams can help ensure that all team members are aware of the state of the product at any time.", "context": "3.3  \u25a0 Agile project management  87\nsprints, that is, how much of the backlog could be covered in a single sprint. This \nleads to the creation of a sprint backlog\u2014the work to be done during that sprint. The \nteam self-organizes to decide who will work on what, and the sprint begins.\nDuring the sprint, the team holds short daily meetings (Scrums) to review pro-\ngress and, where necessary, to re-prioritize work. During the Scrum, all team mem-\nbers share information, describe their progress since the last meeting, bring up \nproblems that have arisen, and state what is planned for the following day. Thus, \neveryone on the team knows what is going on and, if problems arise, can re-plan \nshort-term work to cope with them. Everyone participates in this short-term plan-\nning; there is no top-down direction from the ScrumMaster.\nThe daily interactions among Scrum teams may be coordinated using a Scrum \nboard. This is an office whiteboard that includes information and post-it notes about \nthe Sprint backlog, work done, unavailability of staff, and so on. This is a shared \nresource for the whole team, and anyone can change or move items on the board. It \nmeans that any team member can, at a glance, see what others are doing and what \nwork remains to be done.\nAt the end of each sprint, there is a review meeting, which involves the whole \nteam. This meeting has two purposes. First, it is a means of process improvement. \nThe team reviews the way they have worked and reflects on how things could have \nbeen done better. Second, it provides input on the product and the product state for \nthe product backlog review that precedes the next sprint.\nWhile the ScrumMaster is not formally a project manager, in practice ScrumMasters \ntake this role in many organizations that have a conventional management structure. \nThey report on progress to senior management and are involved in longer-term plan-\nning and project budgeting. They may be involved in project administration (agreeing \non holidays for staff, liaising with HR, etc.) and hardware and software purchases.\nIn various Scrum success stories (Schatz and Abdelshafi 2005; Mulder and van \nVliet 2008; Bellouiti 2009), the things that users like about the Scrum method are:\n1. The product is broken down into a set of manageable and understandable chunks \nthat stakeholders can relate to.\n2. Unstable requirements do not hold up progress.\n3. The whole team has visibility of everything, and consequently team communi-\ncation and morale are improved.\n4. Customers see on-time delivery of increments and gain feedback on how the \nproduct works. They are not faced with last-minute surprises when a team \nannounces that software will not be delivered as expected.\n5. Trust between customers and developers is established, and a positive culture is \ncreated in which everyone expects the project to succeed.\nScrum, as originally designed, was intended for use with co-located teams where \nall team members could get together every day in stand-up meetings. However, \nmuch software development now involves distributed teams, with team members \nlocated in different places around the world. This allows companies to take advantage \n\n\n88  Chapter 3 \u25a0 Agile software development\nof lower cost staff in other countries, makes access to specialist skills possible, and \nallows for 24-hour development, with work going on in different time zones.\nConsequently, there have been developments of Scrum for distributed development \nenvironments and multi-team working. Typically, for offshore development, the prod-\nuct owner is in a different country from the development team, which may also be \ndistributed. Figure 3.10 shows the requirements for Distributed Scrum (Deemer 2011).\n \n3.4  Scaling agile methods\nAgile methods were developed for use by small programming teams that could work \ntogether in the same room and communicate informally. They were originally used \nby for the development of small and medium-sized systems and software products. \nSmall companies, without formal processes or bureaucracy, were enthusiastic initial \nadopters of these methods.\nOf course, the need for faster delivery of software, which is more suited to cus-\ntomer needs, also applies to both larger systems and larger companies. Consequently, \nover the past few years, a lot of work has been put into evolving agile methods for \nboth large software systems and for use in large companies.\nScaling agile methods has closely related facets:\n1. Scaling up these methods to handle the development of large systems that are \ntoo big to be developed by a single small team.\n2. \nScaling out these methods from specialized development teams to more widespread \nuse in a large company that has many years of software development experience.\nVideoconferencing \nbetween the product \nowner and the \ndevelopment team\nDistributed Scrum\nThe ScrumMaster \nshould be located with \nthe development team \nso that he or she is \naware of everyday \nproblems.\nThe Product Owner \nshould visit the \ndevelopers and try to \nestablish a good \nrelationship with them. \nIt is essential that they \ntrust each other.\nReal-time communica-\ntions between team \nmembers for informal \ncommunication, \nparticularly instant \nmessaging and video \ncalls.\nContinuous integration, \nso that all team \nmembers can be aware \nof the state of the \nproduct at any time.\nA common development \nenvironment for all teams\nFigure 3.10 Distributed \nScrum"}
{"query": "How can agile methods be scaled out for widespread use in a large company?", "response": "Agile methods can be scaled out for widespread use in a large company by extending their use beyond specialized development teams and incorporating them into the overall software development process of the company. This involves adapting agile principles and practices to fit the specific needs and context of the organization, and ensuring that all teams and stakeholders are aligned and working together towards the common goal of delivering high-quality software. This may include establishing clear communication channels, promoting collaboration and transparency, implementing continuous integration and delivery processes, and providing training and support to enable teams to effectively adopt and implement agile practices.", "context": "3.3  \u25a0 Agile project management  87\nsprints, that is, how much of the backlog could be covered in a single sprint. This \nleads to the creation of a sprint backlog\u2014the work to be done during that sprint. The \nteam self-organizes to decide who will work on what, and the sprint begins.\nDuring the sprint, the team holds short daily meetings (Scrums) to review pro-\ngress and, where necessary, to re-prioritize work. During the Scrum, all team mem-\nbers share information, describe their progress since the last meeting, bring up \nproblems that have arisen, and state what is planned for the following day. Thus, \neveryone on the team knows what is going on and, if problems arise, can re-plan \nshort-term work to cope with them. Everyone participates in this short-term plan-\nning; there is no top-down direction from the ScrumMaster.\nThe daily interactions among Scrum teams may be coordinated using a Scrum \nboard. This is an office whiteboard that includes information and post-it notes about \nthe Sprint backlog, work done, unavailability of staff, and so on. This is a shared \nresource for the whole team, and anyone can change or move items on the board. It \nmeans that any team member can, at a glance, see what others are doing and what \nwork remains to be done.\nAt the end of each sprint, there is a review meeting, which involves the whole \nteam. This meeting has two purposes. First, it is a means of process improvement. \nThe team reviews the way they have worked and reflects on how things could have \nbeen done better. Second, it provides input on the product and the product state for \nthe product backlog review that precedes the next sprint.\nWhile the ScrumMaster is not formally a project manager, in practice ScrumMasters \ntake this role in many organizations that have a conventional management structure. \nThey report on progress to senior management and are involved in longer-term plan-\nning and project budgeting. They may be involved in project administration (agreeing \non holidays for staff, liaising with HR, etc.) and hardware and software purchases.\nIn various Scrum success stories (Schatz and Abdelshafi 2005; Mulder and van \nVliet 2008; Bellouiti 2009), the things that users like about the Scrum method are:\n1. The product is broken down into a set of manageable and understandable chunks \nthat stakeholders can relate to.\n2. Unstable requirements do not hold up progress.\n3. The whole team has visibility of everything, and consequently team communi-\ncation and morale are improved.\n4. Customers see on-time delivery of increments and gain feedback on how the \nproduct works. They are not faced with last-minute surprises when a team \nannounces that software will not be delivered as expected.\n5. Trust between customers and developers is established, and a positive culture is \ncreated in which everyone expects the project to succeed.\nScrum, as originally designed, was intended for use with co-located teams where \nall team members could get together every day in stand-up meetings. However, \nmuch software development now involves distributed teams, with team members \nlocated in different places around the world. This allows companies to take advantage \n\n\n88  Chapter 3 \u25a0 Agile software development\nof lower cost staff in other countries, makes access to specialist skills possible, and \nallows for 24-hour development, with work going on in different time zones.\nConsequently, there have been developments of Scrum for distributed development \nenvironments and multi-team working. Typically, for offshore development, the prod-\nuct owner is in a different country from the development team, which may also be \ndistributed. Figure 3.10 shows the requirements for Distributed Scrum (Deemer 2011).\n \n3.4  Scaling agile methods\nAgile methods were developed for use by small programming teams that could work \ntogether in the same room and communicate informally. They were originally used \nby for the development of small and medium-sized systems and software products. \nSmall companies, without formal processes or bureaucracy, were enthusiastic initial \nadopters of these methods.\nOf course, the need for faster delivery of software, which is more suited to cus-\ntomer needs, also applies to both larger systems and larger companies. Consequently, \nover the past few years, a lot of work has been put into evolving agile methods for \nboth large software systems and for use in large companies.\nScaling agile methods has closely related facets:\n1. Scaling up these methods to handle the development of large systems that are \ntoo big to be developed by a single small team.\n2. \nScaling out these methods from specialized development teams to more widespread \nuse in a large company that has many years of software development experience.\nVideoconferencing \nbetween the product \nowner and the \ndevelopment team\nDistributed Scrum\nThe ScrumMaster \nshould be located with \nthe development team \nso that he or she is \naware of everyday \nproblems.\nThe Product Owner \nshould visit the \ndevelopers and try to \nestablish a good \nrelationship with them. \nIt is essential that they \ntrust each other.\nReal-time communica-\ntions between team \nmembers for informal \ncommunication, \nparticularly instant \nmessaging and video \ncalls.\nContinuous integration, \nso that all team \nmembers can be aware \nof the state of the \nproduct at any time.\nA common development \nenvironment for all teams\nFigure 3.10 Distributed \nScrum"}
{"query": "What are some of the benefits of using the Scrum method in agile project management?", "response": "The Scrum method in agile project management offers several benefits. Firstly, it allows the product to be broken down into manageable and understandable chunks, which stakeholders can easily relate to. Secondly, it enables progress to continue even in the presence of unstable requirements. Thirdly, it promotes improved team communication and morale, as the whole team has visibility of everything. Fourthly, it ensures on-time delivery of increments, providing customers with feedback on how the product works and avoiding last-minute surprises. Lastly, it helps establish trust between customers and developers, creating a positive culture where everyone expects the project to succeed.", "context": "3.3  \u25a0 Agile project management  87\nsprints, that is, how much of the backlog could be covered in a single sprint. This \nleads to the creation of a sprint backlog\u2014the work to be done during that sprint. The \nteam self-organizes to decide who will work on what, and the sprint begins.\nDuring the sprint, the team holds short daily meetings (Scrums) to review pro-\ngress and, where necessary, to re-prioritize work. During the Scrum, all team mem-\nbers share information, describe their progress since the last meeting, bring up \nproblems that have arisen, and state what is planned for the following day. Thus, \neveryone on the team knows what is going on and, if problems arise, can re-plan \nshort-term work to cope with them. Everyone participates in this short-term plan-\nning; there is no top-down direction from the ScrumMaster.\nThe daily interactions among Scrum teams may be coordinated using a Scrum \nboard. This is an office whiteboard that includes information and post-it notes about \nthe Sprint backlog, work done, unavailability of staff, and so on. This is a shared \nresource for the whole team, and anyone can change or move items on the board. It \nmeans that any team member can, at a glance, see what others are doing and what \nwork remains to be done.\nAt the end of each sprint, there is a review meeting, which involves the whole \nteam. This meeting has two purposes. First, it is a means of process improvement. \nThe team reviews the way they have worked and reflects on how things could have \nbeen done better. Second, it provides input on the product and the product state for \nthe product backlog review that precedes the next sprint.\nWhile the ScrumMaster is not formally a project manager, in practice ScrumMasters \ntake this role in many organizations that have a conventional management structure. \nThey report on progress to senior management and are involved in longer-term plan-\nning and project budgeting. They may be involved in project administration (agreeing \non holidays for staff, liaising with HR, etc.) and hardware and software purchases.\nIn various Scrum success stories (Schatz and Abdelshafi 2005; Mulder and van \nVliet 2008; Bellouiti 2009), the things that users like about the Scrum method are:\n1. The product is broken down into a set of manageable and understandable chunks \nthat stakeholders can relate to.\n2. Unstable requirements do not hold up progress.\n3. The whole team has visibility of everything, and consequently team communi-\ncation and morale are improved.\n4. Customers see on-time delivery of increments and gain feedback on how the \nproduct works. They are not faced with last-minute surprises when a team \nannounces that software will not be delivered as expected.\n5. Trust between customers and developers is established, and a positive culture is \ncreated in which everyone expects the project to succeed.\nScrum, as originally designed, was intended for use with co-located teams where \nall team members could get together every day in stand-up meetings. However, \nmuch software development now involves distributed teams, with team members \nlocated in different places around the world. This allows companies to take advantage \n\n\n88  Chapter 3 \u25a0 Agile software development\nof lower cost staff in other countries, makes access to specialist skills possible, and \nallows for 24-hour development, with work going on in different time zones.\nConsequently, there have been developments of Scrum for distributed development \nenvironments and multi-team working. Typically, for offshore development, the prod-\nuct owner is in a different country from the development team, which may also be \ndistributed. Figure 3.10 shows the requirements for Distributed Scrum (Deemer 2011).\n \n3.4  Scaling agile methods\nAgile methods were developed for use by small programming teams that could work \ntogether in the same room and communicate informally. They were originally used \nby for the development of small and medium-sized systems and software products. \nSmall companies, without formal processes or bureaucracy, were enthusiastic initial \nadopters of these methods.\nOf course, the need for faster delivery of software, which is more suited to cus-\ntomer needs, also applies to both larger systems and larger companies. Consequently, \nover the past few years, a lot of work has been put into evolving agile methods for \nboth large software systems and for use in large companies.\nScaling agile methods has closely related facets:\n1. Scaling up these methods to handle the development of large systems that are \ntoo big to be developed by a single small team.\n2. \nScaling out these methods from specialized development teams to more widespread \nuse in a large company that has many years of software development experience.\nVideoconferencing \nbetween the product \nowner and the \ndevelopment team\nDistributed Scrum\nThe ScrumMaster \nshould be located with \nthe development team \nso that he or she is \naware of everyday \nproblems.\nThe Product Owner \nshould visit the \ndevelopers and try to \nestablish a good \nrelationship with them. \nIt is essential that they \ntrust each other.\nReal-time communica-\ntions between team \nmembers for informal \ncommunication, \nparticularly instant \nmessaging and video \ncalls.\nContinuous integration, \nso that all team \nmembers can be aware \nof the state of the \nproduct at any time.\nA common development \nenvironment for all teams\nFigure 3.10 Distributed \nScrum"}
{"query": "How does the Scrum method handle unstable requirements in a project?", "response": "The Scrum method handles unstable requirements in a project by not allowing them to hold up progress. This means that even if requirements change or become unstable during the project, the Scrum team can still continue working and making progress. The team holds short daily meetings (Scrums) to review progress and re-prioritize work if necessary. This allows the team to adapt and adjust their short-term planning to cope with any problems or changes that arise. By having frequent communication and flexibility, the Scrum method ensures that the team can effectively handle unstable requirements and continue moving forward with the project.", "context": "3.3  \u25a0 Agile project management  87\nsprints, that is, how much of the backlog could be covered in a single sprint. This \nleads to the creation of a sprint backlog\u2014the work to be done during that sprint. The \nteam self-organizes to decide who will work on what, and the sprint begins.\nDuring the sprint, the team holds short daily meetings (Scrums) to review pro-\ngress and, where necessary, to re-prioritize work. During the Scrum, all team mem-\nbers share information, describe their progress since the last meeting, bring up \nproblems that have arisen, and state what is planned for the following day. Thus, \neveryone on the team knows what is going on and, if problems arise, can re-plan \nshort-term work to cope with them. Everyone participates in this short-term plan-\nning; there is no top-down direction from the ScrumMaster.\nThe daily interactions among Scrum teams may be coordinated using a Scrum \nboard. This is an office whiteboard that includes information and post-it notes about \nthe Sprint backlog, work done, unavailability of staff, and so on. This is a shared \nresource for the whole team, and anyone can change or move items on the board. It \nmeans that any team member can, at a glance, see what others are doing and what \nwork remains to be done.\nAt the end of each sprint, there is a review meeting, which involves the whole \nteam. This meeting has two purposes. First, it is a means of process improvement. \nThe team reviews the way they have worked and reflects on how things could have \nbeen done better. Second, it provides input on the product and the product state for \nthe product backlog review that precedes the next sprint.\nWhile the ScrumMaster is not formally a project manager, in practice ScrumMasters \ntake this role in many organizations that have a conventional management structure. \nThey report on progress to senior management and are involved in longer-term plan-\nning and project budgeting. They may be involved in project administration (agreeing \non holidays for staff, liaising with HR, etc.) and hardware and software purchases.\nIn various Scrum success stories (Schatz and Abdelshafi 2005; Mulder and van \nVliet 2008; Bellouiti 2009), the things that users like about the Scrum method are:\n1. The product is broken down into a set of manageable and understandable chunks \nthat stakeholders can relate to.\n2. Unstable requirements do not hold up progress.\n3. The whole team has visibility of everything, and consequently team communi-\ncation and morale are improved.\n4. Customers see on-time delivery of increments and gain feedback on how the \nproduct works. They are not faced with last-minute surprises when a team \nannounces that software will not be delivered as expected.\n5. Trust between customers and developers is established, and a positive culture is \ncreated in which everyone expects the project to succeed.\nScrum, as originally designed, was intended for use with co-located teams where \nall team members could get together every day in stand-up meetings. However, \nmuch software development now involves distributed teams, with team members \nlocated in different places around the world. This allows companies to take advantage \n\n\n88  Chapter 3 \u25a0 Agile software development\nof lower cost staff in other countries, makes access to specialist skills possible, and \nallows for 24-hour development, with work going on in different time zones.\nConsequently, there have been developments of Scrum for distributed development \nenvironments and multi-team working. Typically, for offshore development, the prod-\nuct owner is in a different country from the development team, which may also be \ndistributed. Figure 3.10 shows the requirements for Distributed Scrum (Deemer 2011).\n \n3.4  Scaling agile methods\nAgile methods were developed for use by small programming teams that could work \ntogether in the same room and communicate informally. They were originally used \nby for the development of small and medium-sized systems and software products. \nSmall companies, without formal processes or bureaucracy, were enthusiastic initial \nadopters of these methods.\nOf course, the need for faster delivery of software, which is more suited to cus-\ntomer needs, also applies to both larger systems and larger companies. Consequently, \nover the past few years, a lot of work has been put into evolving agile methods for \nboth large software systems and for use in large companies.\nScaling agile methods has closely related facets:\n1. Scaling up these methods to handle the development of large systems that are \ntoo big to be developed by a single small team.\n2. \nScaling out these methods from specialized development teams to more widespread \nuse in a large company that has many years of software development experience.\nVideoconferencing \nbetween the product \nowner and the \ndevelopment team\nDistributed Scrum\nThe ScrumMaster \nshould be located with \nthe development team \nso that he or she is \naware of everyday \nproblems.\nThe Product Owner \nshould visit the \ndevelopers and try to \nestablish a good \nrelationship with them. \nIt is essential that they \ntrust each other.\nReal-time communica-\ntions between team \nmembers for informal \ncommunication, \nparticularly instant \nmessaging and video \ncalls.\nContinuous integration, \nso that all team \nmembers can be aware \nof the state of the \nproduct at any time.\nA common development \nenvironment for all teams\nFigure 3.10 Distributed \nScrum"}
{"query": "What is the role of the ScrumMaster in reporting progress to senior management?", "response": "The ScrumMaster is responsible for reporting progress to senior management.", "context": "3.3  \u25a0 Agile project management  87\nsprints, that is, how much of the backlog could be covered in a single sprint. This \nleads to the creation of a sprint backlog\u2014the work to be done during that sprint. The \nteam self-organizes to decide who will work on what, and the sprint begins.\nDuring the sprint, the team holds short daily meetings (Scrums) to review pro-\ngress and, where necessary, to re-prioritize work. During the Scrum, all team mem-\nbers share information, describe their progress since the last meeting, bring up \nproblems that have arisen, and state what is planned for the following day. Thus, \neveryone on the team knows what is going on and, if problems arise, can re-plan \nshort-term work to cope with them. Everyone participates in this short-term plan-\nning; there is no top-down direction from the ScrumMaster.\nThe daily interactions among Scrum teams may be coordinated using a Scrum \nboard. This is an office whiteboard that includes information and post-it notes about \nthe Sprint backlog, work done, unavailability of staff, and so on. This is a shared \nresource for the whole team, and anyone can change or move items on the board. It \nmeans that any team member can, at a glance, see what others are doing and what \nwork remains to be done.\nAt the end of each sprint, there is a review meeting, which involves the whole \nteam. This meeting has two purposes. First, it is a means of process improvement. \nThe team reviews the way they have worked and reflects on how things could have \nbeen done better. Second, it provides input on the product and the product state for \nthe product backlog review that precedes the next sprint.\nWhile the ScrumMaster is not formally a project manager, in practice ScrumMasters \ntake this role in many organizations that have a conventional management structure. \nThey report on progress to senior management and are involved in longer-term plan-\nning and project budgeting. They may be involved in project administration (agreeing \non holidays for staff, liaising with HR, etc.) and hardware and software purchases.\nIn various Scrum success stories (Schatz and Abdelshafi 2005; Mulder and van \nVliet 2008; Bellouiti 2009), the things that users like about the Scrum method are:\n1. The product is broken down into a set of manageable and understandable chunks \nthat stakeholders can relate to.\n2. Unstable requirements do not hold up progress.\n3. The whole team has visibility of everything, and consequently team communi-\ncation and morale are improved.\n4. Customers see on-time delivery of increments and gain feedback on how the \nproduct works. They are not faced with last-minute surprises when a team \nannounces that software will not be delivered as expected.\n5. Trust between customers and developers is established, and a positive culture is \ncreated in which everyone expects the project to succeed.\nScrum, as originally designed, was intended for use with co-located teams where \nall team members could get together every day in stand-up meetings. However, \nmuch software development now involves distributed teams, with team members \nlocated in different places around the world. This allows companies to take advantage \n\n\n88  Chapter 3 \u25a0 Agile software development\nof lower cost staff in other countries, makes access to specialist skills possible, and \nallows for 24-hour development, with work going on in different time zones.\nConsequently, there have been developments of Scrum for distributed development \nenvironments and multi-team working. Typically, for offshore development, the prod-\nuct owner is in a different country from the development team, which may also be \ndistributed. Figure 3.10 shows the requirements for Distributed Scrum (Deemer 2011).\n \n3.4  Scaling agile methods\nAgile methods were developed for use by small programming teams that could work \ntogether in the same room and communicate informally. They were originally used \nby for the development of small and medium-sized systems and software products. \nSmall companies, without formal processes or bureaucracy, were enthusiastic initial \nadopters of these methods.\nOf course, the need for faster delivery of software, which is more suited to cus-\ntomer needs, also applies to both larger systems and larger companies. Consequently, \nover the past few years, a lot of work has been put into evolving agile methods for \nboth large software systems and for use in large companies.\nScaling agile methods has closely related facets:\n1. Scaling up these methods to handle the development of large systems that are \ntoo big to be developed by a single small team.\n2. \nScaling out these methods from specialized development teams to more widespread \nuse in a large company that has many years of software development experience.\nVideoconferencing \nbetween the product \nowner and the \ndevelopment team\nDistributed Scrum\nThe ScrumMaster \nshould be located with \nthe development team \nso that he or she is \naware of everyday \nproblems.\nThe Product Owner \nshould visit the \ndevelopers and try to \nestablish a good \nrelationship with them. \nIt is essential that they \ntrust each other.\nReal-time communica-\ntions between team \nmembers for informal \ncommunication, \nparticularly instant \nmessaging and video \ncalls.\nContinuous integration, \nso that all team \nmembers can be aware \nof the state of the \nproduct at any time.\nA common development \nenvironment for all teams\nFigure 3.10 Distributed \nScrum"}
{"query": "How does the Scrum method contribute to on-time delivery of increments in a project?", "response": "The Scrum method contributes to on-time delivery of increments in a project by breaking down the product into manageable and understandable chunks. This allows stakeholders to relate to the work being done and provides visibility for the whole team. With daily meetings and continuous communication, the team can track progress, identify any problems, and re-plan short-term work to cope with any issues that arise. This ensures that everyone on the team knows what is going on and can adjust their work accordingly, leading to timely delivery of increments. Additionally, the Scrum method establishes trust between customers and developers, creating a positive culture where everyone expects the project to succeed.", "context": "3.3  \u25a0 Agile project management  87\nsprints, that is, how much of the backlog could be covered in a single sprint. This \nleads to the creation of a sprint backlog\u2014the work to be done during that sprint. The \nteam self-organizes to decide who will work on what, and the sprint begins.\nDuring the sprint, the team holds short daily meetings (Scrums) to review pro-\ngress and, where necessary, to re-prioritize work. During the Scrum, all team mem-\nbers share information, describe their progress since the last meeting, bring up \nproblems that have arisen, and state what is planned for the following day. Thus, \neveryone on the team knows what is going on and, if problems arise, can re-plan \nshort-term work to cope with them. Everyone participates in this short-term plan-\nning; there is no top-down direction from the ScrumMaster.\nThe daily interactions among Scrum teams may be coordinated using a Scrum \nboard. This is an office whiteboard that includes information and post-it notes about \nthe Sprint backlog, work done, unavailability of staff, and so on. This is a shared \nresource for the whole team, and anyone can change or move items on the board. It \nmeans that any team member can, at a glance, see what others are doing and what \nwork remains to be done.\nAt the end of each sprint, there is a review meeting, which involves the whole \nteam. This meeting has two purposes. First, it is a means of process improvement. \nThe team reviews the way they have worked and reflects on how things could have \nbeen done better. Second, it provides input on the product and the product state for \nthe product backlog review that precedes the next sprint.\nWhile the ScrumMaster is not formally a project manager, in practice ScrumMasters \ntake this role in many organizations that have a conventional management structure. \nThey report on progress to senior management and are involved in longer-term plan-\nning and project budgeting. They may be involved in project administration (agreeing \non holidays for staff, liaising with HR, etc.) and hardware and software purchases.\nIn various Scrum success stories (Schatz and Abdelshafi 2005; Mulder and van \nVliet 2008; Bellouiti 2009), the things that users like about the Scrum method are:\n1. The product is broken down into a set of manageable and understandable chunks \nthat stakeholders can relate to.\n2. Unstable requirements do not hold up progress.\n3. The whole team has visibility of everything, and consequently team communi-\ncation and morale are improved.\n4. Customers see on-time delivery of increments and gain feedback on how the \nproduct works. They are not faced with last-minute surprises when a team \nannounces that software will not be delivered as expected.\n5. Trust between customers and developers is established, and a positive culture is \ncreated in which everyone expects the project to succeed.\nScrum, as originally designed, was intended for use with co-located teams where \nall team members could get together every day in stand-up meetings. However, \nmuch software development now involves distributed teams, with team members \nlocated in different places around the world. This allows companies to take advantage \n\n\n88  Chapter 3 \u25a0 Agile software development\nof lower cost staff in other countries, makes access to specialist skills possible, and \nallows for 24-hour development, with work going on in different time zones.\nConsequently, there have been developments of Scrum for distributed development \nenvironments and multi-team working. Typically, for offshore development, the prod-\nuct owner is in a different country from the development team, which may also be \ndistributed. Figure 3.10 shows the requirements for Distributed Scrum (Deemer 2011).\n \n3.4  Scaling agile methods\nAgile methods were developed for use by small programming teams that could work \ntogether in the same room and communicate informally. They were originally used \nby for the development of small and medium-sized systems and software products. \nSmall companies, without formal processes or bureaucracy, were enthusiastic initial \nadopters of these methods.\nOf course, the need for faster delivery of software, which is more suited to cus-\ntomer needs, also applies to both larger systems and larger companies. Consequently, \nover the past few years, a lot of work has been put into evolving agile methods for \nboth large software systems and for use in large companies.\nScaling agile methods has closely related facets:\n1. Scaling up these methods to handle the development of large systems that are \ntoo big to be developed by a single small team.\n2. \nScaling out these methods from specialized development teams to more widespread \nuse in a large company that has many years of software development experience.\nVideoconferencing \nbetween the product \nowner and the \ndevelopment team\nDistributed Scrum\nThe ScrumMaster \nshould be located with \nthe development team \nso that he or she is \naware of everyday \nproblems.\nThe Product Owner \nshould visit the \ndevelopers and try to \nestablish a good \nrelationship with them. \nIt is essential that they \ntrust each other.\nReal-time communica-\ntions between team \nmembers for informal \ncommunication, \nparticularly instant \nmessaging and video \ncalls.\nContinuous integration, \nso that all team \nmembers can be aware \nof the state of the \nproduct at any time.\nA common development \nenvironment for all teams\nFigure 3.10 Distributed \nScrum"}
{"query": "How does the Scrum method help in avoiding last-minute surprises in software delivery?", "response": "The Scrum method helps in avoiding last-minute surprises in software delivery by providing customers with on-time delivery of increments and feedback on how the product works. This allows customers to have visibility into the progress of the project and prevents them from being faced with unexpected announcements that software will not be delivered as expected.", "context": "3.3  \u25a0 Agile project management  87\nsprints, that is, how much of the backlog could be covered in a single sprint. This \nleads to the creation of a sprint backlog\u2014the work to be done during that sprint. The \nteam self-organizes to decide who will work on what, and the sprint begins.\nDuring the sprint, the team holds short daily meetings (Scrums) to review pro-\ngress and, where necessary, to re-prioritize work. During the Scrum, all team mem-\nbers share information, describe their progress since the last meeting, bring up \nproblems that have arisen, and state what is planned for the following day. Thus, \neveryone on the team knows what is going on and, if problems arise, can re-plan \nshort-term work to cope with them. Everyone participates in this short-term plan-\nning; there is no top-down direction from the ScrumMaster.\nThe daily interactions among Scrum teams may be coordinated using a Scrum \nboard. This is an office whiteboard that includes information and post-it notes about \nthe Sprint backlog, work done, unavailability of staff, and so on. This is a shared \nresource for the whole team, and anyone can change or move items on the board. It \nmeans that any team member can, at a glance, see what others are doing and what \nwork remains to be done.\nAt the end of each sprint, there is a review meeting, which involves the whole \nteam. This meeting has two purposes. First, it is a means of process improvement. \nThe team reviews the way they have worked and reflects on how things could have \nbeen done better. Second, it provides input on the product and the product state for \nthe product backlog review that precedes the next sprint.\nWhile the ScrumMaster is not formally a project manager, in practice ScrumMasters \ntake this role in many organizations that have a conventional management structure. \nThey report on progress to senior management and are involved in longer-term plan-\nning and project budgeting. They may be involved in project administration (agreeing \non holidays for staff, liaising with HR, etc.) and hardware and software purchases.\nIn various Scrum success stories (Schatz and Abdelshafi 2005; Mulder and van \nVliet 2008; Bellouiti 2009), the things that users like about the Scrum method are:\n1. The product is broken down into a set of manageable and understandable chunks \nthat stakeholders can relate to.\n2. Unstable requirements do not hold up progress.\n3. The whole team has visibility of everything, and consequently team communi-\ncation and morale are improved.\n4. Customers see on-time delivery of increments and gain feedback on how the \nproduct works. They are not faced with last-minute surprises when a team \nannounces that software will not be delivered as expected.\n5. Trust between customers and developers is established, and a positive culture is \ncreated in which everyone expects the project to succeed.\nScrum, as originally designed, was intended for use with co-located teams where \nall team members could get together every day in stand-up meetings. However, \nmuch software development now involves distributed teams, with team members \nlocated in different places around the world. This allows companies to take advantage \n\n\n88  Chapter 3 \u25a0 Agile software development\nof lower cost staff in other countries, makes access to specialist skills possible, and \nallows for 24-hour development, with work going on in different time zones.\nConsequently, there have been developments of Scrum for distributed development \nenvironments and multi-team working. Typically, for offshore development, the prod-\nuct owner is in a different country from the development team, which may also be \ndistributed. Figure 3.10 shows the requirements for Distributed Scrum (Deemer 2011).\n \n3.4  Scaling agile methods\nAgile methods were developed for use by small programming teams that could work \ntogether in the same room and communicate informally. They were originally used \nby for the development of small and medium-sized systems and software products. \nSmall companies, without formal processes or bureaucracy, were enthusiastic initial \nadopters of these methods.\nOf course, the need for faster delivery of software, which is more suited to cus-\ntomer needs, also applies to both larger systems and larger companies. Consequently, \nover the past few years, a lot of work has been put into evolving agile methods for \nboth large software systems and for use in large companies.\nScaling agile methods has closely related facets:\n1. Scaling up these methods to handle the development of large systems that are \ntoo big to be developed by a single small team.\n2. \nScaling out these methods from specialized development teams to more widespread \nuse in a large company that has many years of software development experience.\nVideoconferencing \nbetween the product \nowner and the \ndevelopment team\nDistributed Scrum\nThe ScrumMaster \nshould be located with \nthe development team \nso that he or she is \naware of everyday \nproblems.\nThe Product Owner \nshould visit the \ndevelopers and try to \nestablish a good \nrelationship with them. \nIt is essential that they \ntrust each other.\nReal-time communica-\ntions between team \nmembers for informal \ncommunication, \nparticularly instant \nmessaging and video \ncalls.\nContinuous integration, \nso that all team \nmembers can be aware \nof the state of the \nproduct at any time.\nA common development \nenvironment for all teams\nFigure 3.10 Distributed \nScrum"}
{"query": "How does the Scrum method contribute to the creation of a positive culture in a project team?", "response": "The Scrum method contributes to the creation of a positive culture in a project team by establishing trust between customers and developers and creating an environment where everyone expects the project to succeed. Additionally, the whole team has visibility of everything, which improves team communication and morale. This transparency and collaboration foster a positive culture within the team.", "context": "3.3  \u25a0 Agile project management  87\nsprints, that is, how much of the backlog could be covered in a single sprint. This \nleads to the creation of a sprint backlog\u2014the work to be done during that sprint. The \nteam self-organizes to decide who will work on what, and the sprint begins.\nDuring the sprint, the team holds short daily meetings (Scrums) to review pro-\ngress and, where necessary, to re-prioritize work. During the Scrum, all team mem-\nbers share information, describe their progress since the last meeting, bring up \nproblems that have arisen, and state what is planned for the following day. Thus, \neveryone on the team knows what is going on and, if problems arise, can re-plan \nshort-term work to cope with them. Everyone participates in this short-term plan-\nning; there is no top-down direction from the ScrumMaster.\nThe daily interactions among Scrum teams may be coordinated using a Scrum \nboard. This is an office whiteboard that includes information and post-it notes about \nthe Sprint backlog, work done, unavailability of staff, and so on. This is a shared \nresource for the whole team, and anyone can change or move items on the board. It \nmeans that any team member can, at a glance, see what others are doing and what \nwork remains to be done.\nAt the end of each sprint, there is a review meeting, which involves the whole \nteam. This meeting has two purposes. First, it is a means of process improvement. \nThe team reviews the way they have worked and reflects on how things could have \nbeen done better. Second, it provides input on the product and the product state for \nthe product backlog review that precedes the next sprint.\nWhile the ScrumMaster is not formally a project manager, in practice ScrumMasters \ntake this role in many organizations that have a conventional management structure. \nThey report on progress to senior management and are involved in longer-term plan-\nning and project budgeting. They may be involved in project administration (agreeing \non holidays for staff, liaising with HR, etc.) and hardware and software purchases.\nIn various Scrum success stories (Schatz and Abdelshafi 2005; Mulder and van \nVliet 2008; Bellouiti 2009), the things that users like about the Scrum method are:\n1. The product is broken down into a set of manageable and understandable chunks \nthat stakeholders can relate to.\n2. Unstable requirements do not hold up progress.\n3. The whole team has visibility of everything, and consequently team communi-\ncation and morale are improved.\n4. Customers see on-time delivery of increments and gain feedback on how the \nproduct works. They are not faced with last-minute surprises when a team \nannounces that software will not be delivered as expected.\n5. Trust between customers and developers is established, and a positive culture is \ncreated in which everyone expects the project to succeed.\nScrum, as originally designed, was intended for use with co-located teams where \nall team members could get together every day in stand-up meetings. However, \nmuch software development now involves distributed teams, with team members \nlocated in different places around the world. This allows companies to take advantage \n\n\n88  Chapter 3 \u25a0 Agile software development\nof lower cost staff in other countries, makes access to specialist skills possible, and \nallows for 24-hour development, with work going on in different time zones.\nConsequently, there have been developments of Scrum for distributed development \nenvironments and multi-team working. Typically, for offshore development, the prod-\nuct owner is in a different country from the development team, which may also be \ndistributed. Figure 3.10 shows the requirements for Distributed Scrum (Deemer 2011).\n \n3.4  Scaling agile methods\nAgile methods were developed for use by small programming teams that could work \ntogether in the same room and communicate informally. They were originally used \nby for the development of small and medium-sized systems and software products. \nSmall companies, without formal processes or bureaucracy, were enthusiastic initial \nadopters of these methods.\nOf course, the need for faster delivery of software, which is more suited to cus-\ntomer needs, also applies to both larger systems and larger companies. Consequently, \nover the past few years, a lot of work has been put into evolving agile methods for \nboth large software systems and for use in large companies.\nScaling agile methods has closely related facets:\n1. Scaling up these methods to handle the development of large systems that are \ntoo big to be developed by a single small team.\n2. \nScaling out these methods from specialized development teams to more widespread \nuse in a large company that has many years of software development experience.\nVideoconferencing \nbetween the product \nowner and the \ndevelopment team\nDistributed Scrum\nThe ScrumMaster \nshould be located with \nthe development team \nso that he or she is \naware of everyday \nproblems.\nThe Product Owner \nshould visit the \ndevelopers and try to \nestablish a good \nrelationship with them. \nIt is essential that they \ntrust each other.\nReal-time communica-\ntions between team \nmembers for informal \ncommunication, \nparticularly instant \nmessaging and video \ncalls.\nContinuous integration, \nso that all team \nmembers can be aware \nof the state of the \nproduct at any time.\nA common development \nenvironment for all teams\nFigure 3.10 Distributed \nScrum"}
{"query": "What is the concept of Distributed Scrum?", "response": "The concept of Distributed Scrum is an adaptation of the Scrum methodology for software development in distributed environments. It is designed to address the challenges of having team members located in different places around the world. In Distributed Scrum, the product owner and the development team may be in different countries, and the team members communicate through videoconferencing, real-time communication tools, and a common development environment. The ScrumMaster is typically located with the development team to be aware of everyday problems, and the product owner visits the developers to establish a good relationship. Continuous integration is also important in Distributed Scrum to ensure that all team members are aware of the state of the product at any time.", "context": "3.3  \u25a0 Agile project management  87\nsprints, that is, how much of the backlog could be covered in a single sprint. This \nleads to the creation of a sprint backlog\u2014the work to be done during that sprint. The \nteam self-organizes to decide who will work on what, and the sprint begins.\nDuring the sprint, the team holds short daily meetings (Scrums) to review pro-\ngress and, where necessary, to re-prioritize work. During the Scrum, all team mem-\nbers share information, describe their progress since the last meeting, bring up \nproblems that have arisen, and state what is planned for the following day. Thus, \neveryone on the team knows what is going on and, if problems arise, can re-plan \nshort-term work to cope with them. Everyone participates in this short-term plan-\nning; there is no top-down direction from the ScrumMaster.\nThe daily interactions among Scrum teams may be coordinated using a Scrum \nboard. This is an office whiteboard that includes information and post-it notes about \nthe Sprint backlog, work done, unavailability of staff, and so on. This is a shared \nresource for the whole team, and anyone can change or move items on the board. It \nmeans that any team member can, at a glance, see what others are doing and what \nwork remains to be done.\nAt the end of each sprint, there is a review meeting, which involves the whole \nteam. This meeting has two purposes. First, it is a means of process improvement. \nThe team reviews the way they have worked and reflects on how things could have \nbeen done better. Second, it provides input on the product and the product state for \nthe product backlog review that precedes the next sprint.\nWhile the ScrumMaster is not formally a project manager, in practice ScrumMasters \ntake this role in many organizations that have a conventional management structure. \nThey report on progress to senior management and are involved in longer-term plan-\nning and project budgeting. They may be involved in project administration (agreeing \non holidays for staff, liaising with HR, etc.) and hardware and software purchases.\nIn various Scrum success stories (Schatz and Abdelshafi 2005; Mulder and van \nVliet 2008; Bellouiti 2009), the things that users like about the Scrum method are:\n1. The product is broken down into a set of manageable and understandable chunks \nthat stakeholders can relate to.\n2. Unstable requirements do not hold up progress.\n3. The whole team has visibility of everything, and consequently team communi-\ncation and morale are improved.\n4. Customers see on-time delivery of increments and gain feedback on how the \nproduct works. They are not faced with last-minute surprises when a team \nannounces that software will not be delivered as expected.\n5. Trust between customers and developers is established, and a positive culture is \ncreated in which everyone expects the project to succeed.\nScrum, as originally designed, was intended for use with co-located teams where \nall team members could get together every day in stand-up meetings. However, \nmuch software development now involves distributed teams, with team members \nlocated in different places around the world. This allows companies to take advantage \n\n\n88  Chapter 3 \u25a0 Agile software development\nof lower cost staff in other countries, makes access to specialist skills possible, and \nallows for 24-hour development, with work going on in different time zones.\nConsequently, there have been developments of Scrum for distributed development \nenvironments and multi-team working. Typically, for offshore development, the prod-\nuct owner is in a different country from the development team, which may also be \ndistributed. Figure 3.10 shows the requirements for Distributed Scrum (Deemer 2011).\n \n3.4  Scaling agile methods\nAgile methods were developed for use by small programming teams that could work \ntogether in the same room and communicate informally. They were originally used \nby for the development of small and medium-sized systems and software products. \nSmall companies, without formal processes or bureaucracy, were enthusiastic initial \nadopters of these methods.\nOf course, the need for faster delivery of software, which is more suited to cus-\ntomer needs, also applies to both larger systems and larger companies. Consequently, \nover the past few years, a lot of work has been put into evolving agile methods for \nboth large software systems and for use in large companies.\nScaling agile methods has closely related facets:\n1. Scaling up these methods to handle the development of large systems that are \ntoo big to be developed by a single small team.\n2. \nScaling out these methods from specialized development teams to more widespread \nuse in a large company that has many years of software development experience.\nVideoconferencing \nbetween the product \nowner and the \ndevelopment team\nDistributed Scrum\nThe ScrumMaster \nshould be located with \nthe development team \nso that he or she is \naware of everyday \nproblems.\nThe Product Owner \nshould visit the \ndevelopers and try to \nestablish a good \nrelationship with them. \nIt is essential that they \ntrust each other.\nReal-time communica-\ntions between team \nmembers for informal \ncommunication, \nparticularly instant \nmessaging and video \ncalls.\nContinuous integration, \nso that all team \nmembers can be aware \nof the state of the \nproduct at any time.\nA common development \nenvironment for all teams\nFigure 3.10 Distributed \nScrum"}
{"query": "What are the requirements for implementing Distributed Scrum in a project?", "response": "The requirements for implementing Distributed Scrum in a project include:\n1. Videoconferencing between the product owner and the development team.\n2. The ScrumMaster should be located with the development team to be aware of everyday problems.\n3. The Product Owner should visit the developers and establish a good relationship with them.\n4. Real-time communications between team members for informal communication, particularly instant messaging and video calls.\n5. Continuous integration, so that all team members can be aware of the state of the product at any time.\n6. A common development environment for all teams.", "context": "3.3  \u25a0 Agile project management  87\nsprints, that is, how much of the backlog could be covered in a single sprint. This \nleads to the creation of a sprint backlog\u2014the work to be done during that sprint. The \nteam self-organizes to decide who will work on what, and the sprint begins.\nDuring the sprint, the team holds short daily meetings (Scrums) to review pro-\ngress and, where necessary, to re-prioritize work. During the Scrum, all team mem-\nbers share information, describe their progress since the last meeting, bring up \nproblems that have arisen, and state what is planned for the following day. Thus, \neveryone on the team knows what is going on and, if problems arise, can re-plan \nshort-term work to cope with them. Everyone participates in this short-term plan-\nning; there is no top-down direction from the ScrumMaster.\nThe daily interactions among Scrum teams may be coordinated using a Scrum \nboard. This is an office whiteboard that includes information and post-it notes about \nthe Sprint backlog, work done, unavailability of staff, and so on. This is a shared \nresource for the whole team, and anyone can change or move items on the board. It \nmeans that any team member can, at a glance, see what others are doing and what \nwork remains to be done.\nAt the end of each sprint, there is a review meeting, which involves the whole \nteam. This meeting has two purposes. First, it is a means of process improvement. \nThe team reviews the way they have worked and reflects on how things could have \nbeen done better. Second, it provides input on the product and the product state for \nthe product backlog review that precedes the next sprint.\nWhile the ScrumMaster is not formally a project manager, in practice ScrumMasters \ntake this role in many organizations that have a conventional management structure. \nThey report on progress to senior management and are involved in longer-term plan-\nning and project budgeting. They may be involved in project administration (agreeing \non holidays for staff, liaising with HR, etc.) and hardware and software purchases.\nIn various Scrum success stories (Schatz and Abdelshafi 2005; Mulder and van \nVliet 2008; Bellouiti 2009), the things that users like about the Scrum method are:\n1. The product is broken down into a set of manageable and understandable chunks \nthat stakeholders can relate to.\n2. Unstable requirements do not hold up progress.\n3. The whole team has visibility of everything, and consequently team communi-\ncation and morale are improved.\n4. Customers see on-time delivery of increments and gain feedback on how the \nproduct works. They are not faced with last-minute surprises when a team \nannounces that software will not be delivered as expected.\n5. Trust between customers and developers is established, and a positive culture is \ncreated in which everyone expects the project to succeed.\nScrum, as originally designed, was intended for use with co-located teams where \nall team members could get together every day in stand-up meetings. However, \nmuch software development now involves distributed teams, with team members \nlocated in different places around the world. This allows companies to take advantage \n\n\n88  Chapter 3 \u25a0 Agile software development\nof lower cost staff in other countries, makes access to specialist skills possible, and \nallows for 24-hour development, with work going on in different time zones.\nConsequently, there have been developments of Scrum for distributed development \nenvironments and multi-team working. Typically, for offshore development, the prod-\nuct owner is in a different country from the development team, which may also be \ndistributed. Figure 3.10 shows the requirements for Distributed Scrum (Deemer 2011).\n \n3.4  Scaling agile methods\nAgile methods were developed for use by small programming teams that could work \ntogether in the same room and communicate informally. They were originally used \nby for the development of small and medium-sized systems and software products. \nSmall companies, without formal processes or bureaucracy, were enthusiastic initial \nadopters of these methods.\nOf course, the need for faster delivery of software, which is more suited to cus-\ntomer needs, also applies to both larger systems and larger companies. Consequently, \nover the past few years, a lot of work has been put into evolving agile methods for \nboth large software systems and for use in large companies.\nScaling agile methods has closely related facets:\n1. Scaling up these methods to handle the development of large systems that are \ntoo big to be developed by a single small team.\n2. \nScaling out these methods from specialized development teams to more widespread \nuse in a large company that has many years of software development experience.\nVideoconferencing \nbetween the product \nowner and the \ndevelopment team\nDistributed Scrum\nThe ScrumMaster \nshould be located with \nthe development team \nso that he or she is \naware of everyday \nproblems.\nThe Product Owner \nshould visit the \ndevelopers and try to \nestablish a good \nrelationship with them. \nIt is essential that they \ntrust each other.\nReal-time communica-\ntions between team \nmembers for informal \ncommunication, \nparticularly instant \nmessaging and video \ncalls.\nContinuous integration, \nso that all team \nmembers can be aware \nof the state of the \nproduct at any time.\nA common development \nenvironment for all teams\nFigure 3.10 Distributed \nScrum"}
{"query": "How does continuous integration contribute to the effectiveness of Distributed Scrum?", "response": "Continuous integration contributes to the effectiveness of Distributed Scrum by allowing all team members to be aware of the state of the product at any time. This means that even though team members are located in different places around the world, they can still have real-time access to the latest version of the product and stay updated on its progress. This helps to improve communication and collaboration among team members, ensuring that everyone is working with the most up-to-date information and can make informed decisions.", "context": "3.3  \u25a0 Agile project management  87\nsprints, that is, how much of the backlog could be covered in a single sprint. This \nleads to the creation of a sprint backlog\u2014the work to be done during that sprint. The \nteam self-organizes to decide who will work on what, and the sprint begins.\nDuring the sprint, the team holds short daily meetings (Scrums) to review pro-\ngress and, where necessary, to re-prioritize work. During the Scrum, all team mem-\nbers share information, describe their progress since the last meeting, bring up \nproblems that have arisen, and state what is planned for the following day. Thus, \neveryone on the team knows what is going on and, if problems arise, can re-plan \nshort-term work to cope with them. Everyone participates in this short-term plan-\nning; there is no top-down direction from the ScrumMaster.\nThe daily interactions among Scrum teams may be coordinated using a Scrum \nboard. This is an office whiteboard that includes information and post-it notes about \nthe Sprint backlog, work done, unavailability of staff, and so on. This is a shared \nresource for the whole team, and anyone can change or move items on the board. It \nmeans that any team member can, at a glance, see what others are doing and what \nwork remains to be done.\nAt the end of each sprint, there is a review meeting, which involves the whole \nteam. This meeting has two purposes. First, it is a means of process improvement. \nThe team reviews the way they have worked and reflects on how things could have \nbeen done better. Second, it provides input on the product and the product state for \nthe product backlog review that precedes the next sprint.\nWhile the ScrumMaster is not formally a project manager, in practice ScrumMasters \ntake this role in many organizations that have a conventional management structure. \nThey report on progress to senior management and are involved in longer-term plan-\nning and project budgeting. They may be involved in project administration (agreeing \non holidays for staff, liaising with HR, etc.) and hardware and software purchases.\nIn various Scrum success stories (Schatz and Abdelshafi 2005; Mulder and van \nVliet 2008; Bellouiti 2009), the things that users like about the Scrum method are:\n1. The product is broken down into a set of manageable and understandable chunks \nthat stakeholders can relate to.\n2. Unstable requirements do not hold up progress.\n3. The whole team has visibility of everything, and consequently team communi-\ncation and morale are improved.\n4. Customers see on-time delivery of increments and gain feedback on how the \nproduct works. They are not faced with last-minute surprises when a team \nannounces that software will not be delivered as expected.\n5. Trust between customers and developers is established, and a positive culture is \ncreated in which everyone expects the project to succeed.\nScrum, as originally designed, was intended for use with co-located teams where \nall team members could get together every day in stand-up meetings. However, \nmuch software development now involves distributed teams, with team members \nlocated in different places around the world. This allows companies to take advantage \n\n\n88  Chapter 3 \u25a0 Agile software development\nof lower cost staff in other countries, makes access to specialist skills possible, and \nallows for 24-hour development, with work going on in different time zones.\nConsequently, there have been developments of Scrum for distributed development \nenvironments and multi-team working. Typically, for offshore development, the prod-\nuct owner is in a different country from the development team, which may also be \ndistributed. Figure 3.10 shows the requirements for Distributed Scrum (Deemer 2011).\n \n3.4  Scaling agile methods\nAgile methods were developed for use by small programming teams that could work \ntogether in the same room and communicate informally. They were originally used \nby for the development of small and medium-sized systems and software products. \nSmall companies, without formal processes or bureaucracy, were enthusiastic initial \nadopters of these methods.\nOf course, the need for faster delivery of software, which is more suited to cus-\ntomer needs, also applies to both larger systems and larger companies. Consequently, \nover the past few years, a lot of work has been put into evolving agile methods for \nboth large software systems and for use in large companies.\nScaling agile methods has closely related facets:\n1. Scaling up these methods to handle the development of large systems that are \ntoo big to be developed by a single small team.\n2. \nScaling out these methods from specialized development teams to more widespread \nuse in a large company that has many years of software development experience.\nVideoconferencing \nbetween the product \nowner and the \ndevelopment team\nDistributed Scrum\nThe ScrumMaster \nshould be located with \nthe development team \nso that he or she is \naware of everyday \nproblems.\nThe Product Owner \nshould visit the \ndevelopers and try to \nestablish a good \nrelationship with them. \nIt is essential that they \ntrust each other.\nReal-time communica-\ntions between team \nmembers for informal \ncommunication, \nparticularly instant \nmessaging and video \ncalls.\nContinuous integration, \nso that all team \nmembers can be aware \nof the state of the \nproduct at any time.\nA common development \nenvironment for all teams\nFigure 3.10 Distributed \nScrum"}
{"query": "Why is it important for the ScrumMaster to be located with the development team in Distributed Scrum?", "response": "The ScrumMaster should be located with the development team in Distributed Scrum because it is important for them to be aware of everyday problems that may arise during the development process. Being physically present with the team allows the ScrumMaster to have real-time communication and informal discussions with team members, which helps in building trust and addressing any issues promptly. This close proximity facilitates better collaboration and coordination among team members, ensuring that everyone is on the same page and can work together effectively despite being located in different places.", "context": "3.3  \u25a0 Agile project management  87\nsprints, that is, how much of the backlog could be covered in a single sprint. This \nleads to the creation of a sprint backlog\u2014the work to be done during that sprint. The \nteam self-organizes to decide who will work on what, and the sprint begins.\nDuring the sprint, the team holds short daily meetings (Scrums) to review pro-\ngress and, where necessary, to re-prioritize work. During the Scrum, all team mem-\nbers share information, describe their progress since the last meeting, bring up \nproblems that have arisen, and state what is planned for the following day. Thus, \neveryone on the team knows what is going on and, if problems arise, can re-plan \nshort-term work to cope with them. Everyone participates in this short-term plan-\nning; there is no top-down direction from the ScrumMaster.\nThe daily interactions among Scrum teams may be coordinated using a Scrum \nboard. This is an office whiteboard that includes information and post-it notes about \nthe Sprint backlog, work done, unavailability of staff, and so on. This is a shared \nresource for the whole team, and anyone can change or move items on the board. It \nmeans that any team member can, at a glance, see what others are doing and what \nwork remains to be done.\nAt the end of each sprint, there is a review meeting, which involves the whole \nteam. This meeting has two purposes. First, it is a means of process improvement. \nThe team reviews the way they have worked and reflects on how things could have \nbeen done better. Second, it provides input on the product and the product state for \nthe product backlog review that precedes the next sprint.\nWhile the ScrumMaster is not formally a project manager, in practice ScrumMasters \ntake this role in many organizations that have a conventional management structure. \nThey report on progress to senior management and are involved in longer-term plan-\nning and project budgeting. They may be involved in project administration (agreeing \non holidays for staff, liaising with HR, etc.) and hardware and software purchases.\nIn various Scrum success stories (Schatz and Abdelshafi 2005; Mulder and van \nVliet 2008; Bellouiti 2009), the things that users like about the Scrum method are:\n1. The product is broken down into a set of manageable and understandable chunks \nthat stakeholders can relate to.\n2. Unstable requirements do not hold up progress.\n3. The whole team has visibility of everything, and consequently team communi-\ncation and morale are improved.\n4. Customers see on-time delivery of increments and gain feedback on how the \nproduct works. They are not faced with last-minute surprises when a team \nannounces that software will not be delivered as expected.\n5. Trust between customers and developers is established, and a positive culture is \ncreated in which everyone expects the project to succeed.\nScrum, as originally designed, was intended for use with co-located teams where \nall team members could get together every day in stand-up meetings. However, \nmuch software development now involves distributed teams, with team members \nlocated in different places around the world. This allows companies to take advantage \n\n\n88  Chapter 3 \u25a0 Agile software development\nof lower cost staff in other countries, makes access to specialist skills possible, and \nallows for 24-hour development, with work going on in different time zones.\nConsequently, there have been developments of Scrum for distributed development \nenvironments and multi-team working. Typically, for offshore development, the prod-\nuct owner is in a different country from the development team, which may also be \ndistributed. Figure 3.10 shows the requirements for Distributed Scrum (Deemer 2011).\n \n3.4  Scaling agile methods\nAgile methods were developed for use by small programming teams that could work \ntogether in the same room and communicate informally. They were originally used \nby for the development of small and medium-sized systems and software products. \nSmall companies, without formal processes or bureaucracy, were enthusiastic initial \nadopters of these methods.\nOf course, the need for faster delivery of software, which is more suited to cus-\ntomer needs, also applies to both larger systems and larger companies. Consequently, \nover the past few years, a lot of work has been put into evolving agile methods for \nboth large software systems and for use in large companies.\nScaling agile methods has closely related facets:\n1. Scaling up these methods to handle the development of large systems that are \ntoo big to be developed by a single small team.\n2. \nScaling out these methods from specialized development teams to more widespread \nuse in a large company that has many years of software development experience.\nVideoconferencing \nbetween the product \nowner and the \ndevelopment team\nDistributed Scrum\nThe ScrumMaster \nshould be located with \nthe development team \nso that he or she is \naware of everyday \nproblems.\nThe Product Owner \nshould visit the \ndevelopers and try to \nestablish a good \nrelationship with them. \nIt is essential that they \ntrust each other.\nReal-time communica-\ntions between team \nmembers for informal \ncommunication, \nparticularly instant \nmessaging and video \ncalls.\nContinuous integration, \nso that all team \nmembers can be aware \nof the state of the \nproduct at any time.\nA common development \nenvironment for all teams\nFigure 3.10 Distributed \nScrum"}
{"query": "Why should the Product Owner visit the developers in Distributed Scrum?", "response": "The Product Owner should visit the developers in Distributed Scrum to establish a good relationship with them and to try to establish trust. This is important because in a distributed development environment, where team members are located in different places around the world, it can be challenging to maintain effective communication and collaboration. By visiting the developers, the Product Owner can build rapport and foster a positive working relationship, which can help facilitate better communication and collaboration between the Product Owner and the development team.", "context": "3.3  \u25a0 Agile project management  87\nsprints, that is, how much of the backlog could be covered in a single sprint. This \nleads to the creation of a sprint backlog\u2014the work to be done during that sprint. The \nteam self-organizes to decide who will work on what, and the sprint begins.\nDuring the sprint, the team holds short daily meetings (Scrums) to review pro-\ngress and, where necessary, to re-prioritize work. During the Scrum, all team mem-\nbers share information, describe their progress since the last meeting, bring up \nproblems that have arisen, and state what is planned for the following day. Thus, \neveryone on the team knows what is going on and, if problems arise, can re-plan \nshort-term work to cope with them. Everyone participates in this short-term plan-\nning; there is no top-down direction from the ScrumMaster.\nThe daily interactions among Scrum teams may be coordinated using a Scrum \nboard. This is an office whiteboard that includes information and post-it notes about \nthe Sprint backlog, work done, unavailability of staff, and so on. This is a shared \nresource for the whole team, and anyone can change or move items on the board. It \nmeans that any team member can, at a glance, see what others are doing and what \nwork remains to be done.\nAt the end of each sprint, there is a review meeting, which involves the whole \nteam. This meeting has two purposes. First, it is a means of process improvement. \nThe team reviews the way they have worked and reflects on how things could have \nbeen done better. Second, it provides input on the product and the product state for \nthe product backlog review that precedes the next sprint.\nWhile the ScrumMaster is not formally a project manager, in practice ScrumMasters \ntake this role in many organizations that have a conventional management structure. \nThey report on progress to senior management and are involved in longer-term plan-\nning and project budgeting. They may be involved in project administration (agreeing \non holidays for staff, liaising with HR, etc.) and hardware and software purchases.\nIn various Scrum success stories (Schatz and Abdelshafi 2005; Mulder and van \nVliet 2008; Bellouiti 2009), the things that users like about the Scrum method are:\n1. The product is broken down into a set of manageable and understandable chunks \nthat stakeholders can relate to.\n2. Unstable requirements do not hold up progress.\n3. The whole team has visibility of everything, and consequently team communi-\ncation and morale are improved.\n4. Customers see on-time delivery of increments and gain feedback on how the \nproduct works. They are not faced with last-minute surprises when a team \nannounces that software will not be delivered as expected.\n5. Trust between customers and developers is established, and a positive culture is \ncreated in which everyone expects the project to succeed.\nScrum, as originally designed, was intended for use with co-located teams where \nall team members could get together every day in stand-up meetings. However, \nmuch software development now involves distributed teams, with team members \nlocated in different places around the world. This allows companies to take advantage \n\n\n88  Chapter 3 \u25a0 Agile software development\nof lower cost staff in other countries, makes access to specialist skills possible, and \nallows for 24-hour development, with work going on in different time zones.\nConsequently, there have been developments of Scrum for distributed development \nenvironments and multi-team working. Typically, for offshore development, the prod-\nuct owner is in a different country from the development team, which may also be \ndistributed. Figure 3.10 shows the requirements for Distributed Scrum (Deemer 2011).\n \n3.4  Scaling agile methods\nAgile methods were developed for use by small programming teams that could work \ntogether in the same room and communicate informally. They were originally used \nby for the development of small and medium-sized systems and software products. \nSmall companies, without formal processes or bureaucracy, were enthusiastic initial \nadopters of these methods.\nOf course, the need for faster delivery of software, which is more suited to cus-\ntomer needs, also applies to both larger systems and larger companies. Consequently, \nover the past few years, a lot of work has been put into evolving agile methods for \nboth large software systems and for use in large companies.\nScaling agile methods has closely related facets:\n1. Scaling up these methods to handle the development of large systems that are \ntoo big to be developed by a single small team.\n2. \nScaling out these methods from specialized development teams to more widespread \nuse in a large company that has many years of software development experience.\nVideoconferencing \nbetween the product \nowner and the \ndevelopment team\nDistributed Scrum\nThe ScrumMaster \nshould be located with \nthe development team \nso that he or she is \naware of everyday \nproblems.\nThe Product Owner \nshould visit the \ndevelopers and try to \nestablish a good \nrelationship with them. \nIt is essential that they \ntrust each other.\nReal-time communica-\ntions between team \nmembers for informal \ncommunication, \nparticularly instant \nmessaging and video \ncalls.\nContinuous integration, \nso that all team \nmembers can be aware \nof the state of the \nproduct at any time.\nA common development \nenvironment for all teams\nFigure 3.10 Distributed \nScrum"}
{"query": "What is the importance of real-time communications between team members in Distributed Scrum?", "response": "Real-time communications between team members in Distributed Scrum are important because they facilitate informal communication and enable team members to stay connected despite being located in different places around the world. This allows for immediate collaboration, problem-solving, and decision-making, which is crucial for effective teamwork and coordination in a distributed development environment. Real-time communication tools such as instant messaging and video calls help team members to stay in touch, share information, and maintain a sense of camaraderie, ultimately improving team communication and morale.", "context": "3.3  \u25a0 Agile project management  87\nsprints, that is, how much of the backlog could be covered in a single sprint. This \nleads to the creation of a sprint backlog\u2014the work to be done during that sprint. The \nteam self-organizes to decide who will work on what, and the sprint begins.\nDuring the sprint, the team holds short daily meetings (Scrums) to review pro-\ngress and, where necessary, to re-prioritize work. During the Scrum, all team mem-\nbers share information, describe their progress since the last meeting, bring up \nproblems that have arisen, and state what is planned for the following day. Thus, \neveryone on the team knows what is going on and, if problems arise, can re-plan \nshort-term work to cope with them. Everyone participates in this short-term plan-\nning; there is no top-down direction from the ScrumMaster.\nThe daily interactions among Scrum teams may be coordinated using a Scrum \nboard. This is an office whiteboard that includes information and post-it notes about \nthe Sprint backlog, work done, unavailability of staff, and so on. This is a shared \nresource for the whole team, and anyone can change or move items on the board. It \nmeans that any team member can, at a glance, see what others are doing and what \nwork remains to be done.\nAt the end of each sprint, there is a review meeting, which involves the whole \nteam. This meeting has two purposes. First, it is a means of process improvement. \nThe team reviews the way they have worked and reflects on how things could have \nbeen done better. Second, it provides input on the product and the product state for \nthe product backlog review that precedes the next sprint.\nWhile the ScrumMaster is not formally a project manager, in practice ScrumMasters \ntake this role in many organizations that have a conventional management structure. \nThey report on progress to senior management and are involved in longer-term plan-\nning and project budgeting. They may be involved in project administration (agreeing \non holidays for staff, liaising with HR, etc.) and hardware and software purchases.\nIn various Scrum success stories (Schatz and Abdelshafi 2005; Mulder and van \nVliet 2008; Bellouiti 2009), the things that users like about the Scrum method are:\n1. The product is broken down into a set of manageable and understandable chunks \nthat stakeholders can relate to.\n2. Unstable requirements do not hold up progress.\n3. The whole team has visibility of everything, and consequently team communi-\ncation and morale are improved.\n4. Customers see on-time delivery of increments and gain feedback on how the \nproduct works. They are not faced with last-minute surprises when a team \nannounces that software will not be delivered as expected.\n5. Trust between customers and developers is established, and a positive culture is \ncreated in which everyone expects the project to succeed.\nScrum, as originally designed, was intended for use with co-located teams where \nall team members could get together every day in stand-up meetings. However, \nmuch software development now involves distributed teams, with team members \nlocated in different places around the world. This allows companies to take advantage \n\n\n88  Chapter 3 \u25a0 Agile software development\nof lower cost staff in other countries, makes access to specialist skills possible, and \nallows for 24-hour development, with work going on in different time zones.\nConsequently, there have been developments of Scrum for distributed development \nenvironments and multi-team working. Typically, for offshore development, the prod-\nuct owner is in a different country from the development team, which may also be \ndistributed. Figure 3.10 shows the requirements for Distributed Scrum (Deemer 2011).\n \n3.4  Scaling agile methods\nAgile methods were developed for use by small programming teams that could work \ntogether in the same room and communicate informally. They were originally used \nby for the development of small and medium-sized systems and software products. \nSmall companies, without formal processes or bureaucracy, were enthusiastic initial \nadopters of these methods.\nOf course, the need for faster delivery of software, which is more suited to cus-\ntomer needs, also applies to both larger systems and larger companies. Consequently, \nover the past few years, a lot of work has been put into evolving agile methods for \nboth large software systems and for use in large companies.\nScaling agile methods has closely related facets:\n1. Scaling up these methods to handle the development of large systems that are \ntoo big to be developed by a single small team.\n2. \nScaling out these methods from specialized development teams to more widespread \nuse in a large company that has many years of software development experience.\nVideoconferencing \nbetween the product \nowner and the \ndevelopment team\nDistributed Scrum\nThe ScrumMaster \nshould be located with \nthe development team \nso that he or she is \naware of everyday \nproblems.\nThe Product Owner \nshould visit the \ndevelopers and try to \nestablish a good \nrelationship with them. \nIt is essential that they \ntrust each other.\nReal-time communica-\ntions between team \nmembers for informal \ncommunication, \nparticularly instant \nmessaging and video \ncalls.\nContinuous integration, \nso that all team \nmembers can be aware \nof the state of the \nproduct at any time.\nA common development \nenvironment for all teams\nFigure 3.10 Distributed \nScrum"}
{"query": "Why is it essential for the Product Owner and the developers to trust each other in Distributed Scrum?", "response": "Trust between the Product Owner and the developers is essential in Distributed Scrum because it helps establish a good relationship between them. This trust allows for effective communication and collaboration, even when team members are located in different places around the world. When there is trust, the Product Owner can rely on the developers to deliver the software as expected, and the developers can trust that the Product Owner understands their needs and priorities. This trust fosters a positive culture and creates an environment where everyone expects the project to succeed.", "context": "3.3  \u25a0 Agile project management  87\nsprints, that is, how much of the backlog could be covered in a single sprint. This \nleads to the creation of a sprint backlog\u2014the work to be done during that sprint. The \nteam self-organizes to decide who will work on what, and the sprint begins.\nDuring the sprint, the team holds short daily meetings (Scrums) to review pro-\ngress and, where necessary, to re-prioritize work. During the Scrum, all team mem-\nbers share information, describe their progress since the last meeting, bring up \nproblems that have arisen, and state what is planned for the following day. Thus, \neveryone on the team knows what is going on and, if problems arise, can re-plan \nshort-term work to cope with them. Everyone participates in this short-term plan-\nning; there is no top-down direction from the ScrumMaster.\nThe daily interactions among Scrum teams may be coordinated using a Scrum \nboard. This is an office whiteboard that includes information and post-it notes about \nthe Sprint backlog, work done, unavailability of staff, and so on. This is a shared \nresource for the whole team, and anyone can change or move items on the board. It \nmeans that any team member can, at a glance, see what others are doing and what \nwork remains to be done.\nAt the end of each sprint, there is a review meeting, which involves the whole \nteam. This meeting has two purposes. First, it is a means of process improvement. \nThe team reviews the way they have worked and reflects on how things could have \nbeen done better. Second, it provides input on the product and the product state for \nthe product backlog review that precedes the next sprint.\nWhile the ScrumMaster is not formally a project manager, in practice ScrumMasters \ntake this role in many organizations that have a conventional management structure. \nThey report on progress to senior management and are involved in longer-term plan-\nning and project budgeting. They may be involved in project administration (agreeing \non holidays for staff, liaising with HR, etc.) and hardware and software purchases.\nIn various Scrum success stories (Schatz and Abdelshafi 2005; Mulder and van \nVliet 2008; Bellouiti 2009), the things that users like about the Scrum method are:\n1. The product is broken down into a set of manageable and understandable chunks \nthat stakeholders can relate to.\n2. Unstable requirements do not hold up progress.\n3. The whole team has visibility of everything, and consequently team communi-\ncation and morale are improved.\n4. Customers see on-time delivery of increments and gain feedback on how the \nproduct works. They are not faced with last-minute surprises when a team \nannounces that software will not be delivered as expected.\n5. Trust between customers and developers is established, and a positive culture is \ncreated in which everyone expects the project to succeed.\nScrum, as originally designed, was intended for use with co-located teams where \nall team members could get together every day in stand-up meetings. However, \nmuch software development now involves distributed teams, with team members \nlocated in different places around the world. This allows companies to take advantage \n\n\n88  Chapter 3 \u25a0 Agile software development\nof lower cost staff in other countries, makes access to specialist skills possible, and \nallows for 24-hour development, with work going on in different time zones.\nConsequently, there have been developments of Scrum for distributed development \nenvironments and multi-team working. Typically, for offshore development, the prod-\nuct owner is in a different country from the development team, which may also be \ndistributed. Figure 3.10 shows the requirements for Distributed Scrum (Deemer 2011).\n \n3.4  Scaling agile methods\nAgile methods were developed for use by small programming teams that could work \ntogether in the same room and communicate informally. They were originally used \nby for the development of small and medium-sized systems and software products. \nSmall companies, without formal processes or bureaucracy, were enthusiastic initial \nadopters of these methods.\nOf course, the need for faster delivery of software, which is more suited to cus-\ntomer needs, also applies to both larger systems and larger companies. Consequently, \nover the past few years, a lot of work has been put into evolving agile methods for \nboth large software systems and for use in large companies.\nScaling agile methods has closely related facets:\n1. Scaling up these methods to handle the development of large systems that are \ntoo big to be developed by a single small team.\n2. \nScaling out these methods from specialized development teams to more widespread \nuse in a large company that has many years of software development experience.\nVideoconferencing \nbetween the product \nowner and the \ndevelopment team\nDistributed Scrum\nThe ScrumMaster \nshould be located with \nthe development team \nso that he or she is \naware of everyday \nproblems.\nThe Product Owner \nshould visit the \ndevelopers and try to \nestablish a good \nrelationship with them. \nIt is essential that they \ntrust each other.\nReal-time communica-\ntions between team \nmembers for informal \ncommunication, \nparticularly instant \nmessaging and video \ncalls.\nContinuous integration, \nso that all team \nmembers can be aware \nof the state of the \nproduct at any time.\nA common development \nenvironment for all teams\nFigure 3.10 Distributed \nScrum"}
{"query": "Why is a common development environment necessary for all teams in Distributed Scrum?", "response": "A common development environment is necessary for all teams in Distributed Scrum to ensure that all team members can work together seamlessly and efficiently. It allows for consistent collaboration and communication among team members, regardless of their physical location. With a common development environment, team members can easily access and share code, track progress, and stay updated on the state of the product. This promotes transparency, coordination, and effective teamwork across distributed teams.", "context": "3.3  \u25a0 Agile project management  87\nsprints, that is, how much of the backlog could be covered in a single sprint. This \nleads to the creation of a sprint backlog\u2014the work to be done during that sprint. The \nteam self-organizes to decide who will work on what, and the sprint begins.\nDuring the sprint, the team holds short daily meetings (Scrums) to review pro-\ngress and, where necessary, to re-prioritize work. During the Scrum, all team mem-\nbers share information, describe their progress since the last meeting, bring up \nproblems that have arisen, and state what is planned for the following day. Thus, \neveryone on the team knows what is going on and, if problems arise, can re-plan \nshort-term work to cope with them. Everyone participates in this short-term plan-\nning; there is no top-down direction from the ScrumMaster.\nThe daily interactions among Scrum teams may be coordinated using a Scrum \nboard. This is an office whiteboard that includes information and post-it notes about \nthe Sprint backlog, work done, unavailability of staff, and so on. This is a shared \nresource for the whole team, and anyone can change or move items on the board. It \nmeans that any team member can, at a glance, see what others are doing and what \nwork remains to be done.\nAt the end of each sprint, there is a review meeting, which involves the whole \nteam. This meeting has two purposes. First, it is a means of process improvement. \nThe team reviews the way they have worked and reflects on how things could have \nbeen done better. Second, it provides input on the product and the product state for \nthe product backlog review that precedes the next sprint.\nWhile the ScrumMaster is not formally a project manager, in practice ScrumMasters \ntake this role in many organizations that have a conventional management structure. \nThey report on progress to senior management and are involved in longer-term plan-\nning and project budgeting. They may be involved in project administration (agreeing \non holidays for staff, liaising with HR, etc.) and hardware and software purchases.\nIn various Scrum success stories (Schatz and Abdelshafi 2005; Mulder and van \nVliet 2008; Bellouiti 2009), the things that users like about the Scrum method are:\n1. The product is broken down into a set of manageable and understandable chunks \nthat stakeholders can relate to.\n2. Unstable requirements do not hold up progress.\n3. The whole team has visibility of everything, and consequently team communi-\ncation and morale are improved.\n4. Customers see on-time delivery of increments and gain feedback on how the \nproduct works. They are not faced with last-minute surprises when a team \nannounces that software will not be delivered as expected.\n5. Trust between customers and developers is established, and a positive culture is \ncreated in which everyone expects the project to succeed.\nScrum, as originally designed, was intended for use with co-located teams where \nall team members could get together every day in stand-up meetings. However, \nmuch software development now involves distributed teams, with team members \nlocated in different places around the world. This allows companies to take advantage \n\n\n88  Chapter 3 \u25a0 Agile software development\nof lower cost staff in other countries, makes access to specialist skills possible, and \nallows for 24-hour development, with work going on in different time zones.\nConsequently, there have been developments of Scrum for distributed development \nenvironments and multi-team working. Typically, for offshore development, the prod-\nuct owner is in a different country from the development team, which may also be \ndistributed. Figure 3.10 shows the requirements for Distributed Scrum (Deemer 2011).\n \n3.4  Scaling agile methods\nAgile methods were developed for use by small programming teams that could work \ntogether in the same room and communicate informally. They were originally used \nby for the development of small and medium-sized systems and software products. \nSmall companies, without formal processes or bureaucracy, were enthusiastic initial \nadopters of these methods.\nOf course, the need for faster delivery of software, which is more suited to cus-\ntomer needs, also applies to both larger systems and larger companies. Consequently, \nover the past few years, a lot of work has been put into evolving agile methods for \nboth large software systems and for use in large companies.\nScaling agile methods has closely related facets:\n1. Scaling up these methods to handle the development of large systems that are \ntoo big to be developed by a single small team.\n2. \nScaling out these methods from specialized development teams to more widespread \nuse in a large company that has many years of software development experience.\nVideoconferencing \nbetween the product \nowner and the \ndevelopment team\nDistributed Scrum\nThe ScrumMaster \nshould be located with \nthe development team \nso that he or she is \naware of everyday \nproblems.\nThe Product Owner \nshould visit the \ndevelopers and try to \nestablish a good \nrelationship with them. \nIt is essential that they \ntrust each other.\nReal-time communica-\ntions between team \nmembers for informal \ncommunication, \nparticularly instant \nmessaging and video \ncalls.\nContinuous integration, \nso that all team \nmembers can be aware \nof the state of the \nproduct at any time.\nA common development \nenvironment for all teams\nFigure 3.10 Distributed \nScrum"}
{"query": "How does videoconferencing contribute to the effectiveness of Distributed Scrum?", "response": "Videoconferencing contributes to the effectiveness of Distributed Scrum by enabling real-time communication between the product owner and the development team. This allows for informal communication, such as instant messaging and video calls, which helps to establish a good relationship and trust between team members. It also allows for continuous integration, as all team members can be aware of the state of the product at any time. Overall, videoconferencing helps to bridge the distance between distributed team members and facilitates effective collaboration in a distributed Scrum environment.", "context": "3.3  \u25a0 Agile project management  87\nsprints, that is, how much of the backlog could be covered in a single sprint. This \nleads to the creation of a sprint backlog\u2014the work to be done during that sprint. The \nteam self-organizes to decide who will work on what, and the sprint begins.\nDuring the sprint, the team holds short daily meetings (Scrums) to review pro-\ngress and, where necessary, to re-prioritize work. During the Scrum, all team mem-\nbers share information, describe their progress since the last meeting, bring up \nproblems that have arisen, and state what is planned for the following day. Thus, \neveryone on the team knows what is going on and, if problems arise, can re-plan \nshort-term work to cope with them. Everyone participates in this short-term plan-\nning; there is no top-down direction from the ScrumMaster.\nThe daily interactions among Scrum teams may be coordinated using a Scrum \nboard. This is an office whiteboard that includes information and post-it notes about \nthe Sprint backlog, work done, unavailability of staff, and so on. This is a shared \nresource for the whole team, and anyone can change or move items on the board. It \nmeans that any team member can, at a glance, see what others are doing and what \nwork remains to be done.\nAt the end of each sprint, there is a review meeting, which involves the whole \nteam. This meeting has two purposes. First, it is a means of process improvement. \nThe team reviews the way they have worked and reflects on how things could have \nbeen done better. Second, it provides input on the product and the product state for \nthe product backlog review that precedes the next sprint.\nWhile the ScrumMaster is not formally a project manager, in practice ScrumMasters \ntake this role in many organizations that have a conventional management structure. \nThey report on progress to senior management and are involved in longer-term plan-\nning and project budgeting. They may be involved in project administration (agreeing \non holidays for staff, liaising with HR, etc.) and hardware and software purchases.\nIn various Scrum success stories (Schatz and Abdelshafi 2005; Mulder and van \nVliet 2008; Bellouiti 2009), the things that users like about the Scrum method are:\n1. The product is broken down into a set of manageable and understandable chunks \nthat stakeholders can relate to.\n2. Unstable requirements do not hold up progress.\n3. The whole team has visibility of everything, and consequently team communi-\ncation and morale are improved.\n4. Customers see on-time delivery of increments and gain feedback on how the \nproduct works. They are not faced with last-minute surprises when a team \nannounces that software will not be delivered as expected.\n5. Trust between customers and developers is established, and a positive culture is \ncreated in which everyone expects the project to succeed.\nScrum, as originally designed, was intended for use with co-located teams where \nall team members could get together every day in stand-up meetings. However, \nmuch software development now involves distributed teams, with team members \nlocated in different places around the world. This allows companies to take advantage \n\n\n88  Chapter 3 \u25a0 Agile software development\nof lower cost staff in other countries, makes access to specialist skills possible, and \nallows for 24-hour development, with work going on in different time zones.\nConsequently, there have been developments of Scrum for distributed development \nenvironments and multi-team working. Typically, for offshore development, the prod-\nuct owner is in a different country from the development team, which may also be \ndistributed. Figure 3.10 shows the requirements for Distributed Scrum (Deemer 2011).\n \n3.4  Scaling agile methods\nAgile methods were developed for use by small programming teams that could work \ntogether in the same room and communicate informally. They were originally used \nby for the development of small and medium-sized systems and software products. \nSmall companies, without formal processes or bureaucracy, were enthusiastic initial \nadopters of these methods.\nOf course, the need for faster delivery of software, which is more suited to cus-\ntomer needs, also applies to both larger systems and larger companies. Consequently, \nover the past few years, a lot of work has been put into evolving agile methods for \nboth large software systems and for use in large companies.\nScaling agile methods has closely related facets:\n1. Scaling up these methods to handle the development of large systems that are \ntoo big to be developed by a single small team.\n2. \nScaling out these methods from specialized development teams to more widespread \nuse in a large company that has many years of software development experience.\nVideoconferencing \nbetween the product \nowner and the \ndevelopment team\nDistributed Scrum\nThe ScrumMaster \nshould be located with \nthe development team \nso that he or she is \naware of everyday \nproblems.\nThe Product Owner \nshould visit the \ndevelopers and try to \nestablish a good \nrelationship with them. \nIt is essential that they \ntrust each other.\nReal-time communica-\ntions between team \nmembers for informal \ncommunication, \nparticularly instant \nmessaging and video \ncalls.\nContinuous integration, \nso that all team \nmembers can be aware \nof the state of the \nproduct at any time.\nA common development \nenvironment for all teams\nFigure 3.10 Distributed \nScrum"}
{"query": "How does Distributed Scrum facilitate 24-hour development in different time zones?", "response": "Distributed Scrum facilitates 24-hour development in different time zones by allowing team members located in different places around the world to work on the project. This enables companies to take advantage of lower cost staff in other countries and access specialist skills. With team members in different time zones, work can continue around the clock, ensuring continuous progress on the project.", "context": "3.3  \u25a0 Agile project management  87\nsprints, that is, how much of the backlog could be covered in a single sprint. This \nleads to the creation of a sprint backlog\u2014the work to be done during that sprint. The \nteam self-organizes to decide who will work on what, and the sprint begins.\nDuring the sprint, the team holds short daily meetings (Scrums) to review pro-\ngress and, where necessary, to re-prioritize work. During the Scrum, all team mem-\nbers share information, describe their progress since the last meeting, bring up \nproblems that have arisen, and state what is planned for the following day. Thus, \neveryone on the team knows what is going on and, if problems arise, can re-plan \nshort-term work to cope with them. Everyone participates in this short-term plan-\nning; there is no top-down direction from the ScrumMaster.\nThe daily interactions among Scrum teams may be coordinated using a Scrum \nboard. This is an office whiteboard that includes information and post-it notes about \nthe Sprint backlog, work done, unavailability of staff, and so on. This is a shared \nresource for the whole team, and anyone can change or move items on the board. It \nmeans that any team member can, at a glance, see what others are doing and what \nwork remains to be done.\nAt the end of each sprint, there is a review meeting, which involves the whole \nteam. This meeting has two purposes. First, it is a means of process improvement. \nThe team reviews the way they have worked and reflects on how things could have \nbeen done better. Second, it provides input on the product and the product state for \nthe product backlog review that precedes the next sprint.\nWhile the ScrumMaster is not formally a project manager, in practice ScrumMasters \ntake this role in many organizations that have a conventional management structure. \nThey report on progress to senior management and are involved in longer-term plan-\nning and project budgeting. They may be involved in project administration (agreeing \non holidays for staff, liaising with HR, etc.) and hardware and software purchases.\nIn various Scrum success stories (Schatz and Abdelshafi 2005; Mulder and van \nVliet 2008; Bellouiti 2009), the things that users like about the Scrum method are:\n1. The product is broken down into a set of manageable and understandable chunks \nthat stakeholders can relate to.\n2. Unstable requirements do not hold up progress.\n3. The whole team has visibility of everything, and consequently team communi-\ncation and morale are improved.\n4. Customers see on-time delivery of increments and gain feedback on how the \nproduct works. They are not faced with last-minute surprises when a team \nannounces that software will not be delivered as expected.\n5. Trust between customers and developers is established, and a positive culture is \ncreated in which everyone expects the project to succeed.\nScrum, as originally designed, was intended for use with co-located teams where \nall team members could get together every day in stand-up meetings. However, \nmuch software development now involves distributed teams, with team members \nlocated in different places around the world. This allows companies to take advantage \n\n\n88  Chapter 3 \u25a0 Agile software development\nof lower cost staff in other countries, makes access to specialist skills possible, and \nallows for 24-hour development, with work going on in different time zones.\nConsequently, there have been developments of Scrum for distributed development \nenvironments and multi-team working. Typically, for offshore development, the prod-\nuct owner is in a different country from the development team, which may also be \ndistributed. Figure 3.10 shows the requirements for Distributed Scrum (Deemer 2011).\n \n3.4  Scaling agile methods\nAgile methods were developed for use by small programming teams that could work \ntogether in the same room and communicate informally. They were originally used \nby for the development of small and medium-sized systems and software products. \nSmall companies, without formal processes or bureaucracy, were enthusiastic initial \nadopters of these methods.\nOf course, the need for faster delivery of software, which is more suited to cus-\ntomer needs, also applies to both larger systems and larger companies. Consequently, \nover the past few years, a lot of work has been put into evolving agile methods for \nboth large software systems and for use in large companies.\nScaling agile methods has closely related facets:\n1. Scaling up these methods to handle the development of large systems that are \ntoo big to be developed by a single small team.\n2. \nScaling out these methods from specialized development teams to more widespread \nuse in a large company that has many years of software development experience.\nVideoconferencing \nbetween the product \nowner and the \ndevelopment team\nDistributed Scrum\nThe ScrumMaster \nshould be located with \nthe development team \nso that he or she is \naware of everyday \nproblems.\nThe Product Owner \nshould visit the \ndevelopers and try to \nestablish a good \nrelationship with them. \nIt is essential that they \ntrust each other.\nReal-time communica-\ntions between team \nmembers for informal \ncommunication, \nparticularly instant \nmessaging and video \ncalls.\nContinuous integration, \nso that all team \nmembers can be aware \nof the state of the \nproduct at any time.\nA common development \nenvironment for all teams\nFigure 3.10 Distributed \nScrum"}
{"query": "What is the relationship between scaling up and scaling out in agile methods?", "response": "Scaling up and scaling out are closely related in agile methods. When large software systems are developed by large organizations, multiple teams are usually involved in the development project. These organizations may have already experimented with agile methods in smaller projects. Therefore, they face the challenge of scaling up their agile practices to accommodate the larger system and scaling out to coordinate the work of multiple teams.", "context": "3.4  \u25a0 Scaling agile methods  89\nOf course, scaling up and scaling out are closely related. Contracts to develop \nlarge software systems are usually awarded to large organizations, with multiple \nteams working on the development project. These large companies have often exper-\nimented with agile methods in smaller projects, so they face the problems of scaling \nup and scaling out at the same time.\nThere are many anecdotes about the effectiveness of agile methods, and it has \nbeen suggested that these can lead to orders of magnitude improvements in produc-\ntivity and comparable reductions in defects. Ambler (Ambler 2010), an influential \nagile method developer, suggests that these productivity improvements are exagger-\nated for large systems and organizations. He suggests that an organization moving to \nagile methods can expect to see productivity improvement across the organization of \nabout 15% over 3 years, with similar reductions in the number of product defects.\n \n3.4.1  Practical problems with agile methods\nIn some areas, particularly in the development of software products and apps, agile \ndevelopment has been incredibly successful. It is by far the best approach to use for \nthis type of system. However, agile methods may not be suitable for other types of \nsoftware development, such as embedded systems engineering or the development \nof large and complex systems.\nFor large, long-lifetime systems that are developed by a software company for an \nexternal client, using an agile approach presents a number of problems.\n1. The informality of agile development is incompatible with the legal approach to \ncontract definition that is commonly used in large companies.\n2. Agile methods are most appropriate for new software development rather than \nfor software maintenance. Yet the majority of software costs in large companies \ncome from maintaining their existing software systems.\n3. Agile methods are designed for small co-located teams, yet much software \ndevelopment now involves worldwide distributed teams.\nContractual issues can be a major problem when agile methods are used. When \nthe system customer uses an outside organization for system development, a contract \nfor the software development is drawn up between them. The software requirements \ndocument is usually part of that contract between the customer and the supplier. \nBecause the interleaved development of requirements and code is fundamental to \nagile methods, there is no definitive statement of requirements that can be included \nin the contract.\nConsequently, agile methods have to rely on contracts in which the customer \npays for the time required for system development rather than the development of a \nspecific set of requirements. As long as all goes well, this benefits both the customer \nand the developer. However, if problems arise, then there may be difficult disputes \nover who is to blame and who should pay for the extra time and resources required \nto resolve the problems.\n\n\n90  Chapter 3 \u25a0 Agile software development\nAs I explain in Chapter 9, a  huge amount of software engineering effort goes into the \nmaintenance and evolution of existing software systems. Agile practices, such as incre-\nmental delivery, design for change, and maintaining simplicity all make sense when soft-\nware is being changed. In fact, you can think of an agile development process as a process \nthat supports continual change. If agile methods are used for software product develop-\nment, new releases of the product or app simply involve continuing the agile approach.\nHowever, where maintenance involves a custom system that must be changed in \nresponse to new business requirements, there is no clear consensus on the suitability \nof agile methods for software maintenance (Bird 2011; Kilner 2012). Three types of \nproblems can arise:\n\u25a0 lack of product documentation\n\u25a0 keeping customers involved\n\u25a0 development team continuity\nFormal documentation is supposed to describe the system and so make it easier \nfor people changing the system to understand. In practice, however, formal docu-\nmentation is rarely updated and so does not accurately reflect the program code. For \nthis reason, agile methods enthusiasts argue that it is a waste of time to write this \ndocumentation and that the key to implementing maintainable software is to produce \nhigh-quality, readable code. The lack of documentation should not be a problem in \nmaintaining systems developed using an agile approach.\nHowever, my experience of system maintenance is that the most important docu-\nment is the system requirements document, which tells the software engineer what the \nsystem is supposed to do. Without such knowledge, it is difficult to assess the impact of \nproposed system changes. Many agile methods collect requirements informally and \nincrementally and do not create a coherent requirements document. The use of agile \nmethods may therefore make subsequent system maintenance more difficult and expen-\nsive. This is a particular problem if development team continuity cannot be maintained.\nA key challenge in using an agile approach to maintenance is keeping customers \ninvolved in the process. While a customer may be able to justify the full-time involve-\nment of a representative during system development, this is less likely during mainte-\nnance where changes are not continuous. Customer representatives are likely to lose \ninterest in the system. Therefore, it is likely that alternative mechanisms, such as change \nproposals, discussed in Chapter 25, will have to be adapted to fit in with an agile approach.\nAnother potential problem that may arise is maintaining continuity of the devel-\nopment team. Agile methods rely on team members understanding aspects of the \nsystem without having to consult documentation. If an agile development team is \nbroken up, then this implicit knowledge is lost and it is difficult for new team mem-\nbers to build up the same understanding of the system and its components. Many \nprogrammers prefer to work on new development to software maintenance, and so \nthey are unwilling to continue to work on a software system after the first release has \nbeen delivered. Therefore, even when the intention is to keep the development team \ntogether, people leave if they are assigned maintenance tasks."}
{"query": "How can large organizations face the problems of scaling up and scaling out at the same time?", "response": "Large organizations can face the problems of scaling up and scaling out at the same time by having multiple teams working on the development project. These organizations, which have often experimented with agile methods in smaller projects, may need to scale up their teams to handle the larger software systems they are developing. At the same time, they may also need to scale out by involving distributed teams located worldwide. This combination of scaling up and scaling out can present challenges for large organizations in effectively implementing agile methods.", "context": "3.4  \u25a0 Scaling agile methods  89\nOf course, scaling up and scaling out are closely related. Contracts to develop \nlarge software systems are usually awarded to large organizations, with multiple \nteams working on the development project. These large companies have often exper-\nimented with agile methods in smaller projects, so they face the problems of scaling \nup and scaling out at the same time.\nThere are many anecdotes about the effectiveness of agile methods, and it has \nbeen suggested that these can lead to orders of magnitude improvements in produc-\ntivity and comparable reductions in defects. Ambler (Ambler 2010), an influential \nagile method developer, suggests that these productivity improvements are exagger-\nated for large systems and organizations. He suggests that an organization moving to \nagile methods can expect to see productivity improvement across the organization of \nabout 15% over 3 years, with similar reductions in the number of product defects.\n \n3.4.1  Practical problems with agile methods\nIn some areas, particularly in the development of software products and apps, agile \ndevelopment has been incredibly successful. It is by far the best approach to use for \nthis type of system. However, agile methods may not be suitable for other types of \nsoftware development, such as embedded systems engineering or the development \nof large and complex systems.\nFor large, long-lifetime systems that are developed by a software company for an \nexternal client, using an agile approach presents a number of problems.\n1. The informality of agile development is incompatible with the legal approach to \ncontract definition that is commonly used in large companies.\n2. Agile methods are most appropriate for new software development rather than \nfor software maintenance. Yet the majority of software costs in large companies \ncome from maintaining their existing software systems.\n3. Agile methods are designed for small co-located teams, yet much software \ndevelopment now involves worldwide distributed teams.\nContractual issues can be a major problem when agile methods are used. When \nthe system customer uses an outside organization for system development, a contract \nfor the software development is drawn up between them. The software requirements \ndocument is usually part of that contract between the customer and the supplier. \nBecause the interleaved development of requirements and code is fundamental to \nagile methods, there is no definitive statement of requirements that can be included \nin the contract.\nConsequently, agile methods have to rely on contracts in which the customer \npays for the time required for system development rather than the development of a \nspecific set of requirements. As long as all goes well, this benefits both the customer \nand the developer. However, if problems arise, then there may be difficult disputes \nover who is to blame and who should pay for the extra time and resources required \nto resolve the problems.\n\n\n90  Chapter 3 \u25a0 Agile software development\nAs I explain in Chapter 9, a  huge amount of software engineering effort goes into the \nmaintenance and evolution of existing software systems. Agile practices, such as incre-\nmental delivery, design for change, and maintaining simplicity all make sense when soft-\nware is being changed. In fact, you can think of an agile development process as a process \nthat supports continual change. If agile methods are used for software product develop-\nment, new releases of the product or app simply involve continuing the agile approach.\nHowever, where maintenance involves a custom system that must be changed in \nresponse to new business requirements, there is no clear consensus on the suitability \nof agile methods for software maintenance (Bird 2011; Kilner 2012). Three types of \nproblems can arise:\n\u25a0 lack of product documentation\n\u25a0 keeping customers involved\n\u25a0 development team continuity\nFormal documentation is supposed to describe the system and so make it easier \nfor people changing the system to understand. In practice, however, formal docu-\nmentation is rarely updated and so does not accurately reflect the program code. For \nthis reason, agile methods enthusiasts argue that it is a waste of time to write this \ndocumentation and that the key to implementing maintainable software is to produce \nhigh-quality, readable code. The lack of documentation should not be a problem in \nmaintaining systems developed using an agile approach.\nHowever, my experience of system maintenance is that the most important docu-\nment is the system requirements document, which tells the software engineer what the \nsystem is supposed to do. Without such knowledge, it is difficult to assess the impact of \nproposed system changes. Many agile methods collect requirements informally and \nincrementally and do not create a coherent requirements document. The use of agile \nmethods may therefore make subsequent system maintenance more difficult and expen-\nsive. This is a particular problem if development team continuity cannot be maintained.\nA key challenge in using an agile approach to maintenance is keeping customers \ninvolved in the process. While a customer may be able to justify the full-time involve-\nment of a representative during system development, this is less likely during mainte-\nnance where changes are not continuous. Customer representatives are likely to lose \ninterest in the system. Therefore, it is likely that alternative mechanisms, such as change \nproposals, discussed in Chapter 25, will have to be adapted to fit in with an agile approach.\nAnother potential problem that may arise is maintaining continuity of the devel-\nopment team. Agile methods rely on team members understanding aspects of the \nsystem without having to consult documentation. If an agile development team is \nbroken up, then this implicit knowledge is lost and it is difficult for new team mem-\nbers to build up the same understanding of the system and its components. Many \nprogrammers prefer to work on new development to software maintenance, and so \nthey are unwilling to continue to work on a software system after the first release has \nbeen delivered. Therefore, even when the intention is to keep the development team \ntogether, people leave if they are assigned maintenance tasks."}
{"query": "What are some of the suggested benefits of agile methods?", "response": "Agile methods have been suggested to lead to improvements in productivity and reductions in defects. It has been proposed that organizations moving to agile methods can expect to see a productivity improvement of about 15% over 3 years, along with similar reductions in the number of product defects.", "context": "3.4  \u25a0 Scaling agile methods  89\nOf course, scaling up and scaling out are closely related. Contracts to develop \nlarge software systems are usually awarded to large organizations, with multiple \nteams working on the development project. These large companies have often exper-\nimented with agile methods in smaller projects, so they face the problems of scaling \nup and scaling out at the same time.\nThere are many anecdotes about the effectiveness of agile methods, and it has \nbeen suggested that these can lead to orders of magnitude improvements in produc-\ntivity and comparable reductions in defects. Ambler (Ambler 2010), an influential \nagile method developer, suggests that these productivity improvements are exagger-\nated for large systems and organizations. He suggests that an organization moving to \nagile methods can expect to see productivity improvement across the organization of \nabout 15% over 3 years, with similar reductions in the number of product defects.\n \n3.4.1  Practical problems with agile methods\nIn some areas, particularly in the development of software products and apps, agile \ndevelopment has been incredibly successful. It is by far the best approach to use for \nthis type of system. However, agile methods may not be suitable for other types of \nsoftware development, such as embedded systems engineering or the development \nof large and complex systems.\nFor large, long-lifetime systems that are developed by a software company for an \nexternal client, using an agile approach presents a number of problems.\n1. The informality of agile development is incompatible with the legal approach to \ncontract definition that is commonly used in large companies.\n2. Agile methods are most appropriate for new software development rather than \nfor software maintenance. Yet the majority of software costs in large companies \ncome from maintaining their existing software systems.\n3. Agile methods are designed for small co-located teams, yet much software \ndevelopment now involves worldwide distributed teams.\nContractual issues can be a major problem when agile methods are used. When \nthe system customer uses an outside organization for system development, a contract \nfor the software development is drawn up between them. The software requirements \ndocument is usually part of that contract between the customer and the supplier. \nBecause the interleaved development of requirements and code is fundamental to \nagile methods, there is no definitive statement of requirements that can be included \nin the contract.\nConsequently, agile methods have to rely on contracts in which the customer \npays for the time required for system development rather than the development of a \nspecific set of requirements. As long as all goes well, this benefits both the customer \nand the developer. However, if problems arise, then there may be difficult disputes \nover who is to blame and who should pay for the extra time and resources required \nto resolve the problems.\n\n\n90  Chapter 3 \u25a0 Agile software development\nAs I explain in Chapter 9, a  huge amount of software engineering effort goes into the \nmaintenance and evolution of existing software systems. Agile practices, such as incre-\nmental delivery, design for change, and maintaining simplicity all make sense when soft-\nware is being changed. In fact, you can think of an agile development process as a process \nthat supports continual change. If agile methods are used for software product develop-\nment, new releases of the product or app simply involve continuing the agile approach.\nHowever, where maintenance involves a custom system that must be changed in \nresponse to new business requirements, there is no clear consensus on the suitability \nof agile methods for software maintenance (Bird 2011; Kilner 2012). Three types of \nproblems can arise:\n\u25a0 lack of product documentation\n\u25a0 keeping customers involved\n\u25a0 development team continuity\nFormal documentation is supposed to describe the system and so make it easier \nfor people changing the system to understand. In practice, however, formal docu-\nmentation is rarely updated and so does not accurately reflect the program code. For \nthis reason, agile methods enthusiasts argue that it is a waste of time to write this \ndocumentation and that the key to implementing maintainable software is to produce \nhigh-quality, readable code. The lack of documentation should not be a problem in \nmaintaining systems developed using an agile approach.\nHowever, my experience of system maintenance is that the most important docu-\nment is the system requirements document, which tells the software engineer what the \nsystem is supposed to do. Without such knowledge, it is difficult to assess the impact of \nproposed system changes. Many agile methods collect requirements informally and \nincrementally and do not create a coherent requirements document. The use of agile \nmethods may therefore make subsequent system maintenance more difficult and expen-\nsive. This is a particular problem if development team continuity cannot be maintained.\nA key challenge in using an agile approach to maintenance is keeping customers \ninvolved in the process. While a customer may be able to justify the full-time involve-\nment of a representative during system development, this is less likely during mainte-\nnance where changes are not continuous. Customer representatives are likely to lose \ninterest in the system. Therefore, it is likely that alternative mechanisms, such as change \nproposals, discussed in Chapter 25, will have to be adapted to fit in with an agile approach.\nAnother potential problem that may arise is maintaining continuity of the devel-\nopment team. Agile methods rely on team members understanding aspects of the \nsystem without having to consult documentation. If an agile development team is \nbroken up, then this implicit knowledge is lost and it is difficult for new team mem-\nbers to build up the same understanding of the system and its components. Many \nprogrammers prefer to work on new development to software maintenance, and so \nthey are unwilling to continue to work on a software system after the first release has \nbeen delivered. Therefore, even when the intention is to keep the development team \ntogether, people leave if they are assigned maintenance tasks."}
{"query": "What is Ambler's view on the productivity improvements of agile methods in large systems and organizations?", "response": "Ambler suggests that an organization moving to agile methods can expect to see productivity improvement across the organization of about 15% over 3 years, with similar reductions in the number of product defects.", "context": "3.4  \u25a0 Scaling agile methods  89\nOf course, scaling up and scaling out are closely related. Contracts to develop \nlarge software systems are usually awarded to large organizations, with multiple \nteams working on the development project. These large companies have often exper-\nimented with agile methods in smaller projects, so they face the problems of scaling \nup and scaling out at the same time.\nThere are many anecdotes about the effectiveness of agile methods, and it has \nbeen suggested that these can lead to orders of magnitude improvements in produc-\ntivity and comparable reductions in defects. Ambler (Ambler 2010), an influential \nagile method developer, suggests that these productivity improvements are exagger-\nated for large systems and organizations. He suggests that an organization moving to \nagile methods can expect to see productivity improvement across the organization of \nabout 15% over 3 years, with similar reductions in the number of product defects.\n \n3.4.1  Practical problems with agile methods\nIn some areas, particularly in the development of software products and apps, agile \ndevelopment has been incredibly successful. It is by far the best approach to use for \nthis type of system. However, agile methods may not be suitable for other types of \nsoftware development, such as embedded systems engineering or the development \nof large and complex systems.\nFor large, long-lifetime systems that are developed by a software company for an \nexternal client, using an agile approach presents a number of problems.\n1. The informality of agile development is incompatible with the legal approach to \ncontract definition that is commonly used in large companies.\n2. Agile methods are most appropriate for new software development rather than \nfor software maintenance. Yet the majority of software costs in large companies \ncome from maintaining their existing software systems.\n3. Agile methods are designed for small co-located teams, yet much software \ndevelopment now involves worldwide distributed teams.\nContractual issues can be a major problem when agile methods are used. When \nthe system customer uses an outside organization for system development, a contract \nfor the software development is drawn up between them. The software requirements \ndocument is usually part of that contract between the customer and the supplier. \nBecause the interleaved development of requirements and code is fundamental to \nagile methods, there is no definitive statement of requirements that can be included \nin the contract.\nConsequently, agile methods have to rely on contracts in which the customer \npays for the time required for system development rather than the development of a \nspecific set of requirements. As long as all goes well, this benefits both the customer \nand the developer. However, if problems arise, then there may be difficult disputes \nover who is to blame and who should pay for the extra time and resources required \nto resolve the problems.\n\n\n90  Chapter 3 \u25a0 Agile software development\nAs I explain in Chapter 9, a  huge amount of software engineering effort goes into the \nmaintenance and evolution of existing software systems. Agile practices, such as incre-\nmental delivery, design for change, and maintaining simplicity all make sense when soft-\nware is being changed. In fact, you can think of an agile development process as a process \nthat supports continual change. If agile methods are used for software product develop-\nment, new releases of the product or app simply involve continuing the agile approach.\nHowever, where maintenance involves a custom system that must be changed in \nresponse to new business requirements, there is no clear consensus on the suitability \nof agile methods for software maintenance (Bird 2011; Kilner 2012). Three types of \nproblems can arise:\n\u25a0 lack of product documentation\n\u25a0 keeping customers involved\n\u25a0 development team continuity\nFormal documentation is supposed to describe the system and so make it easier \nfor people changing the system to understand. In practice, however, formal docu-\nmentation is rarely updated and so does not accurately reflect the program code. For \nthis reason, agile methods enthusiasts argue that it is a waste of time to write this \ndocumentation and that the key to implementing maintainable software is to produce \nhigh-quality, readable code. The lack of documentation should not be a problem in \nmaintaining systems developed using an agile approach.\nHowever, my experience of system maintenance is that the most important docu-\nment is the system requirements document, which tells the software engineer what the \nsystem is supposed to do. Without such knowledge, it is difficult to assess the impact of \nproposed system changes. Many agile methods collect requirements informally and \nincrementally and do not create a coherent requirements document. The use of agile \nmethods may therefore make subsequent system maintenance more difficult and expen-\nsive. This is a particular problem if development team continuity cannot be maintained.\nA key challenge in using an agile approach to maintenance is keeping customers \ninvolved in the process. While a customer may be able to justify the full-time involve-\nment of a representative during system development, this is less likely during mainte-\nnance where changes are not continuous. Customer representatives are likely to lose \ninterest in the system. Therefore, it is likely that alternative mechanisms, such as change \nproposals, discussed in Chapter 25, will have to be adapted to fit in with an agile approach.\nAnother potential problem that may arise is maintaining continuity of the devel-\nopment team. Agile methods rely on team members understanding aspects of the \nsystem without having to consult documentation. If an agile development team is \nbroken up, then this implicit knowledge is lost and it is difficult for new team mem-\nbers to build up the same understanding of the system and its components. Many \nprogrammers prefer to work on new development to software maintenance, and so \nthey are unwilling to continue to work on a software system after the first release has \nbeen delivered. Therefore, even when the intention is to keep the development team \ntogether, people leave if they are assigned maintenance tasks."}
{"query": "What are some practical problems with agile methods?", "response": "Some practical problems with agile methods include the informality of agile development being incompatible with the legal approach to contract definition used in large companies, the fact that agile methods are most appropriate for new software development rather than software maintenance (which is a significant cost for large companies), and the challenge of using agile methods with worldwide distributed teams. Additionally, contractual issues can arise when using agile methods, as the interleaved development of requirements and code makes it difficult to include a definitive statement of requirements in a contract. This can lead to disputes over who is to blame and who should pay for extra time and resources required to resolve problems.", "context": "3.4  \u25a0 Scaling agile methods  89\nOf course, scaling up and scaling out are closely related. Contracts to develop \nlarge software systems are usually awarded to large organizations, with multiple \nteams working on the development project. These large companies have often exper-\nimented with agile methods in smaller projects, so they face the problems of scaling \nup and scaling out at the same time.\nThere are many anecdotes about the effectiveness of agile methods, and it has \nbeen suggested that these can lead to orders of magnitude improvements in produc-\ntivity and comparable reductions in defects. Ambler (Ambler 2010), an influential \nagile method developer, suggests that these productivity improvements are exagger-\nated for large systems and organizations. He suggests that an organization moving to \nagile methods can expect to see productivity improvement across the organization of \nabout 15% over 3 years, with similar reductions in the number of product defects.\n \n3.4.1  Practical problems with agile methods\nIn some areas, particularly in the development of software products and apps, agile \ndevelopment has been incredibly successful. It is by far the best approach to use for \nthis type of system. However, agile methods may not be suitable for other types of \nsoftware development, such as embedded systems engineering or the development \nof large and complex systems.\nFor large, long-lifetime systems that are developed by a software company for an \nexternal client, using an agile approach presents a number of problems.\n1. The informality of agile development is incompatible with the legal approach to \ncontract definition that is commonly used in large companies.\n2. Agile methods are most appropriate for new software development rather than \nfor software maintenance. Yet the majority of software costs in large companies \ncome from maintaining their existing software systems.\n3. Agile methods are designed for small co-located teams, yet much software \ndevelopment now involves worldwide distributed teams.\nContractual issues can be a major problem when agile methods are used. When \nthe system customer uses an outside organization for system development, a contract \nfor the software development is drawn up between them. The software requirements \ndocument is usually part of that contract between the customer and the supplier. \nBecause the interleaved development of requirements and code is fundamental to \nagile methods, there is no definitive statement of requirements that can be included \nin the contract.\nConsequently, agile methods have to rely on contracts in which the customer \npays for the time required for system development rather than the development of a \nspecific set of requirements. As long as all goes well, this benefits both the customer \nand the developer. However, if problems arise, then there may be difficult disputes \nover who is to blame and who should pay for the extra time and resources required \nto resolve the problems.\n\n\n90  Chapter 3 \u25a0 Agile software development\nAs I explain in Chapter 9, a  huge amount of software engineering effort goes into the \nmaintenance and evolution of existing software systems. Agile practices, such as incre-\nmental delivery, design for change, and maintaining simplicity all make sense when soft-\nware is being changed. In fact, you can think of an agile development process as a process \nthat supports continual change. If agile methods are used for software product develop-\nment, new releases of the product or app simply involve continuing the agile approach.\nHowever, where maintenance involves a custom system that must be changed in \nresponse to new business requirements, there is no clear consensus on the suitability \nof agile methods for software maintenance (Bird 2011; Kilner 2012). Three types of \nproblems can arise:\n\u25a0 lack of product documentation\n\u25a0 keeping customers involved\n\u25a0 development team continuity\nFormal documentation is supposed to describe the system and so make it easier \nfor people changing the system to understand. In practice, however, formal docu-\nmentation is rarely updated and so does not accurately reflect the program code. For \nthis reason, agile methods enthusiasts argue that it is a waste of time to write this \ndocumentation and that the key to implementing maintainable software is to produce \nhigh-quality, readable code. The lack of documentation should not be a problem in \nmaintaining systems developed using an agile approach.\nHowever, my experience of system maintenance is that the most important docu-\nment is the system requirements document, which tells the software engineer what the \nsystem is supposed to do. Without such knowledge, it is difficult to assess the impact of \nproposed system changes. Many agile methods collect requirements informally and \nincrementally and do not create a coherent requirements document. The use of agile \nmethods may therefore make subsequent system maintenance more difficult and expen-\nsive. This is a particular problem if development team continuity cannot be maintained.\nA key challenge in using an agile approach to maintenance is keeping customers \ninvolved in the process. While a customer may be able to justify the full-time involve-\nment of a representative during system development, this is less likely during mainte-\nnance where changes are not continuous. Customer representatives are likely to lose \ninterest in the system. Therefore, it is likely that alternative mechanisms, such as change \nproposals, discussed in Chapter 25, will have to be adapted to fit in with an agile approach.\nAnother potential problem that may arise is maintaining continuity of the devel-\nopment team. Agile methods rely on team members understanding aspects of the \nsystem without having to consult documentation. If an agile development team is \nbroken up, then this implicit knowledge is lost and it is difficult for new team mem-\nbers to build up the same understanding of the system and its components. Many \nprogrammers prefer to work on new development to software maintenance, and so \nthey are unwilling to continue to work on a software system after the first release has \nbeen delivered. Therefore, even when the intention is to keep the development team \ntogether, people leave if they are assigned maintenance tasks."}
{"query": "Why might agile methods not be suitable for the development of large and complex systems?", "response": "Agile methods may not be suitable for the development of large and complex systems for several reasons. Firstly, the informality of agile development may be incompatible with the legal approach to contract definition commonly used in large companies. Secondly, agile methods are most appropriate for new software development rather than for software maintenance, which is where the majority of software costs in large companies come from. Lastly, agile methods are designed for small co-located teams, but much software development now involves worldwide distributed teams.", "context": "3.4  \u25a0 Scaling agile methods  89\nOf course, scaling up and scaling out are closely related. Contracts to develop \nlarge software systems are usually awarded to large organizations, with multiple \nteams working on the development project. These large companies have often exper-\nimented with agile methods in smaller projects, so they face the problems of scaling \nup and scaling out at the same time.\nThere are many anecdotes about the effectiveness of agile methods, and it has \nbeen suggested that these can lead to orders of magnitude improvements in produc-\ntivity and comparable reductions in defects. Ambler (Ambler 2010), an influential \nagile method developer, suggests that these productivity improvements are exagger-\nated for large systems and organizations. He suggests that an organization moving to \nagile methods can expect to see productivity improvement across the organization of \nabout 15% over 3 years, with similar reductions in the number of product defects.\n \n3.4.1  Practical problems with agile methods\nIn some areas, particularly in the development of software products and apps, agile \ndevelopment has been incredibly successful. It is by far the best approach to use for \nthis type of system. However, agile methods may not be suitable for other types of \nsoftware development, such as embedded systems engineering or the development \nof large and complex systems.\nFor large, long-lifetime systems that are developed by a software company for an \nexternal client, using an agile approach presents a number of problems.\n1. The informality of agile development is incompatible with the legal approach to \ncontract definition that is commonly used in large companies.\n2. Agile methods are most appropriate for new software development rather than \nfor software maintenance. Yet the majority of software costs in large companies \ncome from maintaining their existing software systems.\n3. Agile methods are designed for small co-located teams, yet much software \ndevelopment now involves worldwide distributed teams.\nContractual issues can be a major problem when agile methods are used. When \nthe system customer uses an outside organization for system development, a contract \nfor the software development is drawn up between them. The software requirements \ndocument is usually part of that contract between the customer and the supplier. \nBecause the interleaved development of requirements and code is fundamental to \nagile methods, there is no definitive statement of requirements that can be included \nin the contract.\nConsequently, agile methods have to rely on contracts in which the customer \npays for the time required for system development rather than the development of a \nspecific set of requirements. As long as all goes well, this benefits both the customer \nand the developer. However, if problems arise, then there may be difficult disputes \nover who is to blame and who should pay for the extra time and resources required \nto resolve the problems.\n\n\n90  Chapter 3 \u25a0 Agile software development\nAs I explain in Chapter 9, a  huge amount of software engineering effort goes into the \nmaintenance and evolution of existing software systems. Agile practices, such as incre-\nmental delivery, design for change, and maintaining simplicity all make sense when soft-\nware is being changed. In fact, you can think of an agile development process as a process \nthat supports continual change. If agile methods are used for software product develop-\nment, new releases of the product or app simply involve continuing the agile approach.\nHowever, where maintenance involves a custom system that must be changed in \nresponse to new business requirements, there is no clear consensus on the suitability \nof agile methods for software maintenance (Bird 2011; Kilner 2012). Three types of \nproblems can arise:\n\u25a0 lack of product documentation\n\u25a0 keeping customers involved\n\u25a0 development team continuity\nFormal documentation is supposed to describe the system and so make it easier \nfor people changing the system to understand. In practice, however, formal docu-\nmentation is rarely updated and so does not accurately reflect the program code. For \nthis reason, agile methods enthusiasts argue that it is a waste of time to write this \ndocumentation and that the key to implementing maintainable software is to produce \nhigh-quality, readable code. The lack of documentation should not be a problem in \nmaintaining systems developed using an agile approach.\nHowever, my experience of system maintenance is that the most important docu-\nment is the system requirements document, which tells the software engineer what the \nsystem is supposed to do. Without such knowledge, it is difficult to assess the impact of \nproposed system changes. Many agile methods collect requirements informally and \nincrementally and do not create a coherent requirements document. The use of agile \nmethods may therefore make subsequent system maintenance more difficult and expen-\nsive. This is a particular problem if development team continuity cannot be maintained.\nA key challenge in using an agile approach to maintenance is keeping customers \ninvolved in the process. While a customer may be able to justify the full-time involve-\nment of a representative during system development, this is less likely during mainte-\nnance where changes are not continuous. Customer representatives are likely to lose \ninterest in the system. Therefore, it is likely that alternative mechanisms, such as change \nproposals, discussed in Chapter 25, will have to be adapted to fit in with an agile approach.\nAnother potential problem that may arise is maintaining continuity of the devel-\nopment team. Agile methods rely on team members understanding aspects of the \nsystem without having to consult documentation. If an agile development team is \nbroken up, then this implicit knowledge is lost and it is difficult for new team mem-\nbers to build up the same understanding of the system and its components. Many \nprogrammers prefer to work on new development to software maintenance, and so \nthey are unwilling to continue to work on a software system after the first release has \nbeen delivered. Therefore, even when the intention is to keep the development team \ntogether, people leave if they are assigned maintenance tasks."}
{"query": "What are some of the problems that arise when using an agile approach for large, long-lifetime systems developed by a software company for an external client?", "response": "The informality of agile development is incompatible with the legal approach to contract definition commonly used in large companies. Agile methods are most appropriate for new software development rather than for software maintenance, which is a significant cost for large companies. Agile methods are designed for small co-located teams, but much software development now involves worldwide distributed teams. Contractual issues can also be a major problem when agile methods are used, as there is no definitive statement of requirements that can be included in the contract. This can lead to disputes over who is to blame and who should pay for extra time and resources required to resolve problems.", "context": "3.4  \u25a0 Scaling agile methods  89\nOf course, scaling up and scaling out are closely related. Contracts to develop \nlarge software systems are usually awarded to large organizations, with multiple \nteams working on the development project. These large companies have often exper-\nimented with agile methods in smaller projects, so they face the problems of scaling \nup and scaling out at the same time.\nThere are many anecdotes about the effectiveness of agile methods, and it has \nbeen suggested that these can lead to orders of magnitude improvements in produc-\ntivity and comparable reductions in defects. Ambler (Ambler 2010), an influential \nagile method developer, suggests that these productivity improvements are exagger-\nated for large systems and organizations. He suggests that an organization moving to \nagile methods can expect to see productivity improvement across the organization of \nabout 15% over 3 years, with similar reductions in the number of product defects.\n \n3.4.1  Practical problems with agile methods\nIn some areas, particularly in the development of software products and apps, agile \ndevelopment has been incredibly successful. It is by far the best approach to use for \nthis type of system. However, agile methods may not be suitable for other types of \nsoftware development, such as embedded systems engineering or the development \nof large and complex systems.\nFor large, long-lifetime systems that are developed by a software company for an \nexternal client, using an agile approach presents a number of problems.\n1. The informality of agile development is incompatible with the legal approach to \ncontract definition that is commonly used in large companies.\n2. Agile methods are most appropriate for new software development rather than \nfor software maintenance. Yet the majority of software costs in large companies \ncome from maintaining their existing software systems.\n3. Agile methods are designed for small co-located teams, yet much software \ndevelopment now involves worldwide distributed teams.\nContractual issues can be a major problem when agile methods are used. When \nthe system customer uses an outside organization for system development, a contract \nfor the software development is drawn up between them. The software requirements \ndocument is usually part of that contract between the customer and the supplier. \nBecause the interleaved development of requirements and code is fundamental to \nagile methods, there is no definitive statement of requirements that can be included \nin the contract.\nConsequently, agile methods have to rely on contracts in which the customer \npays for the time required for system development rather than the development of a \nspecific set of requirements. As long as all goes well, this benefits both the customer \nand the developer. However, if problems arise, then there may be difficult disputes \nover who is to blame and who should pay for the extra time and resources required \nto resolve the problems.\n\n\n90  Chapter 3 \u25a0 Agile software development\nAs I explain in Chapter 9, a  huge amount of software engineering effort goes into the \nmaintenance and evolution of existing software systems. Agile practices, such as incre-\nmental delivery, design for change, and maintaining simplicity all make sense when soft-\nware is being changed. In fact, you can think of an agile development process as a process \nthat supports continual change. If agile methods are used for software product develop-\nment, new releases of the product or app simply involve continuing the agile approach.\nHowever, where maintenance involves a custom system that must be changed in \nresponse to new business requirements, there is no clear consensus on the suitability \nof agile methods for software maintenance (Bird 2011; Kilner 2012). Three types of \nproblems can arise:\n\u25a0 lack of product documentation\n\u25a0 keeping customers involved\n\u25a0 development team continuity\nFormal documentation is supposed to describe the system and so make it easier \nfor people changing the system to understand. In practice, however, formal docu-\nmentation is rarely updated and so does not accurately reflect the program code. For \nthis reason, agile methods enthusiasts argue that it is a waste of time to write this \ndocumentation and that the key to implementing maintainable software is to produce \nhigh-quality, readable code. The lack of documentation should not be a problem in \nmaintaining systems developed using an agile approach.\nHowever, my experience of system maintenance is that the most important docu-\nment is the system requirements document, which tells the software engineer what the \nsystem is supposed to do. Without such knowledge, it is difficult to assess the impact of \nproposed system changes. Many agile methods collect requirements informally and \nincrementally and do not create a coherent requirements document. The use of agile \nmethods may therefore make subsequent system maintenance more difficult and expen-\nsive. This is a particular problem if development team continuity cannot be maintained.\nA key challenge in using an agile approach to maintenance is keeping customers \ninvolved in the process. While a customer may be able to justify the full-time involve-\nment of a representative during system development, this is less likely during mainte-\nnance where changes are not continuous. Customer representatives are likely to lose \ninterest in the system. Therefore, it is likely that alternative mechanisms, such as change \nproposals, discussed in Chapter 25, will have to be adapted to fit in with an agile approach.\nAnother potential problem that may arise is maintaining continuity of the devel-\nopment team. Agile methods rely on team members understanding aspects of the \nsystem without having to consult documentation. If an agile development team is \nbroken up, then this implicit knowledge is lost and it is difficult for new team mem-\nbers to build up the same understanding of the system and its components. Many \nprogrammers prefer to work on new development to software maintenance, and so \nthey are unwilling to continue to work on a software system after the first release has \nbeen delivered. Therefore, even when the intention is to keep the development team \ntogether, people leave if they are assigned maintenance tasks."}
{"query": "Why are agile methods not most appropriate for software maintenance?", "response": "Agile methods are not most appropriate for software maintenance because they lack formal documentation and do not create a coherent requirements document. This can make subsequent system maintenance more difficult and expensive. Additionally, maintaining continuity of the development team can be a challenge with agile methods, as team members rely on implicit knowledge and may leave if assigned maintenance tasks.", "context": "3.4  \u25a0 Scaling agile methods  89\nOf course, scaling up and scaling out are closely related. Contracts to develop \nlarge software systems are usually awarded to large organizations, with multiple \nteams working on the development project. These large companies have often exper-\nimented with agile methods in smaller projects, so they face the problems of scaling \nup and scaling out at the same time.\nThere are many anecdotes about the effectiveness of agile methods, and it has \nbeen suggested that these can lead to orders of magnitude improvements in produc-\ntivity and comparable reductions in defects. Ambler (Ambler 2010), an influential \nagile method developer, suggests that these productivity improvements are exagger-\nated for large systems and organizations. He suggests that an organization moving to \nagile methods can expect to see productivity improvement across the organization of \nabout 15% over 3 years, with similar reductions in the number of product defects.\n \n3.4.1  Practical problems with agile methods\nIn some areas, particularly in the development of software products and apps, agile \ndevelopment has been incredibly successful. It is by far the best approach to use for \nthis type of system. However, agile methods may not be suitable for other types of \nsoftware development, such as embedded systems engineering or the development \nof large and complex systems.\nFor large, long-lifetime systems that are developed by a software company for an \nexternal client, using an agile approach presents a number of problems.\n1. The informality of agile development is incompatible with the legal approach to \ncontract definition that is commonly used in large companies.\n2. Agile methods are most appropriate for new software development rather than \nfor software maintenance. Yet the majority of software costs in large companies \ncome from maintaining their existing software systems.\n3. Agile methods are designed for small co-located teams, yet much software \ndevelopment now involves worldwide distributed teams.\nContractual issues can be a major problem when agile methods are used. When \nthe system customer uses an outside organization for system development, a contract \nfor the software development is drawn up between them. The software requirements \ndocument is usually part of that contract between the customer and the supplier. \nBecause the interleaved development of requirements and code is fundamental to \nagile methods, there is no definitive statement of requirements that can be included \nin the contract.\nConsequently, agile methods have to rely on contracts in which the customer \npays for the time required for system development rather than the development of a \nspecific set of requirements. As long as all goes well, this benefits both the customer \nand the developer. However, if problems arise, then there may be difficult disputes \nover who is to blame and who should pay for the extra time and resources required \nto resolve the problems.\n\n\n90  Chapter 3 \u25a0 Agile software development\nAs I explain in Chapter 9, a  huge amount of software engineering effort goes into the \nmaintenance and evolution of existing software systems. Agile practices, such as incre-\nmental delivery, design for change, and maintaining simplicity all make sense when soft-\nware is being changed. In fact, you can think of an agile development process as a process \nthat supports continual change. If agile methods are used for software product develop-\nment, new releases of the product or app simply involve continuing the agile approach.\nHowever, where maintenance involves a custom system that must be changed in \nresponse to new business requirements, there is no clear consensus on the suitability \nof agile methods for software maintenance (Bird 2011; Kilner 2012). Three types of \nproblems can arise:\n\u25a0 lack of product documentation\n\u25a0 keeping customers involved\n\u25a0 development team continuity\nFormal documentation is supposed to describe the system and so make it easier \nfor people changing the system to understand. In practice, however, formal docu-\nmentation is rarely updated and so does not accurately reflect the program code. For \nthis reason, agile methods enthusiasts argue that it is a waste of time to write this \ndocumentation and that the key to implementing maintainable software is to produce \nhigh-quality, readable code. The lack of documentation should not be a problem in \nmaintaining systems developed using an agile approach.\nHowever, my experience of system maintenance is that the most important docu-\nment is the system requirements document, which tells the software engineer what the \nsystem is supposed to do. Without such knowledge, it is difficult to assess the impact of \nproposed system changes. Many agile methods collect requirements informally and \nincrementally and do not create a coherent requirements document. The use of agile \nmethods may therefore make subsequent system maintenance more difficult and expen-\nsive. This is a particular problem if development team continuity cannot be maintained.\nA key challenge in using an agile approach to maintenance is keeping customers \ninvolved in the process. While a customer may be able to justify the full-time involve-\nment of a representative during system development, this is less likely during mainte-\nnance where changes are not continuous. Customer representatives are likely to lose \ninterest in the system. Therefore, it is likely that alternative mechanisms, such as change \nproposals, discussed in Chapter 25, will have to be adapted to fit in with an agile approach.\nAnother potential problem that may arise is maintaining continuity of the devel-\nopment team. Agile methods rely on team members understanding aspects of the \nsystem without having to consult documentation. If an agile development team is \nbroken up, then this implicit knowledge is lost and it is difficult for new team mem-\nbers to build up the same understanding of the system and its components. Many \nprogrammers prefer to work on new development to software maintenance, and so \nthey are unwilling to continue to work on a software system after the first release has \nbeen delivered. Therefore, even when the intention is to keep the development team \ntogether, people leave if they are assigned maintenance tasks."}
{"query": "How do contractual issues arise when agile methods are used?", "response": "Contractual issues arise when agile methods are used because the informality of agile development is incompatible with the legal approach to contract definition commonly used in large companies. Agile methods rely on the interleaved development of requirements and code, which means there is no definitive statement of requirements that can be included in the contract. As a result, contracts for agile development often involve the customer paying for the time required for system development rather than the development of a specific set of requirements. While this can benefit both the customer and the developer when things go well, it can lead to difficult disputes over who is to blame and who should pay for extra time and resources when problems arise.", "context": "3.4  \u25a0 Scaling agile methods  89\nOf course, scaling up and scaling out are closely related. Contracts to develop \nlarge software systems are usually awarded to large organizations, with multiple \nteams working on the development project. These large companies have often exper-\nimented with agile methods in smaller projects, so they face the problems of scaling \nup and scaling out at the same time.\nThere are many anecdotes about the effectiveness of agile methods, and it has \nbeen suggested that these can lead to orders of magnitude improvements in produc-\ntivity and comparable reductions in defects. Ambler (Ambler 2010), an influential \nagile method developer, suggests that these productivity improvements are exagger-\nated for large systems and organizations. He suggests that an organization moving to \nagile methods can expect to see productivity improvement across the organization of \nabout 15% over 3 years, with similar reductions in the number of product defects.\n \n3.4.1  Practical problems with agile methods\nIn some areas, particularly in the development of software products and apps, agile \ndevelopment has been incredibly successful. It is by far the best approach to use for \nthis type of system. However, agile methods may not be suitable for other types of \nsoftware development, such as embedded systems engineering or the development \nof large and complex systems.\nFor large, long-lifetime systems that are developed by a software company for an \nexternal client, using an agile approach presents a number of problems.\n1. The informality of agile development is incompatible with the legal approach to \ncontract definition that is commonly used in large companies.\n2. Agile methods are most appropriate for new software development rather than \nfor software maintenance. Yet the majority of software costs in large companies \ncome from maintaining their existing software systems.\n3. Agile methods are designed for small co-located teams, yet much software \ndevelopment now involves worldwide distributed teams.\nContractual issues can be a major problem when agile methods are used. When \nthe system customer uses an outside organization for system development, a contract \nfor the software development is drawn up between them. The software requirements \ndocument is usually part of that contract between the customer and the supplier. \nBecause the interleaved development of requirements and code is fundamental to \nagile methods, there is no definitive statement of requirements that can be included \nin the contract.\nConsequently, agile methods have to rely on contracts in which the customer \npays for the time required for system development rather than the development of a \nspecific set of requirements. As long as all goes well, this benefits both the customer \nand the developer. However, if problems arise, then there may be difficult disputes \nover who is to blame and who should pay for the extra time and resources required \nto resolve the problems.\n\n\n90  Chapter 3 \u25a0 Agile software development\nAs I explain in Chapter 9, a  huge amount of software engineering effort goes into the \nmaintenance and evolution of existing software systems. Agile practices, such as incre-\nmental delivery, design for change, and maintaining simplicity all make sense when soft-\nware is being changed. In fact, you can think of an agile development process as a process \nthat supports continual change. If agile methods are used for software product develop-\nment, new releases of the product or app simply involve continuing the agile approach.\nHowever, where maintenance involves a custom system that must be changed in \nresponse to new business requirements, there is no clear consensus on the suitability \nof agile methods for software maintenance (Bird 2011; Kilner 2012). Three types of \nproblems can arise:\n\u25a0 lack of product documentation\n\u25a0 keeping customers involved\n\u25a0 development team continuity\nFormal documentation is supposed to describe the system and so make it easier \nfor people changing the system to understand. In practice, however, formal docu-\nmentation is rarely updated and so does not accurately reflect the program code. For \nthis reason, agile methods enthusiasts argue that it is a waste of time to write this \ndocumentation and that the key to implementing maintainable software is to produce \nhigh-quality, readable code. The lack of documentation should not be a problem in \nmaintaining systems developed using an agile approach.\nHowever, my experience of system maintenance is that the most important docu-\nment is the system requirements document, which tells the software engineer what the \nsystem is supposed to do. Without such knowledge, it is difficult to assess the impact of \nproposed system changes. Many agile methods collect requirements informally and \nincrementally and do not create a coherent requirements document. The use of agile \nmethods may therefore make subsequent system maintenance more difficult and expen-\nsive. This is a particular problem if development team continuity cannot be maintained.\nA key challenge in using an agile approach to maintenance is keeping customers \ninvolved in the process. While a customer may be able to justify the full-time involve-\nment of a representative during system development, this is less likely during mainte-\nnance where changes are not continuous. Customer representatives are likely to lose \ninterest in the system. Therefore, it is likely that alternative mechanisms, such as change \nproposals, discussed in Chapter 25, will have to be adapted to fit in with an agile approach.\nAnother potential problem that may arise is maintaining continuity of the devel-\nopment team. Agile methods rely on team members understanding aspects of the \nsystem without having to consult documentation. If an agile development team is \nbroken up, then this implicit knowledge is lost and it is difficult for new team mem-\nbers to build up the same understanding of the system and its components. Many \nprogrammers prefer to work on new development to software maintenance, and so \nthey are unwilling to continue to work on a software system after the first release has \nbeen delivered. Therefore, even when the intention is to keep the development team \ntogether, people leave if they are assigned maintenance tasks."}
{"query": "What is the fundamental aspect of agile methods that makes it difficult to include a definitive statement of requirements in the contract?", "response": "The fundamental aspect of agile methods that makes it difficult to include a definitive statement of requirements in the contract is the interleaved development of requirements and code.", "context": "3.4  \u25a0 Scaling agile methods  89\nOf course, scaling up and scaling out are closely related. Contracts to develop \nlarge software systems are usually awarded to large organizations, with multiple \nteams working on the development project. These large companies have often exper-\nimented with agile methods in smaller projects, so they face the problems of scaling \nup and scaling out at the same time.\nThere are many anecdotes about the effectiveness of agile methods, and it has \nbeen suggested that these can lead to orders of magnitude improvements in produc-\ntivity and comparable reductions in defects. Ambler (Ambler 2010), an influential \nagile method developer, suggests that these productivity improvements are exagger-\nated for large systems and organizations. He suggests that an organization moving to \nagile methods can expect to see productivity improvement across the organization of \nabout 15% over 3 years, with similar reductions in the number of product defects.\n \n3.4.1  Practical problems with agile methods\nIn some areas, particularly in the development of software products and apps, agile \ndevelopment has been incredibly successful. It is by far the best approach to use for \nthis type of system. However, agile methods may not be suitable for other types of \nsoftware development, such as embedded systems engineering or the development \nof large and complex systems.\nFor large, long-lifetime systems that are developed by a software company for an \nexternal client, using an agile approach presents a number of problems.\n1. The informality of agile development is incompatible with the legal approach to \ncontract definition that is commonly used in large companies.\n2. Agile methods are most appropriate for new software development rather than \nfor software maintenance. Yet the majority of software costs in large companies \ncome from maintaining their existing software systems.\n3. Agile methods are designed for small co-located teams, yet much software \ndevelopment now involves worldwide distributed teams.\nContractual issues can be a major problem when agile methods are used. When \nthe system customer uses an outside organization for system development, a contract \nfor the software development is drawn up between them. The software requirements \ndocument is usually part of that contract between the customer and the supplier. \nBecause the interleaved development of requirements and code is fundamental to \nagile methods, there is no definitive statement of requirements that can be included \nin the contract.\nConsequently, agile methods have to rely on contracts in which the customer \npays for the time required for system development rather than the development of a \nspecific set of requirements. As long as all goes well, this benefits both the customer \nand the developer. However, if problems arise, then there may be difficult disputes \nover who is to blame and who should pay for the extra time and resources required \nto resolve the problems.\n\n\n90  Chapter 3 \u25a0 Agile software development\nAs I explain in Chapter 9, a  huge amount of software engineering effort goes into the \nmaintenance and evolution of existing software systems. Agile practices, such as incre-\nmental delivery, design for change, and maintaining simplicity all make sense when soft-\nware is being changed. In fact, you can think of an agile development process as a process \nthat supports continual change. If agile methods are used for software product develop-\nment, new releases of the product or app simply involve continuing the agile approach.\nHowever, where maintenance involves a custom system that must be changed in \nresponse to new business requirements, there is no clear consensus on the suitability \nof agile methods for software maintenance (Bird 2011; Kilner 2012). Three types of \nproblems can arise:\n\u25a0 lack of product documentation\n\u25a0 keeping customers involved\n\u25a0 development team continuity\nFormal documentation is supposed to describe the system and so make it easier \nfor people changing the system to understand. In practice, however, formal docu-\nmentation is rarely updated and so does not accurately reflect the program code. For \nthis reason, agile methods enthusiasts argue that it is a waste of time to write this \ndocumentation and that the key to implementing maintainable software is to produce \nhigh-quality, readable code. The lack of documentation should not be a problem in \nmaintaining systems developed using an agile approach.\nHowever, my experience of system maintenance is that the most important docu-\nment is the system requirements document, which tells the software engineer what the \nsystem is supposed to do. Without such knowledge, it is difficult to assess the impact of \nproposed system changes. Many agile methods collect requirements informally and \nincrementally and do not create a coherent requirements document. The use of agile \nmethods may therefore make subsequent system maintenance more difficult and expen-\nsive. This is a particular problem if development team continuity cannot be maintained.\nA key challenge in using an agile approach to maintenance is keeping customers \ninvolved in the process. While a customer may be able to justify the full-time involve-\nment of a representative during system development, this is less likely during mainte-\nnance where changes are not continuous. Customer representatives are likely to lose \ninterest in the system. Therefore, it is likely that alternative mechanisms, such as change \nproposals, discussed in Chapter 25, will have to be adapted to fit in with an agile approach.\nAnother potential problem that may arise is maintaining continuity of the devel-\nopment team. Agile methods rely on team members understanding aspects of the \nsystem without having to consult documentation. If an agile development team is \nbroken up, then this implicit knowledge is lost and it is difficult for new team mem-\nbers to build up the same understanding of the system and its components. Many \nprogrammers prefer to work on new development to software maintenance, and so \nthey are unwilling to continue to work on a software system after the first release has \nbeen delivered. Therefore, even when the intention is to keep the development team \ntogether, people leave if they are assigned maintenance tasks."}
{"query": "What type of contracts do agile methods have to rely on?", "response": "Agile methods have to rely on contracts in which the customer pays for the time required for system development rather than the development of a specific set of requirements.", "context": "3.4  \u25a0 Scaling agile methods  89\nOf course, scaling up and scaling out are closely related. Contracts to develop \nlarge software systems are usually awarded to large organizations, with multiple \nteams working on the development project. These large companies have often exper-\nimented with agile methods in smaller projects, so they face the problems of scaling \nup and scaling out at the same time.\nThere are many anecdotes about the effectiveness of agile methods, and it has \nbeen suggested that these can lead to orders of magnitude improvements in produc-\ntivity and comparable reductions in defects. Ambler (Ambler 2010), an influential \nagile method developer, suggests that these productivity improvements are exagger-\nated for large systems and organizations. He suggests that an organization moving to \nagile methods can expect to see productivity improvement across the organization of \nabout 15% over 3 years, with similar reductions in the number of product defects.\n \n3.4.1  Practical problems with agile methods\nIn some areas, particularly in the development of software products and apps, agile \ndevelopment has been incredibly successful. It is by far the best approach to use for \nthis type of system. However, agile methods may not be suitable for other types of \nsoftware development, such as embedded systems engineering or the development \nof large and complex systems.\nFor large, long-lifetime systems that are developed by a software company for an \nexternal client, using an agile approach presents a number of problems.\n1. The informality of agile development is incompatible with the legal approach to \ncontract definition that is commonly used in large companies.\n2. Agile methods are most appropriate for new software development rather than \nfor software maintenance. Yet the majority of software costs in large companies \ncome from maintaining their existing software systems.\n3. Agile methods are designed for small co-located teams, yet much software \ndevelopment now involves worldwide distributed teams.\nContractual issues can be a major problem when agile methods are used. When \nthe system customer uses an outside organization for system development, a contract \nfor the software development is drawn up between them. The software requirements \ndocument is usually part of that contract between the customer and the supplier. \nBecause the interleaved development of requirements and code is fundamental to \nagile methods, there is no definitive statement of requirements that can be included \nin the contract.\nConsequently, agile methods have to rely on contracts in which the customer \npays for the time required for system development rather than the development of a \nspecific set of requirements. As long as all goes well, this benefits both the customer \nand the developer. However, if problems arise, then there may be difficult disputes \nover who is to blame and who should pay for the extra time and resources required \nto resolve the problems.\n\n\n90  Chapter 3 \u25a0 Agile software development\nAs I explain in Chapter 9, a  huge amount of software engineering effort goes into the \nmaintenance and evolution of existing software systems. Agile practices, such as incre-\nmental delivery, design for change, and maintaining simplicity all make sense when soft-\nware is being changed. In fact, you can think of an agile development process as a process \nthat supports continual change. If agile methods are used for software product develop-\nment, new releases of the product or app simply involve continuing the agile approach.\nHowever, where maintenance involves a custom system that must be changed in \nresponse to new business requirements, there is no clear consensus on the suitability \nof agile methods for software maintenance (Bird 2011; Kilner 2012). Three types of \nproblems can arise:\n\u25a0 lack of product documentation\n\u25a0 keeping customers involved\n\u25a0 development team continuity\nFormal documentation is supposed to describe the system and so make it easier \nfor people changing the system to understand. In practice, however, formal docu-\nmentation is rarely updated and so does not accurately reflect the program code. For \nthis reason, agile methods enthusiasts argue that it is a waste of time to write this \ndocumentation and that the key to implementing maintainable software is to produce \nhigh-quality, readable code. The lack of documentation should not be a problem in \nmaintaining systems developed using an agile approach.\nHowever, my experience of system maintenance is that the most important docu-\nment is the system requirements document, which tells the software engineer what the \nsystem is supposed to do. Without such knowledge, it is difficult to assess the impact of \nproposed system changes. Many agile methods collect requirements informally and \nincrementally and do not create a coherent requirements document. The use of agile \nmethods may therefore make subsequent system maintenance more difficult and expen-\nsive. This is a particular problem if development team continuity cannot be maintained.\nA key challenge in using an agile approach to maintenance is keeping customers \ninvolved in the process. While a customer may be able to justify the full-time involve-\nment of a representative during system development, this is less likely during mainte-\nnance where changes are not continuous. Customer representatives are likely to lose \ninterest in the system. Therefore, it is likely that alternative mechanisms, such as change \nproposals, discussed in Chapter 25, will have to be adapted to fit in with an agile approach.\nAnother potential problem that may arise is maintaining continuity of the devel-\nopment team. Agile methods rely on team members understanding aspects of the \nsystem without having to consult documentation. If an agile development team is \nbroken up, then this implicit knowledge is lost and it is difficult for new team mem-\nbers to build up the same understanding of the system and its components. Many \nprogrammers prefer to work on new development to software maintenance, and so \nthey are unwilling to continue to work on a software system after the first release has \nbeen delivered. Therefore, even when the intention is to keep the development team \ntogether, people leave if they are assigned maintenance tasks."}
{"query": "What are the potential issues that can arise if problems occur during the development process using agile methods?", "response": "If problems occur during the development process using agile methods, potential issues that can arise include difficult disputes over who is to blame and who should pay for the extra time and resources required to resolve the problems. Additionally, there may be challenges with contractual issues, as the informality of agile development may be incompatible with the legal approach to contract definition commonly used in large companies. Agile methods may also be more suitable for new software development rather than software maintenance, which can pose problems for large companies where the majority of software costs come from maintaining existing software systems. Furthermore, agile methods are designed for small co-located teams, but much software development now involves worldwide distributed teams.", "context": "3.4  \u25a0 Scaling agile methods  89\nOf course, scaling up and scaling out are closely related. Contracts to develop \nlarge software systems are usually awarded to large organizations, with multiple \nteams working on the development project. These large companies have often exper-\nimented with agile methods in smaller projects, so they face the problems of scaling \nup and scaling out at the same time.\nThere are many anecdotes about the effectiveness of agile methods, and it has \nbeen suggested that these can lead to orders of magnitude improvements in produc-\ntivity and comparable reductions in defects. Ambler (Ambler 2010), an influential \nagile method developer, suggests that these productivity improvements are exagger-\nated for large systems and organizations. He suggests that an organization moving to \nagile methods can expect to see productivity improvement across the organization of \nabout 15% over 3 years, with similar reductions in the number of product defects.\n \n3.4.1  Practical problems with agile methods\nIn some areas, particularly in the development of software products and apps, agile \ndevelopment has been incredibly successful. It is by far the best approach to use for \nthis type of system. However, agile methods may not be suitable for other types of \nsoftware development, such as embedded systems engineering or the development \nof large and complex systems.\nFor large, long-lifetime systems that are developed by a software company for an \nexternal client, using an agile approach presents a number of problems.\n1. The informality of agile development is incompatible with the legal approach to \ncontract definition that is commonly used in large companies.\n2. Agile methods are most appropriate for new software development rather than \nfor software maintenance. Yet the majority of software costs in large companies \ncome from maintaining their existing software systems.\n3. Agile methods are designed for small co-located teams, yet much software \ndevelopment now involves worldwide distributed teams.\nContractual issues can be a major problem when agile methods are used. When \nthe system customer uses an outside organization for system development, a contract \nfor the software development is drawn up between them. The software requirements \ndocument is usually part of that contract between the customer and the supplier. \nBecause the interleaved development of requirements and code is fundamental to \nagile methods, there is no definitive statement of requirements that can be included \nin the contract.\nConsequently, agile methods have to rely on contracts in which the customer \npays for the time required for system development rather than the development of a \nspecific set of requirements. As long as all goes well, this benefits both the customer \nand the developer. However, if problems arise, then there may be difficult disputes \nover who is to blame and who should pay for the extra time and resources required \nto resolve the problems.\n\n\n90  Chapter 3 \u25a0 Agile software development\nAs I explain in Chapter 9, a  huge amount of software engineering effort goes into the \nmaintenance and evolution of existing software systems. Agile practices, such as incre-\nmental delivery, design for change, and maintaining simplicity all make sense when soft-\nware is being changed. In fact, you can think of an agile development process as a process \nthat supports continual change. If agile methods are used for software product develop-\nment, new releases of the product or app simply involve continuing the agile approach.\nHowever, where maintenance involves a custom system that must be changed in \nresponse to new business requirements, there is no clear consensus on the suitability \nof agile methods for software maintenance (Bird 2011; Kilner 2012). Three types of \nproblems can arise:\n\u25a0 lack of product documentation\n\u25a0 keeping customers involved\n\u25a0 development team continuity\nFormal documentation is supposed to describe the system and so make it easier \nfor people changing the system to understand. In practice, however, formal docu-\nmentation is rarely updated and so does not accurately reflect the program code. For \nthis reason, agile methods enthusiasts argue that it is a waste of time to write this \ndocumentation and that the key to implementing maintainable software is to produce \nhigh-quality, readable code. The lack of documentation should not be a problem in \nmaintaining systems developed using an agile approach.\nHowever, my experience of system maintenance is that the most important docu-\nment is the system requirements document, which tells the software engineer what the \nsystem is supposed to do. Without such knowledge, it is difficult to assess the impact of \nproposed system changes. Many agile methods collect requirements informally and \nincrementally and do not create a coherent requirements document. The use of agile \nmethods may therefore make subsequent system maintenance more difficult and expen-\nsive. This is a particular problem if development team continuity cannot be maintained.\nA key challenge in using an agile approach to maintenance is keeping customers \ninvolved in the process. While a customer may be able to justify the full-time involve-\nment of a representative during system development, this is less likely during mainte-\nnance where changes are not continuous. Customer representatives are likely to lose \ninterest in the system. Therefore, it is likely that alternative mechanisms, such as change \nproposals, discussed in Chapter 25, will have to be adapted to fit in with an agile approach.\nAnother potential problem that may arise is maintaining continuity of the devel-\nopment team. Agile methods rely on team members understanding aspects of the \nsystem without having to consult documentation. If an agile development team is \nbroken up, then this implicit knowledge is lost and it is difficult for new team mem-\nbers to build up the same understanding of the system and its components. Many \nprogrammers prefer to work on new development to software maintenance, and so \nthey are unwilling to continue to work on a software system after the first release has \nbeen delivered. Therefore, even when the intention is to keep the development team \ntogether, people leave if they are assigned maintenance tasks."}
{"query": "How does agile development support continual change?", "response": "Agile development supports continual change by implementing practices such as incremental delivery, design for change, and maintaining simplicity. These practices allow for the flexibility to make changes to the software throughout the development process. Agile methods are designed to embrace change and adapt to evolving requirements, allowing for continuous improvement and iteration. By following an agile development process, new releases of the software product or app can easily be developed and deployed, ensuring that the software remains up-to-date and responsive to changing needs.", "context": "3.4  \u25a0 Scaling agile methods  89\nOf course, scaling up and scaling out are closely related. Contracts to develop \nlarge software systems are usually awarded to large organizations, with multiple \nteams working on the development project. These large companies have often exper-\nimented with agile methods in smaller projects, so they face the problems of scaling \nup and scaling out at the same time.\nThere are many anecdotes about the effectiveness of agile methods, and it has \nbeen suggested that these can lead to orders of magnitude improvements in produc-\ntivity and comparable reductions in defects. Ambler (Ambler 2010), an influential \nagile method developer, suggests that these productivity improvements are exagger-\nated for large systems and organizations. He suggests that an organization moving to \nagile methods can expect to see productivity improvement across the organization of \nabout 15% over 3 years, with similar reductions in the number of product defects.\n \n3.4.1  Practical problems with agile methods\nIn some areas, particularly in the development of software products and apps, agile \ndevelopment has been incredibly successful. It is by far the best approach to use for \nthis type of system. However, agile methods may not be suitable for other types of \nsoftware development, such as embedded systems engineering or the development \nof large and complex systems.\nFor large, long-lifetime systems that are developed by a software company for an \nexternal client, using an agile approach presents a number of problems.\n1. The informality of agile development is incompatible with the legal approach to \ncontract definition that is commonly used in large companies.\n2. Agile methods are most appropriate for new software development rather than \nfor software maintenance. Yet the majority of software costs in large companies \ncome from maintaining their existing software systems.\n3. Agile methods are designed for small co-located teams, yet much software \ndevelopment now involves worldwide distributed teams.\nContractual issues can be a major problem when agile methods are used. When \nthe system customer uses an outside organization for system development, a contract \nfor the software development is drawn up between them. The software requirements \ndocument is usually part of that contract between the customer and the supplier. \nBecause the interleaved development of requirements and code is fundamental to \nagile methods, there is no definitive statement of requirements that can be included \nin the contract.\nConsequently, agile methods have to rely on contracts in which the customer \npays for the time required for system development rather than the development of a \nspecific set of requirements. As long as all goes well, this benefits both the customer \nand the developer. However, if problems arise, then there may be difficult disputes \nover who is to blame and who should pay for the extra time and resources required \nto resolve the problems.\n\n\n90  Chapter 3 \u25a0 Agile software development\nAs I explain in Chapter 9, a  huge amount of software engineering effort goes into the \nmaintenance and evolution of existing software systems. Agile practices, such as incre-\nmental delivery, design for change, and maintaining simplicity all make sense when soft-\nware is being changed. In fact, you can think of an agile development process as a process \nthat supports continual change. If agile methods are used for software product develop-\nment, new releases of the product or app simply involve continuing the agile approach.\nHowever, where maintenance involves a custom system that must be changed in \nresponse to new business requirements, there is no clear consensus on the suitability \nof agile methods for software maintenance (Bird 2011; Kilner 2012). Three types of \nproblems can arise:\n\u25a0 lack of product documentation\n\u25a0 keeping customers involved\n\u25a0 development team continuity\nFormal documentation is supposed to describe the system and so make it easier \nfor people changing the system to understand. In practice, however, formal docu-\nmentation is rarely updated and so does not accurately reflect the program code. For \nthis reason, agile methods enthusiasts argue that it is a waste of time to write this \ndocumentation and that the key to implementing maintainable software is to produce \nhigh-quality, readable code. The lack of documentation should not be a problem in \nmaintaining systems developed using an agile approach.\nHowever, my experience of system maintenance is that the most important docu-\nment is the system requirements document, which tells the software engineer what the \nsystem is supposed to do. Without such knowledge, it is difficult to assess the impact of \nproposed system changes. Many agile methods collect requirements informally and \nincrementally and do not create a coherent requirements document. The use of agile \nmethods may therefore make subsequent system maintenance more difficult and expen-\nsive. This is a particular problem if development team continuity cannot be maintained.\nA key challenge in using an agile approach to maintenance is keeping customers \ninvolved in the process. While a customer may be able to justify the full-time involve-\nment of a representative during system development, this is less likely during mainte-\nnance where changes are not continuous. Customer representatives are likely to lose \ninterest in the system. Therefore, it is likely that alternative mechanisms, such as change \nproposals, discussed in Chapter 25, will have to be adapted to fit in with an agile approach.\nAnother potential problem that may arise is maintaining continuity of the devel-\nopment team. Agile methods rely on team members understanding aspects of the \nsystem without having to consult documentation. If an agile development team is \nbroken up, then this implicit knowledge is lost and it is difficult for new team mem-\nbers to build up the same understanding of the system and its components. Many \nprogrammers prefer to work on new development to software maintenance, and so \nthey are unwilling to continue to work on a software system after the first release has \nbeen delivered. Therefore, even when the intention is to keep the development team \ntogether, people leave if they are assigned maintenance tasks."}
{"query": "What is the consensus on the suitability of agile methods for software maintenance?", "response": "There is no clear consensus on the suitability of agile methods for software maintenance. Some argue that agile methods are not suitable for maintenance because of the lack of formal documentation and the difficulty in maintaining development team continuity. However, others believe that the lack of documentation is not a problem and that high-quality, readable code is sufficient for maintaining the system. Ultimately, the suitability of agile methods for software maintenance may depend on the specific circumstances and requirements of the project.", "context": "3.4  \u25a0 Scaling agile methods  89\nOf course, scaling up and scaling out are closely related. Contracts to develop \nlarge software systems are usually awarded to large organizations, with multiple \nteams working on the development project. These large companies have often exper-\nimented with agile methods in smaller projects, so they face the problems of scaling \nup and scaling out at the same time.\nThere are many anecdotes about the effectiveness of agile methods, and it has \nbeen suggested that these can lead to orders of magnitude improvements in produc-\ntivity and comparable reductions in defects. Ambler (Ambler 2010), an influential \nagile method developer, suggests that these productivity improvements are exagger-\nated for large systems and organizations. He suggests that an organization moving to \nagile methods can expect to see productivity improvement across the organization of \nabout 15% over 3 years, with similar reductions in the number of product defects.\n \n3.4.1  Practical problems with agile methods\nIn some areas, particularly in the development of software products and apps, agile \ndevelopment has been incredibly successful. It is by far the best approach to use for \nthis type of system. However, agile methods may not be suitable for other types of \nsoftware development, such as embedded systems engineering or the development \nof large and complex systems.\nFor large, long-lifetime systems that are developed by a software company for an \nexternal client, using an agile approach presents a number of problems.\n1. The informality of agile development is incompatible with the legal approach to \ncontract definition that is commonly used in large companies.\n2. Agile methods are most appropriate for new software development rather than \nfor software maintenance. Yet the majority of software costs in large companies \ncome from maintaining their existing software systems.\n3. Agile methods are designed for small co-located teams, yet much software \ndevelopment now involves worldwide distributed teams.\nContractual issues can be a major problem when agile methods are used. When \nthe system customer uses an outside organization for system development, a contract \nfor the software development is drawn up between them. The software requirements \ndocument is usually part of that contract between the customer and the supplier. \nBecause the interleaved development of requirements and code is fundamental to \nagile methods, there is no definitive statement of requirements that can be included \nin the contract.\nConsequently, agile methods have to rely on contracts in which the customer \npays for the time required for system development rather than the development of a \nspecific set of requirements. As long as all goes well, this benefits both the customer \nand the developer. However, if problems arise, then there may be difficult disputes \nover who is to blame and who should pay for the extra time and resources required \nto resolve the problems.\n\n\n90  Chapter 3 \u25a0 Agile software development\nAs I explain in Chapter 9, a  huge amount of software engineering effort goes into the \nmaintenance and evolution of existing software systems. Agile practices, such as incre-\nmental delivery, design for change, and maintaining simplicity all make sense when soft-\nware is being changed. In fact, you can think of an agile development process as a process \nthat supports continual change. If agile methods are used for software product develop-\nment, new releases of the product or app simply involve continuing the agile approach.\nHowever, where maintenance involves a custom system that must be changed in \nresponse to new business requirements, there is no clear consensus on the suitability \nof agile methods for software maintenance (Bird 2011; Kilner 2012). Three types of \nproblems can arise:\n\u25a0 lack of product documentation\n\u25a0 keeping customers involved\n\u25a0 development team continuity\nFormal documentation is supposed to describe the system and so make it easier \nfor people changing the system to understand. In practice, however, formal docu-\nmentation is rarely updated and so does not accurately reflect the program code. For \nthis reason, agile methods enthusiasts argue that it is a waste of time to write this \ndocumentation and that the key to implementing maintainable software is to produce \nhigh-quality, readable code. The lack of documentation should not be a problem in \nmaintaining systems developed using an agile approach.\nHowever, my experience of system maintenance is that the most important docu-\nment is the system requirements document, which tells the software engineer what the \nsystem is supposed to do. Without such knowledge, it is difficult to assess the impact of \nproposed system changes. Many agile methods collect requirements informally and \nincrementally and do not create a coherent requirements document. The use of agile \nmethods may therefore make subsequent system maintenance more difficult and expen-\nsive. This is a particular problem if development team continuity cannot be maintained.\nA key challenge in using an agile approach to maintenance is keeping customers \ninvolved in the process. While a customer may be able to justify the full-time involve-\nment of a representative during system development, this is less likely during mainte-\nnance where changes are not continuous. Customer representatives are likely to lose \ninterest in the system. Therefore, it is likely that alternative mechanisms, such as change \nproposals, discussed in Chapter 25, will have to be adapted to fit in with an agile approach.\nAnother potential problem that may arise is maintaining continuity of the devel-\nopment team. Agile methods rely on team members understanding aspects of the \nsystem without having to consult documentation. If an agile development team is \nbroken up, then this implicit knowledge is lost and it is difficult for new team mem-\nbers to build up the same understanding of the system and its components. Many \nprogrammers prefer to work on new development to software maintenance, and so \nthey are unwilling to continue to work on a software system after the first release has \nbeen delivered. Therefore, even when the intention is to keep the development team \ntogether, people leave if they are assigned maintenance tasks."}
{"query": "What are the three types of problems that can arise with the use of agile methods for software maintenance?", "response": "The three types of problems that can arise with the use of agile methods for software maintenance are lack of product documentation, keeping customers involved, and development team continuity.", "context": "3.4  \u25a0 Scaling agile methods  89\nOf course, scaling up and scaling out are closely related. Contracts to develop \nlarge software systems are usually awarded to large organizations, with multiple \nteams working on the development project. These large companies have often exper-\nimented with agile methods in smaller projects, so they face the problems of scaling \nup and scaling out at the same time.\nThere are many anecdotes about the effectiveness of agile methods, and it has \nbeen suggested that these can lead to orders of magnitude improvements in produc-\ntivity and comparable reductions in defects. Ambler (Ambler 2010), an influential \nagile method developer, suggests that these productivity improvements are exagger-\nated for large systems and organizations. He suggests that an organization moving to \nagile methods can expect to see productivity improvement across the organization of \nabout 15% over 3 years, with similar reductions in the number of product defects.\n \n3.4.1  Practical problems with agile methods\nIn some areas, particularly in the development of software products and apps, agile \ndevelopment has been incredibly successful. It is by far the best approach to use for \nthis type of system. However, agile methods may not be suitable for other types of \nsoftware development, such as embedded systems engineering or the development \nof large and complex systems.\nFor large, long-lifetime systems that are developed by a software company for an \nexternal client, using an agile approach presents a number of problems.\n1. The informality of agile development is incompatible with the legal approach to \ncontract definition that is commonly used in large companies.\n2. Agile methods are most appropriate for new software development rather than \nfor software maintenance. Yet the majority of software costs in large companies \ncome from maintaining their existing software systems.\n3. Agile methods are designed for small co-located teams, yet much software \ndevelopment now involves worldwide distributed teams.\nContractual issues can be a major problem when agile methods are used. When \nthe system customer uses an outside organization for system development, a contract \nfor the software development is drawn up between them. The software requirements \ndocument is usually part of that contract between the customer and the supplier. \nBecause the interleaved development of requirements and code is fundamental to \nagile methods, there is no definitive statement of requirements that can be included \nin the contract.\nConsequently, agile methods have to rely on contracts in which the customer \npays for the time required for system development rather than the development of a \nspecific set of requirements. As long as all goes well, this benefits both the customer \nand the developer. However, if problems arise, then there may be difficult disputes \nover who is to blame and who should pay for the extra time and resources required \nto resolve the problems.\n\n\n90  Chapter 3 \u25a0 Agile software development\nAs I explain in Chapter 9, a  huge amount of software engineering effort goes into the \nmaintenance and evolution of existing software systems. Agile practices, such as incre-\nmental delivery, design for change, and maintaining simplicity all make sense when soft-\nware is being changed. In fact, you can think of an agile development process as a process \nthat supports continual change. If agile methods are used for software product develop-\nment, new releases of the product or app simply involve continuing the agile approach.\nHowever, where maintenance involves a custom system that must be changed in \nresponse to new business requirements, there is no clear consensus on the suitability \nof agile methods for software maintenance (Bird 2011; Kilner 2012). Three types of \nproblems can arise:\n\u25a0 lack of product documentation\n\u25a0 keeping customers involved\n\u25a0 development team continuity\nFormal documentation is supposed to describe the system and so make it easier \nfor people changing the system to understand. In practice, however, formal docu-\nmentation is rarely updated and so does not accurately reflect the program code. For \nthis reason, agile methods enthusiasts argue that it is a waste of time to write this \ndocumentation and that the key to implementing maintainable software is to produce \nhigh-quality, readable code. The lack of documentation should not be a problem in \nmaintaining systems developed using an agile approach.\nHowever, my experience of system maintenance is that the most important docu-\nment is the system requirements document, which tells the software engineer what the \nsystem is supposed to do. Without such knowledge, it is difficult to assess the impact of \nproposed system changes. Many agile methods collect requirements informally and \nincrementally and do not create a coherent requirements document. The use of agile \nmethods may therefore make subsequent system maintenance more difficult and expen-\nsive. This is a particular problem if development team continuity cannot be maintained.\nA key challenge in using an agile approach to maintenance is keeping customers \ninvolved in the process. While a customer may be able to justify the full-time involve-\nment of a representative during system development, this is less likely during mainte-\nnance where changes are not continuous. Customer representatives are likely to lose \ninterest in the system. Therefore, it is likely that alternative mechanisms, such as change \nproposals, discussed in Chapter 25, will have to be adapted to fit in with an agile approach.\nAnother potential problem that may arise is maintaining continuity of the devel-\nopment team. Agile methods rely on team members understanding aspects of the \nsystem without having to consult documentation. If an agile development team is \nbroken up, then this implicit knowledge is lost and it is difficult for new team mem-\nbers to build up the same understanding of the system and its components. Many \nprogrammers prefer to work on new development to software maintenance, and so \nthey are unwilling to continue to work on a software system after the first release has \nbeen delivered. Therefore, even when the intention is to keep the development team \ntogether, people leave if they are assigned maintenance tasks."}
{"query": "Why do agile methods enthusiasts argue against the need for formal documentation?", "response": "Agile methods enthusiasts argue against the need for formal documentation because they believe that it is a waste of time. They argue that the key to implementing maintainable software is to produce high-quality, readable code. They believe that formal documentation is rarely updated and does not accurately reflect the program code. Therefore, they believe that the lack of documentation should not be a problem in maintaining systems developed using an agile approach.", "context": "3.4  \u25a0 Scaling agile methods  89\nOf course, scaling up and scaling out are closely related. Contracts to develop \nlarge software systems are usually awarded to large organizations, with multiple \nteams working on the development project. These large companies have often exper-\nimented with agile methods in smaller projects, so they face the problems of scaling \nup and scaling out at the same time.\nThere are many anecdotes about the effectiveness of agile methods, and it has \nbeen suggested that these can lead to orders of magnitude improvements in produc-\ntivity and comparable reductions in defects. Ambler (Ambler 2010), an influential \nagile method developer, suggests that these productivity improvements are exagger-\nated for large systems and organizations. He suggests that an organization moving to \nagile methods can expect to see productivity improvement across the organization of \nabout 15% over 3 years, with similar reductions in the number of product defects.\n \n3.4.1  Practical problems with agile methods\nIn some areas, particularly in the development of software products and apps, agile \ndevelopment has been incredibly successful. It is by far the best approach to use for \nthis type of system. However, agile methods may not be suitable for other types of \nsoftware development, such as embedded systems engineering or the development \nof large and complex systems.\nFor large, long-lifetime systems that are developed by a software company for an \nexternal client, using an agile approach presents a number of problems.\n1. The informality of agile development is incompatible with the legal approach to \ncontract definition that is commonly used in large companies.\n2. Agile methods are most appropriate for new software development rather than \nfor software maintenance. Yet the majority of software costs in large companies \ncome from maintaining their existing software systems.\n3. Agile methods are designed for small co-located teams, yet much software \ndevelopment now involves worldwide distributed teams.\nContractual issues can be a major problem when agile methods are used. When \nthe system customer uses an outside organization for system development, a contract \nfor the software development is drawn up between them. The software requirements \ndocument is usually part of that contract between the customer and the supplier. \nBecause the interleaved development of requirements and code is fundamental to \nagile methods, there is no definitive statement of requirements that can be included \nin the contract.\nConsequently, agile methods have to rely on contracts in which the customer \npays for the time required for system development rather than the development of a \nspecific set of requirements. As long as all goes well, this benefits both the customer \nand the developer. However, if problems arise, then there may be difficult disputes \nover who is to blame and who should pay for the extra time and resources required \nto resolve the problems.\n\n\n90  Chapter 3 \u25a0 Agile software development\nAs I explain in Chapter 9, a  huge amount of software engineering effort goes into the \nmaintenance and evolution of existing software systems. Agile practices, such as incre-\nmental delivery, design for change, and maintaining simplicity all make sense when soft-\nware is being changed. In fact, you can think of an agile development process as a process \nthat supports continual change. If agile methods are used for software product develop-\nment, new releases of the product or app simply involve continuing the agile approach.\nHowever, where maintenance involves a custom system that must be changed in \nresponse to new business requirements, there is no clear consensus on the suitability \nof agile methods for software maintenance (Bird 2011; Kilner 2012). Three types of \nproblems can arise:\n\u25a0 lack of product documentation\n\u25a0 keeping customers involved\n\u25a0 development team continuity\nFormal documentation is supposed to describe the system and so make it easier \nfor people changing the system to understand. In practice, however, formal docu-\nmentation is rarely updated and so does not accurately reflect the program code. For \nthis reason, agile methods enthusiasts argue that it is a waste of time to write this \ndocumentation and that the key to implementing maintainable software is to produce \nhigh-quality, readable code. The lack of documentation should not be a problem in \nmaintaining systems developed using an agile approach.\nHowever, my experience of system maintenance is that the most important docu-\nment is the system requirements document, which tells the software engineer what the \nsystem is supposed to do. Without such knowledge, it is difficult to assess the impact of \nproposed system changes. Many agile methods collect requirements informally and \nincrementally and do not create a coherent requirements document. The use of agile \nmethods may therefore make subsequent system maintenance more difficult and expen-\nsive. This is a particular problem if development team continuity cannot be maintained.\nA key challenge in using an agile approach to maintenance is keeping customers \ninvolved in the process. While a customer may be able to justify the full-time involve-\nment of a representative during system development, this is less likely during mainte-\nnance where changes are not continuous. Customer representatives are likely to lose \ninterest in the system. Therefore, it is likely that alternative mechanisms, such as change \nproposals, discussed in Chapter 25, will have to be adapted to fit in with an agile approach.\nAnother potential problem that may arise is maintaining continuity of the devel-\nopment team. Agile methods rely on team members understanding aspects of the \nsystem without having to consult documentation. If an agile development team is \nbroken up, then this implicit knowledge is lost and it is difficult for new team mem-\nbers to build up the same understanding of the system and its components. Many \nprogrammers prefer to work on new development to software maintenance, and so \nthey are unwilling to continue to work on a software system after the first release has \nbeen delivered. Therefore, even when the intention is to keep the development team \ntogether, people leave if they are assigned maintenance tasks."}
{"query": "How does the lack of a coherent requirements document affect subsequent system maintenance?", "response": "The lack of a coherent requirements document can make subsequent system maintenance more difficult and expensive. Without a clear understanding of what the system is supposed to do, it becomes challenging to assess the impact of proposed system changes. Agile methods often collect requirements informally and incrementally, which may not result in a coherent requirements document. This can hinder the maintenance process and make it harder for software engineers to make necessary changes to the system. Additionally, the lack of documentation can lead to difficulties in maintaining development team continuity, as new team members may struggle to understand the system without proper documentation.", "context": "3.4  \u25a0 Scaling agile methods  89\nOf course, scaling up and scaling out are closely related. Contracts to develop \nlarge software systems are usually awarded to large organizations, with multiple \nteams working on the development project. These large companies have often exper-\nimented with agile methods in smaller projects, so they face the problems of scaling \nup and scaling out at the same time.\nThere are many anecdotes about the effectiveness of agile methods, and it has \nbeen suggested that these can lead to orders of magnitude improvements in produc-\ntivity and comparable reductions in defects. Ambler (Ambler 2010), an influential \nagile method developer, suggests that these productivity improvements are exagger-\nated for large systems and organizations. He suggests that an organization moving to \nagile methods can expect to see productivity improvement across the organization of \nabout 15% over 3 years, with similar reductions in the number of product defects.\n \n3.4.1  Practical problems with agile methods\nIn some areas, particularly in the development of software products and apps, agile \ndevelopment has been incredibly successful. It is by far the best approach to use for \nthis type of system. However, agile methods may not be suitable for other types of \nsoftware development, such as embedded systems engineering or the development \nof large and complex systems.\nFor large, long-lifetime systems that are developed by a software company for an \nexternal client, using an agile approach presents a number of problems.\n1. The informality of agile development is incompatible with the legal approach to \ncontract definition that is commonly used in large companies.\n2. Agile methods are most appropriate for new software development rather than \nfor software maintenance. Yet the majority of software costs in large companies \ncome from maintaining their existing software systems.\n3. Agile methods are designed for small co-located teams, yet much software \ndevelopment now involves worldwide distributed teams.\nContractual issues can be a major problem when agile methods are used. When \nthe system customer uses an outside organization for system development, a contract \nfor the software development is drawn up between them. The software requirements \ndocument is usually part of that contract between the customer and the supplier. \nBecause the interleaved development of requirements and code is fundamental to \nagile methods, there is no definitive statement of requirements that can be included \nin the contract.\nConsequently, agile methods have to rely on contracts in which the customer \npays for the time required for system development rather than the development of a \nspecific set of requirements. As long as all goes well, this benefits both the customer \nand the developer. However, if problems arise, then there may be difficult disputes \nover who is to blame and who should pay for the extra time and resources required \nto resolve the problems.\n\n\n90  Chapter 3 \u25a0 Agile software development\nAs I explain in Chapter 9, a  huge amount of software engineering effort goes into the \nmaintenance and evolution of existing software systems. Agile practices, such as incre-\nmental delivery, design for change, and maintaining simplicity all make sense when soft-\nware is being changed. In fact, you can think of an agile development process as a process \nthat supports continual change. If agile methods are used for software product develop-\nment, new releases of the product or app simply involve continuing the agile approach.\nHowever, where maintenance involves a custom system that must be changed in \nresponse to new business requirements, there is no clear consensus on the suitability \nof agile methods for software maintenance (Bird 2011; Kilner 2012). Three types of \nproblems can arise:\n\u25a0 lack of product documentation\n\u25a0 keeping customers involved\n\u25a0 development team continuity\nFormal documentation is supposed to describe the system and so make it easier \nfor people changing the system to understand. In practice, however, formal docu-\nmentation is rarely updated and so does not accurately reflect the program code. For \nthis reason, agile methods enthusiasts argue that it is a waste of time to write this \ndocumentation and that the key to implementing maintainable software is to produce \nhigh-quality, readable code. The lack of documentation should not be a problem in \nmaintaining systems developed using an agile approach.\nHowever, my experience of system maintenance is that the most important docu-\nment is the system requirements document, which tells the software engineer what the \nsystem is supposed to do. Without such knowledge, it is difficult to assess the impact of \nproposed system changes. Many agile methods collect requirements informally and \nincrementally and do not create a coherent requirements document. The use of agile \nmethods may therefore make subsequent system maintenance more difficult and expen-\nsive. This is a particular problem if development team continuity cannot be maintained.\nA key challenge in using an agile approach to maintenance is keeping customers \ninvolved in the process. While a customer may be able to justify the full-time involve-\nment of a representative during system development, this is less likely during mainte-\nnance where changes are not continuous. Customer representatives are likely to lose \ninterest in the system. Therefore, it is likely that alternative mechanisms, such as change \nproposals, discussed in Chapter 25, will have to be adapted to fit in with an agile approach.\nAnother potential problem that may arise is maintaining continuity of the devel-\nopment team. Agile methods rely on team members understanding aspects of the \nsystem without having to consult documentation. If an agile development team is \nbroken up, then this implicit knowledge is lost and it is difficult for new team mem-\nbers to build up the same understanding of the system and its components. Many \nprogrammers prefer to work on new development to software maintenance, and so \nthey are unwilling to continue to work on a software system after the first release has \nbeen delivered. Therefore, even when the intention is to keep the development team \ntogether, people leave if they are assigned maintenance tasks."}
{"query": "What is the challenge in keeping customers involved in the process during maintenance using an agile approach?", "response": "The challenge in keeping customers involved in the process during maintenance using an agile approach is that customers may lose interest in the system since changes are not continuous.", "context": "3.4  \u25a0 Scaling agile methods  89\nOf course, scaling up and scaling out are closely related. Contracts to develop \nlarge software systems are usually awarded to large organizations, with multiple \nteams working on the development project. These large companies have often exper-\nimented with agile methods in smaller projects, so they face the problems of scaling \nup and scaling out at the same time.\nThere are many anecdotes about the effectiveness of agile methods, and it has \nbeen suggested that these can lead to orders of magnitude improvements in produc-\ntivity and comparable reductions in defects. Ambler (Ambler 2010), an influential \nagile method developer, suggests that these productivity improvements are exagger-\nated for large systems and organizations. He suggests that an organization moving to \nagile methods can expect to see productivity improvement across the organization of \nabout 15% over 3 years, with similar reductions in the number of product defects.\n \n3.4.1  Practical problems with agile methods\nIn some areas, particularly in the development of software products and apps, agile \ndevelopment has been incredibly successful. It is by far the best approach to use for \nthis type of system. However, agile methods may not be suitable for other types of \nsoftware development, such as embedded systems engineering or the development \nof large and complex systems.\nFor large, long-lifetime systems that are developed by a software company for an \nexternal client, using an agile approach presents a number of problems.\n1. The informality of agile development is incompatible with the legal approach to \ncontract definition that is commonly used in large companies.\n2. Agile methods are most appropriate for new software development rather than \nfor software maintenance. Yet the majority of software costs in large companies \ncome from maintaining their existing software systems.\n3. Agile methods are designed for small co-located teams, yet much software \ndevelopment now involves worldwide distributed teams.\nContractual issues can be a major problem when agile methods are used. When \nthe system customer uses an outside organization for system development, a contract \nfor the software development is drawn up between them. The software requirements \ndocument is usually part of that contract between the customer and the supplier. \nBecause the interleaved development of requirements and code is fundamental to \nagile methods, there is no definitive statement of requirements that can be included \nin the contract.\nConsequently, agile methods have to rely on contracts in which the customer \npays for the time required for system development rather than the development of a \nspecific set of requirements. As long as all goes well, this benefits both the customer \nand the developer. However, if problems arise, then there may be difficult disputes \nover who is to blame and who should pay for the extra time and resources required \nto resolve the problems.\n\n\n90  Chapter 3 \u25a0 Agile software development\nAs I explain in Chapter 9, a  huge amount of software engineering effort goes into the \nmaintenance and evolution of existing software systems. Agile practices, such as incre-\nmental delivery, design for change, and maintaining simplicity all make sense when soft-\nware is being changed. In fact, you can think of an agile development process as a process \nthat supports continual change. If agile methods are used for software product develop-\nment, new releases of the product or app simply involve continuing the agile approach.\nHowever, where maintenance involves a custom system that must be changed in \nresponse to new business requirements, there is no clear consensus on the suitability \nof agile methods for software maintenance (Bird 2011; Kilner 2012). Three types of \nproblems can arise:\n\u25a0 lack of product documentation\n\u25a0 keeping customers involved\n\u25a0 development team continuity\nFormal documentation is supposed to describe the system and so make it easier \nfor people changing the system to understand. In practice, however, formal docu-\nmentation is rarely updated and so does not accurately reflect the program code. For \nthis reason, agile methods enthusiasts argue that it is a waste of time to write this \ndocumentation and that the key to implementing maintainable software is to produce \nhigh-quality, readable code. The lack of documentation should not be a problem in \nmaintaining systems developed using an agile approach.\nHowever, my experience of system maintenance is that the most important docu-\nment is the system requirements document, which tells the software engineer what the \nsystem is supposed to do. Without such knowledge, it is difficult to assess the impact of \nproposed system changes. Many agile methods collect requirements informally and \nincrementally and do not create a coherent requirements document. The use of agile \nmethods may therefore make subsequent system maintenance more difficult and expen-\nsive. This is a particular problem if development team continuity cannot be maintained.\nA key challenge in using an agile approach to maintenance is keeping customers \ninvolved in the process. While a customer may be able to justify the full-time involve-\nment of a representative during system development, this is less likely during mainte-\nnance where changes are not continuous. Customer representatives are likely to lose \ninterest in the system. Therefore, it is likely that alternative mechanisms, such as change \nproposals, discussed in Chapter 25, will have to be adapted to fit in with an agile approach.\nAnother potential problem that may arise is maintaining continuity of the devel-\nopment team. Agile methods rely on team members understanding aspects of the \nsystem without having to consult documentation. If an agile development team is \nbroken up, then this implicit knowledge is lost and it is difficult for new team mem-\nbers to build up the same understanding of the system and its components. Many \nprogrammers prefer to work on new development to software maintenance, and so \nthey are unwilling to continue to work on a software system after the first release has \nbeen delivered. Therefore, even when the intention is to keep the development team \ntogether, people leave if they are assigned maintenance tasks."}
{"query": "What are some alternative mechanisms that may need to be adapted to fit in with an agile approach during maintenance?", "response": "During maintenance, one alternative mechanism that may need to be adapted to fit in with an agile approach is change proposals. These change proposals can be used to involve customers in the process and gather their input on system changes. This is important because, unlike during system development where a customer representative may be involved full-time, customer involvement during maintenance is less likely due to the intermittent nature of changes. Therefore, adapting change proposals to fit in with an agile approach can help maintain customer involvement and ensure their needs are addressed during the maintenance process.", "context": "3.4  \u25a0 Scaling agile methods  89\nOf course, scaling up and scaling out are closely related. Contracts to develop \nlarge software systems are usually awarded to large organizations, with multiple \nteams working on the development project. These large companies have often exper-\nimented with agile methods in smaller projects, so they face the problems of scaling \nup and scaling out at the same time.\nThere are many anecdotes about the effectiveness of agile methods, and it has \nbeen suggested that these can lead to orders of magnitude improvements in produc-\ntivity and comparable reductions in defects. Ambler (Ambler 2010), an influential \nagile method developer, suggests that these productivity improvements are exagger-\nated for large systems and organizations. He suggests that an organization moving to \nagile methods can expect to see productivity improvement across the organization of \nabout 15% over 3 years, with similar reductions in the number of product defects.\n \n3.4.1  Practical problems with agile methods\nIn some areas, particularly in the development of software products and apps, agile \ndevelopment has been incredibly successful. It is by far the best approach to use for \nthis type of system. However, agile methods may not be suitable for other types of \nsoftware development, such as embedded systems engineering or the development \nof large and complex systems.\nFor large, long-lifetime systems that are developed by a software company for an \nexternal client, using an agile approach presents a number of problems.\n1. The informality of agile development is incompatible with the legal approach to \ncontract definition that is commonly used in large companies.\n2. Agile methods are most appropriate for new software development rather than \nfor software maintenance. Yet the majority of software costs in large companies \ncome from maintaining their existing software systems.\n3. Agile methods are designed for small co-located teams, yet much software \ndevelopment now involves worldwide distributed teams.\nContractual issues can be a major problem when agile methods are used. When \nthe system customer uses an outside organization for system development, a contract \nfor the software development is drawn up between them. The software requirements \ndocument is usually part of that contract between the customer and the supplier. \nBecause the interleaved development of requirements and code is fundamental to \nagile methods, there is no definitive statement of requirements that can be included \nin the contract.\nConsequently, agile methods have to rely on contracts in which the customer \npays for the time required for system development rather than the development of a \nspecific set of requirements. As long as all goes well, this benefits both the customer \nand the developer. However, if problems arise, then there may be difficult disputes \nover who is to blame and who should pay for the extra time and resources required \nto resolve the problems.\n\n\n90  Chapter 3 \u25a0 Agile software development\nAs I explain in Chapter 9, a  huge amount of software engineering effort goes into the \nmaintenance and evolution of existing software systems. Agile practices, such as incre-\nmental delivery, design for change, and maintaining simplicity all make sense when soft-\nware is being changed. In fact, you can think of an agile development process as a process \nthat supports continual change. If agile methods are used for software product develop-\nment, new releases of the product or app simply involve continuing the agile approach.\nHowever, where maintenance involves a custom system that must be changed in \nresponse to new business requirements, there is no clear consensus on the suitability \nof agile methods for software maintenance (Bird 2011; Kilner 2012). Three types of \nproblems can arise:\n\u25a0 lack of product documentation\n\u25a0 keeping customers involved\n\u25a0 development team continuity\nFormal documentation is supposed to describe the system and so make it easier \nfor people changing the system to understand. In practice, however, formal docu-\nmentation is rarely updated and so does not accurately reflect the program code. For \nthis reason, agile methods enthusiasts argue that it is a waste of time to write this \ndocumentation and that the key to implementing maintainable software is to produce \nhigh-quality, readable code. The lack of documentation should not be a problem in \nmaintaining systems developed using an agile approach.\nHowever, my experience of system maintenance is that the most important docu-\nment is the system requirements document, which tells the software engineer what the \nsystem is supposed to do. Without such knowledge, it is difficult to assess the impact of \nproposed system changes. Many agile methods collect requirements informally and \nincrementally and do not create a coherent requirements document. The use of agile \nmethods may therefore make subsequent system maintenance more difficult and expen-\nsive. This is a particular problem if development team continuity cannot be maintained.\nA key challenge in using an agile approach to maintenance is keeping customers \ninvolved in the process. While a customer may be able to justify the full-time involve-\nment of a representative during system development, this is less likely during mainte-\nnance where changes are not continuous. Customer representatives are likely to lose \ninterest in the system. Therefore, it is likely that alternative mechanisms, such as change \nproposals, discussed in Chapter 25, will have to be adapted to fit in with an agile approach.\nAnother potential problem that may arise is maintaining continuity of the devel-\nopment team. Agile methods rely on team members understanding aspects of the \nsystem without having to consult documentation. If an agile development team is \nbroken up, then this implicit knowledge is lost and it is difficult for new team mem-\nbers to build up the same understanding of the system and its components. Many \nprogrammers prefer to work on new development to software maintenance, and so \nthey are unwilling to continue to work on a software system after the first release has \nbeen delivered. Therefore, even when the intention is to keep the development team \ntogether, people leave if they are assigned maintenance tasks."}
{"query": "Why is maintaining continuity of the development team a potential problem in using an agile approach?", "response": "Maintaining continuity of the development team can be a potential problem in using an agile approach because agile methods rely on team members having a deep understanding of the system and its components without having to consult documentation. If the agile development team is broken up or if team members leave after the first release has been delivered, the implicit knowledge and understanding of the system may be lost. This can make it difficult for new team members to build up the same level of understanding, which can impact the effectiveness and efficiency of the development process.", "context": "3.4  \u25a0 Scaling agile methods  89\nOf course, scaling up and scaling out are closely related. Contracts to develop \nlarge software systems are usually awarded to large organizations, with multiple \nteams working on the development project. These large companies have often exper-\nimented with agile methods in smaller projects, so they face the problems of scaling \nup and scaling out at the same time.\nThere are many anecdotes about the effectiveness of agile methods, and it has \nbeen suggested that these can lead to orders of magnitude improvements in produc-\ntivity and comparable reductions in defects. Ambler (Ambler 2010), an influential \nagile method developer, suggests that these productivity improvements are exagger-\nated for large systems and organizations. He suggests that an organization moving to \nagile methods can expect to see productivity improvement across the organization of \nabout 15% over 3 years, with similar reductions in the number of product defects.\n \n3.4.1  Practical problems with agile methods\nIn some areas, particularly in the development of software products and apps, agile \ndevelopment has been incredibly successful. It is by far the best approach to use for \nthis type of system. However, agile methods may not be suitable for other types of \nsoftware development, such as embedded systems engineering or the development \nof large and complex systems.\nFor large, long-lifetime systems that are developed by a software company for an \nexternal client, using an agile approach presents a number of problems.\n1. The informality of agile development is incompatible with the legal approach to \ncontract definition that is commonly used in large companies.\n2. Agile methods are most appropriate for new software development rather than \nfor software maintenance. Yet the majority of software costs in large companies \ncome from maintaining their existing software systems.\n3. Agile methods are designed for small co-located teams, yet much software \ndevelopment now involves worldwide distributed teams.\nContractual issues can be a major problem when agile methods are used. When \nthe system customer uses an outside organization for system development, a contract \nfor the software development is drawn up between them. The software requirements \ndocument is usually part of that contract between the customer and the supplier. \nBecause the interleaved development of requirements and code is fundamental to \nagile methods, there is no definitive statement of requirements that can be included \nin the contract.\nConsequently, agile methods have to rely on contracts in which the customer \npays for the time required for system development rather than the development of a \nspecific set of requirements. As long as all goes well, this benefits both the customer \nand the developer. However, if problems arise, then there may be difficult disputes \nover who is to blame and who should pay for the extra time and resources required \nto resolve the problems.\n\n\n90  Chapter 3 \u25a0 Agile software development\nAs I explain in Chapter 9, a  huge amount of software engineering effort goes into the \nmaintenance and evolution of existing software systems. Agile practices, such as incre-\nmental delivery, design for change, and maintaining simplicity all make sense when soft-\nware is being changed. In fact, you can think of an agile development process as a process \nthat supports continual change. If agile methods are used for software product develop-\nment, new releases of the product or app simply involve continuing the agile approach.\nHowever, where maintenance involves a custom system that must be changed in \nresponse to new business requirements, there is no clear consensus on the suitability \nof agile methods for software maintenance (Bird 2011; Kilner 2012). Three types of \nproblems can arise:\n\u25a0 lack of product documentation\n\u25a0 keeping customers involved\n\u25a0 development team continuity\nFormal documentation is supposed to describe the system and so make it easier \nfor people changing the system to understand. In practice, however, formal docu-\nmentation is rarely updated and so does not accurately reflect the program code. For \nthis reason, agile methods enthusiasts argue that it is a waste of time to write this \ndocumentation and that the key to implementing maintainable software is to produce \nhigh-quality, readable code. The lack of documentation should not be a problem in \nmaintaining systems developed using an agile approach.\nHowever, my experience of system maintenance is that the most important docu-\nment is the system requirements document, which tells the software engineer what the \nsystem is supposed to do. Without such knowledge, it is difficult to assess the impact of \nproposed system changes. Many agile methods collect requirements informally and \nincrementally and do not create a coherent requirements document. The use of agile \nmethods may therefore make subsequent system maintenance more difficult and expen-\nsive. This is a particular problem if development team continuity cannot be maintained.\nA key challenge in using an agile approach to maintenance is keeping customers \ninvolved in the process. While a customer may be able to justify the full-time involve-\nment of a representative during system development, this is less likely during mainte-\nnance where changes are not continuous. Customer representatives are likely to lose \ninterest in the system. Therefore, it is likely that alternative mechanisms, such as change \nproposals, discussed in Chapter 25, will have to be adapted to fit in with an agile approach.\nAnother potential problem that may arise is maintaining continuity of the devel-\nopment team. Agile methods rely on team members understanding aspects of the \nsystem without having to consult documentation. If an agile development team is \nbroken up, then this implicit knowledge is lost and it is difficult for new team mem-\nbers to build up the same understanding of the system and its components. Many \nprogrammers prefer to work on new development to software maintenance, and so \nthey are unwilling to continue to work on a software system after the first release has \nbeen delivered. Therefore, even when the intention is to keep the development team \ntogether, people leave if they are assigned maintenance tasks."}
{"query": "How does the breaking up of an agile development team affect the understanding of the system and its components?", "response": "The breaking up of an agile development team can have a negative impact on the understanding of the system and its components. Agile methods rely on team members having implicit knowledge and understanding of the system without having to consult documentation. When a team is broken up, this implicit knowledge is lost, making it difficult for new team members to build up the same level of understanding. This can lead to a decrease in productivity and potentially introduce errors or inconsistencies in the system.", "context": "3.4  \u25a0 Scaling agile methods  89\nOf course, scaling up and scaling out are closely related. Contracts to develop \nlarge software systems are usually awarded to large organizations, with multiple \nteams working on the development project. These large companies have often exper-\nimented with agile methods in smaller projects, so they face the problems of scaling \nup and scaling out at the same time.\nThere are many anecdotes about the effectiveness of agile methods, and it has \nbeen suggested that these can lead to orders of magnitude improvements in produc-\ntivity and comparable reductions in defects. Ambler (Ambler 2010), an influential \nagile method developer, suggests that these productivity improvements are exagger-\nated for large systems and organizations. He suggests that an organization moving to \nagile methods can expect to see productivity improvement across the organization of \nabout 15% over 3 years, with similar reductions in the number of product defects.\n \n3.4.1  Practical problems with agile methods\nIn some areas, particularly in the development of software products and apps, agile \ndevelopment has been incredibly successful. It is by far the best approach to use for \nthis type of system. However, agile methods may not be suitable for other types of \nsoftware development, such as embedded systems engineering or the development \nof large and complex systems.\nFor large, long-lifetime systems that are developed by a software company for an \nexternal client, using an agile approach presents a number of problems.\n1. The informality of agile development is incompatible with the legal approach to \ncontract definition that is commonly used in large companies.\n2. Agile methods are most appropriate for new software development rather than \nfor software maintenance. Yet the majority of software costs in large companies \ncome from maintaining their existing software systems.\n3. Agile methods are designed for small co-located teams, yet much software \ndevelopment now involves worldwide distributed teams.\nContractual issues can be a major problem when agile methods are used. When \nthe system customer uses an outside organization for system development, a contract \nfor the software development is drawn up between them. The software requirements \ndocument is usually part of that contract between the customer and the supplier. \nBecause the interleaved development of requirements and code is fundamental to \nagile methods, there is no definitive statement of requirements that can be included \nin the contract.\nConsequently, agile methods have to rely on contracts in which the customer \npays for the time required for system development rather than the development of a \nspecific set of requirements. As long as all goes well, this benefits both the customer \nand the developer. However, if problems arise, then there may be difficult disputes \nover who is to blame and who should pay for the extra time and resources required \nto resolve the problems.\n\n\n90  Chapter 3 \u25a0 Agile software development\nAs I explain in Chapter 9, a  huge amount of software engineering effort goes into the \nmaintenance and evolution of existing software systems. Agile practices, such as incre-\nmental delivery, design for change, and maintaining simplicity all make sense when soft-\nware is being changed. In fact, you can think of an agile development process as a process \nthat supports continual change. If agile methods are used for software product develop-\nment, new releases of the product or app simply involve continuing the agile approach.\nHowever, where maintenance involves a custom system that must be changed in \nresponse to new business requirements, there is no clear consensus on the suitability \nof agile methods for software maintenance (Bird 2011; Kilner 2012). Three types of \nproblems can arise:\n\u25a0 lack of product documentation\n\u25a0 keeping customers involved\n\u25a0 development team continuity\nFormal documentation is supposed to describe the system and so make it easier \nfor people changing the system to understand. In practice, however, formal docu-\nmentation is rarely updated and so does not accurately reflect the program code. For \nthis reason, agile methods enthusiasts argue that it is a waste of time to write this \ndocumentation and that the key to implementing maintainable software is to produce \nhigh-quality, readable code. The lack of documentation should not be a problem in \nmaintaining systems developed using an agile approach.\nHowever, my experience of system maintenance is that the most important docu-\nment is the system requirements document, which tells the software engineer what the \nsystem is supposed to do. Without such knowledge, it is difficult to assess the impact of \nproposed system changes. Many agile methods collect requirements informally and \nincrementally and do not create a coherent requirements document. The use of agile \nmethods may therefore make subsequent system maintenance more difficult and expen-\nsive. This is a particular problem if development team continuity cannot be maintained.\nA key challenge in using an agile approach to maintenance is keeping customers \ninvolved in the process. While a customer may be able to justify the full-time involve-\nment of a representative during system development, this is less likely during mainte-\nnance where changes are not continuous. Customer representatives are likely to lose \ninterest in the system. Therefore, it is likely that alternative mechanisms, such as change \nproposals, discussed in Chapter 25, will have to be adapted to fit in with an agile approach.\nAnother potential problem that may arise is maintaining continuity of the devel-\nopment team. Agile methods rely on team members understanding aspects of the \nsystem without having to consult documentation. If an agile development team is \nbroken up, then this implicit knowledge is lost and it is difficult for new team mem-\nbers to build up the same understanding of the system and its components. Many \nprogrammers prefer to work on new development to software maintenance, and so \nthey are unwilling to continue to work on a software system after the first release has \nbeen delivered. Therefore, even when the intention is to keep the development team \ntogether, people leave if they are assigned maintenance tasks."}
{"query": "Why might programmers be unwilling to continue to work on a software system after the first release has been delivered?", "response": "Programmers might be unwilling to continue to work on a software system after the first release has been delivered because they prefer to work on new development rather than software maintenance.", "context": "3.4  \u25a0 Scaling agile methods  89\nOf course, scaling up and scaling out are closely related. Contracts to develop \nlarge software systems are usually awarded to large organizations, with multiple \nteams working on the development project. These large companies have often exper-\nimented with agile methods in smaller projects, so they face the problems of scaling \nup and scaling out at the same time.\nThere are many anecdotes about the effectiveness of agile methods, and it has \nbeen suggested that these can lead to orders of magnitude improvements in produc-\ntivity and comparable reductions in defects. Ambler (Ambler 2010), an influential \nagile method developer, suggests that these productivity improvements are exagger-\nated for large systems and organizations. He suggests that an organization moving to \nagile methods can expect to see productivity improvement across the organization of \nabout 15% over 3 years, with similar reductions in the number of product defects.\n \n3.4.1  Practical problems with agile methods\nIn some areas, particularly in the development of software products and apps, agile \ndevelopment has been incredibly successful. It is by far the best approach to use for \nthis type of system. However, agile methods may not be suitable for other types of \nsoftware development, such as embedded systems engineering or the development \nof large and complex systems.\nFor large, long-lifetime systems that are developed by a software company for an \nexternal client, using an agile approach presents a number of problems.\n1. The informality of agile development is incompatible with the legal approach to \ncontract definition that is commonly used in large companies.\n2. Agile methods are most appropriate for new software development rather than \nfor software maintenance. Yet the majority of software costs in large companies \ncome from maintaining their existing software systems.\n3. Agile methods are designed for small co-located teams, yet much software \ndevelopment now involves worldwide distributed teams.\nContractual issues can be a major problem when agile methods are used. When \nthe system customer uses an outside organization for system development, a contract \nfor the software development is drawn up between them. The software requirements \ndocument is usually part of that contract between the customer and the supplier. \nBecause the interleaved development of requirements and code is fundamental to \nagile methods, there is no definitive statement of requirements that can be included \nin the contract.\nConsequently, agile methods have to rely on contracts in which the customer \npays for the time required for system development rather than the development of a \nspecific set of requirements. As long as all goes well, this benefits both the customer \nand the developer. However, if problems arise, then there may be difficult disputes \nover who is to blame and who should pay for the extra time and resources required \nto resolve the problems.\n\n\n90  Chapter 3 \u25a0 Agile software development\nAs I explain in Chapter 9, a  huge amount of software engineering effort goes into the \nmaintenance and evolution of existing software systems. Agile practices, such as incre-\nmental delivery, design for change, and maintaining simplicity all make sense when soft-\nware is being changed. In fact, you can think of an agile development process as a process \nthat supports continual change. If agile methods are used for software product develop-\nment, new releases of the product or app simply involve continuing the agile approach.\nHowever, where maintenance involves a custom system that must be changed in \nresponse to new business requirements, there is no clear consensus on the suitability \nof agile methods for software maintenance (Bird 2011; Kilner 2012). Three types of \nproblems can arise:\n\u25a0 lack of product documentation\n\u25a0 keeping customers involved\n\u25a0 development team continuity\nFormal documentation is supposed to describe the system and so make it easier \nfor people changing the system to understand. In practice, however, formal docu-\nmentation is rarely updated and so does not accurately reflect the program code. For \nthis reason, agile methods enthusiasts argue that it is a waste of time to write this \ndocumentation and that the key to implementing maintainable software is to produce \nhigh-quality, readable code. The lack of documentation should not be a problem in \nmaintaining systems developed using an agile approach.\nHowever, my experience of system maintenance is that the most important docu-\nment is the system requirements document, which tells the software engineer what the \nsystem is supposed to do. Without such knowledge, it is difficult to assess the impact of \nproposed system changes. Many agile methods collect requirements informally and \nincrementally and do not create a coherent requirements document. The use of agile \nmethods may therefore make subsequent system maintenance more difficult and expen-\nsive. This is a particular problem if development team continuity cannot be maintained.\nA key challenge in using an agile approach to maintenance is keeping customers \ninvolved in the process. While a customer may be able to justify the full-time involve-\nment of a representative during system development, this is less likely during mainte-\nnance where changes are not continuous. Customer representatives are likely to lose \ninterest in the system. Therefore, it is likely that alternative mechanisms, such as change \nproposals, discussed in Chapter 25, will have to be adapted to fit in with an agile approach.\nAnother potential problem that may arise is maintaining continuity of the devel-\nopment team. Agile methods rely on team members understanding aspects of the \nsystem without having to consult documentation. If an agile development team is \nbroken up, then this implicit knowledge is lost and it is difficult for new team mem-\nbers to build up the same understanding of the system and its components. Many \nprogrammers prefer to work on new development to software maintenance, and so \nthey are unwilling to continue to work on a software system after the first release has \nbeen delivered. Therefore, even when the intention is to keep the development team \ntogether, people leave if they are assigned maintenance tasks."}
{"query": "How does the lack of product documentation affect the maintenance of systems developed using an agile approach?", "response": "The lack of product documentation can make the maintenance of systems developed using an agile approach more difficult and expensive. Agile methods often prioritize producing high-quality, readable code over formal documentation. While this may be sufficient for maintaining systems developed using an agile approach, it can pose challenges when changes need to be made. Without a clear understanding of the system's requirements, it becomes difficult to assess the impact of proposed changes. Additionally, if development team continuity cannot be maintained, the lack of documentation makes it challenging for new team members to understand the system and its components. Therefore, the absence of product documentation in agile development can hinder the maintenance process.", "context": "3.4  \u25a0 Scaling agile methods  89\nOf course, scaling up and scaling out are closely related. Contracts to develop \nlarge software systems are usually awarded to large organizations, with multiple \nteams working on the development project. These large companies have often exper-\nimented with agile methods in smaller projects, so they face the problems of scaling \nup and scaling out at the same time.\nThere are many anecdotes about the effectiveness of agile methods, and it has \nbeen suggested that these can lead to orders of magnitude improvements in produc-\ntivity and comparable reductions in defects. Ambler (Ambler 2010), an influential \nagile method developer, suggests that these productivity improvements are exagger-\nated for large systems and organizations. He suggests that an organization moving to \nagile methods can expect to see productivity improvement across the organization of \nabout 15% over 3 years, with similar reductions in the number of product defects.\n \n3.4.1  Practical problems with agile methods\nIn some areas, particularly in the development of software products and apps, agile \ndevelopment has been incredibly successful. It is by far the best approach to use for \nthis type of system. However, agile methods may not be suitable for other types of \nsoftware development, such as embedded systems engineering or the development \nof large and complex systems.\nFor large, long-lifetime systems that are developed by a software company for an \nexternal client, using an agile approach presents a number of problems.\n1. The informality of agile development is incompatible with the legal approach to \ncontract definition that is commonly used in large companies.\n2. Agile methods are most appropriate for new software development rather than \nfor software maintenance. Yet the majority of software costs in large companies \ncome from maintaining their existing software systems.\n3. Agile methods are designed for small co-located teams, yet much software \ndevelopment now involves worldwide distributed teams.\nContractual issues can be a major problem when agile methods are used. When \nthe system customer uses an outside organization for system development, a contract \nfor the software development is drawn up between them. The software requirements \ndocument is usually part of that contract between the customer and the supplier. \nBecause the interleaved development of requirements and code is fundamental to \nagile methods, there is no definitive statement of requirements that can be included \nin the contract.\nConsequently, agile methods have to rely on contracts in which the customer \npays for the time required for system development rather than the development of a \nspecific set of requirements. As long as all goes well, this benefits both the customer \nand the developer. However, if problems arise, then there may be difficult disputes \nover who is to blame and who should pay for the extra time and resources required \nto resolve the problems.\n\n\n90  Chapter 3 \u25a0 Agile software development\nAs I explain in Chapter 9, a  huge amount of software engineering effort goes into the \nmaintenance and evolution of existing software systems. Agile practices, such as incre-\nmental delivery, design for change, and maintaining simplicity all make sense when soft-\nware is being changed. In fact, you can think of an agile development process as a process \nthat supports continual change. If agile methods are used for software product develop-\nment, new releases of the product or app simply involve continuing the agile approach.\nHowever, where maintenance involves a custom system that must be changed in \nresponse to new business requirements, there is no clear consensus on the suitability \nof agile methods for software maintenance (Bird 2011; Kilner 2012). Three types of \nproblems can arise:\n\u25a0 lack of product documentation\n\u25a0 keeping customers involved\n\u25a0 development team continuity\nFormal documentation is supposed to describe the system and so make it easier \nfor people changing the system to understand. In practice, however, formal docu-\nmentation is rarely updated and so does not accurately reflect the program code. For \nthis reason, agile methods enthusiasts argue that it is a waste of time to write this \ndocumentation and that the key to implementing maintainable software is to produce \nhigh-quality, readable code. The lack of documentation should not be a problem in \nmaintaining systems developed using an agile approach.\nHowever, my experience of system maintenance is that the most important docu-\nment is the system requirements document, which tells the software engineer what the \nsystem is supposed to do. Without such knowledge, it is difficult to assess the impact of \nproposed system changes. Many agile methods collect requirements informally and \nincrementally and do not create a coherent requirements document. The use of agile \nmethods may therefore make subsequent system maintenance more difficult and expen-\nsive. This is a particular problem if development team continuity cannot be maintained.\nA key challenge in using an agile approach to maintenance is keeping customers \ninvolved in the process. While a customer may be able to justify the full-time involve-\nment of a representative during system development, this is less likely during mainte-\nnance where changes are not continuous. Customer representatives are likely to lose \ninterest in the system. Therefore, it is likely that alternative mechanisms, such as change \nproposals, discussed in Chapter 25, will have to be adapted to fit in with an agile approach.\nAnother potential problem that may arise is maintaining continuity of the devel-\nopment team. Agile methods rely on team members understanding aspects of the \nsystem without having to consult documentation. If an agile development team is \nbroken up, then this implicit knowledge is lost and it is difficult for new team mem-\nbers to build up the same understanding of the system and its components. Many \nprogrammers prefer to work on new development to software maintenance, and so \nthey are unwilling to continue to work on a software system after the first release has \nbeen delivered. Therefore, even when the intention is to keep the development team \ntogether, people leave if they are assigned maintenance tasks."}
{"query": "How does the informality of agile development clash with the legal approach to contract definition in large companies?", "response": "The informality of agile development clashes with the legal approach to contract definition in large companies because agile methods rely on the interleaved development of requirements and code, which means there is no definitive statement of requirements that can be included in the contract. This can create difficulties when drawing up a contract for software development between the customer and the supplier, as there is no clear agreement on the specific set of requirements that will be developed. Instead, agile methods require contracts where the customer pays for the time required for system development. While this can be beneficial when everything goes well, it can lead to disputes and difficulties if problems arise during the development process.", "context": "3.4  \u25a0 Scaling agile methods  89\nOf course, scaling up and scaling out are closely related. Contracts to develop \nlarge software systems are usually awarded to large organizations, with multiple \nteams working on the development project. These large companies have often exper-\nimented with agile methods in smaller projects, so they face the problems of scaling \nup and scaling out at the same time.\nThere are many anecdotes about the effectiveness of agile methods, and it has \nbeen suggested that these can lead to orders of magnitude improvements in produc-\ntivity and comparable reductions in defects. Ambler (Ambler 2010), an influential \nagile method developer, suggests that these productivity improvements are exagger-\nated for large systems and organizations. He suggests that an organization moving to \nagile methods can expect to see productivity improvement across the organization of \nabout 15% over 3 years, with similar reductions in the number of product defects.\n \n3.4.1  Practical problems with agile methods\nIn some areas, particularly in the development of software products and apps, agile \ndevelopment has been incredibly successful. It is by far the best approach to use for \nthis type of system. However, agile methods may not be suitable for other types of \nsoftware development, such as embedded systems engineering or the development \nof large and complex systems.\nFor large, long-lifetime systems that are developed by a software company for an \nexternal client, using an agile approach presents a number of problems.\n1. The informality of agile development is incompatible with the legal approach to \ncontract definition that is commonly used in large companies.\n2. Agile methods are most appropriate for new software development rather than \nfor software maintenance. Yet the majority of software costs in large companies \ncome from maintaining their existing software systems.\n3. Agile methods are designed for small co-located teams, yet much software \ndevelopment now involves worldwide distributed teams.\nContractual issues can be a major problem when agile methods are used. When \nthe system customer uses an outside organization for system development, a contract \nfor the software development is drawn up between them. The software requirements \ndocument is usually part of that contract between the customer and the supplier. \nBecause the interleaved development of requirements and code is fundamental to \nagile methods, there is no definitive statement of requirements that can be included \nin the contract.\nConsequently, agile methods have to rely on contracts in which the customer \npays for the time required for system development rather than the development of a \nspecific set of requirements. As long as all goes well, this benefits both the customer \nand the developer. However, if problems arise, then there may be difficult disputes \nover who is to blame and who should pay for the extra time and resources required \nto resolve the problems.\n\n\n90  Chapter 3 \u25a0 Agile software development\nAs I explain in Chapter 9, a  huge amount of software engineering effort goes into the \nmaintenance and evolution of existing software systems. Agile practices, such as incre-\nmental delivery, design for change, and maintaining simplicity all make sense when soft-\nware is being changed. In fact, you can think of an agile development process as a process \nthat supports continual change. If agile methods are used for software product develop-\nment, new releases of the product or app simply involve continuing the agile approach.\nHowever, where maintenance involves a custom system that must be changed in \nresponse to new business requirements, there is no clear consensus on the suitability \nof agile methods for software maintenance (Bird 2011; Kilner 2012). Three types of \nproblems can arise:\n\u25a0 lack of product documentation\n\u25a0 keeping customers involved\n\u25a0 development team continuity\nFormal documentation is supposed to describe the system and so make it easier \nfor people changing the system to understand. In practice, however, formal docu-\nmentation is rarely updated and so does not accurately reflect the program code. For \nthis reason, agile methods enthusiasts argue that it is a waste of time to write this \ndocumentation and that the key to implementing maintainable software is to produce \nhigh-quality, readable code. The lack of documentation should not be a problem in \nmaintaining systems developed using an agile approach.\nHowever, my experience of system maintenance is that the most important docu-\nment is the system requirements document, which tells the software engineer what the \nsystem is supposed to do. Without such knowledge, it is difficult to assess the impact of \nproposed system changes. Many agile methods collect requirements informally and \nincrementally and do not create a coherent requirements document. The use of agile \nmethods may therefore make subsequent system maintenance more difficult and expen-\nsive. This is a particular problem if development team continuity cannot be maintained.\nA key challenge in using an agile approach to maintenance is keeping customers \ninvolved in the process. While a customer may be able to justify the full-time involve-\nment of a representative during system development, this is less likely during mainte-\nnance where changes are not continuous. Customer representatives are likely to lose \ninterest in the system. Therefore, it is likely that alternative mechanisms, such as change \nproposals, discussed in Chapter 25, will have to be adapted to fit in with an agile approach.\nAnother potential problem that may arise is maintaining continuity of the devel-\nopment team. Agile methods rely on team members understanding aspects of the \nsystem without having to consult documentation. If an agile development team is \nbroken up, then this implicit knowledge is lost and it is difficult for new team mem-\nbers to build up the same understanding of the system and its components. Many \nprogrammers prefer to work on new development to software maintenance, and so \nthey are unwilling to continue to work on a software system after the first release has \nbeen delivered. Therefore, even when the intention is to keep the development team \ntogether, people leave if they are assigned maintenance tasks."}
{"query": "Why are agile methods designed for small co-located teams not suitable for worldwide distributed teams?", "response": "Agile methods are designed for small co-located teams because they rely on close collaboration and communication among team members. This level of collaboration is easier to achieve when team members are physically located in the same place. However, when software development involves worldwide distributed teams, it becomes more challenging to maintain the same level of collaboration and communication. The geographical distance and time zone differences can create barriers to effective communication and coordination. Therefore, agile methods may not be as suitable for worldwide distributed teams as they are for small co-located teams.", "context": "3.4  \u25a0 Scaling agile methods  89\nOf course, scaling up and scaling out are closely related. Contracts to develop \nlarge software systems are usually awarded to large organizations, with multiple \nteams working on the development project. These large companies have often exper-\nimented with agile methods in smaller projects, so they face the problems of scaling \nup and scaling out at the same time.\nThere are many anecdotes about the effectiveness of agile methods, and it has \nbeen suggested that these can lead to orders of magnitude improvements in produc-\ntivity and comparable reductions in defects. Ambler (Ambler 2010), an influential \nagile method developer, suggests that these productivity improvements are exagger-\nated for large systems and organizations. He suggests that an organization moving to \nagile methods can expect to see productivity improvement across the organization of \nabout 15% over 3 years, with similar reductions in the number of product defects.\n \n3.4.1  Practical problems with agile methods\nIn some areas, particularly in the development of software products and apps, agile \ndevelopment has been incredibly successful. It is by far the best approach to use for \nthis type of system. However, agile methods may not be suitable for other types of \nsoftware development, such as embedded systems engineering or the development \nof large and complex systems.\nFor large, long-lifetime systems that are developed by a software company for an \nexternal client, using an agile approach presents a number of problems.\n1. The informality of agile development is incompatible with the legal approach to \ncontract definition that is commonly used in large companies.\n2. Agile methods are most appropriate for new software development rather than \nfor software maintenance. Yet the majority of software costs in large companies \ncome from maintaining their existing software systems.\n3. Agile methods are designed for small co-located teams, yet much software \ndevelopment now involves worldwide distributed teams.\nContractual issues can be a major problem when agile methods are used. When \nthe system customer uses an outside organization for system development, a contract \nfor the software development is drawn up between them. The software requirements \ndocument is usually part of that contract between the customer and the supplier. \nBecause the interleaved development of requirements and code is fundamental to \nagile methods, there is no definitive statement of requirements that can be included \nin the contract.\nConsequently, agile methods have to rely on contracts in which the customer \npays for the time required for system development rather than the development of a \nspecific set of requirements. As long as all goes well, this benefits both the customer \nand the developer. However, if problems arise, then there may be difficult disputes \nover who is to blame and who should pay for the extra time and resources required \nto resolve the problems.\n\n\n90  Chapter 3 \u25a0 Agile software development\nAs I explain in Chapter 9, a  huge amount of software engineering effort goes into the \nmaintenance and evolution of existing software systems. Agile practices, such as incre-\nmental delivery, design for change, and maintaining simplicity all make sense when soft-\nware is being changed. In fact, you can think of an agile development process as a process \nthat supports continual change. If agile methods are used for software product develop-\nment, new releases of the product or app simply involve continuing the agile approach.\nHowever, where maintenance involves a custom system that must be changed in \nresponse to new business requirements, there is no clear consensus on the suitability \nof agile methods for software maintenance (Bird 2011; Kilner 2012). Three types of \nproblems can arise:\n\u25a0 lack of product documentation\n\u25a0 keeping customers involved\n\u25a0 development team continuity\nFormal documentation is supposed to describe the system and so make it easier \nfor people changing the system to understand. In practice, however, formal docu-\nmentation is rarely updated and so does not accurately reflect the program code. For \nthis reason, agile methods enthusiasts argue that it is a waste of time to write this \ndocumentation and that the key to implementing maintainable software is to produce \nhigh-quality, readable code. The lack of documentation should not be a problem in \nmaintaining systems developed using an agile approach.\nHowever, my experience of system maintenance is that the most important docu-\nment is the system requirements document, which tells the software engineer what the \nsystem is supposed to do. Without such knowledge, it is difficult to assess the impact of \nproposed system changes. Many agile methods collect requirements informally and \nincrementally and do not create a coherent requirements document. The use of agile \nmethods may therefore make subsequent system maintenance more difficult and expen-\nsive. This is a particular problem if development team continuity cannot be maintained.\nA key challenge in using an agile approach to maintenance is keeping customers \ninvolved in the process. While a customer may be able to justify the full-time involve-\nment of a representative during system development, this is less likely during mainte-\nnance where changes are not continuous. Customer representatives are likely to lose \ninterest in the system. Therefore, it is likely that alternative mechanisms, such as change \nproposals, discussed in Chapter 25, will have to be adapted to fit in with an agile approach.\nAnother potential problem that may arise is maintaining continuity of the devel-\nopment team. Agile methods rely on team members understanding aspects of the \nsystem without having to consult documentation. If an agile development team is \nbroken up, then this implicit knowledge is lost and it is difficult for new team mem-\nbers to build up the same understanding of the system and its components. Many \nprogrammers prefer to work on new development to software maintenance, and so \nthey are unwilling to continue to work on a software system after the first release has \nbeen delivered. Therefore, even when the intention is to keep the development team \ntogether, people leave if they are assigned maintenance tasks."}
{"query": "What is the impact of the lack of a definitive statement of requirements in the contract when using agile methods?", "response": "The lack of a definitive statement of requirements in the contract when using agile methods can lead to difficulties and disputes. Since agile methods involve the interleaved development of requirements and code, there is no clear and fixed set of requirements that can be included in the contract. Instead, the customer pays for the time required for system development. While this arrangement can be beneficial when everything goes smoothly, it can create problems when issues arise. Disputes may arise over who is responsible for the problems and who should bear the additional time and resource costs required to resolve them.", "context": "3.4  \u25a0 Scaling agile methods  89\nOf course, scaling up and scaling out are closely related. Contracts to develop \nlarge software systems are usually awarded to large organizations, with multiple \nteams working on the development project. These large companies have often exper-\nimented with agile methods in smaller projects, so they face the problems of scaling \nup and scaling out at the same time.\nThere are many anecdotes about the effectiveness of agile methods, and it has \nbeen suggested that these can lead to orders of magnitude improvements in produc-\ntivity and comparable reductions in defects. Ambler (Ambler 2010), an influential \nagile method developer, suggests that these productivity improvements are exagger-\nated for large systems and organizations. He suggests that an organization moving to \nagile methods can expect to see productivity improvement across the organization of \nabout 15% over 3 years, with similar reductions in the number of product defects.\n \n3.4.1  Practical problems with agile methods\nIn some areas, particularly in the development of software products and apps, agile \ndevelopment has been incredibly successful. It is by far the best approach to use for \nthis type of system. However, agile methods may not be suitable for other types of \nsoftware development, such as embedded systems engineering or the development \nof large and complex systems.\nFor large, long-lifetime systems that are developed by a software company for an \nexternal client, using an agile approach presents a number of problems.\n1. The informality of agile development is incompatible with the legal approach to \ncontract definition that is commonly used in large companies.\n2. Agile methods are most appropriate for new software development rather than \nfor software maintenance. Yet the majority of software costs in large companies \ncome from maintaining their existing software systems.\n3. Agile methods are designed for small co-located teams, yet much software \ndevelopment now involves worldwide distributed teams.\nContractual issues can be a major problem when agile methods are used. When \nthe system customer uses an outside organization for system development, a contract \nfor the software development is drawn up between them. The software requirements \ndocument is usually part of that contract between the customer and the supplier. \nBecause the interleaved development of requirements and code is fundamental to \nagile methods, there is no definitive statement of requirements that can be included \nin the contract.\nConsequently, agile methods have to rely on contracts in which the customer \npays for the time required for system development rather than the development of a \nspecific set of requirements. As long as all goes well, this benefits both the customer \nand the developer. However, if problems arise, then there may be difficult disputes \nover who is to blame and who should pay for the extra time and resources required \nto resolve the problems.\n\n\n90  Chapter 3 \u25a0 Agile software development\nAs I explain in Chapter 9, a  huge amount of software engineering effort goes into the \nmaintenance and evolution of existing software systems. Agile practices, such as incre-\nmental delivery, design for change, and maintaining simplicity all make sense when soft-\nware is being changed. In fact, you can think of an agile development process as a process \nthat supports continual change. If agile methods are used for software product develop-\nment, new releases of the product or app simply involve continuing the agile approach.\nHowever, where maintenance involves a custom system that must be changed in \nresponse to new business requirements, there is no clear consensus on the suitability \nof agile methods for software maintenance (Bird 2011; Kilner 2012). Three types of \nproblems can arise:\n\u25a0 lack of product documentation\n\u25a0 keeping customers involved\n\u25a0 development team continuity\nFormal documentation is supposed to describe the system and so make it easier \nfor people changing the system to understand. In practice, however, formal docu-\nmentation is rarely updated and so does not accurately reflect the program code. For \nthis reason, agile methods enthusiasts argue that it is a waste of time to write this \ndocumentation and that the key to implementing maintainable software is to produce \nhigh-quality, readable code. The lack of documentation should not be a problem in \nmaintaining systems developed using an agile approach.\nHowever, my experience of system maintenance is that the most important docu-\nment is the system requirements document, which tells the software engineer what the \nsystem is supposed to do. Without such knowledge, it is difficult to assess the impact of \nproposed system changes. Many agile methods collect requirements informally and \nincrementally and do not create a coherent requirements document. The use of agile \nmethods may therefore make subsequent system maintenance more difficult and expen-\nsive. This is a particular problem if development team continuity cannot be maintained.\nA key challenge in using an agile approach to maintenance is keeping customers \ninvolved in the process. While a customer may be able to justify the full-time involve-\nment of a representative during system development, this is less likely during mainte-\nnance where changes are not continuous. Customer representatives are likely to lose \ninterest in the system. Therefore, it is likely that alternative mechanisms, such as change \nproposals, discussed in Chapter 25, will have to be adapted to fit in with an agile approach.\nAnother potential problem that may arise is maintaining continuity of the devel-\nopment team. Agile methods rely on team members understanding aspects of the \nsystem without having to consult documentation. If an agile development team is \nbroken up, then this implicit knowledge is lost and it is difficult for new team mem-\nbers to build up the same understanding of the system and its components. Many \nprogrammers prefer to work on new development to software maintenance, and so \nthey are unwilling to continue to work on a software system after the first release has \nbeen delivered. Therefore, even when the intention is to keep the development team \ntogether, people leave if they are assigned maintenance tasks."}
{"query": "How does the lack of a coherent requirements document in agile methods make subsequent system maintenance more difficult and expensive?", "response": "The lack of a coherent requirements document in agile methods makes subsequent system maintenance more difficult and expensive because without a clear understanding of what the system is supposed to do, it becomes challenging to assess the impact of proposed system changes. Agile methods often collect requirements informally and incrementally, which means that there is no comprehensive requirements document that outlines the system's functionality. This lack of documentation can make it harder for software engineers to make informed decisions about system changes during maintenance, leading to increased complexity and potential errors. Additionally, the absence of a coherent requirements document can result in higher costs as more time and effort may be required to understand and modify the system without clear guidance.", "context": "3.4  \u25a0 Scaling agile methods  89\nOf course, scaling up and scaling out are closely related. Contracts to develop \nlarge software systems are usually awarded to large organizations, with multiple \nteams working on the development project. These large companies have often exper-\nimented with agile methods in smaller projects, so they face the problems of scaling \nup and scaling out at the same time.\nThere are many anecdotes about the effectiveness of agile methods, and it has \nbeen suggested that these can lead to orders of magnitude improvements in produc-\ntivity and comparable reductions in defects. Ambler (Ambler 2010), an influential \nagile method developer, suggests that these productivity improvements are exagger-\nated for large systems and organizations. He suggests that an organization moving to \nagile methods can expect to see productivity improvement across the organization of \nabout 15% over 3 years, with similar reductions in the number of product defects.\n \n3.4.1  Practical problems with agile methods\nIn some areas, particularly in the development of software products and apps, agile \ndevelopment has been incredibly successful. It is by far the best approach to use for \nthis type of system. However, agile methods may not be suitable for other types of \nsoftware development, such as embedded systems engineering or the development \nof large and complex systems.\nFor large, long-lifetime systems that are developed by a software company for an \nexternal client, using an agile approach presents a number of problems.\n1. The informality of agile development is incompatible with the legal approach to \ncontract definition that is commonly used in large companies.\n2. Agile methods are most appropriate for new software development rather than \nfor software maintenance. Yet the majority of software costs in large companies \ncome from maintaining their existing software systems.\n3. Agile methods are designed for small co-located teams, yet much software \ndevelopment now involves worldwide distributed teams.\nContractual issues can be a major problem when agile methods are used. When \nthe system customer uses an outside organization for system development, a contract \nfor the software development is drawn up between them. The software requirements \ndocument is usually part of that contract between the customer and the supplier. \nBecause the interleaved development of requirements and code is fundamental to \nagile methods, there is no definitive statement of requirements that can be included \nin the contract.\nConsequently, agile methods have to rely on contracts in which the customer \npays for the time required for system development rather than the development of a \nspecific set of requirements. As long as all goes well, this benefits both the customer \nand the developer. However, if problems arise, then there may be difficult disputes \nover who is to blame and who should pay for the extra time and resources required \nto resolve the problems.\n\n\n90  Chapter 3 \u25a0 Agile software development\nAs I explain in Chapter 9, a  huge amount of software engineering effort goes into the \nmaintenance and evolution of existing software systems. Agile practices, such as incre-\nmental delivery, design for change, and maintaining simplicity all make sense when soft-\nware is being changed. In fact, you can think of an agile development process as a process \nthat supports continual change. If agile methods are used for software product develop-\nment, new releases of the product or app simply involve continuing the agile approach.\nHowever, where maintenance involves a custom system that must be changed in \nresponse to new business requirements, there is no clear consensus on the suitability \nof agile methods for software maintenance (Bird 2011; Kilner 2012). Three types of \nproblems can arise:\n\u25a0 lack of product documentation\n\u25a0 keeping customers involved\n\u25a0 development team continuity\nFormal documentation is supposed to describe the system and so make it easier \nfor people changing the system to understand. In practice, however, formal docu-\nmentation is rarely updated and so does not accurately reflect the program code. For \nthis reason, agile methods enthusiasts argue that it is a waste of time to write this \ndocumentation and that the key to implementing maintainable software is to produce \nhigh-quality, readable code. The lack of documentation should not be a problem in \nmaintaining systems developed using an agile approach.\nHowever, my experience of system maintenance is that the most important docu-\nment is the system requirements document, which tells the software engineer what the \nsystem is supposed to do. Without such knowledge, it is difficult to assess the impact of \nproposed system changes. Many agile methods collect requirements informally and \nincrementally and do not create a coherent requirements document. The use of agile \nmethods may therefore make subsequent system maintenance more difficult and expen-\nsive. This is a particular problem if development team continuity cannot be maintained.\nA key challenge in using an agile approach to maintenance is keeping customers \ninvolved in the process. While a customer may be able to justify the full-time involve-\nment of a representative during system development, this is less likely during mainte-\nnance where changes are not continuous. Customer representatives are likely to lose \ninterest in the system. Therefore, it is likely that alternative mechanisms, such as change \nproposals, discussed in Chapter 25, will have to be adapted to fit in with an agile approach.\nAnother potential problem that may arise is maintaining continuity of the devel-\nopment team. Agile methods rely on team members understanding aspects of the \nsystem without having to consult documentation. If an agile development team is \nbroken up, then this implicit knowledge is lost and it is difficult for new team mem-\nbers to build up the same understanding of the system and its components. Many \nprogrammers prefer to work on new development to software maintenance, and so \nthey are unwilling to continue to work on a software system after the first release has \nbeen delivered. Therefore, even when the intention is to keep the development team \ntogether, people leave if they are assigned maintenance tasks."}
{"query": "How does the lack of continuity in the development team affect the maintenance of systems developed using an agile approach?", "response": "The lack of continuity in the development team can have a negative impact on the maintenance of systems developed using an agile approach. Agile methods rely on team members having a deep understanding of the system and its components without having to consult documentation. When the development team is broken up or team members leave, this implicit knowledge is lost. As a result, it becomes difficult for new team members to build up the same understanding of the system, which can hinder the maintenance process. Additionally, many programmers prefer to work on new development rather than software maintenance, so they may be unwilling to continue working on a software system after the first release has been delivered. This further exacerbates the challenge of maintaining continuity in the development team and can impact the effectiveness of agile maintenance practices.", "context": "3.4  \u25a0 Scaling agile methods  89\nOf course, scaling up and scaling out are closely related. Contracts to develop \nlarge software systems are usually awarded to large organizations, with multiple \nteams working on the development project. These large companies have often exper-\nimented with agile methods in smaller projects, so they face the problems of scaling \nup and scaling out at the same time.\nThere are many anecdotes about the effectiveness of agile methods, and it has \nbeen suggested that these can lead to orders of magnitude improvements in produc-\ntivity and comparable reductions in defects. Ambler (Ambler 2010), an influential \nagile method developer, suggests that these productivity improvements are exagger-\nated for large systems and organizations. He suggests that an organization moving to \nagile methods can expect to see productivity improvement across the organization of \nabout 15% over 3 years, with similar reductions in the number of product defects.\n \n3.4.1  Practical problems with agile methods\nIn some areas, particularly in the development of software products and apps, agile \ndevelopment has been incredibly successful. It is by far the best approach to use for \nthis type of system. However, agile methods may not be suitable for other types of \nsoftware development, such as embedded systems engineering or the development \nof large and complex systems.\nFor large, long-lifetime systems that are developed by a software company for an \nexternal client, using an agile approach presents a number of problems.\n1. The informality of agile development is incompatible with the legal approach to \ncontract definition that is commonly used in large companies.\n2. Agile methods are most appropriate for new software development rather than \nfor software maintenance. Yet the majority of software costs in large companies \ncome from maintaining their existing software systems.\n3. Agile methods are designed for small co-located teams, yet much software \ndevelopment now involves worldwide distributed teams.\nContractual issues can be a major problem when agile methods are used. When \nthe system customer uses an outside organization for system development, a contract \nfor the software development is drawn up between them. The software requirements \ndocument is usually part of that contract between the customer and the supplier. \nBecause the interleaved development of requirements and code is fundamental to \nagile methods, there is no definitive statement of requirements that can be included \nin the contract.\nConsequently, agile methods have to rely on contracts in which the customer \npays for the time required for system development rather than the development of a \nspecific set of requirements. As long as all goes well, this benefits both the customer \nand the developer. However, if problems arise, then there may be difficult disputes \nover who is to blame and who should pay for the extra time and resources required \nto resolve the problems.\n\n\n90  Chapter 3 \u25a0 Agile software development\nAs I explain in Chapter 9, a  huge amount of software engineering effort goes into the \nmaintenance and evolution of existing software systems. Agile practices, such as incre-\nmental delivery, design for change, and maintaining simplicity all make sense when soft-\nware is being changed. In fact, you can think of an agile development process as a process \nthat supports continual change. If agile methods are used for software product develop-\nment, new releases of the product or app simply involve continuing the agile approach.\nHowever, where maintenance involves a custom system that must be changed in \nresponse to new business requirements, there is no clear consensus on the suitability \nof agile methods for software maintenance (Bird 2011; Kilner 2012). Three types of \nproblems can arise:\n\u25a0 lack of product documentation\n\u25a0 keeping customers involved\n\u25a0 development team continuity\nFormal documentation is supposed to describe the system and so make it easier \nfor people changing the system to understand. In practice, however, formal docu-\nmentation is rarely updated and so does not accurately reflect the program code. For \nthis reason, agile methods enthusiasts argue that it is a waste of time to write this \ndocumentation and that the key to implementing maintainable software is to produce \nhigh-quality, readable code. The lack of documentation should not be a problem in \nmaintaining systems developed using an agile approach.\nHowever, my experience of system maintenance is that the most important docu-\nment is the system requirements document, which tells the software engineer what the \nsystem is supposed to do. Without such knowledge, it is difficult to assess the impact of \nproposed system changes. Many agile methods collect requirements informally and \nincrementally and do not create a coherent requirements document. The use of agile \nmethods may therefore make subsequent system maintenance more difficult and expen-\nsive. This is a particular problem if development team continuity cannot be maintained.\nA key challenge in using an agile approach to maintenance is keeping customers \ninvolved in the process. While a customer may be able to justify the full-time involve-\nment of a representative during system development, this is less likely during mainte-\nnance where changes are not continuous. Customer representatives are likely to lose \ninterest in the system. Therefore, it is likely that alternative mechanisms, such as change \nproposals, discussed in Chapter 25, will have to be adapted to fit in with an agile approach.\nAnother potential problem that may arise is maintaining continuity of the devel-\nopment team. Agile methods rely on team members understanding aspects of the \nsystem without having to consult documentation. If an agile development team is \nbroken up, then this implicit knowledge is lost and it is difficult for new team mem-\nbers to build up the same understanding of the system and its components. Many \nprogrammers prefer to work on new development to software maintenance, and so \nthey are unwilling to continue to work on a software system after the first release has \nbeen delivered. Therefore, even when the intention is to keep the development team \ntogether, people leave if they are assigned maintenance tasks."}
{"query": "What are the potential disputes that can arise if problems occur during system development using agile methods?", "response": "If problems arise during system development using agile methods, potential disputes can occur over who is to blame and who should pay for the extra time and resources required to resolve the problems.", "context": "3.4  \u25a0 Scaling agile methods  89\nOf course, scaling up and scaling out are closely related. Contracts to develop \nlarge software systems are usually awarded to large organizations, with multiple \nteams working on the development project. These large companies have often exper-\nimented with agile methods in smaller projects, so they face the problems of scaling \nup and scaling out at the same time.\nThere are many anecdotes about the effectiveness of agile methods, and it has \nbeen suggested that these can lead to orders of magnitude improvements in produc-\ntivity and comparable reductions in defects. Ambler (Ambler 2010), an influential \nagile method developer, suggests that these productivity improvements are exagger-\nated for large systems and organizations. He suggests that an organization moving to \nagile methods can expect to see productivity improvement across the organization of \nabout 15% over 3 years, with similar reductions in the number of product defects.\n \n3.4.1  Practical problems with agile methods\nIn some areas, particularly in the development of software products and apps, agile \ndevelopment has been incredibly successful. It is by far the best approach to use for \nthis type of system. However, agile methods may not be suitable for other types of \nsoftware development, such as embedded systems engineering or the development \nof large and complex systems.\nFor large, long-lifetime systems that are developed by a software company for an \nexternal client, using an agile approach presents a number of problems.\n1. The informality of agile development is incompatible with the legal approach to \ncontract definition that is commonly used in large companies.\n2. Agile methods are most appropriate for new software development rather than \nfor software maintenance. Yet the majority of software costs in large companies \ncome from maintaining their existing software systems.\n3. Agile methods are designed for small co-located teams, yet much software \ndevelopment now involves worldwide distributed teams.\nContractual issues can be a major problem when agile methods are used. When \nthe system customer uses an outside organization for system development, a contract \nfor the software development is drawn up between them. The software requirements \ndocument is usually part of that contract between the customer and the supplier. \nBecause the interleaved development of requirements and code is fundamental to \nagile methods, there is no definitive statement of requirements that can be included \nin the contract.\nConsequently, agile methods have to rely on contracts in which the customer \npays for the time required for system development rather than the development of a \nspecific set of requirements. As long as all goes well, this benefits both the customer \nand the developer. However, if problems arise, then there may be difficult disputes \nover who is to blame and who should pay for the extra time and resources required \nto resolve the problems.\n\n\n90  Chapter 3 \u25a0 Agile software development\nAs I explain in Chapter 9, a  huge amount of software engineering effort goes into the \nmaintenance and evolution of existing software systems. Agile practices, such as incre-\nmental delivery, design for change, and maintaining simplicity all make sense when soft-\nware is being changed. In fact, you can think of an agile development process as a process \nthat supports continual change. If agile methods are used for software product develop-\nment, new releases of the product or app simply involve continuing the agile approach.\nHowever, where maintenance involves a custom system that must be changed in \nresponse to new business requirements, there is no clear consensus on the suitability \nof agile methods for software maintenance (Bird 2011; Kilner 2012). Three types of \nproblems can arise:\n\u25a0 lack of product documentation\n\u25a0 keeping customers involved\n\u25a0 development team continuity\nFormal documentation is supposed to describe the system and so make it easier \nfor people changing the system to understand. In practice, however, formal docu-\nmentation is rarely updated and so does not accurately reflect the program code. For \nthis reason, agile methods enthusiasts argue that it is a waste of time to write this \ndocumentation and that the key to implementing maintainable software is to produce \nhigh-quality, readable code. The lack of documentation should not be a problem in \nmaintaining systems developed using an agile approach.\nHowever, my experience of system maintenance is that the most important docu-\nment is the system requirements document, which tells the software engineer what the \nsystem is supposed to do. Without such knowledge, it is difficult to assess the impact of \nproposed system changes. Many agile methods collect requirements informally and \nincrementally and do not create a coherent requirements document. The use of agile \nmethods may therefore make subsequent system maintenance more difficult and expen-\nsive. This is a particular problem if development team continuity cannot be maintained.\nA key challenge in using an agile approach to maintenance is keeping customers \ninvolved in the process. While a customer may be able to justify the full-time involve-\nment of a representative during system development, this is less likely during mainte-\nnance where changes are not continuous. Customer representatives are likely to lose \ninterest in the system. Therefore, it is likely that alternative mechanisms, such as change \nproposals, discussed in Chapter 25, will have to be adapted to fit in with an agile approach.\nAnother potential problem that may arise is maintaining continuity of the devel-\nopment team. Agile methods rely on team members understanding aspects of the \nsystem without having to consult documentation. If an agile development team is \nbroken up, then this implicit knowledge is lost and it is difficult for new team mem-\nbers to build up the same understanding of the system and its components. Many \nprogrammers prefer to work on new development to software maintenance, and so \nthey are unwilling to continue to work on a software system after the first release has \nbeen delivered. Therefore, even when the intention is to keep the development team \ntogether, people leave if they are assigned maintenance tasks."}
{"query": "How does the lack of full-time involvement of a customer representative during system maintenance affect the use of an agile approach?", "response": "The lack of full-time involvement of a customer representative during system maintenance can affect the use of an agile approach in several ways. Firstly, it may be more difficult to keep the customer involved in the process, as their interest in the system may wane over time. This can make it challenging to gather feedback and make informed decisions about system changes. Secondly, without a dedicated customer representative, alternative mechanisms, such as change proposals, may need to be adapted to fit in with an agile approach. This can add complexity and potentially slow down the decision-making process. Finally, the lack of full-time customer involvement can make it harder to maintain continuity of the development team. Agile methods rely on team members having a deep understanding of the system, and if this knowledge is not readily available from a customer representative, it can be difficult for new team members to build up the same level of understanding.", "context": "3.4  \u25a0 Scaling agile methods  89\nOf course, scaling up and scaling out are closely related. Contracts to develop \nlarge software systems are usually awarded to large organizations, with multiple \nteams working on the development project. These large companies have often exper-\nimented with agile methods in smaller projects, so they face the problems of scaling \nup and scaling out at the same time.\nThere are many anecdotes about the effectiveness of agile methods, and it has \nbeen suggested that these can lead to orders of magnitude improvements in produc-\ntivity and comparable reductions in defects. Ambler (Ambler 2010), an influential \nagile method developer, suggests that these productivity improvements are exagger-\nated for large systems and organizations. He suggests that an organization moving to \nagile methods can expect to see productivity improvement across the organization of \nabout 15% over 3 years, with similar reductions in the number of product defects.\n \n3.4.1  Practical problems with agile methods\nIn some areas, particularly in the development of software products and apps, agile \ndevelopment has been incredibly successful. It is by far the best approach to use for \nthis type of system. However, agile methods may not be suitable for other types of \nsoftware development, such as embedded systems engineering or the development \nof large and complex systems.\nFor large, long-lifetime systems that are developed by a software company for an \nexternal client, using an agile approach presents a number of problems.\n1. The informality of agile development is incompatible with the legal approach to \ncontract definition that is commonly used in large companies.\n2. Agile methods are most appropriate for new software development rather than \nfor software maintenance. Yet the majority of software costs in large companies \ncome from maintaining their existing software systems.\n3. Agile methods are designed for small co-located teams, yet much software \ndevelopment now involves worldwide distributed teams.\nContractual issues can be a major problem when agile methods are used. When \nthe system customer uses an outside organization for system development, a contract \nfor the software development is drawn up between them. The software requirements \ndocument is usually part of that contract between the customer and the supplier. \nBecause the interleaved development of requirements and code is fundamental to \nagile methods, there is no definitive statement of requirements that can be included \nin the contract.\nConsequently, agile methods have to rely on contracts in which the customer \npays for the time required for system development rather than the development of a \nspecific set of requirements. As long as all goes well, this benefits both the customer \nand the developer. However, if problems arise, then there may be difficult disputes \nover who is to blame and who should pay for the extra time and resources required \nto resolve the problems.\n\n\n90  Chapter 3 \u25a0 Agile software development\nAs I explain in Chapter 9, a  huge amount of software engineering effort goes into the \nmaintenance and evolution of existing software systems. Agile practices, such as incre-\nmental delivery, design for change, and maintaining simplicity all make sense when soft-\nware is being changed. In fact, you can think of an agile development process as a process \nthat supports continual change. If agile methods are used for software product develop-\nment, new releases of the product or app simply involve continuing the agile approach.\nHowever, where maintenance involves a custom system that must be changed in \nresponse to new business requirements, there is no clear consensus on the suitability \nof agile methods for software maintenance (Bird 2011; Kilner 2012). Three types of \nproblems can arise:\n\u25a0 lack of product documentation\n\u25a0 keeping customers involved\n\u25a0 development team continuity\nFormal documentation is supposed to describe the system and so make it easier \nfor people changing the system to understand. In practice, however, formal docu-\nmentation is rarely updated and so does not accurately reflect the program code. For \nthis reason, agile methods enthusiasts argue that it is a waste of time to write this \ndocumentation and that the key to implementing maintainable software is to produce \nhigh-quality, readable code. The lack of documentation should not be a problem in \nmaintaining systems developed using an agile approach.\nHowever, my experience of system maintenance is that the most important docu-\nment is the system requirements document, which tells the software engineer what the \nsystem is supposed to do. Without such knowledge, it is difficult to assess the impact of \nproposed system changes. Many agile methods collect requirements informally and \nincrementally and do not create a coherent requirements document. The use of agile \nmethods may therefore make subsequent system maintenance more difficult and expen-\nsive. This is a particular problem if development team continuity cannot be maintained.\nA key challenge in using an agile approach to maintenance is keeping customers \ninvolved in the process. While a customer may be able to justify the full-time involve-\nment of a representative during system development, this is less likely during mainte-\nnance where changes are not continuous. Customer representatives are likely to lose \ninterest in the system. Therefore, it is likely that alternative mechanisms, such as change \nproposals, discussed in Chapter 25, will have to be adapted to fit in with an agile approach.\nAnother potential problem that may arise is maintaining continuity of the devel-\nopment team. Agile methods rely on team members understanding aspects of the \nsystem without having to consult documentation. If an agile development team is \nbroken up, then this implicit knowledge is lost and it is difficult for new team mem-\nbers to build up the same understanding of the system and its components. Many \nprogrammers prefer to work on new development to software maintenance, and so \nthey are unwilling to continue to work on a software system after the first release has \nbeen delivered. Therefore, even when the intention is to keep the development team \ntogether, people leave if they are assigned maintenance tasks."}
{"query": "What is a fundamental requirement of scaling agile methods?", "response": "A fundamental requirement of scaling agile methods is to integrate them with plan-driven approaches.", "context": "3.4  \u25a0 Scaling agile methods  91\n \n3.4.2  Agile and plan-driven methods\nA fundamental requirement of scaling agile methods is to integrate them with plan-\ndriven approaches. Small startup companies can work with informal and short-term \nplanning, but larger companies have to have longer-term plans and budgets for \ninvestment, staffing, and business development. Their software development must \nsupport these plans, so longer-term software planning is essential.\nEarly adopters of agile methods in the first decade of the 21st century were enthu-\nsiasts and deeply committed to the agile manifesto. They deliberately rejected the \nplan-driven approach to software engineering and were reluctant to change the ini-\ntial vision of agile methods in any way. However, as organizations saw the value and \nbenefits of an agile approach, they adapted these methods to suit their own culture \nand ways of working. They had to do this because the principles underlying agile \nmethods are sometimes difficult to realize in practice (Figure 3.11).\nTo address these problems, most large \u201cagile\u201d software development projects com-\nbine practices from plan-driven and agile approaches. Some are mostly agile, and others \nare mostly plan-driven but with some agile practices. To decide on the balance between \na plan-based and an agile approach, you have to answer a range of technical, human and \norganizational questions. These relate to the system being developed, the development \nteam, and the organizations that are developing and procuring the system (Figure 3.12).\nAgile methods were developed and refined in projects to develop small to medium-\nsized business systems and software products, where the software developer controls \nthe specification of the system. Other types of system have attributes such as size, com-\nplexity, real-time response, and external regulation that mean a \u201cpure\u201d agile approach is \nPrinciple\nPractice\nCustomer involvement\nThis depends on having a customer who is willing and able to spend time with \nthe development team and who can represent all system stakeholders. Often, \ncustomer representatives have other demands on their time and cannot play a \nfull part in the software development. Where there are external stakeholders, \nsuch as regulators, it is difficult to represent their views to the agile team.\nEmbrace change\nPrioritizing changes can be extremely difficult, especially in systems for which \nthere are many stakeholders. Typically, each stakeholder gives different \npriorities to different changes.\nIncremental delivery\nRapid iterations and short-term planning for development does not always fit \nin with the longer-term planning cycles of business planning and marketing. \nMarketing managers may need to know product features several months in \nadvance to prepare an effective marketing campaign.\nMaintain simplicity\nUnder pressure from delivery schedules, team members may not have time to \ncarry out desirable system simplifications.\nPeople, not process\nIndividual team members may not have suitable personalities for the intense \ninvolvement that is typical of agile methods and therefore may not interact \nwell with other team members.\nFigure 3.11 Agile \nprinciples and \norganizational practice\n\n\n92  Chapter 3 \u25a0 Agile software development\nunlikely to work. There needs to be some up-front planning, design, and documentation \nin the systems engineering process. Some of the key issues are as follows:\n1. \nHow large is the system that is being developed? Agile methods are most effective \nwhen the system can be developed with a relatively small co-located team who \ncan communicate informally. This may not be possible for large systems that \nrequire larger development teams, so a plan-driven approach may have to be used.\n2. What type of system is being developed? Systems that require a lot of analysis \nbefore implementation (e.g., real-time system with complex timing require-\nments) usually need a fairly detailed design to carry out this analysis. A plan-\ndriven approach may be best in those circumstances.\n3. What is the expected system lifetime? Long-lifetime systems may require more \ndesign documentation to communicate the original intentions of the system \ndevelopers to the support team. However, supporters of agile methods rightly \nargue that documentation is frequently not kept up to date and is not of much \nuse for long-term system maintenance.\n4. Is the system subject to external regulation? If a system has to be approved \nby\u00a0an external regulator (e.g., the Federal Aviation Administration approves \nsoftware that is critical to the operation of an aircraft), then you will probably be \nrequired to produce detailed documentation as part of the system safety\u00a0case.\nAgile methods place a great deal of responsibility on the development team to \ncooperate and communicate during the development of the system. They rely on indi-\nvidual engineering skills and software support for the development process. However, \nin reality, not everyone is a highly skilled engineer, people do not communicate effec-\ntively, and it is not always possible for teams to work together. Some planning may be \nrequired to make the most effective use of the people available. Key issues are:\n1. How good are the designers and programmers in the development team? \nIt\u00a0is\u00a0sometimes argued that agile methods require higher skill levels than plan-\nbased approaches in which programmers simply translate a detailed design into \ncode. If you have a team with relatively low skill levels, you may need to use \nthe best people to develop the design, with others responsible for programming.\nSystem\nTeam\nOrganization\nScale\nTechnology\nDistribution\nContracts\nDelivery\nRegulation\nType\nLifetime\nCompetence\nCulture\nFigure 3.12 Factors \ninfluencing the choice  \nof plan-based or agile \ndevelopment"}
{"query": "Why do larger companies need to integrate agile methods with plan-driven approaches?", "response": "Larger companies need to integrate agile methods with plan-driven approaches because they have longer-term plans and budgets for investment, staffing, and business development. Their software development must support these plans, so longer-term software planning is essential. Additionally, the principles underlying agile methods can sometimes be difficult to realize in practice, so combining practices from plan-driven and agile approaches allows larger companies to adapt agile methods to suit their own culture and ways of working.", "context": "3.4  \u25a0 Scaling agile methods  91\n \n3.4.2  Agile and plan-driven methods\nA fundamental requirement of scaling agile methods is to integrate them with plan-\ndriven approaches. Small startup companies can work with informal and short-term \nplanning, but larger companies have to have longer-term plans and budgets for \ninvestment, staffing, and business development. Their software development must \nsupport these plans, so longer-term software planning is essential.\nEarly adopters of agile methods in the first decade of the 21st century were enthu-\nsiasts and deeply committed to the agile manifesto. They deliberately rejected the \nplan-driven approach to software engineering and were reluctant to change the ini-\ntial vision of agile methods in any way. However, as organizations saw the value and \nbenefits of an agile approach, they adapted these methods to suit their own culture \nand ways of working. They had to do this because the principles underlying agile \nmethods are sometimes difficult to realize in practice (Figure 3.11).\nTo address these problems, most large \u201cagile\u201d software development projects com-\nbine practices from plan-driven and agile approaches. Some are mostly agile, and others \nare mostly plan-driven but with some agile practices. To decide on the balance between \na plan-based and an agile approach, you have to answer a range of technical, human and \norganizational questions. These relate to the system being developed, the development \nteam, and the organizations that are developing and procuring the system (Figure 3.12).\nAgile methods were developed and refined in projects to develop small to medium-\nsized business systems and software products, where the software developer controls \nthe specification of the system. Other types of system have attributes such as size, com-\nplexity, real-time response, and external regulation that mean a \u201cpure\u201d agile approach is \nPrinciple\nPractice\nCustomer involvement\nThis depends on having a customer who is willing and able to spend time with \nthe development team and who can represent all system stakeholders. Often, \ncustomer representatives have other demands on their time and cannot play a \nfull part in the software development. Where there are external stakeholders, \nsuch as regulators, it is difficult to represent their views to the agile team.\nEmbrace change\nPrioritizing changes can be extremely difficult, especially in systems for which \nthere are many stakeholders. Typically, each stakeholder gives different \npriorities to different changes.\nIncremental delivery\nRapid iterations and short-term planning for development does not always fit \nin with the longer-term planning cycles of business planning and marketing. \nMarketing managers may need to know product features several months in \nadvance to prepare an effective marketing campaign.\nMaintain simplicity\nUnder pressure from delivery schedules, team members may not have time to \ncarry out desirable system simplifications.\nPeople, not process\nIndividual team members may not have suitable personalities for the intense \ninvolvement that is typical of agile methods and therefore may not interact \nwell with other team members.\nFigure 3.11 Agile \nprinciples and \norganizational practice\n\n\n92  Chapter 3 \u25a0 Agile software development\nunlikely to work. There needs to be some up-front planning, design, and documentation \nin the systems engineering process. Some of the key issues are as follows:\n1. \nHow large is the system that is being developed? Agile methods are most effective \nwhen the system can be developed with a relatively small co-located team who \ncan communicate informally. This may not be possible for large systems that \nrequire larger development teams, so a plan-driven approach may have to be used.\n2. What type of system is being developed? Systems that require a lot of analysis \nbefore implementation (e.g., real-time system with complex timing require-\nments) usually need a fairly detailed design to carry out this analysis. A plan-\ndriven approach may be best in those circumstances.\n3. What is the expected system lifetime? Long-lifetime systems may require more \ndesign documentation to communicate the original intentions of the system \ndevelopers to the support team. However, supporters of agile methods rightly \nargue that documentation is frequently not kept up to date and is not of much \nuse for long-term system maintenance.\n4. Is the system subject to external regulation? If a system has to be approved \nby\u00a0an external regulator (e.g., the Federal Aviation Administration approves \nsoftware that is critical to the operation of an aircraft), then you will probably be \nrequired to produce detailed documentation as part of the system safety\u00a0case.\nAgile methods place a great deal of responsibility on the development team to \ncooperate and communicate during the development of the system. They rely on indi-\nvidual engineering skills and software support for the development process. However, \nin reality, not everyone is a highly skilled engineer, people do not communicate effec-\ntively, and it is not always possible for teams to work together. Some planning may be \nrequired to make the most effective use of the people available. Key issues are:\n1. How good are the designers and programmers in the development team? \nIt\u00a0is\u00a0sometimes argued that agile methods require higher skill levels than plan-\nbased approaches in which programmers simply translate a detailed design into \ncode. If you have a team with relatively low skill levels, you may need to use \nthe best people to develop the design, with others responsible for programming.\nSystem\nTeam\nOrganization\nScale\nTechnology\nDistribution\nContracts\nDelivery\nRegulation\nType\nLifetime\nCompetence\nCulture\nFigure 3.12 Factors \ninfluencing the choice  \nof plan-based or agile \ndevelopment"}
{"query": "How did early adopters of agile methods in the first decade of the 21st century view plan-driven approaches?", "response": "Early adopters of agile methods in the first decade of the 21st century viewed plan-driven approaches negatively. They deliberately rejected the plan-driven approach to software engineering and were reluctant to change the initial vision of agile methods in any way.", "context": "3.4  \u25a0 Scaling agile methods  91\n \n3.4.2  Agile and plan-driven methods\nA fundamental requirement of scaling agile methods is to integrate them with plan-\ndriven approaches. Small startup companies can work with informal and short-term \nplanning, but larger companies have to have longer-term plans and budgets for \ninvestment, staffing, and business development. Their software development must \nsupport these plans, so longer-term software planning is essential.\nEarly adopters of agile methods in the first decade of the 21st century were enthu-\nsiasts and deeply committed to the agile manifesto. They deliberately rejected the \nplan-driven approach to software engineering and were reluctant to change the ini-\ntial vision of agile methods in any way. However, as organizations saw the value and \nbenefits of an agile approach, they adapted these methods to suit their own culture \nand ways of working. They had to do this because the principles underlying agile \nmethods are sometimes difficult to realize in practice (Figure 3.11).\nTo address these problems, most large \u201cagile\u201d software development projects com-\nbine practices from plan-driven and agile approaches. Some are mostly agile, and others \nare mostly plan-driven but with some agile practices. To decide on the balance between \na plan-based and an agile approach, you have to answer a range of technical, human and \norganizational questions. These relate to the system being developed, the development \nteam, and the organizations that are developing and procuring the system (Figure 3.12).\nAgile methods were developed and refined in projects to develop small to medium-\nsized business systems and software products, where the software developer controls \nthe specification of the system. Other types of system have attributes such as size, com-\nplexity, real-time response, and external regulation that mean a \u201cpure\u201d agile approach is \nPrinciple\nPractice\nCustomer involvement\nThis depends on having a customer who is willing and able to spend time with \nthe development team and who can represent all system stakeholders. Often, \ncustomer representatives have other demands on their time and cannot play a \nfull part in the software development. Where there are external stakeholders, \nsuch as regulators, it is difficult to represent their views to the agile team.\nEmbrace change\nPrioritizing changes can be extremely difficult, especially in systems for which \nthere are many stakeholders. Typically, each stakeholder gives different \npriorities to different changes.\nIncremental delivery\nRapid iterations and short-term planning for development does not always fit \nin with the longer-term planning cycles of business planning and marketing. \nMarketing managers may need to know product features several months in \nadvance to prepare an effective marketing campaign.\nMaintain simplicity\nUnder pressure from delivery schedules, team members may not have time to \ncarry out desirable system simplifications.\nPeople, not process\nIndividual team members may not have suitable personalities for the intense \ninvolvement that is typical of agile methods and therefore may not interact \nwell with other team members.\nFigure 3.11 Agile \nprinciples and \norganizational practice\n\n\n92  Chapter 3 \u25a0 Agile software development\nunlikely to work. There needs to be some up-front planning, design, and documentation \nin the systems engineering process. Some of the key issues are as follows:\n1. \nHow large is the system that is being developed? Agile methods are most effective \nwhen the system can be developed with a relatively small co-located team who \ncan communicate informally. This may not be possible for large systems that \nrequire larger development teams, so a plan-driven approach may have to be used.\n2. What type of system is being developed? Systems that require a lot of analysis \nbefore implementation (e.g., real-time system with complex timing require-\nments) usually need a fairly detailed design to carry out this analysis. A plan-\ndriven approach may be best in those circumstances.\n3. What is the expected system lifetime? Long-lifetime systems may require more \ndesign documentation to communicate the original intentions of the system \ndevelopers to the support team. However, supporters of agile methods rightly \nargue that documentation is frequently not kept up to date and is not of much \nuse for long-term system maintenance.\n4. Is the system subject to external regulation? If a system has to be approved \nby\u00a0an external regulator (e.g., the Federal Aviation Administration approves \nsoftware that is critical to the operation of an aircraft), then you will probably be \nrequired to produce detailed documentation as part of the system safety\u00a0case.\nAgile methods place a great deal of responsibility on the development team to \ncooperate and communicate during the development of the system. They rely on indi-\nvidual engineering skills and software support for the development process. However, \nin reality, not everyone is a highly skilled engineer, people do not communicate effec-\ntively, and it is not always possible for teams to work together. Some planning may be \nrequired to make the most effective use of the people available. Key issues are:\n1. How good are the designers and programmers in the development team? \nIt\u00a0is\u00a0sometimes argued that agile methods require higher skill levels than plan-\nbased approaches in which programmers simply translate a detailed design into \ncode. If you have a team with relatively low skill levels, you may need to use \nthe best people to develop the design, with others responsible for programming.\nSystem\nTeam\nOrganization\nScale\nTechnology\nDistribution\nContracts\nDelivery\nRegulation\nType\nLifetime\nCompetence\nCulture\nFigure 3.12 Factors \ninfluencing the choice  \nof plan-based or agile \ndevelopment"}
{"query": "Why did organizations adapt agile methods to suit their own culture and ways of working?", "response": "Organizations adapted agile methods to suit their own culture and ways of working because the principles underlying agile methods can be difficult to realize in practice. As organizations saw the value and benefits of an agile approach, they recognized the need to tailor these methods to align with their existing culture and work processes. This adaptation allowed them to effectively implement agile practices while still accommodating their specific organizational context.", "context": "3.4  \u25a0 Scaling agile methods  91\n \n3.4.2  Agile and plan-driven methods\nA fundamental requirement of scaling agile methods is to integrate them with plan-\ndriven approaches. Small startup companies can work with informal and short-term \nplanning, but larger companies have to have longer-term plans and budgets for \ninvestment, staffing, and business development. Their software development must \nsupport these plans, so longer-term software planning is essential.\nEarly adopters of agile methods in the first decade of the 21st century were enthu-\nsiasts and deeply committed to the agile manifesto. They deliberately rejected the \nplan-driven approach to software engineering and were reluctant to change the ini-\ntial vision of agile methods in any way. However, as organizations saw the value and \nbenefits of an agile approach, they adapted these methods to suit their own culture \nand ways of working. They had to do this because the principles underlying agile \nmethods are sometimes difficult to realize in practice (Figure 3.11).\nTo address these problems, most large \u201cagile\u201d software development projects com-\nbine practices from plan-driven and agile approaches. Some are mostly agile, and others \nare mostly plan-driven but with some agile practices. To decide on the balance between \na plan-based and an agile approach, you have to answer a range of technical, human and \norganizational questions. These relate to the system being developed, the development \nteam, and the organizations that are developing and procuring the system (Figure 3.12).\nAgile methods were developed and refined in projects to develop small to medium-\nsized business systems and software products, where the software developer controls \nthe specification of the system. Other types of system have attributes such as size, com-\nplexity, real-time response, and external regulation that mean a \u201cpure\u201d agile approach is \nPrinciple\nPractice\nCustomer involvement\nThis depends on having a customer who is willing and able to spend time with \nthe development team and who can represent all system stakeholders. Often, \ncustomer representatives have other demands on their time and cannot play a \nfull part in the software development. Where there are external stakeholders, \nsuch as regulators, it is difficult to represent their views to the agile team.\nEmbrace change\nPrioritizing changes can be extremely difficult, especially in systems for which \nthere are many stakeholders. Typically, each stakeholder gives different \npriorities to different changes.\nIncremental delivery\nRapid iterations and short-term planning for development does not always fit \nin with the longer-term planning cycles of business planning and marketing. \nMarketing managers may need to know product features several months in \nadvance to prepare an effective marketing campaign.\nMaintain simplicity\nUnder pressure from delivery schedules, team members may not have time to \ncarry out desirable system simplifications.\nPeople, not process\nIndividual team members may not have suitable personalities for the intense \ninvolvement that is typical of agile methods and therefore may not interact \nwell with other team members.\nFigure 3.11 Agile \nprinciples and \norganizational practice\n\n\n92  Chapter 3 \u25a0 Agile software development\nunlikely to work. There needs to be some up-front planning, design, and documentation \nin the systems engineering process. Some of the key issues are as follows:\n1. \nHow large is the system that is being developed? Agile methods are most effective \nwhen the system can be developed with a relatively small co-located team who \ncan communicate informally. This may not be possible for large systems that \nrequire larger development teams, so a plan-driven approach may have to be used.\n2. What type of system is being developed? Systems that require a lot of analysis \nbefore implementation (e.g., real-time system with complex timing require-\nments) usually need a fairly detailed design to carry out this analysis. A plan-\ndriven approach may be best in those circumstances.\n3. What is the expected system lifetime? Long-lifetime systems may require more \ndesign documentation to communicate the original intentions of the system \ndevelopers to the support team. However, supporters of agile methods rightly \nargue that documentation is frequently not kept up to date and is not of much \nuse for long-term system maintenance.\n4. Is the system subject to external regulation? If a system has to be approved \nby\u00a0an external regulator (e.g., the Federal Aviation Administration approves \nsoftware that is critical to the operation of an aircraft), then you will probably be \nrequired to produce detailed documentation as part of the system safety\u00a0case.\nAgile methods place a great deal of responsibility on the development team to \ncooperate and communicate during the development of the system. They rely on indi-\nvidual engineering skills and software support for the development process. However, \nin reality, not everyone is a highly skilled engineer, people do not communicate effec-\ntively, and it is not always possible for teams to work together. Some planning may be \nrequired to make the most effective use of the people available. Key issues are:\n1. How good are the designers and programmers in the development team? \nIt\u00a0is\u00a0sometimes argued that agile methods require higher skill levels than plan-\nbased approaches in which programmers simply translate a detailed design into \ncode. If you have a team with relatively low skill levels, you may need to use \nthe best people to develop the design, with others responsible for programming.\nSystem\nTeam\nOrganization\nScale\nTechnology\nDistribution\nContracts\nDelivery\nRegulation\nType\nLifetime\nCompetence\nCulture\nFigure 3.12 Factors \ninfluencing the choice  \nof plan-based or agile \ndevelopment"}
{"query": "What are some of the challenges in realizing the principles underlying agile methods in practice?", "response": "Prioritizing changes can be extremely difficult, especially in systems with many stakeholders. Each stakeholder may have different priorities for different changes. Additionally, rapid iterations and short-term planning for development may not align with the longer-term planning cycles of business planning and marketing. Marketing managers may need to know product features several months in advance to prepare an effective marketing campaign. Under pressure from delivery schedules, team members may not have time to carry out desirable system simplifications. Individual team members may not have suitable personalities for the intense involvement that is typical of agile methods and may not interact well with other team members.", "context": "3.4  \u25a0 Scaling agile methods  91\n \n3.4.2  Agile and plan-driven methods\nA fundamental requirement of scaling agile methods is to integrate them with plan-\ndriven approaches. Small startup companies can work with informal and short-term \nplanning, but larger companies have to have longer-term plans and budgets for \ninvestment, staffing, and business development. Their software development must \nsupport these plans, so longer-term software planning is essential.\nEarly adopters of agile methods in the first decade of the 21st century were enthu-\nsiasts and deeply committed to the agile manifesto. They deliberately rejected the \nplan-driven approach to software engineering and were reluctant to change the ini-\ntial vision of agile methods in any way. However, as organizations saw the value and \nbenefits of an agile approach, they adapted these methods to suit their own culture \nand ways of working. They had to do this because the principles underlying agile \nmethods are sometimes difficult to realize in practice (Figure 3.11).\nTo address these problems, most large \u201cagile\u201d software development projects com-\nbine practices from plan-driven and agile approaches. Some are mostly agile, and others \nare mostly plan-driven but with some agile practices. To decide on the balance between \na plan-based and an agile approach, you have to answer a range of technical, human and \norganizational questions. These relate to the system being developed, the development \nteam, and the organizations that are developing and procuring the system (Figure 3.12).\nAgile methods were developed and refined in projects to develop small to medium-\nsized business systems and software products, where the software developer controls \nthe specification of the system. Other types of system have attributes such as size, com-\nplexity, real-time response, and external regulation that mean a \u201cpure\u201d agile approach is \nPrinciple\nPractice\nCustomer involvement\nThis depends on having a customer who is willing and able to spend time with \nthe development team and who can represent all system stakeholders. Often, \ncustomer representatives have other demands on their time and cannot play a \nfull part in the software development. Where there are external stakeholders, \nsuch as regulators, it is difficult to represent their views to the agile team.\nEmbrace change\nPrioritizing changes can be extremely difficult, especially in systems for which \nthere are many stakeholders. Typically, each stakeholder gives different \npriorities to different changes.\nIncremental delivery\nRapid iterations and short-term planning for development does not always fit \nin with the longer-term planning cycles of business planning and marketing. \nMarketing managers may need to know product features several months in \nadvance to prepare an effective marketing campaign.\nMaintain simplicity\nUnder pressure from delivery schedules, team members may not have time to \ncarry out desirable system simplifications.\nPeople, not process\nIndividual team members may not have suitable personalities for the intense \ninvolvement that is typical of agile methods and therefore may not interact \nwell with other team members.\nFigure 3.11 Agile \nprinciples and \norganizational practice\n\n\n92  Chapter 3 \u25a0 Agile software development\nunlikely to work. There needs to be some up-front planning, design, and documentation \nin the systems engineering process. Some of the key issues are as follows:\n1. \nHow large is the system that is being developed? Agile methods are most effective \nwhen the system can be developed with a relatively small co-located team who \ncan communicate informally. This may not be possible for large systems that \nrequire larger development teams, so a plan-driven approach may have to be used.\n2. What type of system is being developed? Systems that require a lot of analysis \nbefore implementation (e.g., real-time system with complex timing require-\nments) usually need a fairly detailed design to carry out this analysis. A plan-\ndriven approach may be best in those circumstances.\n3. What is the expected system lifetime? Long-lifetime systems may require more \ndesign documentation to communicate the original intentions of the system \ndevelopers to the support team. However, supporters of agile methods rightly \nargue that documentation is frequently not kept up to date and is not of much \nuse for long-term system maintenance.\n4. Is the system subject to external regulation? If a system has to be approved \nby\u00a0an external regulator (e.g., the Federal Aviation Administration approves \nsoftware that is critical to the operation of an aircraft), then you will probably be \nrequired to produce detailed documentation as part of the system safety\u00a0case.\nAgile methods place a great deal of responsibility on the development team to \ncooperate and communicate during the development of the system. They rely on indi-\nvidual engineering skills and software support for the development process. However, \nin reality, not everyone is a highly skilled engineer, people do not communicate effec-\ntively, and it is not always possible for teams to work together. Some planning may be \nrequired to make the most effective use of the people available. Key issues are:\n1. How good are the designers and programmers in the development team? \nIt\u00a0is\u00a0sometimes argued that agile methods require higher skill levels than plan-\nbased approaches in which programmers simply translate a detailed design into \ncode. If you have a team with relatively low skill levels, you may need to use \nthe best people to develop the design, with others responsible for programming.\nSystem\nTeam\nOrganization\nScale\nTechnology\nDistribution\nContracts\nDelivery\nRegulation\nType\nLifetime\nCompetence\nCulture\nFigure 3.12 Factors \ninfluencing the choice  \nof plan-based or agile \ndevelopment"}
{"query": "How do most large \"agile\" software development projects address these challenges?", "response": "Most large \"agile\" software development projects address these challenges by combining practices from both plan-driven and agile approaches. They find a balance between a plan-based and an agile approach by considering technical, human, and organizational factors. This allows them to adapt agile methods to suit their own culture and ways of working, while still supporting longer-term plans and budgets for investment, staffing, and business development.", "context": "3.4  \u25a0 Scaling agile methods  91\n \n3.4.2  Agile and plan-driven methods\nA fundamental requirement of scaling agile methods is to integrate them with plan-\ndriven approaches. Small startup companies can work with informal and short-term \nplanning, but larger companies have to have longer-term plans and budgets for \ninvestment, staffing, and business development. Their software development must \nsupport these plans, so longer-term software planning is essential.\nEarly adopters of agile methods in the first decade of the 21st century were enthu-\nsiasts and deeply committed to the agile manifesto. They deliberately rejected the \nplan-driven approach to software engineering and were reluctant to change the ini-\ntial vision of agile methods in any way. However, as organizations saw the value and \nbenefits of an agile approach, they adapted these methods to suit their own culture \nand ways of working. They had to do this because the principles underlying agile \nmethods are sometimes difficult to realize in practice (Figure 3.11).\nTo address these problems, most large \u201cagile\u201d software development projects com-\nbine practices from plan-driven and agile approaches. Some are mostly agile, and others \nare mostly plan-driven but with some agile practices. To decide on the balance between \na plan-based and an agile approach, you have to answer a range of technical, human and \norganizational questions. These relate to the system being developed, the development \nteam, and the organizations that are developing and procuring the system (Figure 3.12).\nAgile methods were developed and refined in projects to develop small to medium-\nsized business systems and software products, where the software developer controls \nthe specification of the system. Other types of system have attributes such as size, com-\nplexity, real-time response, and external regulation that mean a \u201cpure\u201d agile approach is \nPrinciple\nPractice\nCustomer involvement\nThis depends on having a customer who is willing and able to spend time with \nthe development team and who can represent all system stakeholders. Often, \ncustomer representatives have other demands on their time and cannot play a \nfull part in the software development. Where there are external stakeholders, \nsuch as regulators, it is difficult to represent their views to the agile team.\nEmbrace change\nPrioritizing changes can be extremely difficult, especially in systems for which \nthere are many stakeholders. Typically, each stakeholder gives different \npriorities to different changes.\nIncremental delivery\nRapid iterations and short-term planning for development does not always fit \nin with the longer-term planning cycles of business planning and marketing. \nMarketing managers may need to know product features several months in \nadvance to prepare an effective marketing campaign.\nMaintain simplicity\nUnder pressure from delivery schedules, team members may not have time to \ncarry out desirable system simplifications.\nPeople, not process\nIndividual team members may not have suitable personalities for the intense \ninvolvement that is typical of agile methods and therefore may not interact \nwell with other team members.\nFigure 3.11 Agile \nprinciples and \norganizational practice\n\n\n92  Chapter 3 \u25a0 Agile software development\nunlikely to work. There needs to be some up-front planning, design, and documentation \nin the systems engineering process. Some of the key issues are as follows:\n1. \nHow large is the system that is being developed? Agile methods are most effective \nwhen the system can be developed with a relatively small co-located team who \ncan communicate informally. This may not be possible for large systems that \nrequire larger development teams, so a plan-driven approach may have to be used.\n2. What type of system is being developed? Systems that require a lot of analysis \nbefore implementation (e.g., real-time system with complex timing require-\nments) usually need a fairly detailed design to carry out this analysis. A plan-\ndriven approach may be best in those circumstances.\n3. What is the expected system lifetime? Long-lifetime systems may require more \ndesign documentation to communicate the original intentions of the system \ndevelopers to the support team. However, supporters of agile methods rightly \nargue that documentation is frequently not kept up to date and is not of much \nuse for long-term system maintenance.\n4. Is the system subject to external regulation? If a system has to be approved \nby\u00a0an external regulator (e.g., the Federal Aviation Administration approves \nsoftware that is critical to the operation of an aircraft), then you will probably be \nrequired to produce detailed documentation as part of the system safety\u00a0case.\nAgile methods place a great deal of responsibility on the development team to \ncooperate and communicate during the development of the system. They rely on indi-\nvidual engineering skills and software support for the development process. However, \nin reality, not everyone is a highly skilled engineer, people do not communicate effec-\ntively, and it is not always possible for teams to work together. Some planning may be \nrequired to make the most effective use of the people available. Key issues are:\n1. How good are the designers and programmers in the development team? \nIt\u00a0is\u00a0sometimes argued that agile methods require higher skill levels than plan-\nbased approaches in which programmers simply translate a detailed design into \ncode. If you have a team with relatively low skill levels, you may need to use \nthe best people to develop the design, with others responsible for programming.\nSystem\nTeam\nOrganization\nScale\nTechnology\nDistribution\nContracts\nDelivery\nRegulation\nType\nLifetime\nCompetence\nCulture\nFigure 3.12 Factors \ninfluencing the choice  \nof plan-based or agile \ndevelopment"}
{"query": "What factors should be considered to decide on the balance between a plan-based and an agile approach?", "response": "Factors that should be considered to decide on the balance between a plan-based and an agile approach include the size of the system being developed, the type of system being developed, the expected system lifetime, and whether the system is subject to external regulation. These factors will help determine whether a plan-driven approach or an agile approach is more suitable for the specific project.", "context": "3.4  \u25a0 Scaling agile methods  91\n \n3.4.2  Agile and plan-driven methods\nA fundamental requirement of scaling agile methods is to integrate them with plan-\ndriven approaches. Small startup companies can work with informal and short-term \nplanning, but larger companies have to have longer-term plans and budgets for \ninvestment, staffing, and business development. Their software development must \nsupport these plans, so longer-term software planning is essential.\nEarly adopters of agile methods in the first decade of the 21st century were enthu-\nsiasts and deeply committed to the agile manifesto. They deliberately rejected the \nplan-driven approach to software engineering and were reluctant to change the ini-\ntial vision of agile methods in any way. However, as organizations saw the value and \nbenefits of an agile approach, they adapted these methods to suit their own culture \nand ways of working. They had to do this because the principles underlying agile \nmethods are sometimes difficult to realize in practice (Figure 3.11).\nTo address these problems, most large \u201cagile\u201d software development projects com-\nbine practices from plan-driven and agile approaches. Some are mostly agile, and others \nare mostly plan-driven but with some agile practices. To decide on the balance between \na plan-based and an agile approach, you have to answer a range of technical, human and \norganizational questions. These relate to the system being developed, the development \nteam, and the organizations that are developing and procuring the system (Figure 3.12).\nAgile methods were developed and refined in projects to develop small to medium-\nsized business systems and software products, where the software developer controls \nthe specification of the system. Other types of system have attributes such as size, com-\nplexity, real-time response, and external regulation that mean a \u201cpure\u201d agile approach is \nPrinciple\nPractice\nCustomer involvement\nThis depends on having a customer who is willing and able to spend time with \nthe development team and who can represent all system stakeholders. Often, \ncustomer representatives have other demands on their time and cannot play a \nfull part in the software development. Where there are external stakeholders, \nsuch as regulators, it is difficult to represent their views to the agile team.\nEmbrace change\nPrioritizing changes can be extremely difficult, especially in systems for which \nthere are many stakeholders. Typically, each stakeholder gives different \npriorities to different changes.\nIncremental delivery\nRapid iterations and short-term planning for development does not always fit \nin with the longer-term planning cycles of business planning and marketing. \nMarketing managers may need to know product features several months in \nadvance to prepare an effective marketing campaign.\nMaintain simplicity\nUnder pressure from delivery schedules, team members may not have time to \ncarry out desirable system simplifications.\nPeople, not process\nIndividual team members may not have suitable personalities for the intense \ninvolvement that is typical of agile methods and therefore may not interact \nwell with other team members.\nFigure 3.11 Agile \nprinciples and \norganizational practice\n\n\n92  Chapter 3 \u25a0 Agile software development\nunlikely to work. There needs to be some up-front planning, design, and documentation \nin the systems engineering process. Some of the key issues are as follows:\n1. \nHow large is the system that is being developed? Agile methods are most effective \nwhen the system can be developed with a relatively small co-located team who \ncan communicate informally. This may not be possible for large systems that \nrequire larger development teams, so a plan-driven approach may have to be used.\n2. What type of system is being developed? Systems that require a lot of analysis \nbefore implementation (e.g., real-time system with complex timing require-\nments) usually need a fairly detailed design to carry out this analysis. A plan-\ndriven approach may be best in those circumstances.\n3. What is the expected system lifetime? Long-lifetime systems may require more \ndesign documentation to communicate the original intentions of the system \ndevelopers to the support team. However, supporters of agile methods rightly \nargue that documentation is frequently not kept up to date and is not of much \nuse for long-term system maintenance.\n4. Is the system subject to external regulation? If a system has to be approved \nby\u00a0an external regulator (e.g., the Federal Aviation Administration approves \nsoftware that is critical to the operation of an aircraft), then you will probably be \nrequired to produce detailed documentation as part of the system safety\u00a0case.\nAgile methods place a great deal of responsibility on the development team to \ncooperate and communicate during the development of the system. They rely on indi-\nvidual engineering skills and software support for the development process. However, \nin reality, not everyone is a highly skilled engineer, people do not communicate effec-\ntively, and it is not always possible for teams to work together. Some planning may be \nrequired to make the most effective use of the people available. Key issues are:\n1. How good are the designers and programmers in the development team? \nIt\u00a0is\u00a0sometimes argued that agile methods require higher skill levels than plan-\nbased approaches in which programmers simply translate a detailed design into \ncode. If you have a team with relatively low skill levels, you may need to use \nthe best people to develop the design, with others responsible for programming.\nSystem\nTeam\nOrganization\nScale\nTechnology\nDistribution\nContracts\nDelivery\nRegulation\nType\nLifetime\nCompetence\nCulture\nFigure 3.12 Factors \ninfluencing the choice  \nof plan-based or agile \ndevelopment"}
{"query": "In what types of projects were agile methods initially developed and refined?", "response": "Agile methods were initially developed and refined in projects to develop small to medium-sized business systems and software products.", "context": "3.4  \u25a0 Scaling agile methods  91\n \n3.4.2  Agile and plan-driven methods\nA fundamental requirement of scaling agile methods is to integrate them with plan-\ndriven approaches. Small startup companies can work with informal and short-term \nplanning, but larger companies have to have longer-term plans and budgets for \ninvestment, staffing, and business development. Their software development must \nsupport these plans, so longer-term software planning is essential.\nEarly adopters of agile methods in the first decade of the 21st century were enthu-\nsiasts and deeply committed to the agile manifesto. They deliberately rejected the \nplan-driven approach to software engineering and were reluctant to change the ini-\ntial vision of agile methods in any way. However, as organizations saw the value and \nbenefits of an agile approach, they adapted these methods to suit their own culture \nand ways of working. They had to do this because the principles underlying agile \nmethods are sometimes difficult to realize in practice (Figure 3.11).\nTo address these problems, most large \u201cagile\u201d software development projects com-\nbine practices from plan-driven and agile approaches. Some are mostly agile, and others \nare mostly plan-driven but with some agile practices. To decide on the balance between \na plan-based and an agile approach, you have to answer a range of technical, human and \norganizational questions. These relate to the system being developed, the development \nteam, and the organizations that are developing and procuring the system (Figure 3.12).\nAgile methods were developed and refined in projects to develop small to medium-\nsized business systems and software products, where the software developer controls \nthe specification of the system. Other types of system have attributes such as size, com-\nplexity, real-time response, and external regulation that mean a \u201cpure\u201d agile approach is \nPrinciple\nPractice\nCustomer involvement\nThis depends on having a customer who is willing and able to spend time with \nthe development team and who can represent all system stakeholders. Often, \ncustomer representatives have other demands on their time and cannot play a \nfull part in the software development. Where there are external stakeholders, \nsuch as regulators, it is difficult to represent their views to the agile team.\nEmbrace change\nPrioritizing changes can be extremely difficult, especially in systems for which \nthere are many stakeholders. Typically, each stakeholder gives different \npriorities to different changes.\nIncremental delivery\nRapid iterations and short-term planning for development does not always fit \nin with the longer-term planning cycles of business planning and marketing. \nMarketing managers may need to know product features several months in \nadvance to prepare an effective marketing campaign.\nMaintain simplicity\nUnder pressure from delivery schedules, team members may not have time to \ncarry out desirable system simplifications.\nPeople, not process\nIndividual team members may not have suitable personalities for the intense \ninvolvement that is typical of agile methods and therefore may not interact \nwell with other team members.\nFigure 3.11 Agile \nprinciples and \norganizational practice\n\n\n92  Chapter 3 \u25a0 Agile software development\nunlikely to work. There needs to be some up-front planning, design, and documentation \nin the systems engineering process. Some of the key issues are as follows:\n1. \nHow large is the system that is being developed? Agile methods are most effective \nwhen the system can be developed with a relatively small co-located team who \ncan communicate informally. This may not be possible for large systems that \nrequire larger development teams, so a plan-driven approach may have to be used.\n2. What type of system is being developed? Systems that require a lot of analysis \nbefore implementation (e.g., real-time system with complex timing require-\nments) usually need a fairly detailed design to carry out this analysis. A plan-\ndriven approach may be best in those circumstances.\n3. What is the expected system lifetime? Long-lifetime systems may require more \ndesign documentation to communicate the original intentions of the system \ndevelopers to the support team. However, supporters of agile methods rightly \nargue that documentation is frequently not kept up to date and is not of much \nuse for long-term system maintenance.\n4. Is the system subject to external regulation? If a system has to be approved \nby\u00a0an external regulator (e.g., the Federal Aviation Administration approves \nsoftware that is critical to the operation of an aircraft), then you will probably be \nrequired to produce detailed documentation as part of the system safety\u00a0case.\nAgile methods place a great deal of responsibility on the development team to \ncooperate and communicate during the development of the system. They rely on indi-\nvidual engineering skills and software support for the development process. However, \nin reality, not everyone is a highly skilled engineer, people do not communicate effec-\ntively, and it is not always possible for teams to work together. Some planning may be \nrequired to make the most effective use of the people available. Key issues are:\n1. How good are the designers and programmers in the development team? \nIt\u00a0is\u00a0sometimes argued that agile methods require higher skill levels than plan-\nbased approaches in which programmers simply translate a detailed design into \ncode. If you have a team with relatively low skill levels, you may need to use \nthe best people to develop the design, with others responsible for programming.\nSystem\nTeam\nOrganization\nScale\nTechnology\nDistribution\nContracts\nDelivery\nRegulation\nType\nLifetime\nCompetence\nCulture\nFigure 3.12 Factors \ninfluencing the choice  \nof plan-based or agile \ndevelopment"}
{"query": "Why might a \"pure\" agile approach not work for certain types of systems?", "response": "A \"pure\" agile approach may not work for certain types of systems because these systems may have attributes such as size, complexity, real-time response, and external regulation that make it difficult to realize the principles underlying agile methods in practice. For example, systems that require a lot of analysis before implementation or systems subject to external regulation may require more detailed design and documentation, which are not typically emphasized in agile methods. Additionally, long-lifetime systems may require more design documentation to communicate the original intentions of the system developers to the support team. Therefore, some up-front planning, design, and documentation may be necessary in these cases, making a \"pure\" agile approach less suitable.", "context": "3.4  \u25a0 Scaling agile methods  91\n \n3.4.2  Agile and plan-driven methods\nA fundamental requirement of scaling agile methods is to integrate them with plan-\ndriven approaches. Small startup companies can work with informal and short-term \nplanning, but larger companies have to have longer-term plans and budgets for \ninvestment, staffing, and business development. Their software development must \nsupport these plans, so longer-term software planning is essential.\nEarly adopters of agile methods in the first decade of the 21st century were enthu-\nsiasts and deeply committed to the agile manifesto. They deliberately rejected the \nplan-driven approach to software engineering and were reluctant to change the ini-\ntial vision of agile methods in any way. However, as organizations saw the value and \nbenefits of an agile approach, they adapted these methods to suit their own culture \nand ways of working. They had to do this because the principles underlying agile \nmethods are sometimes difficult to realize in practice (Figure 3.11).\nTo address these problems, most large \u201cagile\u201d software development projects com-\nbine practices from plan-driven and agile approaches. Some are mostly agile, and others \nare mostly plan-driven but with some agile practices. To decide on the balance between \na plan-based and an agile approach, you have to answer a range of technical, human and \norganizational questions. These relate to the system being developed, the development \nteam, and the organizations that are developing and procuring the system (Figure 3.12).\nAgile methods were developed and refined in projects to develop small to medium-\nsized business systems and software products, where the software developer controls \nthe specification of the system. Other types of system have attributes such as size, com-\nplexity, real-time response, and external regulation that mean a \u201cpure\u201d agile approach is \nPrinciple\nPractice\nCustomer involvement\nThis depends on having a customer who is willing and able to spend time with \nthe development team and who can represent all system stakeholders. Often, \ncustomer representatives have other demands on their time and cannot play a \nfull part in the software development. Where there are external stakeholders, \nsuch as regulators, it is difficult to represent their views to the agile team.\nEmbrace change\nPrioritizing changes can be extremely difficult, especially in systems for which \nthere are many stakeholders. Typically, each stakeholder gives different \npriorities to different changes.\nIncremental delivery\nRapid iterations and short-term planning for development does not always fit \nin with the longer-term planning cycles of business planning and marketing. \nMarketing managers may need to know product features several months in \nadvance to prepare an effective marketing campaign.\nMaintain simplicity\nUnder pressure from delivery schedules, team members may not have time to \ncarry out desirable system simplifications.\nPeople, not process\nIndividual team members may not have suitable personalities for the intense \ninvolvement that is typical of agile methods and therefore may not interact \nwell with other team members.\nFigure 3.11 Agile \nprinciples and \norganizational practice\n\n\n92  Chapter 3 \u25a0 Agile software development\nunlikely to work. There needs to be some up-front planning, design, and documentation \nin the systems engineering process. Some of the key issues are as follows:\n1. \nHow large is the system that is being developed? Agile methods are most effective \nwhen the system can be developed with a relatively small co-located team who \ncan communicate informally. This may not be possible for large systems that \nrequire larger development teams, so a plan-driven approach may have to be used.\n2. What type of system is being developed? Systems that require a lot of analysis \nbefore implementation (e.g., real-time system with complex timing require-\nments) usually need a fairly detailed design to carry out this analysis. A plan-\ndriven approach may be best in those circumstances.\n3. What is the expected system lifetime? Long-lifetime systems may require more \ndesign documentation to communicate the original intentions of the system \ndevelopers to the support team. However, supporters of agile methods rightly \nargue that documentation is frequently not kept up to date and is not of much \nuse for long-term system maintenance.\n4. Is the system subject to external regulation? If a system has to be approved \nby\u00a0an external regulator (e.g., the Federal Aviation Administration approves \nsoftware that is critical to the operation of an aircraft), then you will probably be \nrequired to produce detailed documentation as part of the system safety\u00a0case.\nAgile methods place a great deal of responsibility on the development team to \ncooperate and communicate during the development of the system. They rely on indi-\nvidual engineering skills and software support for the development process. However, \nin reality, not everyone is a highly skilled engineer, people do not communicate effec-\ntively, and it is not always possible for teams to work together. Some planning may be \nrequired to make the most effective use of the people available. Key issues are:\n1. How good are the designers and programmers in the development team? \nIt\u00a0is\u00a0sometimes argued that agile methods require higher skill levels than plan-\nbased approaches in which programmers simply translate a detailed design into \ncode. If you have a team with relatively low skill levels, you may need to use \nthe best people to develop the design, with others responsible for programming.\nSystem\nTeam\nOrganization\nScale\nTechnology\nDistribution\nContracts\nDelivery\nRegulation\nType\nLifetime\nCompetence\nCulture\nFigure 3.12 Factors \ninfluencing the choice  \nof plan-based or agile \ndevelopment"}
{"query": "What are some of the key issues to consider when deciding whether to use agile methods or a plan-driven approach?", "response": "The key issues to consider when deciding whether to use agile methods or a plan-driven approach include the size of the system being developed, the type of system being developed, the expected system lifetime, and whether the system is subject to external regulation. These factors can influence the effectiveness and feasibility of using agile methods, as larger systems may require larger development teams and more formal planning, while systems that require extensive analysis or are subject to external regulation may benefit from a plan-driven approach. Additionally, the expected system lifetime and the need for documentation to communicate the original intentions of the system developers may also impact the choice between agile methods and a plan-driven approach.", "context": "3.4  \u25a0 Scaling agile methods  91\n \n3.4.2  Agile and plan-driven methods\nA fundamental requirement of scaling agile methods is to integrate them with plan-\ndriven approaches. Small startup companies can work with informal and short-term \nplanning, but larger companies have to have longer-term plans and budgets for \ninvestment, staffing, and business development. Their software development must \nsupport these plans, so longer-term software planning is essential.\nEarly adopters of agile methods in the first decade of the 21st century were enthu-\nsiasts and deeply committed to the agile manifesto. They deliberately rejected the \nplan-driven approach to software engineering and were reluctant to change the ini-\ntial vision of agile methods in any way. However, as organizations saw the value and \nbenefits of an agile approach, they adapted these methods to suit their own culture \nand ways of working. They had to do this because the principles underlying agile \nmethods are sometimes difficult to realize in practice (Figure 3.11).\nTo address these problems, most large \u201cagile\u201d software development projects com-\nbine practices from plan-driven and agile approaches. Some are mostly agile, and others \nare mostly plan-driven but with some agile practices. To decide on the balance between \na plan-based and an agile approach, you have to answer a range of technical, human and \norganizational questions. These relate to the system being developed, the development \nteam, and the organizations that are developing and procuring the system (Figure 3.12).\nAgile methods were developed and refined in projects to develop small to medium-\nsized business systems and software products, where the software developer controls \nthe specification of the system. Other types of system have attributes such as size, com-\nplexity, real-time response, and external regulation that mean a \u201cpure\u201d agile approach is \nPrinciple\nPractice\nCustomer involvement\nThis depends on having a customer who is willing and able to spend time with \nthe development team and who can represent all system stakeholders. Often, \ncustomer representatives have other demands on their time and cannot play a \nfull part in the software development. Where there are external stakeholders, \nsuch as regulators, it is difficult to represent their views to the agile team.\nEmbrace change\nPrioritizing changes can be extremely difficult, especially in systems for which \nthere are many stakeholders. Typically, each stakeholder gives different \npriorities to different changes.\nIncremental delivery\nRapid iterations and short-term planning for development does not always fit \nin with the longer-term planning cycles of business planning and marketing. \nMarketing managers may need to know product features several months in \nadvance to prepare an effective marketing campaign.\nMaintain simplicity\nUnder pressure from delivery schedules, team members may not have time to \ncarry out desirable system simplifications.\nPeople, not process\nIndividual team members may not have suitable personalities for the intense \ninvolvement that is typical of agile methods and therefore may not interact \nwell with other team members.\nFigure 3.11 Agile \nprinciples and \norganizational practice\n\n\n92  Chapter 3 \u25a0 Agile software development\nunlikely to work. There needs to be some up-front planning, design, and documentation \nin the systems engineering process. Some of the key issues are as follows:\n1. \nHow large is the system that is being developed? Agile methods are most effective \nwhen the system can be developed with a relatively small co-located team who \ncan communicate informally. This may not be possible for large systems that \nrequire larger development teams, so a plan-driven approach may have to be used.\n2. What type of system is being developed? Systems that require a lot of analysis \nbefore implementation (e.g., real-time system with complex timing require-\nments) usually need a fairly detailed design to carry out this analysis. A plan-\ndriven approach may be best in those circumstances.\n3. What is the expected system lifetime? Long-lifetime systems may require more \ndesign documentation to communicate the original intentions of the system \ndevelopers to the support team. However, supporters of agile methods rightly \nargue that documentation is frequently not kept up to date and is not of much \nuse for long-term system maintenance.\n4. Is the system subject to external regulation? If a system has to be approved \nby\u00a0an external regulator (e.g., the Federal Aviation Administration approves \nsoftware that is critical to the operation of an aircraft), then you will probably be \nrequired to produce detailed documentation as part of the system safety\u00a0case.\nAgile methods place a great deal of responsibility on the development team to \ncooperate and communicate during the development of the system. They rely on indi-\nvidual engineering skills and software support for the development process. However, \nin reality, not everyone is a highly skilled engineer, people do not communicate effec-\ntively, and it is not always possible for teams to work together. Some planning may be \nrequired to make the most effective use of the people available. Key issues are:\n1. How good are the designers and programmers in the development team? \nIt\u00a0is\u00a0sometimes argued that agile methods require higher skill levels than plan-\nbased approaches in which programmers simply translate a detailed design into \ncode. If you have a team with relatively low skill levels, you may need to use \nthe best people to develop the design, with others responsible for programming.\nSystem\nTeam\nOrganization\nScale\nTechnology\nDistribution\nContracts\nDelivery\nRegulation\nType\nLifetime\nCompetence\nCulture\nFigure 3.12 Factors \ninfluencing the choice  \nof plan-based or agile \ndevelopment"}
{"query": "How does the size of the system being developed impact the effectiveness of agile methods?", "response": "The effectiveness of agile methods can be impacted by the size of the system being developed. Agile methods are most effective when the system can be developed with a relatively small co-located team who can communicate informally. However, for larger systems that require larger development teams, a plan-driven approach may be more suitable.", "context": "3.4  \u25a0 Scaling agile methods  91\n \n3.4.2  Agile and plan-driven methods\nA fundamental requirement of scaling agile methods is to integrate them with plan-\ndriven approaches. Small startup companies can work with informal and short-term \nplanning, but larger companies have to have longer-term plans and budgets for \ninvestment, staffing, and business development. Their software development must \nsupport these plans, so longer-term software planning is essential.\nEarly adopters of agile methods in the first decade of the 21st century were enthu-\nsiasts and deeply committed to the agile manifesto. They deliberately rejected the \nplan-driven approach to software engineering and were reluctant to change the ini-\ntial vision of agile methods in any way. However, as organizations saw the value and \nbenefits of an agile approach, they adapted these methods to suit their own culture \nand ways of working. They had to do this because the principles underlying agile \nmethods are sometimes difficult to realize in practice (Figure 3.11).\nTo address these problems, most large \u201cagile\u201d software development projects com-\nbine practices from plan-driven and agile approaches. Some are mostly agile, and others \nare mostly plan-driven but with some agile practices. To decide on the balance between \na plan-based and an agile approach, you have to answer a range of technical, human and \norganizational questions. These relate to the system being developed, the development \nteam, and the organizations that are developing and procuring the system (Figure 3.12).\nAgile methods were developed and refined in projects to develop small to medium-\nsized business systems and software products, where the software developer controls \nthe specification of the system. Other types of system have attributes such as size, com-\nplexity, real-time response, and external regulation that mean a \u201cpure\u201d agile approach is \nPrinciple\nPractice\nCustomer involvement\nThis depends on having a customer who is willing and able to spend time with \nthe development team and who can represent all system stakeholders. Often, \ncustomer representatives have other demands on their time and cannot play a \nfull part in the software development. Where there are external stakeholders, \nsuch as regulators, it is difficult to represent their views to the agile team.\nEmbrace change\nPrioritizing changes can be extremely difficult, especially in systems for which \nthere are many stakeholders. Typically, each stakeholder gives different \npriorities to different changes.\nIncremental delivery\nRapid iterations and short-term planning for development does not always fit \nin with the longer-term planning cycles of business planning and marketing. \nMarketing managers may need to know product features several months in \nadvance to prepare an effective marketing campaign.\nMaintain simplicity\nUnder pressure from delivery schedules, team members may not have time to \ncarry out desirable system simplifications.\nPeople, not process\nIndividual team members may not have suitable personalities for the intense \ninvolvement that is typical of agile methods and therefore may not interact \nwell with other team members.\nFigure 3.11 Agile \nprinciples and \norganizational practice\n\n\n92  Chapter 3 \u25a0 Agile software development\nunlikely to work. There needs to be some up-front planning, design, and documentation \nin the systems engineering process. Some of the key issues are as follows:\n1. \nHow large is the system that is being developed? Agile methods are most effective \nwhen the system can be developed with a relatively small co-located team who \ncan communicate informally. This may not be possible for large systems that \nrequire larger development teams, so a plan-driven approach may have to be used.\n2. What type of system is being developed? Systems that require a lot of analysis \nbefore implementation (e.g., real-time system with complex timing require-\nments) usually need a fairly detailed design to carry out this analysis. A plan-\ndriven approach may be best in those circumstances.\n3. What is the expected system lifetime? Long-lifetime systems may require more \ndesign documentation to communicate the original intentions of the system \ndevelopers to the support team. However, supporters of agile methods rightly \nargue that documentation is frequently not kept up to date and is not of much \nuse for long-term system maintenance.\n4. Is the system subject to external regulation? If a system has to be approved \nby\u00a0an external regulator (e.g., the Federal Aviation Administration approves \nsoftware that is critical to the operation of an aircraft), then you will probably be \nrequired to produce detailed documentation as part of the system safety\u00a0case.\nAgile methods place a great deal of responsibility on the development team to \ncooperate and communicate during the development of the system. They rely on indi-\nvidual engineering skills and software support for the development process. However, \nin reality, not everyone is a highly skilled engineer, people do not communicate effec-\ntively, and it is not always possible for teams to work together. Some planning may be \nrequired to make the most effective use of the people available. Key issues are:\n1. How good are the designers and programmers in the development team? \nIt\u00a0is\u00a0sometimes argued that agile methods require higher skill levels than plan-\nbased approaches in which programmers simply translate a detailed design into \ncode. If you have a team with relatively low skill levels, you may need to use \nthe best people to develop the design, with others responsible for programming.\nSystem\nTeam\nOrganization\nScale\nTechnology\nDistribution\nContracts\nDelivery\nRegulation\nType\nLifetime\nCompetence\nCulture\nFigure 3.12 Factors \ninfluencing the choice  \nof plan-based or agile \ndevelopment"}
{"query": "Why might a plan-driven approach be best for systems that require a lot of analysis before implementation?", "response": "A plan-driven approach might be best for systems that require a lot of analysis before implementation because a plan-driven approach typically involves more detailed design and documentation. Systems that require extensive analysis, such as real-time systems with complex timing requirements, often need a detailed design to carry out this analysis effectively. Therefore, a plan-driven approach can provide the necessary structure and documentation to support the analysis and design process in these types of systems.", "context": "3.4  \u25a0 Scaling agile methods  91\n \n3.4.2  Agile and plan-driven methods\nA fundamental requirement of scaling agile methods is to integrate them with plan-\ndriven approaches. Small startup companies can work with informal and short-term \nplanning, but larger companies have to have longer-term plans and budgets for \ninvestment, staffing, and business development. Their software development must \nsupport these plans, so longer-term software planning is essential.\nEarly adopters of agile methods in the first decade of the 21st century were enthu-\nsiasts and deeply committed to the agile manifesto. They deliberately rejected the \nplan-driven approach to software engineering and were reluctant to change the ini-\ntial vision of agile methods in any way. However, as organizations saw the value and \nbenefits of an agile approach, they adapted these methods to suit their own culture \nand ways of working. They had to do this because the principles underlying agile \nmethods are sometimes difficult to realize in practice (Figure 3.11).\nTo address these problems, most large \u201cagile\u201d software development projects com-\nbine practices from plan-driven and agile approaches. Some are mostly agile, and others \nare mostly plan-driven but with some agile practices. To decide on the balance between \na plan-based and an agile approach, you have to answer a range of technical, human and \norganizational questions. These relate to the system being developed, the development \nteam, and the organizations that are developing and procuring the system (Figure 3.12).\nAgile methods were developed and refined in projects to develop small to medium-\nsized business systems and software products, where the software developer controls \nthe specification of the system. Other types of system have attributes such as size, com-\nplexity, real-time response, and external regulation that mean a \u201cpure\u201d agile approach is \nPrinciple\nPractice\nCustomer involvement\nThis depends on having a customer who is willing and able to spend time with \nthe development team and who can represent all system stakeholders. Often, \ncustomer representatives have other demands on their time and cannot play a \nfull part in the software development. Where there are external stakeholders, \nsuch as regulators, it is difficult to represent their views to the agile team.\nEmbrace change\nPrioritizing changes can be extremely difficult, especially in systems for which \nthere are many stakeholders. Typically, each stakeholder gives different \npriorities to different changes.\nIncremental delivery\nRapid iterations and short-term planning for development does not always fit \nin with the longer-term planning cycles of business planning and marketing. \nMarketing managers may need to know product features several months in \nadvance to prepare an effective marketing campaign.\nMaintain simplicity\nUnder pressure from delivery schedules, team members may not have time to \ncarry out desirable system simplifications.\nPeople, not process\nIndividual team members may not have suitable personalities for the intense \ninvolvement that is typical of agile methods and therefore may not interact \nwell with other team members.\nFigure 3.11 Agile \nprinciples and \norganizational practice\n\n\n92  Chapter 3 \u25a0 Agile software development\nunlikely to work. There needs to be some up-front planning, design, and documentation \nin the systems engineering process. Some of the key issues are as follows:\n1. \nHow large is the system that is being developed? Agile methods are most effective \nwhen the system can be developed with a relatively small co-located team who \ncan communicate informally. This may not be possible for large systems that \nrequire larger development teams, so a plan-driven approach may have to be used.\n2. What type of system is being developed? Systems that require a lot of analysis \nbefore implementation (e.g., real-time system with complex timing require-\nments) usually need a fairly detailed design to carry out this analysis. A plan-\ndriven approach may be best in those circumstances.\n3. What is the expected system lifetime? Long-lifetime systems may require more \ndesign documentation to communicate the original intentions of the system \ndevelopers to the support team. However, supporters of agile methods rightly \nargue that documentation is frequently not kept up to date and is not of much \nuse for long-term system maintenance.\n4. Is the system subject to external regulation? If a system has to be approved \nby\u00a0an external regulator (e.g., the Federal Aviation Administration approves \nsoftware that is critical to the operation of an aircraft), then you will probably be \nrequired to produce detailed documentation as part of the system safety\u00a0case.\nAgile methods place a great deal of responsibility on the development team to \ncooperate and communicate during the development of the system. They rely on indi-\nvidual engineering skills and software support for the development process. However, \nin reality, not everyone is a highly skilled engineer, people do not communicate effec-\ntively, and it is not always possible for teams to work together. Some planning may be \nrequired to make the most effective use of the people available. Key issues are:\n1. How good are the designers and programmers in the development team? \nIt\u00a0is\u00a0sometimes argued that agile methods require higher skill levels than plan-\nbased approaches in which programmers simply translate a detailed design into \ncode. If you have a team with relatively low skill levels, you may need to use \nthe best people to develop the design, with others responsible for programming.\nSystem\nTeam\nOrganization\nScale\nTechnology\nDistribution\nContracts\nDelivery\nRegulation\nType\nLifetime\nCompetence\nCulture\nFigure 3.12 Factors \ninfluencing the choice  \nof plan-based or agile \ndevelopment"}
{"query": "How does the expected system lifetime impact the choice between agile methods and a plan-driven approach?", "response": "The expected system lifetime can impact the choice between agile methods and a plan-driven approach. Long-lifetime systems may require more design documentation to communicate the original intentions of the system developers to the support team. However, supporters of agile methods argue that documentation is often not kept up to date and is not very useful for long-term system maintenance. Therefore, if the system is expected to have a long lifetime, a plan-driven approach may be more suitable.", "context": "3.4  \u25a0 Scaling agile methods  91\n \n3.4.2  Agile and plan-driven methods\nA fundamental requirement of scaling agile methods is to integrate them with plan-\ndriven approaches. Small startup companies can work with informal and short-term \nplanning, but larger companies have to have longer-term plans and budgets for \ninvestment, staffing, and business development. Their software development must \nsupport these plans, so longer-term software planning is essential.\nEarly adopters of agile methods in the first decade of the 21st century were enthu-\nsiasts and deeply committed to the agile manifesto. They deliberately rejected the \nplan-driven approach to software engineering and were reluctant to change the ini-\ntial vision of agile methods in any way. However, as organizations saw the value and \nbenefits of an agile approach, they adapted these methods to suit their own culture \nand ways of working. They had to do this because the principles underlying agile \nmethods are sometimes difficult to realize in practice (Figure 3.11).\nTo address these problems, most large \u201cagile\u201d software development projects com-\nbine practices from plan-driven and agile approaches. Some are mostly agile, and others \nare mostly plan-driven but with some agile practices. To decide on the balance between \na plan-based and an agile approach, you have to answer a range of technical, human and \norganizational questions. These relate to the system being developed, the development \nteam, and the organizations that are developing and procuring the system (Figure 3.12).\nAgile methods were developed and refined in projects to develop small to medium-\nsized business systems and software products, where the software developer controls \nthe specification of the system. Other types of system have attributes such as size, com-\nplexity, real-time response, and external regulation that mean a \u201cpure\u201d agile approach is \nPrinciple\nPractice\nCustomer involvement\nThis depends on having a customer who is willing and able to spend time with \nthe development team and who can represent all system stakeholders. Often, \ncustomer representatives have other demands on their time and cannot play a \nfull part in the software development. Where there are external stakeholders, \nsuch as regulators, it is difficult to represent their views to the agile team.\nEmbrace change\nPrioritizing changes can be extremely difficult, especially in systems for which \nthere are many stakeholders. Typically, each stakeholder gives different \npriorities to different changes.\nIncremental delivery\nRapid iterations and short-term planning for development does not always fit \nin with the longer-term planning cycles of business planning and marketing. \nMarketing managers may need to know product features several months in \nadvance to prepare an effective marketing campaign.\nMaintain simplicity\nUnder pressure from delivery schedules, team members may not have time to \ncarry out desirable system simplifications.\nPeople, not process\nIndividual team members may not have suitable personalities for the intense \ninvolvement that is typical of agile methods and therefore may not interact \nwell with other team members.\nFigure 3.11 Agile \nprinciples and \norganizational practice\n\n\n92  Chapter 3 \u25a0 Agile software development\nunlikely to work. There needs to be some up-front planning, design, and documentation \nin the systems engineering process. Some of the key issues are as follows:\n1. \nHow large is the system that is being developed? Agile methods are most effective \nwhen the system can be developed with a relatively small co-located team who \ncan communicate informally. This may not be possible for large systems that \nrequire larger development teams, so a plan-driven approach may have to be used.\n2. What type of system is being developed? Systems that require a lot of analysis \nbefore implementation (e.g., real-time system with complex timing require-\nments) usually need a fairly detailed design to carry out this analysis. A plan-\ndriven approach may be best in those circumstances.\n3. What is the expected system lifetime? Long-lifetime systems may require more \ndesign documentation to communicate the original intentions of the system \ndevelopers to the support team. However, supporters of agile methods rightly \nargue that documentation is frequently not kept up to date and is not of much \nuse for long-term system maintenance.\n4. Is the system subject to external regulation? If a system has to be approved \nby\u00a0an external regulator (e.g., the Federal Aviation Administration approves \nsoftware that is critical to the operation of an aircraft), then you will probably be \nrequired to produce detailed documentation as part of the system safety\u00a0case.\nAgile methods place a great deal of responsibility on the development team to \ncooperate and communicate during the development of the system. They rely on indi-\nvidual engineering skills and software support for the development process. However, \nin reality, not everyone is a highly skilled engineer, people do not communicate effec-\ntively, and it is not always possible for teams to work together. Some planning may be \nrequired to make the most effective use of the people available. Key issues are:\n1. How good are the designers and programmers in the development team? \nIt\u00a0is\u00a0sometimes argued that agile methods require higher skill levels than plan-\nbased approaches in which programmers simply translate a detailed design into \ncode. If you have a team with relatively low skill levels, you may need to use \nthe best people to develop the design, with others responsible for programming.\nSystem\nTeam\nOrganization\nScale\nTechnology\nDistribution\nContracts\nDelivery\nRegulation\nType\nLifetime\nCompetence\nCulture\nFigure 3.12 Factors \ninfluencing the choice  \nof plan-based or agile \ndevelopment"}
{"query": "Why might external regulation necessitate a plan-driven approach?", "response": "External regulation might necessitate a plan-driven approach because when a system is subject to external regulation, such as approval from a regulatory body, detailed documentation is often required as part of the system safety case. This documentation helps to demonstrate compliance with the regulatory requirements and ensure the system's safety and reliability. A plan-driven approach typically involves more upfront planning, design, and documentation, which can help meet the regulatory requirements and provide the necessary evidence for approval.", "context": "3.4  \u25a0 Scaling agile methods  91\n \n3.4.2  Agile and plan-driven methods\nA fundamental requirement of scaling agile methods is to integrate them with plan-\ndriven approaches. Small startup companies can work with informal and short-term \nplanning, but larger companies have to have longer-term plans and budgets for \ninvestment, staffing, and business development. Their software development must \nsupport these plans, so longer-term software planning is essential.\nEarly adopters of agile methods in the first decade of the 21st century were enthu-\nsiasts and deeply committed to the agile manifesto. They deliberately rejected the \nplan-driven approach to software engineering and were reluctant to change the ini-\ntial vision of agile methods in any way. However, as organizations saw the value and \nbenefits of an agile approach, they adapted these methods to suit their own culture \nand ways of working. They had to do this because the principles underlying agile \nmethods are sometimes difficult to realize in practice (Figure 3.11).\nTo address these problems, most large \u201cagile\u201d software development projects com-\nbine practices from plan-driven and agile approaches. Some are mostly agile, and others \nare mostly plan-driven but with some agile practices. To decide on the balance between \na plan-based and an agile approach, you have to answer a range of technical, human and \norganizational questions. These relate to the system being developed, the development \nteam, and the organizations that are developing and procuring the system (Figure 3.12).\nAgile methods were developed and refined in projects to develop small to medium-\nsized business systems and software products, where the software developer controls \nthe specification of the system. Other types of system have attributes such as size, com-\nplexity, real-time response, and external regulation that mean a \u201cpure\u201d agile approach is \nPrinciple\nPractice\nCustomer involvement\nThis depends on having a customer who is willing and able to spend time with \nthe development team and who can represent all system stakeholders. Often, \ncustomer representatives have other demands on their time and cannot play a \nfull part in the software development. Where there are external stakeholders, \nsuch as regulators, it is difficult to represent their views to the agile team.\nEmbrace change\nPrioritizing changes can be extremely difficult, especially in systems for which \nthere are many stakeholders. Typically, each stakeholder gives different \npriorities to different changes.\nIncremental delivery\nRapid iterations and short-term planning for development does not always fit \nin with the longer-term planning cycles of business planning and marketing. \nMarketing managers may need to know product features several months in \nadvance to prepare an effective marketing campaign.\nMaintain simplicity\nUnder pressure from delivery schedules, team members may not have time to \ncarry out desirable system simplifications.\nPeople, not process\nIndividual team members may not have suitable personalities for the intense \ninvolvement that is typical of agile methods and therefore may not interact \nwell with other team members.\nFigure 3.11 Agile \nprinciples and \norganizational practice\n\n\n92  Chapter 3 \u25a0 Agile software development\nunlikely to work. There needs to be some up-front planning, design, and documentation \nin the systems engineering process. Some of the key issues are as follows:\n1. \nHow large is the system that is being developed? Agile methods are most effective \nwhen the system can be developed with a relatively small co-located team who \ncan communicate informally. This may not be possible for large systems that \nrequire larger development teams, so a plan-driven approach may have to be used.\n2. What type of system is being developed? Systems that require a lot of analysis \nbefore implementation (e.g., real-time system with complex timing require-\nments) usually need a fairly detailed design to carry out this analysis. A plan-\ndriven approach may be best in those circumstances.\n3. What is the expected system lifetime? Long-lifetime systems may require more \ndesign documentation to communicate the original intentions of the system \ndevelopers to the support team. However, supporters of agile methods rightly \nargue that documentation is frequently not kept up to date and is not of much \nuse for long-term system maintenance.\n4. Is the system subject to external regulation? If a system has to be approved \nby\u00a0an external regulator (e.g., the Federal Aviation Administration approves \nsoftware that is critical to the operation of an aircraft), then you will probably be \nrequired to produce detailed documentation as part of the system safety\u00a0case.\nAgile methods place a great deal of responsibility on the development team to \ncooperate and communicate during the development of the system. They rely on indi-\nvidual engineering skills and software support for the development process. However, \nin reality, not everyone is a highly skilled engineer, people do not communicate effec-\ntively, and it is not always possible for teams to work together. Some planning may be \nrequired to make the most effective use of the people available. Key issues are:\n1. How good are the designers and programmers in the development team? \nIt\u00a0is\u00a0sometimes argued that agile methods require higher skill levels than plan-\nbased approaches in which programmers simply translate a detailed design into \ncode. If you have a team with relatively low skill levels, you may need to use \nthe best people to develop the design, with others responsible for programming.\nSystem\nTeam\nOrganization\nScale\nTechnology\nDistribution\nContracts\nDelivery\nRegulation\nType\nLifetime\nCompetence\nCulture\nFigure 3.12 Factors \ninfluencing the choice  \nof plan-based or agile \ndevelopment"}
{"query": "What responsibilities do agile methods place on the development team?", "response": "Agile methods place a great deal of responsibility on the development team to cooperate and communicate during the development of the system. They rely on individual engineering skills and software support for the development process. However, in reality, not everyone is a highly skilled engineer, people do not communicate effectively, and it is not always possible for teams to work together. Some planning may be required to make the most effective use of the people available.", "context": "3.4  \u25a0 Scaling agile methods  91\n \n3.4.2  Agile and plan-driven methods\nA fundamental requirement of scaling agile methods is to integrate them with plan-\ndriven approaches. Small startup companies can work with informal and short-term \nplanning, but larger companies have to have longer-term plans and budgets for \ninvestment, staffing, and business development. Their software development must \nsupport these plans, so longer-term software planning is essential.\nEarly adopters of agile methods in the first decade of the 21st century were enthu-\nsiasts and deeply committed to the agile manifesto. They deliberately rejected the \nplan-driven approach to software engineering and were reluctant to change the ini-\ntial vision of agile methods in any way. However, as organizations saw the value and \nbenefits of an agile approach, they adapted these methods to suit their own culture \nand ways of working. They had to do this because the principles underlying agile \nmethods are sometimes difficult to realize in practice (Figure 3.11).\nTo address these problems, most large \u201cagile\u201d software development projects com-\nbine practices from plan-driven and agile approaches. Some are mostly agile, and others \nare mostly plan-driven but with some agile practices. To decide on the balance between \na plan-based and an agile approach, you have to answer a range of technical, human and \norganizational questions. These relate to the system being developed, the development \nteam, and the organizations that are developing and procuring the system (Figure 3.12).\nAgile methods were developed and refined in projects to develop small to medium-\nsized business systems and software products, where the software developer controls \nthe specification of the system. Other types of system have attributes such as size, com-\nplexity, real-time response, and external regulation that mean a \u201cpure\u201d agile approach is \nPrinciple\nPractice\nCustomer involvement\nThis depends on having a customer who is willing and able to spend time with \nthe development team and who can represent all system stakeholders. Often, \ncustomer representatives have other demands on their time and cannot play a \nfull part in the software development. Where there are external stakeholders, \nsuch as regulators, it is difficult to represent their views to the agile team.\nEmbrace change\nPrioritizing changes can be extremely difficult, especially in systems for which \nthere are many stakeholders. Typically, each stakeholder gives different \npriorities to different changes.\nIncremental delivery\nRapid iterations and short-term planning for development does not always fit \nin with the longer-term planning cycles of business planning and marketing. \nMarketing managers may need to know product features several months in \nadvance to prepare an effective marketing campaign.\nMaintain simplicity\nUnder pressure from delivery schedules, team members may not have time to \ncarry out desirable system simplifications.\nPeople, not process\nIndividual team members may not have suitable personalities for the intense \ninvolvement that is typical of agile methods and therefore may not interact \nwell with other team members.\nFigure 3.11 Agile \nprinciples and \norganizational practice\n\n\n92  Chapter 3 \u25a0 Agile software development\nunlikely to work. There needs to be some up-front planning, design, and documentation \nin the systems engineering process. Some of the key issues are as follows:\n1. \nHow large is the system that is being developed? Agile methods are most effective \nwhen the system can be developed with a relatively small co-located team who \ncan communicate informally. This may not be possible for large systems that \nrequire larger development teams, so a plan-driven approach may have to be used.\n2. What type of system is being developed? Systems that require a lot of analysis \nbefore implementation (e.g., real-time system with complex timing require-\nments) usually need a fairly detailed design to carry out this analysis. A plan-\ndriven approach may be best in those circumstances.\n3. What is the expected system lifetime? Long-lifetime systems may require more \ndesign documentation to communicate the original intentions of the system \ndevelopers to the support team. However, supporters of agile methods rightly \nargue that documentation is frequently not kept up to date and is not of much \nuse for long-term system maintenance.\n4. Is the system subject to external regulation? If a system has to be approved \nby\u00a0an external regulator (e.g., the Federal Aviation Administration approves \nsoftware that is critical to the operation of an aircraft), then you will probably be \nrequired to produce detailed documentation as part of the system safety\u00a0case.\nAgile methods place a great deal of responsibility on the development team to \ncooperate and communicate during the development of the system. They rely on indi-\nvidual engineering skills and software support for the development process. However, \nin reality, not everyone is a highly skilled engineer, people do not communicate effec-\ntively, and it is not always possible for teams to work together. Some planning may be \nrequired to make the most effective use of the people available. Key issues are:\n1. How good are the designers and programmers in the development team? \nIt\u00a0is\u00a0sometimes argued that agile methods require higher skill levels than plan-\nbased approaches in which programmers simply translate a detailed design into \ncode. If you have a team with relatively low skill levels, you may need to use \nthe best people to develop the design, with others responsible for programming.\nSystem\nTeam\nOrganization\nScale\nTechnology\nDistribution\nContracts\nDelivery\nRegulation\nType\nLifetime\nCompetence\nCulture\nFigure 3.12 Factors \ninfluencing the choice  \nof plan-based or agile \ndevelopment"}
{"query": "Why might some planning be required even when using agile methods?", "response": "Planning may be required even when using agile methods because not everyone in the development team may be highly skilled engineers, effective communication may not always be possible, and teams may not always be able to work together seamlessly. In such cases, some level of planning may be necessary to ensure the most effective use of the available resources and to address any skill gaps within the team.", "context": "3.4  \u25a0 Scaling agile methods  91\n \n3.4.2  Agile and plan-driven methods\nA fundamental requirement of scaling agile methods is to integrate them with plan-\ndriven approaches. Small startup companies can work with informal and short-term \nplanning, but larger companies have to have longer-term plans and budgets for \ninvestment, staffing, and business development. Their software development must \nsupport these plans, so longer-term software planning is essential.\nEarly adopters of agile methods in the first decade of the 21st century were enthu-\nsiasts and deeply committed to the agile manifesto. They deliberately rejected the \nplan-driven approach to software engineering and were reluctant to change the ini-\ntial vision of agile methods in any way. However, as organizations saw the value and \nbenefits of an agile approach, they adapted these methods to suit their own culture \nand ways of working. They had to do this because the principles underlying agile \nmethods are sometimes difficult to realize in practice (Figure 3.11).\nTo address these problems, most large \u201cagile\u201d software development projects com-\nbine practices from plan-driven and agile approaches. Some are mostly agile, and others \nare mostly plan-driven but with some agile practices. To decide on the balance between \na plan-based and an agile approach, you have to answer a range of technical, human and \norganizational questions. These relate to the system being developed, the development \nteam, and the organizations that are developing and procuring the system (Figure 3.12).\nAgile methods were developed and refined in projects to develop small to medium-\nsized business systems and software products, where the software developer controls \nthe specification of the system. Other types of system have attributes such as size, com-\nplexity, real-time response, and external regulation that mean a \u201cpure\u201d agile approach is \nPrinciple\nPractice\nCustomer involvement\nThis depends on having a customer who is willing and able to spend time with \nthe development team and who can represent all system stakeholders. Often, \ncustomer representatives have other demands on their time and cannot play a \nfull part in the software development. Where there are external stakeholders, \nsuch as regulators, it is difficult to represent their views to the agile team.\nEmbrace change\nPrioritizing changes can be extremely difficult, especially in systems for which \nthere are many stakeholders. Typically, each stakeholder gives different \npriorities to different changes.\nIncremental delivery\nRapid iterations and short-term planning for development does not always fit \nin with the longer-term planning cycles of business planning and marketing. \nMarketing managers may need to know product features several months in \nadvance to prepare an effective marketing campaign.\nMaintain simplicity\nUnder pressure from delivery schedules, team members may not have time to \ncarry out desirable system simplifications.\nPeople, not process\nIndividual team members may not have suitable personalities for the intense \ninvolvement that is typical of agile methods and therefore may not interact \nwell with other team members.\nFigure 3.11 Agile \nprinciples and \norganizational practice\n\n\n92  Chapter 3 \u25a0 Agile software development\nunlikely to work. There needs to be some up-front planning, design, and documentation \nin the systems engineering process. Some of the key issues are as follows:\n1. \nHow large is the system that is being developed? Agile methods are most effective \nwhen the system can be developed with a relatively small co-located team who \ncan communicate informally. This may not be possible for large systems that \nrequire larger development teams, so a plan-driven approach may have to be used.\n2. What type of system is being developed? Systems that require a lot of analysis \nbefore implementation (e.g., real-time system with complex timing require-\nments) usually need a fairly detailed design to carry out this analysis. A plan-\ndriven approach may be best in those circumstances.\n3. What is the expected system lifetime? Long-lifetime systems may require more \ndesign documentation to communicate the original intentions of the system \ndevelopers to the support team. However, supporters of agile methods rightly \nargue that documentation is frequently not kept up to date and is not of much \nuse for long-term system maintenance.\n4. Is the system subject to external regulation? If a system has to be approved \nby\u00a0an external regulator (e.g., the Federal Aviation Administration approves \nsoftware that is critical to the operation of an aircraft), then you will probably be \nrequired to produce detailed documentation as part of the system safety\u00a0case.\nAgile methods place a great deal of responsibility on the development team to \ncooperate and communicate during the development of the system. They rely on indi-\nvidual engineering skills and software support for the development process. However, \nin reality, not everyone is a highly skilled engineer, people do not communicate effec-\ntively, and it is not always possible for teams to work together. Some planning may be \nrequired to make the most effective use of the people available. Key issues are:\n1. How good are the designers and programmers in the development team? \nIt\u00a0is\u00a0sometimes argued that agile methods require higher skill levels than plan-\nbased approaches in which programmers simply translate a detailed design into \ncode. If you have a team with relatively low skill levels, you may need to use \nthe best people to develop the design, with others responsible for programming.\nSystem\nTeam\nOrganization\nScale\nTechnology\nDistribution\nContracts\nDelivery\nRegulation\nType\nLifetime\nCompetence\nCulture\nFigure 3.12 Factors \ninfluencing the choice  \nof plan-based or agile \ndevelopment"}
{"query": "How do the skills of the designers and programmers in the development team influence the choice of development approach?", "response": "The skills of the designers and programmers in the development team can influence the choice of development approach. It is sometimes argued that agile methods require higher skill levels than plan-based approaches, where programmers simply translate a detailed design into code. If the team has designers and programmers with relatively low skill levels, it may be necessary to use the best people to develop the design, with others responsible for programming. This suggests that the skill level of the team members can impact whether an agile or plan-based approach is more suitable for the development process.", "context": "3.4  \u25a0 Scaling agile methods  91\n \n3.4.2  Agile and plan-driven methods\nA fundamental requirement of scaling agile methods is to integrate them with plan-\ndriven approaches. Small startup companies can work with informal and short-term \nplanning, but larger companies have to have longer-term plans and budgets for \ninvestment, staffing, and business development. Their software development must \nsupport these plans, so longer-term software planning is essential.\nEarly adopters of agile methods in the first decade of the 21st century were enthu-\nsiasts and deeply committed to the agile manifesto. They deliberately rejected the \nplan-driven approach to software engineering and were reluctant to change the ini-\ntial vision of agile methods in any way. However, as organizations saw the value and \nbenefits of an agile approach, they adapted these methods to suit their own culture \nand ways of working. They had to do this because the principles underlying agile \nmethods are sometimes difficult to realize in practice (Figure 3.11).\nTo address these problems, most large \u201cagile\u201d software development projects com-\nbine practices from plan-driven and agile approaches. Some are mostly agile, and others \nare mostly plan-driven but with some agile practices. To decide on the balance between \na plan-based and an agile approach, you have to answer a range of technical, human and \norganizational questions. These relate to the system being developed, the development \nteam, and the organizations that are developing and procuring the system (Figure 3.12).\nAgile methods were developed and refined in projects to develop small to medium-\nsized business systems and software products, where the software developer controls \nthe specification of the system. Other types of system have attributes such as size, com-\nplexity, real-time response, and external regulation that mean a \u201cpure\u201d agile approach is \nPrinciple\nPractice\nCustomer involvement\nThis depends on having a customer who is willing and able to spend time with \nthe development team and who can represent all system stakeholders. Often, \ncustomer representatives have other demands on their time and cannot play a \nfull part in the software development. Where there are external stakeholders, \nsuch as regulators, it is difficult to represent their views to the agile team.\nEmbrace change\nPrioritizing changes can be extremely difficult, especially in systems for which \nthere are many stakeholders. Typically, each stakeholder gives different \npriorities to different changes.\nIncremental delivery\nRapid iterations and short-term planning for development does not always fit \nin with the longer-term planning cycles of business planning and marketing. \nMarketing managers may need to know product features several months in \nadvance to prepare an effective marketing campaign.\nMaintain simplicity\nUnder pressure from delivery schedules, team members may not have time to \ncarry out desirable system simplifications.\nPeople, not process\nIndividual team members may not have suitable personalities for the intense \ninvolvement that is typical of agile methods and therefore may not interact \nwell with other team members.\nFigure 3.11 Agile \nprinciples and \norganizational practice\n\n\n92  Chapter 3 \u25a0 Agile software development\nunlikely to work. There needs to be some up-front planning, design, and documentation \nin the systems engineering process. Some of the key issues are as follows:\n1. \nHow large is the system that is being developed? Agile methods are most effective \nwhen the system can be developed with a relatively small co-located team who \ncan communicate informally. This may not be possible for large systems that \nrequire larger development teams, so a plan-driven approach may have to be used.\n2. What type of system is being developed? Systems that require a lot of analysis \nbefore implementation (e.g., real-time system with complex timing require-\nments) usually need a fairly detailed design to carry out this analysis. A plan-\ndriven approach may be best in those circumstances.\n3. What is the expected system lifetime? Long-lifetime systems may require more \ndesign documentation to communicate the original intentions of the system \ndevelopers to the support team. However, supporters of agile methods rightly \nargue that documentation is frequently not kept up to date and is not of much \nuse for long-term system maintenance.\n4. Is the system subject to external regulation? If a system has to be approved \nby\u00a0an external regulator (e.g., the Federal Aviation Administration approves \nsoftware that is critical to the operation of an aircraft), then you will probably be \nrequired to produce detailed documentation as part of the system safety\u00a0case.\nAgile methods place a great deal of responsibility on the development team to \ncooperate and communicate during the development of the system. They rely on indi-\nvidual engineering skills and software support for the development process. However, \nin reality, not everyone is a highly skilled engineer, people do not communicate effec-\ntively, and it is not always possible for teams to work together. Some planning may be \nrequired to make the most effective use of the people available. Key issues are:\n1. How good are the designers and programmers in the development team? \nIt\u00a0is\u00a0sometimes argued that agile methods require higher skill levels than plan-\nbased approaches in which programmers simply translate a detailed design into \ncode. If you have a team with relatively low skill levels, you may need to use \nthe best people to develop the design, with others responsible for programming.\nSystem\nTeam\nOrganization\nScale\nTechnology\nDistribution\nContracts\nDelivery\nRegulation\nType\nLifetime\nCompetence\nCulture\nFigure 3.12 Factors \ninfluencing the choice  \nof plan-based or agile \ndevelopment"}
{"query": "Why might a team with relatively low skill levels need to use a plan-driven approach?", "response": "A team with relatively low skill levels may need to use a plan-driven approach because plan-driven approaches typically involve translating a detailed design into code. This approach may be more suitable for teams with lower skill levels as it provides a clear and structured plan to follow, reducing the need for high-level engineering skills.", "context": "3.4  \u25a0 Scaling agile methods  91\n \n3.4.2  Agile and plan-driven methods\nA fundamental requirement of scaling agile methods is to integrate them with plan-\ndriven approaches. Small startup companies can work with informal and short-term \nplanning, but larger companies have to have longer-term plans and budgets for \ninvestment, staffing, and business development. Their software development must \nsupport these plans, so longer-term software planning is essential.\nEarly adopters of agile methods in the first decade of the 21st century were enthu-\nsiasts and deeply committed to the agile manifesto. They deliberately rejected the \nplan-driven approach to software engineering and were reluctant to change the ini-\ntial vision of agile methods in any way. However, as organizations saw the value and \nbenefits of an agile approach, they adapted these methods to suit their own culture \nand ways of working. They had to do this because the principles underlying agile \nmethods are sometimes difficult to realize in practice (Figure 3.11).\nTo address these problems, most large \u201cagile\u201d software development projects com-\nbine practices from plan-driven and agile approaches. Some are mostly agile, and others \nare mostly plan-driven but with some agile practices. To decide on the balance between \na plan-based and an agile approach, you have to answer a range of technical, human and \norganizational questions. These relate to the system being developed, the development \nteam, and the organizations that are developing and procuring the system (Figure 3.12).\nAgile methods were developed and refined in projects to develop small to medium-\nsized business systems and software products, where the software developer controls \nthe specification of the system. Other types of system have attributes such as size, com-\nplexity, real-time response, and external regulation that mean a \u201cpure\u201d agile approach is \nPrinciple\nPractice\nCustomer involvement\nThis depends on having a customer who is willing and able to spend time with \nthe development team and who can represent all system stakeholders. Often, \ncustomer representatives have other demands on their time and cannot play a \nfull part in the software development. Where there are external stakeholders, \nsuch as regulators, it is difficult to represent their views to the agile team.\nEmbrace change\nPrioritizing changes can be extremely difficult, especially in systems for which \nthere are many stakeholders. Typically, each stakeholder gives different \npriorities to different changes.\nIncremental delivery\nRapid iterations and short-term planning for development does not always fit \nin with the longer-term planning cycles of business planning and marketing. \nMarketing managers may need to know product features several months in \nadvance to prepare an effective marketing campaign.\nMaintain simplicity\nUnder pressure from delivery schedules, team members may not have time to \ncarry out desirable system simplifications.\nPeople, not process\nIndividual team members may not have suitable personalities for the intense \ninvolvement that is typical of agile methods and therefore may not interact \nwell with other team members.\nFigure 3.11 Agile \nprinciples and \norganizational practice\n\n\n92  Chapter 3 \u25a0 Agile software development\nunlikely to work. There needs to be some up-front planning, design, and documentation \nin the systems engineering process. Some of the key issues are as follows:\n1. \nHow large is the system that is being developed? Agile methods are most effective \nwhen the system can be developed with a relatively small co-located team who \ncan communicate informally. This may not be possible for large systems that \nrequire larger development teams, so a plan-driven approach may have to be used.\n2. What type of system is being developed? Systems that require a lot of analysis \nbefore implementation (e.g., real-time system with complex timing require-\nments) usually need a fairly detailed design to carry out this analysis. A plan-\ndriven approach may be best in those circumstances.\n3. What is the expected system lifetime? Long-lifetime systems may require more \ndesign documentation to communicate the original intentions of the system \ndevelopers to the support team. However, supporters of agile methods rightly \nargue that documentation is frequently not kept up to date and is not of much \nuse for long-term system maintenance.\n4. Is the system subject to external regulation? If a system has to be approved \nby\u00a0an external regulator (e.g., the Federal Aviation Administration approves \nsoftware that is critical to the operation of an aircraft), then you will probably be \nrequired to produce detailed documentation as part of the system safety\u00a0case.\nAgile methods place a great deal of responsibility on the development team to \ncooperate and communicate during the development of the system. They rely on indi-\nvidual engineering skills and software support for the development process. However, \nin reality, not everyone is a highly skilled engineer, people do not communicate effec-\ntively, and it is not always possible for teams to work together. Some planning may be \nrequired to make the most effective use of the people available. Key issues are:\n1. How good are the designers and programmers in the development team? \nIt\u00a0is\u00a0sometimes argued that agile methods require higher skill levels than plan-\nbased approaches in which programmers simply translate a detailed design into \ncode. If you have a team with relatively low skill levels, you may need to use \nthe best people to develop the design, with others responsible for programming.\nSystem\nTeam\nOrganization\nScale\nTechnology\nDistribution\nContracts\nDelivery\nRegulation\nType\nLifetime\nCompetence\nCulture\nFigure 3.12 Factors \ninfluencing the choice  \nof plan-based or agile \ndevelopment"}
{"query": "What are the factors that influence the choice of plan-based or agile development?", "response": "The factors that influence the choice of plan-based or agile development include the size of the system being developed, the type of system being developed (e.g., real-time system with complex timing requirements), the expected system lifetime, whether the system is subject to external regulation, the competence of the development team (e.g., skill levels of designers and programmers), and the culture of the organization. These factors need to be considered when deciding on the balance between a plan-based and an agile approach to software development.", "context": "3.4  \u25a0 Scaling agile methods  91\n \n3.4.2  Agile and plan-driven methods\nA fundamental requirement of scaling agile methods is to integrate them with plan-\ndriven approaches. Small startup companies can work with informal and short-term \nplanning, but larger companies have to have longer-term plans and budgets for \ninvestment, staffing, and business development. Their software development must \nsupport these plans, so longer-term software planning is essential.\nEarly adopters of agile methods in the first decade of the 21st century were enthu-\nsiasts and deeply committed to the agile manifesto. They deliberately rejected the \nplan-driven approach to software engineering and were reluctant to change the ini-\ntial vision of agile methods in any way. However, as organizations saw the value and \nbenefits of an agile approach, they adapted these methods to suit their own culture \nand ways of working. They had to do this because the principles underlying agile \nmethods are sometimes difficult to realize in practice (Figure 3.11).\nTo address these problems, most large \u201cagile\u201d software development projects com-\nbine practices from plan-driven and agile approaches. Some are mostly agile, and others \nare mostly plan-driven but with some agile practices. To decide on the balance between \na plan-based and an agile approach, you have to answer a range of technical, human and \norganizational questions. These relate to the system being developed, the development \nteam, and the organizations that are developing and procuring the system (Figure 3.12).\nAgile methods were developed and refined in projects to develop small to medium-\nsized business systems and software products, where the software developer controls \nthe specification of the system. Other types of system have attributes such as size, com-\nplexity, real-time response, and external regulation that mean a \u201cpure\u201d agile approach is \nPrinciple\nPractice\nCustomer involvement\nThis depends on having a customer who is willing and able to spend time with \nthe development team and who can represent all system stakeholders. Often, \ncustomer representatives have other demands on their time and cannot play a \nfull part in the software development. Where there are external stakeholders, \nsuch as regulators, it is difficult to represent their views to the agile team.\nEmbrace change\nPrioritizing changes can be extremely difficult, especially in systems for which \nthere are many stakeholders. Typically, each stakeholder gives different \npriorities to different changes.\nIncremental delivery\nRapid iterations and short-term planning for development does not always fit \nin with the longer-term planning cycles of business planning and marketing. \nMarketing managers may need to know product features several months in \nadvance to prepare an effective marketing campaign.\nMaintain simplicity\nUnder pressure from delivery schedules, team members may not have time to \ncarry out desirable system simplifications.\nPeople, not process\nIndividual team members may not have suitable personalities for the intense \ninvolvement that is typical of agile methods and therefore may not interact \nwell with other team members.\nFigure 3.11 Agile \nprinciples and \norganizational practice\n\n\n92  Chapter 3 \u25a0 Agile software development\nunlikely to work. There needs to be some up-front planning, design, and documentation \nin the systems engineering process. Some of the key issues are as follows:\n1. \nHow large is the system that is being developed? Agile methods are most effective \nwhen the system can be developed with a relatively small co-located team who \ncan communicate informally. This may not be possible for large systems that \nrequire larger development teams, so a plan-driven approach may have to be used.\n2. What type of system is being developed? Systems that require a lot of analysis \nbefore implementation (e.g., real-time system with complex timing require-\nments) usually need a fairly detailed design to carry out this analysis. A plan-\ndriven approach may be best in those circumstances.\n3. What is the expected system lifetime? Long-lifetime systems may require more \ndesign documentation to communicate the original intentions of the system \ndevelopers to the support team. However, supporters of agile methods rightly \nargue that documentation is frequently not kept up to date and is not of much \nuse for long-term system maintenance.\n4. Is the system subject to external regulation? If a system has to be approved \nby\u00a0an external regulator (e.g., the Federal Aviation Administration approves \nsoftware that is critical to the operation of an aircraft), then you will probably be \nrequired to produce detailed documentation as part of the system safety\u00a0case.\nAgile methods place a great deal of responsibility on the development team to \ncooperate and communicate during the development of the system. They rely on indi-\nvidual engineering skills and software support for the development process. However, \nin reality, not everyone is a highly skilled engineer, people do not communicate effec-\ntively, and it is not always possible for teams to work together. Some planning may be \nrequired to make the most effective use of the people available. Key issues are:\n1. How good are the designers and programmers in the development team? \nIt\u00a0is\u00a0sometimes argued that agile methods require higher skill levels than plan-\nbased approaches in which programmers simply translate a detailed design into \ncode. If you have a team with relatively low skill levels, you may need to use \nthe best people to develop the design, with others responsible for programming.\nSystem\nTeam\nOrganization\nScale\nTechnology\nDistribution\nContracts\nDelivery\nRegulation\nType\nLifetime\nCompetence\nCulture\nFigure 3.12 Factors \ninfluencing the choice  \nof plan-based or agile \ndevelopment"}
{"query": "How does the scale of the system influence the choice of development approach?", "response": "The scale of the system influences the choice of development approach by determining whether a plan-driven or agile approach is more suitable. Agile methods are most effective for developing systems with a relatively small co-located team who can communicate informally. However, for larger systems that require larger development teams, a plan-driven approach may be necessary. The size of the system is a key factor in deciding which approach to use.", "context": "3.4  \u25a0 Scaling agile methods  91\n \n3.4.2  Agile and plan-driven methods\nA fundamental requirement of scaling agile methods is to integrate them with plan-\ndriven approaches. Small startup companies can work with informal and short-term \nplanning, but larger companies have to have longer-term plans and budgets for \ninvestment, staffing, and business development. Their software development must \nsupport these plans, so longer-term software planning is essential.\nEarly adopters of agile methods in the first decade of the 21st century were enthu-\nsiasts and deeply committed to the agile manifesto. They deliberately rejected the \nplan-driven approach to software engineering and were reluctant to change the ini-\ntial vision of agile methods in any way. However, as organizations saw the value and \nbenefits of an agile approach, they adapted these methods to suit their own culture \nand ways of working. They had to do this because the principles underlying agile \nmethods are sometimes difficult to realize in practice (Figure 3.11).\nTo address these problems, most large \u201cagile\u201d software development projects com-\nbine practices from plan-driven and agile approaches. Some are mostly agile, and others \nare mostly plan-driven but with some agile practices. To decide on the balance between \na plan-based and an agile approach, you have to answer a range of technical, human and \norganizational questions. These relate to the system being developed, the development \nteam, and the organizations that are developing and procuring the system (Figure 3.12).\nAgile methods were developed and refined in projects to develop small to medium-\nsized business systems and software products, where the software developer controls \nthe specification of the system. Other types of system have attributes such as size, com-\nplexity, real-time response, and external regulation that mean a \u201cpure\u201d agile approach is \nPrinciple\nPractice\nCustomer involvement\nThis depends on having a customer who is willing and able to spend time with \nthe development team and who can represent all system stakeholders. Often, \ncustomer representatives have other demands on their time and cannot play a \nfull part in the software development. Where there are external stakeholders, \nsuch as regulators, it is difficult to represent their views to the agile team.\nEmbrace change\nPrioritizing changes can be extremely difficult, especially in systems for which \nthere are many stakeholders. Typically, each stakeholder gives different \npriorities to different changes.\nIncremental delivery\nRapid iterations and short-term planning for development does not always fit \nin with the longer-term planning cycles of business planning and marketing. \nMarketing managers may need to know product features several months in \nadvance to prepare an effective marketing campaign.\nMaintain simplicity\nUnder pressure from delivery schedules, team members may not have time to \ncarry out desirable system simplifications.\nPeople, not process\nIndividual team members may not have suitable personalities for the intense \ninvolvement that is typical of agile methods and therefore may not interact \nwell with other team members.\nFigure 3.11 Agile \nprinciples and \norganizational practice\n\n\n92  Chapter 3 \u25a0 Agile software development\nunlikely to work. There needs to be some up-front planning, design, and documentation \nin the systems engineering process. Some of the key issues are as follows:\n1. \nHow large is the system that is being developed? Agile methods are most effective \nwhen the system can be developed with a relatively small co-located team who \ncan communicate informally. This may not be possible for large systems that \nrequire larger development teams, so a plan-driven approach may have to be used.\n2. What type of system is being developed? Systems that require a lot of analysis \nbefore implementation (e.g., real-time system with complex timing require-\nments) usually need a fairly detailed design to carry out this analysis. A plan-\ndriven approach may be best in those circumstances.\n3. What is the expected system lifetime? Long-lifetime systems may require more \ndesign documentation to communicate the original intentions of the system \ndevelopers to the support team. However, supporters of agile methods rightly \nargue that documentation is frequently not kept up to date and is not of much \nuse for long-term system maintenance.\n4. Is the system subject to external regulation? If a system has to be approved \nby\u00a0an external regulator (e.g., the Federal Aviation Administration approves \nsoftware that is critical to the operation of an aircraft), then you will probably be \nrequired to produce detailed documentation as part of the system safety\u00a0case.\nAgile methods place a great deal of responsibility on the development team to \ncooperate and communicate during the development of the system. They rely on indi-\nvidual engineering skills and software support for the development process. However, \nin reality, not everyone is a highly skilled engineer, people do not communicate effec-\ntively, and it is not always possible for teams to work together. Some planning may be \nrequired to make the most effective use of the people available. Key issues are:\n1. How good are the designers and programmers in the development team? \nIt\u00a0is\u00a0sometimes argued that agile methods require higher skill levels than plan-\nbased approaches in which programmers simply translate a detailed design into \ncode. If you have a team with relatively low skill levels, you may need to use \nthe best people to develop the design, with others responsible for programming.\nSystem\nTeam\nOrganization\nScale\nTechnology\nDistribution\nContracts\nDelivery\nRegulation\nType\nLifetime\nCompetence\nCulture\nFigure 3.12 Factors \ninfluencing the choice  \nof plan-based or agile \ndevelopment"}
{"query": "How does the technology used in the system influence the choice of development approach?", "response": "The technology used in the system can influence the choice of development approach. Different technologies may have different requirements and constraints, which can impact the feasibility and effectiveness of using an agile or plan-driven approach. For example, if the system being developed requires complex analysis or real-time response, a plan-driven approach may be more suitable. On the other hand, if the technology allows for rapid iterations and informal communication, an agile approach may be more appropriate. The choice of development approach should consider how well the technology aligns with the principles and practices of agile methods, as well as any specific requirements or limitations imposed by the technology itself.", "context": "3.4  \u25a0 Scaling agile methods  91\n \n3.4.2  Agile and plan-driven methods\nA fundamental requirement of scaling agile methods is to integrate them with plan-\ndriven approaches. Small startup companies can work with informal and short-term \nplanning, but larger companies have to have longer-term plans and budgets for \ninvestment, staffing, and business development. Their software development must \nsupport these plans, so longer-term software planning is essential.\nEarly adopters of agile methods in the first decade of the 21st century were enthu-\nsiasts and deeply committed to the agile manifesto. They deliberately rejected the \nplan-driven approach to software engineering and were reluctant to change the ini-\ntial vision of agile methods in any way. However, as organizations saw the value and \nbenefits of an agile approach, they adapted these methods to suit their own culture \nand ways of working. They had to do this because the principles underlying agile \nmethods are sometimes difficult to realize in practice (Figure 3.11).\nTo address these problems, most large \u201cagile\u201d software development projects com-\nbine practices from plan-driven and agile approaches. Some are mostly agile, and others \nare mostly plan-driven but with some agile practices. To decide on the balance between \na plan-based and an agile approach, you have to answer a range of technical, human and \norganizational questions. These relate to the system being developed, the development \nteam, and the organizations that are developing and procuring the system (Figure 3.12).\nAgile methods were developed and refined in projects to develop small to medium-\nsized business systems and software products, where the software developer controls \nthe specification of the system. Other types of system have attributes such as size, com-\nplexity, real-time response, and external regulation that mean a \u201cpure\u201d agile approach is \nPrinciple\nPractice\nCustomer involvement\nThis depends on having a customer who is willing and able to spend time with \nthe development team and who can represent all system stakeholders. Often, \ncustomer representatives have other demands on their time and cannot play a \nfull part in the software development. Where there are external stakeholders, \nsuch as regulators, it is difficult to represent their views to the agile team.\nEmbrace change\nPrioritizing changes can be extremely difficult, especially in systems for which \nthere are many stakeholders. Typically, each stakeholder gives different \npriorities to different changes.\nIncremental delivery\nRapid iterations and short-term planning for development does not always fit \nin with the longer-term planning cycles of business planning and marketing. \nMarketing managers may need to know product features several months in \nadvance to prepare an effective marketing campaign.\nMaintain simplicity\nUnder pressure from delivery schedules, team members may not have time to \ncarry out desirable system simplifications.\nPeople, not process\nIndividual team members may not have suitable personalities for the intense \ninvolvement that is typical of agile methods and therefore may not interact \nwell with other team members.\nFigure 3.11 Agile \nprinciples and \norganizational practice\n\n\n92  Chapter 3 \u25a0 Agile software development\nunlikely to work. There needs to be some up-front planning, design, and documentation \nin the systems engineering process. Some of the key issues are as follows:\n1. \nHow large is the system that is being developed? Agile methods are most effective \nwhen the system can be developed with a relatively small co-located team who \ncan communicate informally. This may not be possible for large systems that \nrequire larger development teams, so a plan-driven approach may have to be used.\n2. What type of system is being developed? Systems that require a lot of analysis \nbefore implementation (e.g., real-time system with complex timing require-\nments) usually need a fairly detailed design to carry out this analysis. A plan-\ndriven approach may be best in those circumstances.\n3. What is the expected system lifetime? Long-lifetime systems may require more \ndesign documentation to communicate the original intentions of the system \ndevelopers to the support team. However, supporters of agile methods rightly \nargue that documentation is frequently not kept up to date and is not of much \nuse for long-term system maintenance.\n4. Is the system subject to external regulation? If a system has to be approved \nby\u00a0an external regulator (e.g., the Federal Aviation Administration approves \nsoftware that is critical to the operation of an aircraft), then you will probably be \nrequired to produce detailed documentation as part of the system safety\u00a0case.\nAgile methods place a great deal of responsibility on the development team to \ncooperate and communicate during the development of the system. They rely on indi-\nvidual engineering skills and software support for the development process. However, \nin reality, not everyone is a highly skilled engineer, people do not communicate effec-\ntively, and it is not always possible for teams to work together. Some planning may be \nrequired to make the most effective use of the people available. Key issues are:\n1. How good are the designers and programmers in the development team? \nIt\u00a0is\u00a0sometimes argued that agile methods require higher skill levels than plan-\nbased approaches in which programmers simply translate a detailed design into \ncode. If you have a team with relatively low skill levels, you may need to use \nthe best people to develop the design, with others responsible for programming.\nSystem\nTeam\nOrganization\nScale\nTechnology\nDistribution\nContracts\nDelivery\nRegulation\nType\nLifetime\nCompetence\nCulture\nFigure 3.12 Factors \ninfluencing the choice  \nof plan-based or agile \ndevelopment"}
{"query": "How does the distribution of the system influence the choice of development approach?", "response": "The distribution of the system can influence the choice of development approach. In a distributed system, where the development team is geographically dispersed, it may be more challenging to effectively communicate and collaborate. Agile methods heavily rely on close collaboration and communication within the development team. Therefore, in a distributed system, a plan-driven approach may be more suitable as it allows for more formalized communication and coordination across different locations.", "context": "3.4  \u25a0 Scaling agile methods  91\n \n3.4.2  Agile and plan-driven methods\nA fundamental requirement of scaling agile methods is to integrate them with plan-\ndriven approaches. Small startup companies can work with informal and short-term \nplanning, but larger companies have to have longer-term plans and budgets for \ninvestment, staffing, and business development. Their software development must \nsupport these plans, so longer-term software planning is essential.\nEarly adopters of agile methods in the first decade of the 21st century were enthu-\nsiasts and deeply committed to the agile manifesto. They deliberately rejected the \nplan-driven approach to software engineering and were reluctant to change the ini-\ntial vision of agile methods in any way. However, as organizations saw the value and \nbenefits of an agile approach, they adapted these methods to suit their own culture \nand ways of working. They had to do this because the principles underlying agile \nmethods are sometimes difficult to realize in practice (Figure 3.11).\nTo address these problems, most large \u201cagile\u201d software development projects com-\nbine practices from plan-driven and agile approaches. Some are mostly agile, and others \nare mostly plan-driven but with some agile practices. To decide on the balance between \na plan-based and an agile approach, you have to answer a range of technical, human and \norganizational questions. These relate to the system being developed, the development \nteam, and the organizations that are developing and procuring the system (Figure 3.12).\nAgile methods were developed and refined in projects to develop small to medium-\nsized business systems and software products, where the software developer controls \nthe specification of the system. Other types of system have attributes such as size, com-\nplexity, real-time response, and external regulation that mean a \u201cpure\u201d agile approach is \nPrinciple\nPractice\nCustomer involvement\nThis depends on having a customer who is willing and able to spend time with \nthe development team and who can represent all system stakeholders. Often, \ncustomer representatives have other demands on their time and cannot play a \nfull part in the software development. Where there are external stakeholders, \nsuch as regulators, it is difficult to represent their views to the agile team.\nEmbrace change\nPrioritizing changes can be extremely difficult, especially in systems for which \nthere are many stakeholders. Typically, each stakeholder gives different \npriorities to different changes.\nIncremental delivery\nRapid iterations and short-term planning for development does not always fit \nin with the longer-term planning cycles of business planning and marketing. \nMarketing managers may need to know product features several months in \nadvance to prepare an effective marketing campaign.\nMaintain simplicity\nUnder pressure from delivery schedules, team members may not have time to \ncarry out desirable system simplifications.\nPeople, not process\nIndividual team members may not have suitable personalities for the intense \ninvolvement that is typical of agile methods and therefore may not interact \nwell with other team members.\nFigure 3.11 Agile \nprinciples and \norganizational practice\n\n\n92  Chapter 3 \u25a0 Agile software development\nunlikely to work. There needs to be some up-front planning, design, and documentation \nin the systems engineering process. Some of the key issues are as follows:\n1. \nHow large is the system that is being developed? Agile methods are most effective \nwhen the system can be developed with a relatively small co-located team who \ncan communicate informally. This may not be possible for large systems that \nrequire larger development teams, so a plan-driven approach may have to be used.\n2. What type of system is being developed? Systems that require a lot of analysis \nbefore implementation (e.g., real-time system with complex timing require-\nments) usually need a fairly detailed design to carry out this analysis. A plan-\ndriven approach may be best in those circumstances.\n3. What is the expected system lifetime? Long-lifetime systems may require more \ndesign documentation to communicate the original intentions of the system \ndevelopers to the support team. However, supporters of agile methods rightly \nargue that documentation is frequently not kept up to date and is not of much \nuse for long-term system maintenance.\n4. Is the system subject to external regulation? If a system has to be approved \nby\u00a0an external regulator (e.g., the Federal Aviation Administration approves \nsoftware that is critical to the operation of an aircraft), then you will probably be \nrequired to produce detailed documentation as part of the system safety\u00a0case.\nAgile methods place a great deal of responsibility on the development team to \ncooperate and communicate during the development of the system. They rely on indi-\nvidual engineering skills and software support for the development process. However, \nin reality, not everyone is a highly skilled engineer, people do not communicate effec-\ntively, and it is not always possible for teams to work together. Some planning may be \nrequired to make the most effective use of the people available. Key issues are:\n1. How good are the designers and programmers in the development team? \nIt\u00a0is\u00a0sometimes argued that agile methods require higher skill levels than plan-\nbased approaches in which programmers simply translate a detailed design into \ncode. If you have a team with relatively low skill levels, you may need to use \nthe best people to develop the design, with others responsible for programming.\nSystem\nTeam\nOrganization\nScale\nTechnology\nDistribution\nContracts\nDelivery\nRegulation\nType\nLifetime\nCompetence\nCulture\nFigure 3.12 Factors \ninfluencing the choice  \nof plan-based or agile \ndevelopment"}
{"query": "How do contracts influence the choice of development approach?", "response": "Contracts can influence the choice of development approach by imposing certain requirements and constraints on the development process. If a project is subject to contractual agreements, such as fixed deadlines or specific deliverables, a plan-driven approach may be more suitable. This is because plan-driven methods typically involve detailed upfront planning and documentation, which can help ensure that contractual obligations are met. On the other hand, if a project has more flexibility in terms of timelines and deliverables, an agile approach may be preferred as it allows for more adaptability and iterative development. Ultimately, the choice of development approach depends on the specific contractual requirements and the level of flexibility allowed within those contracts.", "context": "3.4  \u25a0 Scaling agile methods  91\n \n3.4.2  Agile and plan-driven methods\nA fundamental requirement of scaling agile methods is to integrate them with plan-\ndriven approaches. Small startup companies can work with informal and short-term \nplanning, but larger companies have to have longer-term plans and budgets for \ninvestment, staffing, and business development. Their software development must \nsupport these plans, so longer-term software planning is essential.\nEarly adopters of agile methods in the first decade of the 21st century were enthu-\nsiasts and deeply committed to the agile manifesto. They deliberately rejected the \nplan-driven approach to software engineering and were reluctant to change the ini-\ntial vision of agile methods in any way. However, as organizations saw the value and \nbenefits of an agile approach, they adapted these methods to suit their own culture \nand ways of working. They had to do this because the principles underlying agile \nmethods are sometimes difficult to realize in practice (Figure 3.11).\nTo address these problems, most large \u201cagile\u201d software development projects com-\nbine practices from plan-driven and agile approaches. Some are mostly agile, and others \nare mostly plan-driven but with some agile practices. To decide on the balance between \na plan-based and an agile approach, you have to answer a range of technical, human and \norganizational questions. These relate to the system being developed, the development \nteam, and the organizations that are developing and procuring the system (Figure 3.12).\nAgile methods were developed and refined in projects to develop small to medium-\nsized business systems and software products, where the software developer controls \nthe specification of the system. Other types of system have attributes such as size, com-\nplexity, real-time response, and external regulation that mean a \u201cpure\u201d agile approach is \nPrinciple\nPractice\nCustomer involvement\nThis depends on having a customer who is willing and able to spend time with \nthe development team and who can represent all system stakeholders. Often, \ncustomer representatives have other demands on their time and cannot play a \nfull part in the software development. Where there are external stakeholders, \nsuch as regulators, it is difficult to represent their views to the agile team.\nEmbrace change\nPrioritizing changes can be extremely difficult, especially in systems for which \nthere are many stakeholders. Typically, each stakeholder gives different \npriorities to different changes.\nIncremental delivery\nRapid iterations and short-term planning for development does not always fit \nin with the longer-term planning cycles of business planning and marketing. \nMarketing managers may need to know product features several months in \nadvance to prepare an effective marketing campaign.\nMaintain simplicity\nUnder pressure from delivery schedules, team members may not have time to \ncarry out desirable system simplifications.\nPeople, not process\nIndividual team members may not have suitable personalities for the intense \ninvolvement that is typical of agile methods and therefore may not interact \nwell with other team members.\nFigure 3.11 Agile \nprinciples and \norganizational practice\n\n\n92  Chapter 3 \u25a0 Agile software development\nunlikely to work. There needs to be some up-front planning, design, and documentation \nin the systems engineering process. Some of the key issues are as follows:\n1. \nHow large is the system that is being developed? Agile methods are most effective \nwhen the system can be developed with a relatively small co-located team who \ncan communicate informally. This may not be possible for large systems that \nrequire larger development teams, so a plan-driven approach may have to be used.\n2. What type of system is being developed? Systems that require a lot of analysis \nbefore implementation (e.g., real-time system with complex timing require-\nments) usually need a fairly detailed design to carry out this analysis. A plan-\ndriven approach may be best in those circumstances.\n3. What is the expected system lifetime? Long-lifetime systems may require more \ndesign documentation to communicate the original intentions of the system \ndevelopers to the support team. However, supporters of agile methods rightly \nargue that documentation is frequently not kept up to date and is not of much \nuse for long-term system maintenance.\n4. Is the system subject to external regulation? If a system has to be approved \nby\u00a0an external regulator (e.g., the Federal Aviation Administration approves \nsoftware that is critical to the operation of an aircraft), then you will probably be \nrequired to produce detailed documentation as part of the system safety\u00a0case.\nAgile methods place a great deal of responsibility on the development team to \ncooperate and communicate during the development of the system. They rely on indi-\nvidual engineering skills and software support for the development process. However, \nin reality, not everyone is a highly skilled engineer, people do not communicate effec-\ntively, and it is not always possible for teams to work together. Some planning may be \nrequired to make the most effective use of the people available. Key issues are:\n1. How good are the designers and programmers in the development team? \nIt\u00a0is\u00a0sometimes argued that agile methods require higher skill levels than plan-\nbased approaches in which programmers simply translate a detailed design into \ncode. If you have a team with relatively low skill levels, you may need to use \nthe best people to develop the design, with others responsible for programming.\nSystem\nTeam\nOrganization\nScale\nTechnology\nDistribution\nContracts\nDelivery\nRegulation\nType\nLifetime\nCompetence\nCulture\nFigure 3.12 Factors \ninfluencing the choice  \nof plan-based or agile \ndevelopment"}
{"query": "How does the delivery of the system influence the choice of development approach?", "response": "The delivery of the system can influence the choice of development approach in terms of planning and coordination. If the system requires rapid iterations and short-term planning for development, it may not align well with longer-term planning cycles of business planning and marketing. In such cases, a plan-driven approach may be more suitable. On the other hand, if the system can be developed with a relatively small co-located team who can communicate informally, an agile approach may be more effective. The choice of development approach should consider the delivery requirements and how well they align with the planning and coordination needs of the system.", "context": "3.4  \u25a0 Scaling agile methods  91\n \n3.4.2  Agile and plan-driven methods\nA fundamental requirement of scaling agile methods is to integrate them with plan-\ndriven approaches. Small startup companies can work with informal and short-term \nplanning, but larger companies have to have longer-term plans and budgets for \ninvestment, staffing, and business development. Their software development must \nsupport these plans, so longer-term software planning is essential.\nEarly adopters of agile methods in the first decade of the 21st century were enthu-\nsiasts and deeply committed to the agile manifesto. They deliberately rejected the \nplan-driven approach to software engineering and were reluctant to change the ini-\ntial vision of agile methods in any way. However, as organizations saw the value and \nbenefits of an agile approach, they adapted these methods to suit their own culture \nand ways of working. They had to do this because the principles underlying agile \nmethods are sometimes difficult to realize in practice (Figure 3.11).\nTo address these problems, most large \u201cagile\u201d software development projects com-\nbine practices from plan-driven and agile approaches. Some are mostly agile, and others \nare mostly plan-driven but with some agile practices. To decide on the balance between \na plan-based and an agile approach, you have to answer a range of technical, human and \norganizational questions. These relate to the system being developed, the development \nteam, and the organizations that are developing and procuring the system (Figure 3.12).\nAgile methods were developed and refined in projects to develop small to medium-\nsized business systems and software products, where the software developer controls \nthe specification of the system. Other types of system have attributes such as size, com-\nplexity, real-time response, and external regulation that mean a \u201cpure\u201d agile approach is \nPrinciple\nPractice\nCustomer involvement\nThis depends on having a customer who is willing and able to spend time with \nthe development team and who can represent all system stakeholders. Often, \ncustomer representatives have other demands on their time and cannot play a \nfull part in the software development. Where there are external stakeholders, \nsuch as regulators, it is difficult to represent their views to the agile team.\nEmbrace change\nPrioritizing changes can be extremely difficult, especially in systems for which \nthere are many stakeholders. Typically, each stakeholder gives different \npriorities to different changes.\nIncremental delivery\nRapid iterations and short-term planning for development does not always fit \nin with the longer-term planning cycles of business planning and marketing. \nMarketing managers may need to know product features several months in \nadvance to prepare an effective marketing campaign.\nMaintain simplicity\nUnder pressure from delivery schedules, team members may not have time to \ncarry out desirable system simplifications.\nPeople, not process\nIndividual team members may not have suitable personalities for the intense \ninvolvement that is typical of agile methods and therefore may not interact \nwell with other team members.\nFigure 3.11 Agile \nprinciples and \norganizational practice\n\n\n92  Chapter 3 \u25a0 Agile software development\nunlikely to work. There needs to be some up-front planning, design, and documentation \nin the systems engineering process. Some of the key issues are as follows:\n1. \nHow large is the system that is being developed? Agile methods are most effective \nwhen the system can be developed with a relatively small co-located team who \ncan communicate informally. This may not be possible for large systems that \nrequire larger development teams, so a plan-driven approach may have to be used.\n2. What type of system is being developed? Systems that require a lot of analysis \nbefore implementation (e.g., real-time system with complex timing require-\nments) usually need a fairly detailed design to carry out this analysis. A plan-\ndriven approach may be best in those circumstances.\n3. What is the expected system lifetime? Long-lifetime systems may require more \ndesign documentation to communicate the original intentions of the system \ndevelopers to the support team. However, supporters of agile methods rightly \nargue that documentation is frequently not kept up to date and is not of much \nuse for long-term system maintenance.\n4. Is the system subject to external regulation? If a system has to be approved \nby\u00a0an external regulator (e.g., the Federal Aviation Administration approves \nsoftware that is critical to the operation of an aircraft), then you will probably be \nrequired to produce detailed documentation as part of the system safety\u00a0case.\nAgile methods place a great deal of responsibility on the development team to \ncooperate and communicate during the development of the system. They rely on indi-\nvidual engineering skills and software support for the development process. However, \nin reality, not everyone is a highly skilled engineer, people do not communicate effec-\ntively, and it is not always possible for teams to work together. Some planning may be \nrequired to make the most effective use of the people available. Key issues are:\n1. How good are the designers and programmers in the development team? \nIt\u00a0is\u00a0sometimes argued that agile methods require higher skill levels than plan-\nbased approaches in which programmers simply translate a detailed design into \ncode. If you have a team with relatively low skill levels, you may need to use \nthe best people to develop the design, with others responsible for programming.\nSystem\nTeam\nOrganization\nScale\nTechnology\nDistribution\nContracts\nDelivery\nRegulation\nType\nLifetime\nCompetence\nCulture\nFigure 3.12 Factors \ninfluencing the choice  \nof plan-based or agile \ndevelopment"}
{"query": "How does regulation influence the choice of development approach?", "response": "Regulation can influence the choice of development approach by requiring detailed documentation as part of the system safety case. If a system needs to be approved by an external regulator, such as the Federal Aviation Administration for critical aircraft software, then a plan-driven approach with detailed documentation may be necessary to meet regulatory requirements.", "context": "3.4  \u25a0 Scaling agile methods  91\n \n3.4.2  Agile and plan-driven methods\nA fundamental requirement of scaling agile methods is to integrate them with plan-\ndriven approaches. Small startup companies can work with informal and short-term \nplanning, but larger companies have to have longer-term plans and budgets for \ninvestment, staffing, and business development. Their software development must \nsupport these plans, so longer-term software planning is essential.\nEarly adopters of agile methods in the first decade of the 21st century were enthu-\nsiasts and deeply committed to the agile manifesto. They deliberately rejected the \nplan-driven approach to software engineering and were reluctant to change the ini-\ntial vision of agile methods in any way. However, as organizations saw the value and \nbenefits of an agile approach, they adapted these methods to suit their own culture \nand ways of working. They had to do this because the principles underlying agile \nmethods are sometimes difficult to realize in practice (Figure 3.11).\nTo address these problems, most large \u201cagile\u201d software development projects com-\nbine practices from plan-driven and agile approaches. Some are mostly agile, and others \nare mostly plan-driven but with some agile practices. To decide on the balance between \na plan-based and an agile approach, you have to answer a range of technical, human and \norganizational questions. These relate to the system being developed, the development \nteam, and the organizations that are developing and procuring the system (Figure 3.12).\nAgile methods were developed and refined in projects to develop small to medium-\nsized business systems and software products, where the software developer controls \nthe specification of the system. Other types of system have attributes such as size, com-\nplexity, real-time response, and external regulation that mean a \u201cpure\u201d agile approach is \nPrinciple\nPractice\nCustomer involvement\nThis depends on having a customer who is willing and able to spend time with \nthe development team and who can represent all system stakeholders. Often, \ncustomer representatives have other demands on their time and cannot play a \nfull part in the software development. Where there are external stakeholders, \nsuch as regulators, it is difficult to represent their views to the agile team.\nEmbrace change\nPrioritizing changes can be extremely difficult, especially in systems for which \nthere are many stakeholders. Typically, each stakeholder gives different \npriorities to different changes.\nIncremental delivery\nRapid iterations and short-term planning for development does not always fit \nin with the longer-term planning cycles of business planning and marketing. \nMarketing managers may need to know product features several months in \nadvance to prepare an effective marketing campaign.\nMaintain simplicity\nUnder pressure from delivery schedules, team members may not have time to \ncarry out desirable system simplifications.\nPeople, not process\nIndividual team members may not have suitable personalities for the intense \ninvolvement that is typical of agile methods and therefore may not interact \nwell with other team members.\nFigure 3.11 Agile \nprinciples and \norganizational practice\n\n\n92  Chapter 3 \u25a0 Agile software development\nunlikely to work. There needs to be some up-front planning, design, and documentation \nin the systems engineering process. Some of the key issues are as follows:\n1. \nHow large is the system that is being developed? Agile methods are most effective \nwhen the system can be developed with a relatively small co-located team who \ncan communicate informally. This may not be possible for large systems that \nrequire larger development teams, so a plan-driven approach may have to be used.\n2. What type of system is being developed? Systems that require a lot of analysis \nbefore implementation (e.g., real-time system with complex timing require-\nments) usually need a fairly detailed design to carry out this analysis. A plan-\ndriven approach may be best in those circumstances.\n3. What is the expected system lifetime? Long-lifetime systems may require more \ndesign documentation to communicate the original intentions of the system \ndevelopers to the support team. However, supporters of agile methods rightly \nargue that documentation is frequently not kept up to date and is not of much \nuse for long-term system maintenance.\n4. Is the system subject to external regulation? If a system has to be approved \nby\u00a0an external regulator (e.g., the Federal Aviation Administration approves \nsoftware that is critical to the operation of an aircraft), then you will probably be \nrequired to produce detailed documentation as part of the system safety\u00a0case.\nAgile methods place a great deal of responsibility on the development team to \ncooperate and communicate during the development of the system. They rely on indi-\nvidual engineering skills and software support for the development process. However, \nin reality, not everyone is a highly skilled engineer, people do not communicate effec-\ntively, and it is not always possible for teams to work together. Some planning may be \nrequired to make the most effective use of the people available. Key issues are:\n1. How good are the designers and programmers in the development team? \nIt\u00a0is\u00a0sometimes argued that agile methods require higher skill levels than plan-\nbased approaches in which programmers simply translate a detailed design into \ncode. If you have a team with relatively low skill levels, you may need to use \nthe best people to develop the design, with others responsible for programming.\nSystem\nTeam\nOrganization\nScale\nTechnology\nDistribution\nContracts\nDelivery\nRegulation\nType\nLifetime\nCompetence\nCulture\nFigure 3.12 Factors \ninfluencing the choice  \nof plan-based or agile \ndevelopment"}
{"query": "How does the type of system influence the choice of development approach?", "response": "The type of system being developed can influence the choice of development approach. Systems that require a lot of analysis before implementation, such as real-time systems with complex timing requirements, usually need a fairly detailed design to carry out this analysis. In these circumstances, a plan-driven approach may be the best choice. On the other hand, agile methods are most effective when the system can be developed with a relatively small co-located team who can communicate informally. So, for systems that can be developed with a small team and do not require extensive analysis, an agile approach may be more suitable.", "context": "3.4  \u25a0 Scaling agile methods  91\n \n3.4.2  Agile and plan-driven methods\nA fundamental requirement of scaling agile methods is to integrate them with plan-\ndriven approaches. Small startup companies can work with informal and short-term \nplanning, but larger companies have to have longer-term plans and budgets for \ninvestment, staffing, and business development. Their software development must \nsupport these plans, so longer-term software planning is essential.\nEarly adopters of agile methods in the first decade of the 21st century were enthu-\nsiasts and deeply committed to the agile manifesto. They deliberately rejected the \nplan-driven approach to software engineering and were reluctant to change the ini-\ntial vision of agile methods in any way. However, as organizations saw the value and \nbenefits of an agile approach, they adapted these methods to suit their own culture \nand ways of working. They had to do this because the principles underlying agile \nmethods are sometimes difficult to realize in practice (Figure 3.11).\nTo address these problems, most large \u201cagile\u201d software development projects com-\nbine practices from plan-driven and agile approaches. Some are mostly agile, and others \nare mostly plan-driven but with some agile practices. To decide on the balance between \na plan-based and an agile approach, you have to answer a range of technical, human and \norganizational questions. These relate to the system being developed, the development \nteam, and the organizations that are developing and procuring the system (Figure 3.12).\nAgile methods were developed and refined in projects to develop small to medium-\nsized business systems and software products, where the software developer controls \nthe specification of the system. Other types of system have attributes such as size, com-\nplexity, real-time response, and external regulation that mean a \u201cpure\u201d agile approach is \nPrinciple\nPractice\nCustomer involvement\nThis depends on having a customer who is willing and able to spend time with \nthe development team and who can represent all system stakeholders. Often, \ncustomer representatives have other demands on their time and cannot play a \nfull part in the software development. Where there are external stakeholders, \nsuch as regulators, it is difficult to represent their views to the agile team.\nEmbrace change\nPrioritizing changes can be extremely difficult, especially in systems for which \nthere are many stakeholders. Typically, each stakeholder gives different \npriorities to different changes.\nIncremental delivery\nRapid iterations and short-term planning for development does not always fit \nin with the longer-term planning cycles of business planning and marketing. \nMarketing managers may need to know product features several months in \nadvance to prepare an effective marketing campaign.\nMaintain simplicity\nUnder pressure from delivery schedules, team members may not have time to \ncarry out desirable system simplifications.\nPeople, not process\nIndividual team members may not have suitable personalities for the intense \ninvolvement that is typical of agile methods and therefore may not interact \nwell with other team members.\nFigure 3.11 Agile \nprinciples and \norganizational practice\n\n\n92  Chapter 3 \u25a0 Agile software development\nunlikely to work. There needs to be some up-front planning, design, and documentation \nin the systems engineering process. Some of the key issues are as follows:\n1. \nHow large is the system that is being developed? Agile methods are most effective \nwhen the system can be developed with a relatively small co-located team who \ncan communicate informally. This may not be possible for large systems that \nrequire larger development teams, so a plan-driven approach may have to be used.\n2. What type of system is being developed? Systems that require a lot of analysis \nbefore implementation (e.g., real-time system with complex timing require-\nments) usually need a fairly detailed design to carry out this analysis. A plan-\ndriven approach may be best in those circumstances.\n3. What is the expected system lifetime? Long-lifetime systems may require more \ndesign documentation to communicate the original intentions of the system \ndevelopers to the support team. However, supporters of agile methods rightly \nargue that documentation is frequently not kept up to date and is not of much \nuse for long-term system maintenance.\n4. Is the system subject to external regulation? If a system has to be approved \nby\u00a0an external regulator (e.g., the Federal Aviation Administration approves \nsoftware that is critical to the operation of an aircraft), then you will probably be \nrequired to produce detailed documentation as part of the system safety\u00a0case.\nAgile methods place a great deal of responsibility on the development team to \ncooperate and communicate during the development of the system. They rely on indi-\nvidual engineering skills and software support for the development process. However, \nin reality, not everyone is a highly skilled engineer, people do not communicate effec-\ntively, and it is not always possible for teams to work together. Some planning may be \nrequired to make the most effective use of the people available. Key issues are:\n1. How good are the designers and programmers in the development team? \nIt\u00a0is\u00a0sometimes argued that agile methods require higher skill levels than plan-\nbased approaches in which programmers simply translate a detailed design into \ncode. If you have a team with relatively low skill levels, you may need to use \nthe best people to develop the design, with others responsible for programming.\nSystem\nTeam\nOrganization\nScale\nTechnology\nDistribution\nContracts\nDelivery\nRegulation\nType\nLifetime\nCompetence\nCulture\nFigure 3.12 Factors \ninfluencing the choice  \nof plan-based or agile \ndevelopment"}
{"query": "How does the lifetime of the system influence the choice of development approach?", "response": "The lifetime of the system can influence the choice of development approach. Long-lifetime systems may require more design documentation to communicate the original intentions of the system developers to the support team. However, supporters of agile methods argue that documentation is often not kept up to date and is not very useful for long-term system maintenance. Therefore, the expected lifetime of the system may lead to a decision to use a plan-driven approach that emphasizes detailed documentation.", "context": "3.4  \u25a0 Scaling agile methods  91\n \n3.4.2  Agile and plan-driven methods\nA fundamental requirement of scaling agile methods is to integrate them with plan-\ndriven approaches. Small startup companies can work with informal and short-term \nplanning, but larger companies have to have longer-term plans and budgets for \ninvestment, staffing, and business development. Their software development must \nsupport these plans, so longer-term software planning is essential.\nEarly adopters of agile methods in the first decade of the 21st century were enthu-\nsiasts and deeply committed to the agile manifesto. They deliberately rejected the \nplan-driven approach to software engineering and were reluctant to change the ini-\ntial vision of agile methods in any way. However, as organizations saw the value and \nbenefits of an agile approach, they adapted these methods to suit their own culture \nand ways of working. They had to do this because the principles underlying agile \nmethods are sometimes difficult to realize in practice (Figure 3.11).\nTo address these problems, most large \u201cagile\u201d software development projects com-\nbine practices from plan-driven and agile approaches. Some are mostly agile, and others \nare mostly plan-driven but with some agile practices. To decide on the balance between \na plan-based and an agile approach, you have to answer a range of technical, human and \norganizational questions. These relate to the system being developed, the development \nteam, and the organizations that are developing and procuring the system (Figure 3.12).\nAgile methods were developed and refined in projects to develop small to medium-\nsized business systems and software products, where the software developer controls \nthe specification of the system. Other types of system have attributes such as size, com-\nplexity, real-time response, and external regulation that mean a \u201cpure\u201d agile approach is \nPrinciple\nPractice\nCustomer involvement\nThis depends on having a customer who is willing and able to spend time with \nthe development team and who can represent all system stakeholders. Often, \ncustomer representatives have other demands on their time and cannot play a \nfull part in the software development. Where there are external stakeholders, \nsuch as regulators, it is difficult to represent their views to the agile team.\nEmbrace change\nPrioritizing changes can be extremely difficult, especially in systems for which \nthere are many stakeholders. Typically, each stakeholder gives different \npriorities to different changes.\nIncremental delivery\nRapid iterations and short-term planning for development does not always fit \nin with the longer-term planning cycles of business planning and marketing. \nMarketing managers may need to know product features several months in \nadvance to prepare an effective marketing campaign.\nMaintain simplicity\nUnder pressure from delivery schedules, team members may not have time to \ncarry out desirable system simplifications.\nPeople, not process\nIndividual team members may not have suitable personalities for the intense \ninvolvement that is typical of agile methods and therefore may not interact \nwell with other team members.\nFigure 3.11 Agile \nprinciples and \norganizational practice\n\n\n92  Chapter 3 \u25a0 Agile software development\nunlikely to work. There needs to be some up-front planning, design, and documentation \nin the systems engineering process. Some of the key issues are as follows:\n1. \nHow large is the system that is being developed? Agile methods are most effective \nwhen the system can be developed with a relatively small co-located team who \ncan communicate informally. This may not be possible for large systems that \nrequire larger development teams, so a plan-driven approach may have to be used.\n2. What type of system is being developed? Systems that require a lot of analysis \nbefore implementation (e.g., real-time system with complex timing require-\nments) usually need a fairly detailed design to carry out this analysis. A plan-\ndriven approach may be best in those circumstances.\n3. What is the expected system lifetime? Long-lifetime systems may require more \ndesign documentation to communicate the original intentions of the system \ndevelopers to the support team. However, supporters of agile methods rightly \nargue that documentation is frequently not kept up to date and is not of much \nuse for long-term system maintenance.\n4. Is the system subject to external regulation? If a system has to be approved \nby\u00a0an external regulator (e.g., the Federal Aviation Administration approves \nsoftware that is critical to the operation of an aircraft), then you will probably be \nrequired to produce detailed documentation as part of the system safety\u00a0case.\nAgile methods place a great deal of responsibility on the development team to \ncooperate and communicate during the development of the system. They rely on indi-\nvidual engineering skills and software support for the development process. However, \nin reality, not everyone is a highly skilled engineer, people do not communicate effec-\ntively, and it is not always possible for teams to work together. Some planning may be \nrequired to make the most effective use of the people available. Key issues are:\n1. How good are the designers and programmers in the development team? \nIt\u00a0is\u00a0sometimes argued that agile methods require higher skill levels than plan-\nbased approaches in which programmers simply translate a detailed design into \ncode. If you have a team with relatively low skill levels, you may need to use \nthe best people to develop the design, with others responsible for programming.\nSystem\nTeam\nOrganization\nScale\nTechnology\nDistribution\nContracts\nDelivery\nRegulation\nType\nLifetime\nCompetence\nCulture\nFigure 3.12 Factors \ninfluencing the choice  \nof plan-based or agile \ndevelopment"}
{"query": "How does the competence of the team influence the choice of development approach?", "response": "The competence of the team can influence the choice of development approach. If the team consists of highly skilled designers and programmers, agile methods may be more suitable as they rely on individual engineering skills. However, if the team has relatively low skill levels, a plan-based approach may be more appropriate, where programmers simply translate a detailed design into code.", "context": "3.4  \u25a0 Scaling agile methods  91\n \n3.4.2  Agile and plan-driven methods\nA fundamental requirement of scaling agile methods is to integrate them with plan-\ndriven approaches. Small startup companies can work with informal and short-term \nplanning, but larger companies have to have longer-term plans and budgets for \ninvestment, staffing, and business development. Their software development must \nsupport these plans, so longer-term software planning is essential.\nEarly adopters of agile methods in the first decade of the 21st century were enthu-\nsiasts and deeply committed to the agile manifesto. They deliberately rejected the \nplan-driven approach to software engineering and were reluctant to change the ini-\ntial vision of agile methods in any way. However, as organizations saw the value and \nbenefits of an agile approach, they adapted these methods to suit their own culture \nand ways of working. They had to do this because the principles underlying agile \nmethods are sometimes difficult to realize in practice (Figure 3.11).\nTo address these problems, most large \u201cagile\u201d software development projects com-\nbine practices from plan-driven and agile approaches. Some are mostly agile, and others \nare mostly plan-driven but with some agile practices. To decide on the balance between \na plan-based and an agile approach, you have to answer a range of technical, human and \norganizational questions. These relate to the system being developed, the development \nteam, and the organizations that are developing and procuring the system (Figure 3.12).\nAgile methods were developed and refined in projects to develop small to medium-\nsized business systems and software products, where the software developer controls \nthe specification of the system. Other types of system have attributes such as size, com-\nplexity, real-time response, and external regulation that mean a \u201cpure\u201d agile approach is \nPrinciple\nPractice\nCustomer involvement\nThis depends on having a customer who is willing and able to spend time with \nthe development team and who can represent all system stakeholders. Often, \ncustomer representatives have other demands on their time and cannot play a \nfull part in the software development. Where there are external stakeholders, \nsuch as regulators, it is difficult to represent their views to the agile team.\nEmbrace change\nPrioritizing changes can be extremely difficult, especially in systems for which \nthere are many stakeholders. Typically, each stakeholder gives different \npriorities to different changes.\nIncremental delivery\nRapid iterations and short-term planning for development does not always fit \nin with the longer-term planning cycles of business planning and marketing. \nMarketing managers may need to know product features several months in \nadvance to prepare an effective marketing campaign.\nMaintain simplicity\nUnder pressure from delivery schedules, team members may not have time to \ncarry out desirable system simplifications.\nPeople, not process\nIndividual team members may not have suitable personalities for the intense \ninvolvement that is typical of agile methods and therefore may not interact \nwell with other team members.\nFigure 3.11 Agile \nprinciples and \norganizational practice\n\n\n92  Chapter 3 \u25a0 Agile software development\nunlikely to work. There needs to be some up-front planning, design, and documentation \nin the systems engineering process. Some of the key issues are as follows:\n1. \nHow large is the system that is being developed? Agile methods are most effective \nwhen the system can be developed with a relatively small co-located team who \ncan communicate informally. This may not be possible for large systems that \nrequire larger development teams, so a plan-driven approach may have to be used.\n2. What type of system is being developed? Systems that require a lot of analysis \nbefore implementation (e.g., real-time system with complex timing require-\nments) usually need a fairly detailed design to carry out this analysis. A plan-\ndriven approach may be best in those circumstances.\n3. What is the expected system lifetime? Long-lifetime systems may require more \ndesign documentation to communicate the original intentions of the system \ndevelopers to the support team. However, supporters of agile methods rightly \nargue that documentation is frequently not kept up to date and is not of much \nuse for long-term system maintenance.\n4. Is the system subject to external regulation? If a system has to be approved \nby\u00a0an external regulator (e.g., the Federal Aviation Administration approves \nsoftware that is critical to the operation of an aircraft), then you will probably be \nrequired to produce detailed documentation as part of the system safety\u00a0case.\nAgile methods place a great deal of responsibility on the development team to \ncooperate and communicate during the development of the system. They rely on indi-\nvidual engineering skills and software support for the development process. However, \nin reality, not everyone is a highly skilled engineer, people do not communicate effec-\ntively, and it is not always possible for teams to work together. Some planning may be \nrequired to make the most effective use of the people available. Key issues are:\n1. How good are the designers and programmers in the development team? \nIt\u00a0is\u00a0sometimes argued that agile methods require higher skill levels than plan-\nbased approaches in which programmers simply translate a detailed design into \ncode. If you have a team with relatively low skill levels, you may need to use \nthe best people to develop the design, with others responsible for programming.\nSystem\nTeam\nOrganization\nScale\nTechnology\nDistribution\nContracts\nDelivery\nRegulation\nType\nLifetime\nCompetence\nCulture\nFigure 3.12 Factors \ninfluencing the choice  \nof plan-based or agile \ndevelopment"}
{"query": "How does the culture of the organization influence the choice of development approach?", "response": "The culture of the organization can influence the choice of development approach. Agile methods rely on close collaboration and communication within the development team. If the organization has a culture that values teamwork, open communication, and flexibility, then an agile approach may be more suitable. On the other hand, if the organization has a more hierarchical and structured culture that values detailed planning and documentation, then a plan-driven approach may be preferred. The choice of development approach should align with the organization's culture to ensure successful implementation.", "context": "3.4  \u25a0 Scaling agile methods  91\n \n3.4.2  Agile and plan-driven methods\nA fundamental requirement of scaling agile methods is to integrate them with plan-\ndriven approaches. Small startup companies can work with informal and short-term \nplanning, but larger companies have to have longer-term plans and budgets for \ninvestment, staffing, and business development. Their software development must \nsupport these plans, so longer-term software planning is essential.\nEarly adopters of agile methods in the first decade of the 21st century were enthu-\nsiasts and deeply committed to the agile manifesto. They deliberately rejected the \nplan-driven approach to software engineering and were reluctant to change the ini-\ntial vision of agile methods in any way. However, as organizations saw the value and \nbenefits of an agile approach, they adapted these methods to suit their own culture \nand ways of working. They had to do this because the principles underlying agile \nmethods are sometimes difficult to realize in practice (Figure 3.11).\nTo address these problems, most large \u201cagile\u201d software development projects com-\nbine practices from plan-driven and agile approaches. Some are mostly agile, and others \nare mostly plan-driven but with some agile practices. To decide on the balance between \na plan-based and an agile approach, you have to answer a range of technical, human and \norganizational questions. These relate to the system being developed, the development \nteam, and the organizations that are developing and procuring the system (Figure 3.12).\nAgile methods were developed and refined in projects to develop small to medium-\nsized business systems and software products, where the software developer controls \nthe specification of the system. Other types of system have attributes such as size, com-\nplexity, real-time response, and external regulation that mean a \u201cpure\u201d agile approach is \nPrinciple\nPractice\nCustomer involvement\nThis depends on having a customer who is willing and able to spend time with \nthe development team and who can represent all system stakeholders. Often, \ncustomer representatives have other demands on their time and cannot play a \nfull part in the software development. Where there are external stakeholders, \nsuch as regulators, it is difficult to represent their views to the agile team.\nEmbrace change\nPrioritizing changes can be extremely difficult, especially in systems for which \nthere are many stakeholders. Typically, each stakeholder gives different \npriorities to different changes.\nIncremental delivery\nRapid iterations and short-term planning for development does not always fit \nin with the longer-term planning cycles of business planning and marketing. \nMarketing managers may need to know product features several months in \nadvance to prepare an effective marketing campaign.\nMaintain simplicity\nUnder pressure from delivery schedules, team members may not have time to \ncarry out desirable system simplifications.\nPeople, not process\nIndividual team members may not have suitable personalities for the intense \ninvolvement that is typical of agile methods and therefore may not interact \nwell with other team members.\nFigure 3.11 Agile \nprinciples and \norganizational practice\n\n\n92  Chapter 3 \u25a0 Agile software development\nunlikely to work. There needs to be some up-front planning, design, and documentation \nin the systems engineering process. Some of the key issues are as follows:\n1. \nHow large is the system that is being developed? Agile methods are most effective \nwhen the system can be developed with a relatively small co-located team who \ncan communicate informally. This may not be possible for large systems that \nrequire larger development teams, so a plan-driven approach may have to be used.\n2. What type of system is being developed? Systems that require a lot of analysis \nbefore implementation (e.g., real-time system with complex timing require-\nments) usually need a fairly detailed design to carry out this analysis. A plan-\ndriven approach may be best in those circumstances.\n3. What is the expected system lifetime? Long-lifetime systems may require more \ndesign documentation to communicate the original intentions of the system \ndevelopers to the support team. However, supporters of agile methods rightly \nargue that documentation is frequently not kept up to date and is not of much \nuse for long-term system maintenance.\n4. Is the system subject to external regulation? If a system has to be approved \nby\u00a0an external regulator (e.g., the Federal Aviation Administration approves \nsoftware that is critical to the operation of an aircraft), then you will probably be \nrequired to produce detailed documentation as part of the system safety\u00a0case.\nAgile methods place a great deal of responsibility on the development team to \ncooperate and communicate during the development of the system. They rely on indi-\nvidual engineering skills and software support for the development process. However, \nin reality, not everyone is a highly skilled engineer, people do not communicate effec-\ntively, and it is not always possible for teams to work together. Some planning may be \nrequired to make the most effective use of the people available. Key issues are:\n1. How good are the designers and programmers in the development team? \nIt\u00a0is\u00a0sometimes argued that agile methods require higher skill levels than plan-\nbased approaches in which programmers simply translate a detailed design into \ncode. If you have a team with relatively low skill levels, you may need to use \nthe best people to develop the design, with others responsible for programming.\nSystem\nTeam\nOrganization\nScale\nTechnology\nDistribution\nContracts\nDelivery\nRegulation\nType\nLifetime\nCompetence\nCulture\nFigure 3.12 Factors \ninfluencing the choice  \nof plan-based or agile \ndevelopment"}
{"query": "How does the organization itself influence the choice of development approach?", "response": "The organization itself can influence the choice of development approach based on factors such as its culture, competence, and the scale of the system being developed. If the organization has a culture that values flexibility, collaboration, and adaptability, it may be more inclined to adopt an agile approach. On the other hand, if the organization has a more traditional and hierarchical culture, it may prefer a plan-driven approach. The competence of the development team also plays a role, as agile methods require higher skill levels and effective communication among team members. Additionally, the scale of the system being developed can influence the choice of approach. Agile methods are most effective for relatively small systems that can be developed with a small co-located team, while larger systems may require a plan-driven approach.", "context": "3.4  \u25a0 Scaling agile methods  91\n \n3.4.2  Agile and plan-driven methods\nA fundamental requirement of scaling agile methods is to integrate them with plan-\ndriven approaches. Small startup companies can work with informal and short-term \nplanning, but larger companies have to have longer-term plans and budgets for \ninvestment, staffing, and business development. Their software development must \nsupport these plans, so longer-term software planning is essential.\nEarly adopters of agile methods in the first decade of the 21st century were enthu-\nsiasts and deeply committed to the agile manifesto. They deliberately rejected the \nplan-driven approach to software engineering and were reluctant to change the ini-\ntial vision of agile methods in any way. However, as organizations saw the value and \nbenefits of an agile approach, they adapted these methods to suit their own culture \nand ways of working. They had to do this because the principles underlying agile \nmethods are sometimes difficult to realize in practice (Figure 3.11).\nTo address these problems, most large \u201cagile\u201d software development projects com-\nbine practices from plan-driven and agile approaches. Some are mostly agile, and others \nare mostly plan-driven but with some agile practices. To decide on the balance between \na plan-based and an agile approach, you have to answer a range of technical, human and \norganizational questions. These relate to the system being developed, the development \nteam, and the organizations that are developing and procuring the system (Figure 3.12).\nAgile methods were developed and refined in projects to develop small to medium-\nsized business systems and software products, where the software developer controls \nthe specification of the system. Other types of system have attributes such as size, com-\nplexity, real-time response, and external regulation that mean a \u201cpure\u201d agile approach is \nPrinciple\nPractice\nCustomer involvement\nThis depends on having a customer who is willing and able to spend time with \nthe development team and who can represent all system stakeholders. Often, \ncustomer representatives have other demands on their time and cannot play a \nfull part in the software development. Where there are external stakeholders, \nsuch as regulators, it is difficult to represent their views to the agile team.\nEmbrace change\nPrioritizing changes can be extremely difficult, especially in systems for which \nthere are many stakeholders. Typically, each stakeholder gives different \npriorities to different changes.\nIncremental delivery\nRapid iterations and short-term planning for development does not always fit \nin with the longer-term planning cycles of business planning and marketing. \nMarketing managers may need to know product features several months in \nadvance to prepare an effective marketing campaign.\nMaintain simplicity\nUnder pressure from delivery schedules, team members may not have time to \ncarry out desirable system simplifications.\nPeople, not process\nIndividual team members may not have suitable personalities for the intense \ninvolvement that is typical of agile methods and therefore may not interact \nwell with other team members.\nFigure 3.11 Agile \nprinciples and \norganizational practice\n\n\n92  Chapter 3 \u25a0 Agile software development\nunlikely to work. There needs to be some up-front planning, design, and documentation \nin the systems engineering process. Some of the key issues are as follows:\n1. \nHow large is the system that is being developed? Agile methods are most effective \nwhen the system can be developed with a relatively small co-located team who \ncan communicate informally. This may not be possible for large systems that \nrequire larger development teams, so a plan-driven approach may have to be used.\n2. What type of system is being developed? Systems that require a lot of analysis \nbefore implementation (e.g., real-time system with complex timing require-\nments) usually need a fairly detailed design to carry out this analysis. A plan-\ndriven approach may be best in those circumstances.\n3. What is the expected system lifetime? Long-lifetime systems may require more \ndesign documentation to communicate the original intentions of the system \ndevelopers to the support team. However, supporters of agile methods rightly \nargue that documentation is frequently not kept up to date and is not of much \nuse for long-term system maintenance.\n4. Is the system subject to external regulation? If a system has to be approved \nby\u00a0an external regulator (e.g., the Federal Aviation Administration approves \nsoftware that is critical to the operation of an aircraft), then you will probably be \nrequired to produce detailed documentation as part of the system safety\u00a0case.\nAgile methods place a great deal of responsibility on the development team to \ncooperate and communicate during the development of the system. They rely on indi-\nvidual engineering skills and software support for the development process. However, \nin reality, not everyone is a highly skilled engineer, people do not communicate effec-\ntively, and it is not always possible for teams to work together. Some planning may be \nrequired to make the most effective use of the people available. Key issues are:\n1. How good are the designers and programmers in the development team? \nIt\u00a0is\u00a0sometimes argued that agile methods require higher skill levels than plan-\nbased approaches in which programmers simply translate a detailed design into \ncode. If you have a team with relatively low skill levels, you may need to use \nthe best people to develop the design, with others responsible for programming.\nSystem\nTeam\nOrganization\nScale\nTechnology\nDistribution\nContracts\nDelivery\nRegulation\nType\nLifetime\nCompetence\nCulture\nFigure 3.12 Factors \ninfluencing the choice  \nof plan-based or agile \ndevelopment"}
{"query": "What factors should be considered when organizing a development team?", "response": "When organizing a development team, several factors should be considered. One factor is whether the development team is distributed or if part of the development is being outsourced. In such cases, it may be necessary to develop design documents to facilitate communication across the development teams. Another factor to consider is the availability of technologies to support system development. Agile methods often rely on good tools to keep track of an evolving design, so it is important to have access to such tools. Additionally, the cultural context of the organization should be taken into account. Traditional engineering organizations may have a culture of plan-based development, which requires extensive design documentation. Finally, the willingness and availability of customer representatives to participate in the development team should also be considered, especially if an incremental delivery strategy is being pursued.", "context": "3.4  \u25a0 Scaling agile methods  93\n2. How is the development team organized? If the development team is distributed \nor if part of the development is being outsourced, then you may need to develop \ndesign documents to communicate across the development teams.\n3. What technologies are available to support system development? Agile methods \noften rely on good tools to keep track of an evolving design. If you are develop-\ning a system using an IDE that does not have good tools for program visualiza-\ntion and analysis, then more design documentation may be required.\nTelevision and films have created a popular vision of software companies as \ninformal organizations run by young men (mostly) who provide a fashionable work-\ning environment, with a minimum of bureaucracy and organizational procedures. \nThis is far from the truth. Most software is developed in large companies that have \nestablished their own working practices and procedures. Management in these \n companies may be uncomfortable with the lack of documentation and the informal \ndecision making in agile methods. Key issues are:\n1. Is it important to have a very detailed specification and design before moving to \nimplementation, perhaps for contractual reasons? If so, you probably need to \nuse a plan-driven approach for requirements engineering but may use agile \ndevelopment practices during system implementation.\n2. Is an incremental delivery strategy, where you deliver the software to customers \nor other system stakeholders and get rapid feedback from them, realistic? Will \ncustomer representatives be available, and are they willing to participate in the \ndevelopment team?\n3. Are there cultural issues that may affect system development? Traditional engi-\nneering organizations have a culture of plan-based development, as this is the \nnorm in engineering. This usually requires extensive design documentation \nrather than the informal knowledge used in agile processes.\nIn reality, the issue of whether a project can be labeled as plan-driven or agile \nis\u00a0not very important. Ultimately, the primary concern of buyers of a software  system \nis whether or not they have an executable software system that meets their needs and \ndoes useful things for the individual user or the organization. Software developers \nshould be pragmatic and should choose those methods that are most effective for the \ntype of system being developed, whether or not these are labeled agile or plan-driven.\n \n3.4.3  Agile methods for large systems\nAgile methods have to evolve to be used for large-scale software development. \nThe fundamental reason for this is that large-scale software systems are much \nmore complex and difficult to understand and manage than small-scale systems \nor software products. Six principal factors (Figure 3.13) contribute to this \n complexity:\n\n\n94  Chapter 3 \u25a0 Agile software development\n1. Large systems are usually systems of systems\u2014collections of separate, com-\nmunicating systems, where separate teams develop each system. Frequently, \nthese teams are working in different places, sometimes in different time zones. \nIt is practically impossible for each team to have a view of the whole system. \nConsequently, their priorities are usually to complete their part of the system \nwithout regard for wider systems issues.\n2. \nLarge systems are brownfield systems (Hopkins and Jenkins 2008); that is, they \ninclude and interact with a number of existing systems. Many of the system require-\nments are concerned with this interaction and so don\u2019t really lend themselves to \nflexibility and incremental development. Political issues can also be significant \nhere\u2014often the easiest solution to a problem is to change an existing system. \nHowever, this requires negotiation with the managers of that system to convince \nthem that the changes can be implemented without risk to the system\u2019s operation.\n3. Where several systems are integrated to create a system, a significant fraction of \nthe development is concerned with system configuration rather than original \ncode development. This is not necessarily compatible with incremental devel-\nopment and frequent system integration.\n4. Large systems and their development processes are often constrained by exter-\nnal rules and regulations limiting the way that they can be developed, that \nrequire certain types of system documentation to be produced, and so on. \nCustomers may have specific compliance requirements that may have to be fol-\nlowed, and these may require process documentation to be completed.\n5. Large systems have a long procurement and development time. It is difficult to \nmaintain coherent teams who know about the system over that period as, inevi-\ntably, people move on to other jobs and projects.\n6. Large systems usually have a diverse set of stakeholders with different perspec-\ntives and objectives. For example, nurses and administrators may be the end-users \nof a medical system, but senior medical staff, hospital managers, and others, are \nalso stakeholders in the system. It is practically impossible to involve all of \nthese different stakeholders in the development process.\nLarge software system\nSystem of\nsystems\nBrownfield\ndevelopment\nDiverse\nstakeholders\nProlonged\nprocurement\nSystem\nconfiguration\nRegulatory\nconstraints\nFigure 3.13 Large \nproject characteristics"}
{"query": "How can design documents be used in a distributed development team?", "response": "Design documents can be used in a distributed development team to facilitate communication across the teams. Since the development team is distributed or part of the development is being outsourced, design documents can serve as a means to convey the design and requirements of the system to all team members. These documents can provide a common understanding of the system architecture, functionality, and interfaces, ensuring that all team members are aligned and working towards the same goals. Design documents can also help in coordinating the efforts of different teams by providing a reference for integration and collaboration.", "context": "3.4  \u25a0 Scaling agile methods  93\n2. How is the development team organized? If the development team is distributed \nor if part of the development is being outsourced, then you may need to develop \ndesign documents to communicate across the development teams.\n3. What technologies are available to support system development? Agile methods \noften rely on good tools to keep track of an evolving design. If you are develop-\ning a system using an IDE that does not have good tools for program visualiza-\ntion and analysis, then more design documentation may be required.\nTelevision and films have created a popular vision of software companies as \ninformal organizations run by young men (mostly) who provide a fashionable work-\ning environment, with a minimum of bureaucracy and organizational procedures. \nThis is far from the truth. Most software is developed in large companies that have \nestablished their own working practices and procedures. Management in these \n companies may be uncomfortable with the lack of documentation and the informal \ndecision making in agile methods. Key issues are:\n1. Is it important to have a very detailed specification and design before moving to \nimplementation, perhaps for contractual reasons? If so, you probably need to \nuse a plan-driven approach for requirements engineering but may use agile \ndevelopment practices during system implementation.\n2. Is an incremental delivery strategy, where you deliver the software to customers \nor other system stakeholders and get rapid feedback from them, realistic? Will \ncustomer representatives be available, and are they willing to participate in the \ndevelopment team?\n3. Are there cultural issues that may affect system development? Traditional engi-\nneering organizations have a culture of plan-based development, as this is the \nnorm in engineering. This usually requires extensive design documentation \nrather than the informal knowledge used in agile processes.\nIn reality, the issue of whether a project can be labeled as plan-driven or agile \nis\u00a0not very important. Ultimately, the primary concern of buyers of a software  system \nis whether or not they have an executable software system that meets their needs and \ndoes useful things for the individual user or the organization. Software developers \nshould be pragmatic and should choose those methods that are most effective for the \ntype of system being developed, whether or not these are labeled agile or plan-driven.\n \n3.4.3  Agile methods for large systems\nAgile methods have to evolve to be used for large-scale software development. \nThe fundamental reason for this is that large-scale software systems are much \nmore complex and difficult to understand and manage than small-scale systems \nor software products. Six principal factors (Figure 3.13) contribute to this \n complexity:\n\n\n94  Chapter 3 \u25a0 Agile software development\n1. Large systems are usually systems of systems\u2014collections of separate, com-\nmunicating systems, where separate teams develop each system. Frequently, \nthese teams are working in different places, sometimes in different time zones. \nIt is practically impossible for each team to have a view of the whole system. \nConsequently, their priorities are usually to complete their part of the system \nwithout regard for wider systems issues.\n2. \nLarge systems are brownfield systems (Hopkins and Jenkins 2008); that is, they \ninclude and interact with a number of existing systems. Many of the system require-\nments are concerned with this interaction and so don\u2019t really lend themselves to \nflexibility and incremental development. Political issues can also be significant \nhere\u2014often the easiest solution to a problem is to change an existing system. \nHowever, this requires negotiation with the managers of that system to convince \nthem that the changes can be implemented without risk to the system\u2019s operation.\n3. Where several systems are integrated to create a system, a significant fraction of \nthe development is concerned with system configuration rather than original \ncode development. This is not necessarily compatible with incremental devel-\nopment and frequent system integration.\n4. Large systems and their development processes are often constrained by exter-\nnal rules and regulations limiting the way that they can be developed, that \nrequire certain types of system documentation to be produced, and so on. \nCustomers may have specific compliance requirements that may have to be fol-\nlowed, and these may require process documentation to be completed.\n5. Large systems have a long procurement and development time. It is difficult to \nmaintain coherent teams who know about the system over that period as, inevi-\ntably, people move on to other jobs and projects.\n6. Large systems usually have a diverse set of stakeholders with different perspec-\ntives and objectives. For example, nurses and administrators may be the end-users \nof a medical system, but senior medical staff, hospital managers, and others, are \nalso stakeholders in the system. It is practically impossible to involve all of \nthese different stakeholders in the development process.\nLarge software system\nSystem of\nsystems\nBrownfield\ndevelopment\nDiverse\nstakeholders\nProlonged\nprocurement\nSystem\nconfiguration\nRegulatory\nconstraints\nFigure 3.13 Large \nproject characteristics"}
{"query": "What role do technologies play in supporting system development?", "response": "Technologies play a crucial role in supporting system development. Agile methods, in particular, rely on good tools to keep track of an evolving design. These tools can help with program visualization and analysis, making it easier for development teams to collaborate and communicate effectively. If an Integrated Development Environment (IDE) lacks these tools, more design documentation may be required to compensate for the lack of visual representation and analysis capabilities. Therefore, having the right technologies in place can enhance the efficiency and effectiveness of system development processes.", "context": "3.4  \u25a0 Scaling agile methods  93\n2. How is the development team organized? If the development team is distributed \nor if part of the development is being outsourced, then you may need to develop \ndesign documents to communicate across the development teams.\n3. What technologies are available to support system development? Agile methods \noften rely on good tools to keep track of an evolving design. If you are develop-\ning a system using an IDE that does not have good tools for program visualiza-\ntion and analysis, then more design documentation may be required.\nTelevision and films have created a popular vision of software companies as \ninformal organizations run by young men (mostly) who provide a fashionable work-\ning environment, with a minimum of bureaucracy and organizational procedures. \nThis is far from the truth. Most software is developed in large companies that have \nestablished their own working practices and procedures. Management in these \n companies may be uncomfortable with the lack of documentation and the informal \ndecision making in agile methods. Key issues are:\n1. Is it important to have a very detailed specification and design before moving to \nimplementation, perhaps for contractual reasons? If so, you probably need to \nuse a plan-driven approach for requirements engineering but may use agile \ndevelopment practices during system implementation.\n2. Is an incremental delivery strategy, where you deliver the software to customers \nor other system stakeholders and get rapid feedback from them, realistic? Will \ncustomer representatives be available, and are they willing to participate in the \ndevelopment team?\n3. Are there cultural issues that may affect system development? Traditional engi-\nneering organizations have a culture of plan-based development, as this is the \nnorm in engineering. This usually requires extensive design documentation \nrather than the informal knowledge used in agile processes.\nIn reality, the issue of whether a project can be labeled as plan-driven or agile \nis\u00a0not very important. Ultimately, the primary concern of buyers of a software  system \nis whether or not they have an executable software system that meets their needs and \ndoes useful things for the individual user or the organization. Software developers \nshould be pragmatic and should choose those methods that are most effective for the \ntype of system being developed, whether or not these are labeled agile or plan-driven.\n \n3.4.3  Agile methods for large systems\nAgile methods have to evolve to be used for large-scale software development. \nThe fundamental reason for this is that large-scale software systems are much \nmore complex and difficult to understand and manage than small-scale systems \nor software products. Six principal factors (Figure 3.13) contribute to this \n complexity:\n\n\n94  Chapter 3 \u25a0 Agile software development\n1. Large systems are usually systems of systems\u2014collections of separate, com-\nmunicating systems, where separate teams develop each system. Frequently, \nthese teams are working in different places, sometimes in different time zones. \nIt is practically impossible for each team to have a view of the whole system. \nConsequently, their priorities are usually to complete their part of the system \nwithout regard for wider systems issues.\n2. \nLarge systems are brownfield systems (Hopkins and Jenkins 2008); that is, they \ninclude and interact with a number of existing systems. Many of the system require-\nments are concerned with this interaction and so don\u2019t really lend themselves to \nflexibility and incremental development. Political issues can also be significant \nhere\u2014often the easiest solution to a problem is to change an existing system. \nHowever, this requires negotiation with the managers of that system to convince \nthem that the changes can be implemented without risk to the system\u2019s operation.\n3. Where several systems are integrated to create a system, a significant fraction of \nthe development is concerned with system configuration rather than original \ncode development. This is not necessarily compatible with incremental devel-\nopment and frequent system integration.\n4. Large systems and their development processes are often constrained by exter-\nnal rules and regulations limiting the way that they can be developed, that \nrequire certain types of system documentation to be produced, and so on. \nCustomers may have specific compliance requirements that may have to be fol-\nlowed, and these may require process documentation to be completed.\n5. Large systems have a long procurement and development time. It is difficult to \nmaintain coherent teams who know about the system over that period as, inevi-\ntably, people move on to other jobs and projects.\n6. Large systems usually have a diverse set of stakeholders with different perspec-\ntives and objectives. For example, nurses and administrators may be the end-users \nof a medical system, but senior medical staff, hospital managers, and others, are \nalso stakeholders in the system. It is practically impossible to involve all of \nthese different stakeholders in the development process.\nLarge software system\nSystem of\nsystems\nBrownfield\ndevelopment\nDiverse\nstakeholders\nProlonged\nprocurement\nSystem\nconfiguration\nRegulatory\nconstraints\nFigure 3.13 Large \nproject characteristics"}
{"query": "How do agile methods rely on tools for system development?", "response": "Agile methods rely on good tools to keep track of an evolving design. These tools are used to support system development by providing program visualization and analysis capabilities. If an IDE (Integrated Development Environment) does not have these tools, then more design documentation may be required in agile methods.", "context": "3.4  \u25a0 Scaling agile methods  93\n2. How is the development team organized? If the development team is distributed \nor if part of the development is being outsourced, then you may need to develop \ndesign documents to communicate across the development teams.\n3. What technologies are available to support system development? Agile methods \noften rely on good tools to keep track of an evolving design. If you are develop-\ning a system using an IDE that does not have good tools for program visualiza-\ntion and analysis, then more design documentation may be required.\nTelevision and films have created a popular vision of software companies as \ninformal organizations run by young men (mostly) who provide a fashionable work-\ning environment, with a minimum of bureaucracy and organizational procedures. \nThis is far from the truth. Most software is developed in large companies that have \nestablished their own working practices and procedures. Management in these \n companies may be uncomfortable with the lack of documentation and the informal \ndecision making in agile methods. Key issues are:\n1. Is it important to have a very detailed specification and design before moving to \nimplementation, perhaps for contractual reasons? If so, you probably need to \nuse a plan-driven approach for requirements engineering but may use agile \ndevelopment practices during system implementation.\n2. Is an incremental delivery strategy, where you deliver the software to customers \nor other system stakeholders and get rapid feedback from them, realistic? Will \ncustomer representatives be available, and are they willing to participate in the \ndevelopment team?\n3. Are there cultural issues that may affect system development? Traditional engi-\nneering organizations have a culture of plan-based development, as this is the \nnorm in engineering. This usually requires extensive design documentation \nrather than the informal knowledge used in agile processes.\nIn reality, the issue of whether a project can be labeled as plan-driven or agile \nis\u00a0not very important. Ultimately, the primary concern of buyers of a software  system \nis whether or not they have an executable software system that meets their needs and \ndoes useful things for the individual user or the organization. Software developers \nshould be pragmatic and should choose those methods that are most effective for the \ntype of system being developed, whether or not these are labeled agile or plan-driven.\n \n3.4.3  Agile methods for large systems\nAgile methods have to evolve to be used for large-scale software development. \nThe fundamental reason for this is that large-scale software systems are much \nmore complex and difficult to understand and manage than small-scale systems \nor software products. Six principal factors (Figure 3.13) contribute to this \n complexity:\n\n\n94  Chapter 3 \u25a0 Agile software development\n1. Large systems are usually systems of systems\u2014collections of separate, com-\nmunicating systems, where separate teams develop each system. Frequently, \nthese teams are working in different places, sometimes in different time zones. \nIt is practically impossible for each team to have a view of the whole system. \nConsequently, their priorities are usually to complete their part of the system \nwithout regard for wider systems issues.\n2. \nLarge systems are brownfield systems (Hopkins and Jenkins 2008); that is, they \ninclude and interact with a number of existing systems. Many of the system require-\nments are concerned with this interaction and so don\u2019t really lend themselves to \nflexibility and incremental development. Political issues can also be significant \nhere\u2014often the easiest solution to a problem is to change an existing system. \nHowever, this requires negotiation with the managers of that system to convince \nthem that the changes can be implemented without risk to the system\u2019s operation.\n3. Where several systems are integrated to create a system, a significant fraction of \nthe development is concerned with system configuration rather than original \ncode development. This is not necessarily compatible with incremental devel-\nopment and frequent system integration.\n4. Large systems and their development processes are often constrained by exter-\nnal rules and regulations limiting the way that they can be developed, that \nrequire certain types of system documentation to be produced, and so on. \nCustomers may have specific compliance requirements that may have to be fol-\nlowed, and these may require process documentation to be completed.\n5. Large systems have a long procurement and development time. It is difficult to \nmaintain coherent teams who know about the system over that period as, inevi-\ntably, people move on to other jobs and projects.\n6. Large systems usually have a diverse set of stakeholders with different perspec-\ntives and objectives. For example, nurses and administrators may be the end-users \nof a medical system, but senior medical staff, hospital managers, and others, are \nalso stakeholders in the system. It is practically impossible to involve all of \nthese different stakeholders in the development process.\nLarge software system\nSystem of\nsystems\nBrownfield\ndevelopment\nDiverse\nstakeholders\nProlonged\nprocurement\nSystem\nconfiguration\nRegulatory\nconstraints\nFigure 3.13 Large \nproject characteristics"}
{"query": "What might necessitate more design documentation in system development?", "response": "The use of an IDE that does not have good tools for program visualization and analysis may necessitate more design documentation in system development.", "context": "3.4  \u25a0 Scaling agile methods  93\n2. How is the development team organized? If the development team is distributed \nor if part of the development is being outsourced, then you may need to develop \ndesign documents to communicate across the development teams.\n3. What technologies are available to support system development? Agile methods \noften rely on good tools to keep track of an evolving design. If you are develop-\ning a system using an IDE that does not have good tools for program visualiza-\ntion and analysis, then more design documentation may be required.\nTelevision and films have created a popular vision of software companies as \ninformal organizations run by young men (mostly) who provide a fashionable work-\ning environment, with a minimum of bureaucracy and organizational procedures. \nThis is far from the truth. Most software is developed in large companies that have \nestablished their own working practices and procedures. Management in these \n companies may be uncomfortable with the lack of documentation and the informal \ndecision making in agile methods. Key issues are:\n1. Is it important to have a very detailed specification and design before moving to \nimplementation, perhaps for contractual reasons? If so, you probably need to \nuse a plan-driven approach for requirements engineering but may use agile \ndevelopment practices during system implementation.\n2. Is an incremental delivery strategy, where you deliver the software to customers \nor other system stakeholders and get rapid feedback from them, realistic? Will \ncustomer representatives be available, and are they willing to participate in the \ndevelopment team?\n3. Are there cultural issues that may affect system development? Traditional engi-\nneering organizations have a culture of plan-based development, as this is the \nnorm in engineering. This usually requires extensive design documentation \nrather than the informal knowledge used in agile processes.\nIn reality, the issue of whether a project can be labeled as plan-driven or agile \nis\u00a0not very important. Ultimately, the primary concern of buyers of a software  system \nis whether or not they have an executable software system that meets their needs and \ndoes useful things for the individual user or the organization. Software developers \nshould be pragmatic and should choose those methods that are most effective for the \ntype of system being developed, whether or not these are labeled agile or plan-driven.\n \n3.4.3  Agile methods for large systems\nAgile methods have to evolve to be used for large-scale software development. \nThe fundamental reason for this is that large-scale software systems are much \nmore complex and difficult to understand and manage than small-scale systems \nor software products. Six principal factors (Figure 3.13) contribute to this \n complexity:\n\n\n94  Chapter 3 \u25a0 Agile software development\n1. Large systems are usually systems of systems\u2014collections of separate, com-\nmunicating systems, where separate teams develop each system. Frequently, \nthese teams are working in different places, sometimes in different time zones. \nIt is practically impossible for each team to have a view of the whole system. \nConsequently, their priorities are usually to complete their part of the system \nwithout regard for wider systems issues.\n2. \nLarge systems are brownfield systems (Hopkins and Jenkins 2008); that is, they \ninclude and interact with a number of existing systems. Many of the system require-\nments are concerned with this interaction and so don\u2019t really lend themselves to \nflexibility and incremental development. Political issues can also be significant \nhere\u2014often the easiest solution to a problem is to change an existing system. \nHowever, this requires negotiation with the managers of that system to convince \nthem that the changes can be implemented without risk to the system\u2019s operation.\n3. Where several systems are integrated to create a system, a significant fraction of \nthe development is concerned with system configuration rather than original \ncode development. This is not necessarily compatible with incremental devel-\nopment and frequent system integration.\n4. Large systems and their development processes are often constrained by exter-\nnal rules and regulations limiting the way that they can be developed, that \nrequire certain types of system documentation to be produced, and so on. \nCustomers may have specific compliance requirements that may have to be fol-\nlowed, and these may require process documentation to be completed.\n5. Large systems have a long procurement and development time. It is difficult to \nmaintain coherent teams who know about the system over that period as, inevi-\ntably, people move on to other jobs and projects.\n6. Large systems usually have a diverse set of stakeholders with different perspec-\ntives and objectives. For example, nurses and administrators may be the end-users \nof a medical system, but senior medical staff, hospital managers, and others, are \nalso stakeholders in the system. It is practically impossible to involve all of \nthese different stakeholders in the development process.\nLarge software system\nSystem of\nsystems\nBrownfield\ndevelopment\nDiverse\nstakeholders\nProlonged\nprocurement\nSystem\nconfiguration\nRegulatory\nconstraints\nFigure 3.13 Large \nproject characteristics"}
{"query": "How is the popular vision of software companies different from the reality?", "response": "The popular vision of software companies as portrayed in television and films is that they are informal organizations run by young men, providing a fashionable working environment with minimal bureaucracy and organizational procedures. However, the reality is quite different. Most software is developed in large companies that have established their own working practices and procedures. These companies often have management that is uncomfortable with the lack of documentation and informal decision-making in agile methods.", "context": "3.4  \u25a0 Scaling agile methods  93\n2. How is the development team organized? If the development team is distributed \nor if part of the development is being outsourced, then you may need to develop \ndesign documents to communicate across the development teams.\n3. What technologies are available to support system development? Agile methods \noften rely on good tools to keep track of an evolving design. If you are develop-\ning a system using an IDE that does not have good tools for program visualiza-\ntion and analysis, then more design documentation may be required.\nTelevision and films have created a popular vision of software companies as \ninformal organizations run by young men (mostly) who provide a fashionable work-\ning environment, with a minimum of bureaucracy and organizational procedures. \nThis is far from the truth. Most software is developed in large companies that have \nestablished their own working practices and procedures. Management in these \n companies may be uncomfortable with the lack of documentation and the informal \ndecision making in agile methods. Key issues are:\n1. Is it important to have a very detailed specification and design before moving to \nimplementation, perhaps for contractual reasons? If so, you probably need to \nuse a plan-driven approach for requirements engineering but may use agile \ndevelopment practices during system implementation.\n2. Is an incremental delivery strategy, where you deliver the software to customers \nor other system stakeholders and get rapid feedback from them, realistic? Will \ncustomer representatives be available, and are they willing to participate in the \ndevelopment team?\n3. Are there cultural issues that may affect system development? Traditional engi-\nneering organizations have a culture of plan-based development, as this is the \nnorm in engineering. This usually requires extensive design documentation \nrather than the informal knowledge used in agile processes.\nIn reality, the issue of whether a project can be labeled as plan-driven or agile \nis\u00a0not very important. Ultimately, the primary concern of buyers of a software  system \nis whether or not they have an executable software system that meets their needs and \ndoes useful things for the individual user or the organization. Software developers \nshould be pragmatic and should choose those methods that are most effective for the \ntype of system being developed, whether or not these are labeled agile or plan-driven.\n \n3.4.3  Agile methods for large systems\nAgile methods have to evolve to be used for large-scale software development. \nThe fundamental reason for this is that large-scale software systems are much \nmore complex and difficult to understand and manage than small-scale systems \nor software products. Six principal factors (Figure 3.13) contribute to this \n complexity:\n\n\n94  Chapter 3 \u25a0 Agile software development\n1. Large systems are usually systems of systems\u2014collections of separate, com-\nmunicating systems, where separate teams develop each system. Frequently, \nthese teams are working in different places, sometimes in different time zones. \nIt is practically impossible for each team to have a view of the whole system. \nConsequently, their priorities are usually to complete their part of the system \nwithout regard for wider systems issues.\n2. \nLarge systems are brownfield systems (Hopkins and Jenkins 2008); that is, they \ninclude and interact with a number of existing systems. Many of the system require-\nments are concerned with this interaction and so don\u2019t really lend themselves to \nflexibility and incremental development. Political issues can also be significant \nhere\u2014often the easiest solution to a problem is to change an existing system. \nHowever, this requires negotiation with the managers of that system to convince \nthem that the changes can be implemented without risk to the system\u2019s operation.\n3. Where several systems are integrated to create a system, a significant fraction of \nthe development is concerned with system configuration rather than original \ncode development. This is not necessarily compatible with incremental devel-\nopment and frequent system integration.\n4. Large systems and their development processes are often constrained by exter-\nnal rules and regulations limiting the way that they can be developed, that \nrequire certain types of system documentation to be produced, and so on. \nCustomers may have specific compliance requirements that may have to be fol-\nlowed, and these may require process documentation to be completed.\n5. Large systems have a long procurement and development time. It is difficult to \nmaintain coherent teams who know about the system over that period as, inevi-\ntably, people move on to other jobs and projects.\n6. Large systems usually have a diverse set of stakeholders with different perspec-\ntives and objectives. For example, nurses and administrators may be the end-users \nof a medical system, but senior medical staff, hospital managers, and others, are \nalso stakeholders in the system. It is practically impossible to involve all of \nthese different stakeholders in the development process.\nLarge software system\nSystem of\nsystems\nBrownfield\ndevelopment\nDiverse\nstakeholders\nProlonged\nprocurement\nSystem\nconfiguration\nRegulatory\nconstraints\nFigure 3.13 Large \nproject characteristics"}
{"query": "What are some common practices in large software companies?", "response": "Large software companies often have established working practices and procedures. They may require detailed specifications and designs before moving to implementation, especially for contractual reasons. These companies may also have a culture of plan-based development, which typically involves extensive design documentation. Additionally, large software companies may have external rules and regulations that limit the way they can develop software and require specific types of system documentation to be produced. They may also face challenges in maintaining coherent teams over a long procurement and development time, as people often move on to other jobs and projects.", "context": "3.4  \u25a0 Scaling agile methods  93\n2. How is the development team organized? If the development team is distributed \nor if part of the development is being outsourced, then you may need to develop \ndesign documents to communicate across the development teams.\n3. What technologies are available to support system development? Agile methods \noften rely on good tools to keep track of an evolving design. If you are develop-\ning a system using an IDE that does not have good tools for program visualiza-\ntion and analysis, then more design documentation may be required.\nTelevision and films have created a popular vision of software companies as \ninformal organizations run by young men (mostly) who provide a fashionable work-\ning environment, with a minimum of bureaucracy and organizational procedures. \nThis is far from the truth. Most software is developed in large companies that have \nestablished their own working practices and procedures. Management in these \n companies may be uncomfortable with the lack of documentation and the informal \ndecision making in agile methods. Key issues are:\n1. Is it important to have a very detailed specification and design before moving to \nimplementation, perhaps for contractual reasons? If so, you probably need to \nuse a plan-driven approach for requirements engineering but may use agile \ndevelopment practices during system implementation.\n2. Is an incremental delivery strategy, where you deliver the software to customers \nor other system stakeholders and get rapid feedback from them, realistic? Will \ncustomer representatives be available, and are they willing to participate in the \ndevelopment team?\n3. Are there cultural issues that may affect system development? Traditional engi-\nneering organizations have a culture of plan-based development, as this is the \nnorm in engineering. This usually requires extensive design documentation \nrather than the informal knowledge used in agile processes.\nIn reality, the issue of whether a project can be labeled as plan-driven or agile \nis\u00a0not very important. Ultimately, the primary concern of buyers of a software  system \nis whether or not they have an executable software system that meets their needs and \ndoes useful things for the individual user or the organization. Software developers \nshould be pragmatic and should choose those methods that are most effective for the \ntype of system being developed, whether or not these are labeled agile or plan-driven.\n \n3.4.3  Agile methods for large systems\nAgile methods have to evolve to be used for large-scale software development. \nThe fundamental reason for this is that large-scale software systems are much \nmore complex and difficult to understand and manage than small-scale systems \nor software products. Six principal factors (Figure 3.13) contribute to this \n complexity:\n\n\n94  Chapter 3 \u25a0 Agile software development\n1. Large systems are usually systems of systems\u2014collections of separate, com-\nmunicating systems, where separate teams develop each system. Frequently, \nthese teams are working in different places, sometimes in different time zones. \nIt is practically impossible for each team to have a view of the whole system. \nConsequently, their priorities are usually to complete their part of the system \nwithout regard for wider systems issues.\n2. \nLarge systems are brownfield systems (Hopkins and Jenkins 2008); that is, they \ninclude and interact with a number of existing systems. Many of the system require-\nments are concerned with this interaction and so don\u2019t really lend themselves to \nflexibility and incremental development. Political issues can also be significant \nhere\u2014often the easiest solution to a problem is to change an existing system. \nHowever, this requires negotiation with the managers of that system to convince \nthem that the changes can be implemented without risk to the system\u2019s operation.\n3. Where several systems are integrated to create a system, a significant fraction of \nthe development is concerned with system configuration rather than original \ncode development. This is not necessarily compatible with incremental devel-\nopment and frequent system integration.\n4. Large systems and their development processes are often constrained by exter-\nnal rules and regulations limiting the way that they can be developed, that \nrequire certain types of system documentation to be produced, and so on. \nCustomers may have specific compliance requirements that may have to be fol-\nlowed, and these may require process documentation to be completed.\n5. Large systems have a long procurement and development time. It is difficult to \nmaintain coherent teams who know about the system over that period as, inevi-\ntably, people move on to other jobs and projects.\n6. Large systems usually have a diverse set of stakeholders with different perspec-\ntives and objectives. For example, nurses and administrators may be the end-users \nof a medical system, but senior medical staff, hospital managers, and others, are \nalso stakeholders in the system. It is practically impossible to involve all of \nthese different stakeholders in the development process.\nLarge software system\nSystem of\nsystems\nBrownfield\ndevelopment\nDiverse\nstakeholders\nProlonged\nprocurement\nSystem\nconfiguration\nRegulatory\nconstraints\nFigure 3.13 Large \nproject characteristics"}
{"query": "What are some key issues with the use of agile methods in large companies?", "response": "Some key issues with the use of agile methods in large companies include the discomfort of management with the lack of documentation and informal decision making, the importance of having a detailed specification and design before implementation for contractual reasons, the feasibility of an incremental delivery strategy and the availability and willingness of customer representatives to participate in the development team, and the cultural issues that may affect system development, such as the traditional engineering culture of plan-based development and extensive design documentation.", "context": "3.4  \u25a0 Scaling agile methods  93\n2. How is the development team organized? If the development team is distributed \nor if part of the development is being outsourced, then you may need to develop \ndesign documents to communicate across the development teams.\n3. What technologies are available to support system development? Agile methods \noften rely on good tools to keep track of an evolving design. If you are develop-\ning a system using an IDE that does not have good tools for program visualiza-\ntion and analysis, then more design documentation may be required.\nTelevision and films have created a popular vision of software companies as \ninformal organizations run by young men (mostly) who provide a fashionable work-\ning environment, with a minimum of bureaucracy and organizational procedures. \nThis is far from the truth. Most software is developed in large companies that have \nestablished their own working practices and procedures. Management in these \n companies may be uncomfortable with the lack of documentation and the informal \ndecision making in agile methods. Key issues are:\n1. Is it important to have a very detailed specification and design before moving to \nimplementation, perhaps for contractual reasons? If so, you probably need to \nuse a plan-driven approach for requirements engineering but may use agile \ndevelopment practices during system implementation.\n2. Is an incremental delivery strategy, where you deliver the software to customers \nor other system stakeholders and get rapid feedback from them, realistic? Will \ncustomer representatives be available, and are they willing to participate in the \ndevelopment team?\n3. Are there cultural issues that may affect system development? Traditional engi-\nneering organizations have a culture of plan-based development, as this is the \nnorm in engineering. This usually requires extensive design documentation \nrather than the informal knowledge used in agile processes.\nIn reality, the issue of whether a project can be labeled as plan-driven or agile \nis\u00a0not very important. Ultimately, the primary concern of buyers of a software  system \nis whether or not they have an executable software system that meets their needs and \ndoes useful things for the individual user or the organization. Software developers \nshould be pragmatic and should choose those methods that are most effective for the \ntype of system being developed, whether or not these are labeled agile or plan-driven.\n \n3.4.3  Agile methods for large systems\nAgile methods have to evolve to be used for large-scale software development. \nThe fundamental reason for this is that large-scale software systems are much \nmore complex and difficult to understand and manage than small-scale systems \nor software products. Six principal factors (Figure 3.13) contribute to this \n complexity:\n\n\n94  Chapter 3 \u25a0 Agile software development\n1. Large systems are usually systems of systems\u2014collections of separate, com-\nmunicating systems, where separate teams develop each system. Frequently, \nthese teams are working in different places, sometimes in different time zones. \nIt is practically impossible for each team to have a view of the whole system. \nConsequently, their priorities are usually to complete their part of the system \nwithout regard for wider systems issues.\n2. \nLarge systems are brownfield systems (Hopkins and Jenkins 2008); that is, they \ninclude and interact with a number of existing systems. Many of the system require-\nments are concerned with this interaction and so don\u2019t really lend themselves to \nflexibility and incremental development. Political issues can also be significant \nhere\u2014often the easiest solution to a problem is to change an existing system. \nHowever, this requires negotiation with the managers of that system to convince \nthem that the changes can be implemented without risk to the system\u2019s operation.\n3. Where several systems are integrated to create a system, a significant fraction of \nthe development is concerned with system configuration rather than original \ncode development. This is not necessarily compatible with incremental devel-\nopment and frequent system integration.\n4. Large systems and their development processes are often constrained by exter-\nnal rules and regulations limiting the way that they can be developed, that \nrequire certain types of system documentation to be produced, and so on. \nCustomers may have specific compliance requirements that may have to be fol-\nlowed, and these may require process documentation to be completed.\n5. Large systems have a long procurement and development time. It is difficult to \nmaintain coherent teams who know about the system over that period as, inevi-\ntably, people move on to other jobs and projects.\n6. Large systems usually have a diverse set of stakeholders with different perspec-\ntives and objectives. For example, nurses and administrators may be the end-users \nof a medical system, but senior medical staff, hospital managers, and others, are \nalso stakeholders in the system. It is practically impossible to involve all of \nthese different stakeholders in the development process.\nLarge software system\nSystem of\nsystems\nBrownfield\ndevelopment\nDiverse\nstakeholders\nProlonged\nprocurement\nSystem\nconfiguration\nRegulatory\nconstraints\nFigure 3.13 Large \nproject characteristics"}
{"query": "What factors might necessitate a plan-driven approach for requirements engineering?", "response": "Factors that might necessitate a plan-driven approach for requirements engineering include the need for a very detailed specification and design before moving to implementation, contractual reasons, and cultural issues within traditional engineering organizations that require extensive design documentation.", "context": "3.4  \u25a0 Scaling agile methods  93\n2. How is the development team organized? If the development team is distributed \nor if part of the development is being outsourced, then you may need to develop \ndesign documents to communicate across the development teams.\n3. What technologies are available to support system development? Agile methods \noften rely on good tools to keep track of an evolving design. If you are develop-\ning a system using an IDE that does not have good tools for program visualiza-\ntion and analysis, then more design documentation may be required.\nTelevision and films have created a popular vision of software companies as \ninformal organizations run by young men (mostly) who provide a fashionable work-\ning environment, with a minimum of bureaucracy and organizational procedures. \nThis is far from the truth. Most software is developed in large companies that have \nestablished their own working practices and procedures. Management in these \n companies may be uncomfortable with the lack of documentation and the informal \ndecision making in agile methods. Key issues are:\n1. Is it important to have a very detailed specification and design before moving to \nimplementation, perhaps for contractual reasons? If so, you probably need to \nuse a plan-driven approach for requirements engineering but may use agile \ndevelopment practices during system implementation.\n2. Is an incremental delivery strategy, where you deliver the software to customers \nor other system stakeholders and get rapid feedback from them, realistic? Will \ncustomer representatives be available, and are they willing to participate in the \ndevelopment team?\n3. Are there cultural issues that may affect system development? Traditional engi-\nneering organizations have a culture of plan-based development, as this is the \nnorm in engineering. This usually requires extensive design documentation \nrather than the informal knowledge used in agile processes.\nIn reality, the issue of whether a project can be labeled as plan-driven or agile \nis\u00a0not very important. Ultimately, the primary concern of buyers of a software  system \nis whether or not they have an executable software system that meets their needs and \ndoes useful things for the individual user or the organization. Software developers \nshould be pragmatic and should choose those methods that are most effective for the \ntype of system being developed, whether or not these are labeled agile or plan-driven.\n \n3.4.3  Agile methods for large systems\nAgile methods have to evolve to be used for large-scale software development. \nThe fundamental reason for this is that large-scale software systems are much \nmore complex and difficult to understand and manage than small-scale systems \nor software products. Six principal factors (Figure 3.13) contribute to this \n complexity:\n\n\n94  Chapter 3 \u25a0 Agile software development\n1. Large systems are usually systems of systems\u2014collections of separate, com-\nmunicating systems, where separate teams develop each system. Frequently, \nthese teams are working in different places, sometimes in different time zones. \nIt is practically impossible for each team to have a view of the whole system. \nConsequently, their priorities are usually to complete their part of the system \nwithout regard for wider systems issues.\n2. \nLarge systems are brownfield systems (Hopkins and Jenkins 2008); that is, they \ninclude and interact with a number of existing systems. Many of the system require-\nments are concerned with this interaction and so don\u2019t really lend themselves to \nflexibility and incremental development. Political issues can also be significant \nhere\u2014often the easiest solution to a problem is to change an existing system. \nHowever, this requires negotiation with the managers of that system to convince \nthem that the changes can be implemented without risk to the system\u2019s operation.\n3. Where several systems are integrated to create a system, a significant fraction of \nthe development is concerned with system configuration rather than original \ncode development. This is not necessarily compatible with incremental devel-\nopment and frequent system integration.\n4. Large systems and their development processes are often constrained by exter-\nnal rules and regulations limiting the way that they can be developed, that \nrequire certain types of system documentation to be produced, and so on. \nCustomers may have specific compliance requirements that may have to be fol-\nlowed, and these may require process documentation to be completed.\n5. Large systems have a long procurement and development time. It is difficult to \nmaintain coherent teams who know about the system over that period as, inevi-\ntably, people move on to other jobs and projects.\n6. Large systems usually have a diverse set of stakeholders with different perspec-\ntives and objectives. For example, nurses and administrators may be the end-users \nof a medical system, but senior medical staff, hospital managers, and others, are \nalso stakeholders in the system. It is practically impossible to involve all of \nthese different stakeholders in the development process.\nLarge software system\nSystem of\nsystems\nBrownfield\ndevelopment\nDiverse\nstakeholders\nProlonged\nprocurement\nSystem\nconfiguration\nRegulatory\nconstraints\nFigure 3.13 Large \nproject characteristics"}
{"query": "What is an incremental delivery strategy in software development?", "response": "An incremental delivery strategy in software development is a approach where the software is delivered to customers or system stakeholders in small increments or iterations. This allows for rapid feedback from the stakeholders, which can then be used to make necessary adjustments and improvements to the software. This strategy is often used in agile development methods, where the focus is on delivering working software quickly and continuously improving it based on feedback.", "context": "3.4  \u25a0 Scaling agile methods  93\n2. How is the development team organized? If the development team is distributed \nor if part of the development is being outsourced, then you may need to develop \ndesign documents to communicate across the development teams.\n3. What technologies are available to support system development? Agile methods \noften rely on good tools to keep track of an evolving design. If you are develop-\ning a system using an IDE that does not have good tools for program visualiza-\ntion and analysis, then more design documentation may be required.\nTelevision and films have created a popular vision of software companies as \ninformal organizations run by young men (mostly) who provide a fashionable work-\ning environment, with a minimum of bureaucracy and organizational procedures. \nThis is far from the truth. Most software is developed in large companies that have \nestablished their own working practices and procedures. Management in these \n companies may be uncomfortable with the lack of documentation and the informal \ndecision making in agile methods. Key issues are:\n1. Is it important to have a very detailed specification and design before moving to \nimplementation, perhaps for contractual reasons? If so, you probably need to \nuse a plan-driven approach for requirements engineering but may use agile \ndevelopment practices during system implementation.\n2. Is an incremental delivery strategy, where you deliver the software to customers \nor other system stakeholders and get rapid feedback from them, realistic? Will \ncustomer representatives be available, and are they willing to participate in the \ndevelopment team?\n3. Are there cultural issues that may affect system development? Traditional engi-\nneering organizations have a culture of plan-based development, as this is the \nnorm in engineering. This usually requires extensive design documentation \nrather than the informal knowledge used in agile processes.\nIn reality, the issue of whether a project can be labeled as plan-driven or agile \nis\u00a0not very important. Ultimately, the primary concern of buyers of a software  system \nis whether or not they have an executable software system that meets their needs and \ndoes useful things for the individual user or the organization. Software developers \nshould be pragmatic and should choose those methods that are most effective for the \ntype of system being developed, whether or not these are labeled agile or plan-driven.\n \n3.4.3  Agile methods for large systems\nAgile methods have to evolve to be used for large-scale software development. \nThe fundamental reason for this is that large-scale software systems are much \nmore complex and difficult to understand and manage than small-scale systems \nor software products. Six principal factors (Figure 3.13) contribute to this \n complexity:\n\n\n94  Chapter 3 \u25a0 Agile software development\n1. Large systems are usually systems of systems\u2014collections of separate, com-\nmunicating systems, where separate teams develop each system. Frequently, \nthese teams are working in different places, sometimes in different time zones. \nIt is practically impossible for each team to have a view of the whole system. \nConsequently, their priorities are usually to complete their part of the system \nwithout regard for wider systems issues.\n2. \nLarge systems are brownfield systems (Hopkins and Jenkins 2008); that is, they \ninclude and interact with a number of existing systems. Many of the system require-\nments are concerned with this interaction and so don\u2019t really lend themselves to \nflexibility and incremental development. Political issues can also be significant \nhere\u2014often the easiest solution to a problem is to change an existing system. \nHowever, this requires negotiation with the managers of that system to convince \nthem that the changes can be implemented without risk to the system\u2019s operation.\n3. Where several systems are integrated to create a system, a significant fraction of \nthe development is concerned with system configuration rather than original \ncode development. This is not necessarily compatible with incremental devel-\nopment and frequent system integration.\n4. Large systems and their development processes are often constrained by exter-\nnal rules and regulations limiting the way that they can be developed, that \nrequire certain types of system documentation to be produced, and so on. \nCustomers may have specific compliance requirements that may have to be fol-\nlowed, and these may require process documentation to be completed.\n5. Large systems have a long procurement and development time. It is difficult to \nmaintain coherent teams who know about the system over that period as, inevi-\ntably, people move on to other jobs and projects.\n6. Large systems usually have a diverse set of stakeholders with different perspec-\ntives and objectives. For example, nurses and administrators may be the end-users \nof a medical system, but senior medical staff, hospital managers, and others, are \nalso stakeholders in the system. It is practically impossible to involve all of \nthese different stakeholders in the development process.\nLarge software system\nSystem of\nsystems\nBrownfield\ndevelopment\nDiverse\nstakeholders\nProlonged\nprocurement\nSystem\nconfiguration\nRegulatory\nconstraints\nFigure 3.13 Large \nproject characteristics"}
{"query": "How can cultural issues affect system development?", "response": "Cultural issues can affect system development by influencing the development approach and the level of documentation required. Traditional engineering organizations often have a culture of plan-based development, which emphasizes extensive design documentation. This can clash with the informal knowledge and decision-making processes used in agile methods. If there are cultural issues that favor a plan-driven approach, it may be necessary to have a very detailed specification and design before moving to implementation. On the other hand, if the cultural context is more open to agile practices, an incremental delivery strategy with rapid feedback from stakeholders may be more realistic. Ultimately, the cultural context can shape the expectations and requirements for system development, impacting the choice of development methods and the level of documentation needed.", "context": "3.4  \u25a0 Scaling agile methods  93\n2. How is the development team organized? If the development team is distributed \nor if part of the development is being outsourced, then you may need to develop \ndesign documents to communicate across the development teams.\n3. What technologies are available to support system development? Agile methods \noften rely on good tools to keep track of an evolving design. If you are develop-\ning a system using an IDE that does not have good tools for program visualiza-\ntion and analysis, then more design documentation may be required.\nTelevision and films have created a popular vision of software companies as \ninformal organizations run by young men (mostly) who provide a fashionable work-\ning environment, with a minimum of bureaucracy and organizational procedures. \nThis is far from the truth. Most software is developed in large companies that have \nestablished their own working practices and procedures. Management in these \n companies may be uncomfortable with the lack of documentation and the informal \ndecision making in agile methods. Key issues are:\n1. Is it important to have a very detailed specification and design before moving to \nimplementation, perhaps for contractual reasons? If so, you probably need to \nuse a plan-driven approach for requirements engineering but may use agile \ndevelopment practices during system implementation.\n2. Is an incremental delivery strategy, where you deliver the software to customers \nor other system stakeholders and get rapid feedback from them, realistic? Will \ncustomer representatives be available, and are they willing to participate in the \ndevelopment team?\n3. Are there cultural issues that may affect system development? Traditional engi-\nneering organizations have a culture of plan-based development, as this is the \nnorm in engineering. This usually requires extensive design documentation \nrather than the informal knowledge used in agile processes.\nIn reality, the issue of whether a project can be labeled as plan-driven or agile \nis\u00a0not very important. Ultimately, the primary concern of buyers of a software  system \nis whether or not they have an executable software system that meets their needs and \ndoes useful things for the individual user or the organization. Software developers \nshould be pragmatic and should choose those methods that are most effective for the \ntype of system being developed, whether or not these are labeled agile or plan-driven.\n \n3.4.3  Agile methods for large systems\nAgile methods have to evolve to be used for large-scale software development. \nThe fundamental reason for this is that large-scale software systems are much \nmore complex and difficult to understand and manage than small-scale systems \nor software products. Six principal factors (Figure 3.13) contribute to this \n complexity:\n\n\n94  Chapter 3 \u25a0 Agile software development\n1. Large systems are usually systems of systems\u2014collections of separate, com-\nmunicating systems, where separate teams develop each system. Frequently, \nthese teams are working in different places, sometimes in different time zones. \nIt is practically impossible for each team to have a view of the whole system. \nConsequently, their priorities are usually to complete their part of the system \nwithout regard for wider systems issues.\n2. \nLarge systems are brownfield systems (Hopkins and Jenkins 2008); that is, they \ninclude and interact with a number of existing systems. Many of the system require-\nments are concerned with this interaction and so don\u2019t really lend themselves to \nflexibility and incremental development. Political issues can also be significant \nhere\u2014often the easiest solution to a problem is to change an existing system. \nHowever, this requires negotiation with the managers of that system to convince \nthem that the changes can be implemented without risk to the system\u2019s operation.\n3. Where several systems are integrated to create a system, a significant fraction of \nthe development is concerned with system configuration rather than original \ncode development. This is not necessarily compatible with incremental devel-\nopment and frequent system integration.\n4. Large systems and their development processes are often constrained by exter-\nnal rules and regulations limiting the way that they can be developed, that \nrequire certain types of system documentation to be produced, and so on. \nCustomers may have specific compliance requirements that may have to be fol-\nlowed, and these may require process documentation to be completed.\n5. Large systems have a long procurement and development time. It is difficult to \nmaintain coherent teams who know about the system over that period as, inevi-\ntably, people move on to other jobs and projects.\n6. Large systems usually have a diverse set of stakeholders with different perspec-\ntives and objectives. For example, nurses and administrators may be the end-users \nof a medical system, but senior medical staff, hospital managers, and others, are \nalso stakeholders in the system. It is practically impossible to involve all of \nthese different stakeholders in the development process.\nLarge software system\nSystem of\nsystems\nBrownfield\ndevelopment\nDiverse\nstakeholders\nProlonged\nprocurement\nSystem\nconfiguration\nRegulatory\nconstraints\nFigure 3.13 Large \nproject characteristics"}
{"query": "What is the primary concern of buyers of a software system?", "response": "The primary concern of buyers of a software system is whether or not they have an executable software system that meets their needs and does useful things for the individual user or the organization.", "context": "3.4  \u25a0 Scaling agile methods  93\n2. How is the development team organized? If the development team is distributed \nor if part of the development is being outsourced, then you may need to develop \ndesign documents to communicate across the development teams.\n3. What technologies are available to support system development? Agile methods \noften rely on good tools to keep track of an evolving design. If you are develop-\ning a system using an IDE that does not have good tools for program visualiza-\ntion and analysis, then more design documentation may be required.\nTelevision and films have created a popular vision of software companies as \ninformal organizations run by young men (mostly) who provide a fashionable work-\ning environment, with a minimum of bureaucracy and organizational procedures. \nThis is far from the truth. Most software is developed in large companies that have \nestablished their own working practices and procedures. Management in these \n companies may be uncomfortable with the lack of documentation and the informal \ndecision making in agile methods. Key issues are:\n1. Is it important to have a very detailed specification and design before moving to \nimplementation, perhaps for contractual reasons? If so, you probably need to \nuse a plan-driven approach for requirements engineering but may use agile \ndevelopment practices during system implementation.\n2. Is an incremental delivery strategy, where you deliver the software to customers \nor other system stakeholders and get rapid feedback from them, realistic? Will \ncustomer representatives be available, and are they willing to participate in the \ndevelopment team?\n3. Are there cultural issues that may affect system development? Traditional engi-\nneering organizations have a culture of plan-based development, as this is the \nnorm in engineering. This usually requires extensive design documentation \nrather than the informal knowledge used in agile processes.\nIn reality, the issue of whether a project can be labeled as plan-driven or agile \nis\u00a0not very important. Ultimately, the primary concern of buyers of a software  system \nis whether or not they have an executable software system that meets their needs and \ndoes useful things for the individual user or the organization. Software developers \nshould be pragmatic and should choose those methods that are most effective for the \ntype of system being developed, whether or not these are labeled agile or plan-driven.\n \n3.4.3  Agile methods for large systems\nAgile methods have to evolve to be used for large-scale software development. \nThe fundamental reason for this is that large-scale software systems are much \nmore complex and difficult to understand and manage than small-scale systems \nor software products. Six principal factors (Figure 3.13) contribute to this \n complexity:\n\n\n94  Chapter 3 \u25a0 Agile software development\n1. Large systems are usually systems of systems\u2014collections of separate, com-\nmunicating systems, where separate teams develop each system. Frequently, \nthese teams are working in different places, sometimes in different time zones. \nIt is practically impossible for each team to have a view of the whole system. \nConsequently, their priorities are usually to complete their part of the system \nwithout regard for wider systems issues.\n2. \nLarge systems are brownfield systems (Hopkins and Jenkins 2008); that is, they \ninclude and interact with a number of existing systems. Many of the system require-\nments are concerned with this interaction and so don\u2019t really lend themselves to \nflexibility and incremental development. Political issues can also be significant \nhere\u2014often the easiest solution to a problem is to change an existing system. \nHowever, this requires negotiation with the managers of that system to convince \nthem that the changes can be implemented without risk to the system\u2019s operation.\n3. Where several systems are integrated to create a system, a significant fraction of \nthe development is concerned with system configuration rather than original \ncode development. This is not necessarily compatible with incremental devel-\nopment and frequent system integration.\n4. Large systems and their development processes are often constrained by exter-\nnal rules and regulations limiting the way that they can be developed, that \nrequire certain types of system documentation to be produced, and so on. \nCustomers may have specific compliance requirements that may have to be fol-\nlowed, and these may require process documentation to be completed.\n5. Large systems have a long procurement and development time. It is difficult to \nmaintain coherent teams who know about the system over that period as, inevi-\ntably, people move on to other jobs and projects.\n6. Large systems usually have a diverse set of stakeholders with different perspec-\ntives and objectives. For example, nurses and administrators may be the end-users \nof a medical system, but senior medical staff, hospital managers, and others, are \nalso stakeholders in the system. It is practically impossible to involve all of \nthese different stakeholders in the development process.\nLarge software system\nSystem of\nsystems\nBrownfield\ndevelopment\nDiverse\nstakeholders\nProlonged\nprocurement\nSystem\nconfiguration\nRegulatory\nconstraints\nFigure 3.13 Large \nproject characteristics"}
{"query": "Why should software developers be pragmatic in choosing development methods?", "response": "Software developers should be pragmatic in choosing development methods because the primary concern of buyers of a software system is whether or not they have an executable software system that meets their needs and does useful things for the individual user or the organization. The effectiveness of the chosen methods in developing the type of system being developed is more important than whether they are labeled as agile or plan-driven. Pragmatism allows developers to select the most suitable methods for the specific project, regardless of the labels attached to them.", "context": "3.4  \u25a0 Scaling agile methods  93\n2. How is the development team organized? If the development team is distributed \nor if part of the development is being outsourced, then you may need to develop \ndesign documents to communicate across the development teams.\n3. What technologies are available to support system development? Agile methods \noften rely on good tools to keep track of an evolving design. If you are develop-\ning a system using an IDE that does not have good tools for program visualiza-\ntion and analysis, then more design documentation may be required.\nTelevision and films have created a popular vision of software companies as \ninformal organizations run by young men (mostly) who provide a fashionable work-\ning environment, with a minimum of bureaucracy and organizational procedures. \nThis is far from the truth. Most software is developed in large companies that have \nestablished their own working practices and procedures. Management in these \n companies may be uncomfortable with the lack of documentation and the informal \ndecision making in agile methods. Key issues are:\n1. Is it important to have a very detailed specification and design before moving to \nimplementation, perhaps for contractual reasons? If so, you probably need to \nuse a plan-driven approach for requirements engineering but may use agile \ndevelopment practices during system implementation.\n2. Is an incremental delivery strategy, where you deliver the software to customers \nor other system stakeholders and get rapid feedback from them, realistic? Will \ncustomer representatives be available, and are they willing to participate in the \ndevelopment team?\n3. Are there cultural issues that may affect system development? Traditional engi-\nneering organizations have a culture of plan-based development, as this is the \nnorm in engineering. This usually requires extensive design documentation \nrather than the informal knowledge used in agile processes.\nIn reality, the issue of whether a project can be labeled as plan-driven or agile \nis\u00a0not very important. Ultimately, the primary concern of buyers of a software  system \nis whether or not they have an executable software system that meets their needs and \ndoes useful things for the individual user or the organization. Software developers \nshould be pragmatic and should choose those methods that are most effective for the \ntype of system being developed, whether or not these are labeled agile or plan-driven.\n \n3.4.3  Agile methods for large systems\nAgile methods have to evolve to be used for large-scale software development. \nThe fundamental reason for this is that large-scale software systems are much \nmore complex and difficult to understand and manage than small-scale systems \nor software products. Six principal factors (Figure 3.13) contribute to this \n complexity:\n\n\n94  Chapter 3 \u25a0 Agile software development\n1. Large systems are usually systems of systems\u2014collections of separate, com-\nmunicating systems, where separate teams develop each system. Frequently, \nthese teams are working in different places, sometimes in different time zones. \nIt is practically impossible for each team to have a view of the whole system. \nConsequently, their priorities are usually to complete their part of the system \nwithout regard for wider systems issues.\n2. \nLarge systems are brownfield systems (Hopkins and Jenkins 2008); that is, they \ninclude and interact with a number of existing systems. Many of the system require-\nments are concerned with this interaction and so don\u2019t really lend themselves to \nflexibility and incremental development. Political issues can also be significant \nhere\u2014often the easiest solution to a problem is to change an existing system. \nHowever, this requires negotiation with the managers of that system to convince \nthem that the changes can be implemented without risk to the system\u2019s operation.\n3. Where several systems are integrated to create a system, a significant fraction of \nthe development is concerned with system configuration rather than original \ncode development. This is not necessarily compatible with incremental devel-\nopment and frequent system integration.\n4. Large systems and their development processes are often constrained by exter-\nnal rules and regulations limiting the way that they can be developed, that \nrequire certain types of system documentation to be produced, and so on. \nCustomers may have specific compliance requirements that may have to be fol-\nlowed, and these may require process documentation to be completed.\n5. Large systems have a long procurement and development time. It is difficult to \nmaintain coherent teams who know about the system over that period as, inevi-\ntably, people move on to other jobs and projects.\n6. Large systems usually have a diverse set of stakeholders with different perspec-\ntives and objectives. For example, nurses and administrators may be the end-users \nof a medical system, but senior medical staff, hospital managers, and others, are \nalso stakeholders in the system. It is practically impossible to involve all of \nthese different stakeholders in the development process.\nLarge software system\nSystem of\nsystems\nBrownfield\ndevelopment\nDiverse\nstakeholders\nProlonged\nprocurement\nSystem\nconfiguration\nRegulatory\nconstraints\nFigure 3.13 Large \nproject characteristics"}
{"query": "Why do agile methods need to evolve for large-scale software development?", "response": "Agile methods need to evolve for large-scale software development because large-scale software systems are much more complex and difficult to understand and manage than small-scale systems or software products. There are several factors that contribute to this complexity, such as the fact that large systems are usually systems of systems, where separate teams develop each system. These teams may be working in different places and time zones, making it practically impossible for each team to have a view of the whole system. Additionally, large systems often include and interact with existing systems, which can introduce political issues and make flexibility and incremental development challenging. System configuration and integration can also be significant factors in large-scale development, as well as external rules and regulations that may constrain the development process. Furthermore, the long procurement and development time of large systems can make it difficult to maintain coherent teams over that period, and there are usually diverse stakeholders with different perspectives and objectives. Therefore, agile methods need to evolve to address these complexities and adapt to the unique challenges of large-scale software development.", "context": "3.4  \u25a0 Scaling agile methods  93\n2. How is the development team organized? If the development team is distributed \nor if part of the development is being outsourced, then you may need to develop \ndesign documents to communicate across the development teams.\n3. What technologies are available to support system development? Agile methods \noften rely on good tools to keep track of an evolving design. If you are develop-\ning a system using an IDE that does not have good tools for program visualiza-\ntion and analysis, then more design documentation may be required.\nTelevision and films have created a popular vision of software companies as \ninformal organizations run by young men (mostly) who provide a fashionable work-\ning environment, with a minimum of bureaucracy and organizational procedures. \nThis is far from the truth. Most software is developed in large companies that have \nestablished their own working practices and procedures. Management in these \n companies may be uncomfortable with the lack of documentation and the informal \ndecision making in agile methods. Key issues are:\n1. Is it important to have a very detailed specification and design before moving to \nimplementation, perhaps for contractual reasons? If so, you probably need to \nuse a plan-driven approach for requirements engineering but may use agile \ndevelopment practices during system implementation.\n2. Is an incremental delivery strategy, where you deliver the software to customers \nor other system stakeholders and get rapid feedback from them, realistic? Will \ncustomer representatives be available, and are they willing to participate in the \ndevelopment team?\n3. Are there cultural issues that may affect system development? Traditional engi-\nneering organizations have a culture of plan-based development, as this is the \nnorm in engineering. This usually requires extensive design documentation \nrather than the informal knowledge used in agile processes.\nIn reality, the issue of whether a project can be labeled as plan-driven or agile \nis\u00a0not very important. Ultimately, the primary concern of buyers of a software  system \nis whether or not they have an executable software system that meets their needs and \ndoes useful things for the individual user or the organization. Software developers \nshould be pragmatic and should choose those methods that are most effective for the \ntype of system being developed, whether or not these are labeled agile or plan-driven.\n \n3.4.3  Agile methods for large systems\nAgile methods have to evolve to be used for large-scale software development. \nThe fundamental reason for this is that large-scale software systems are much \nmore complex and difficult to understand and manage than small-scale systems \nor software products. Six principal factors (Figure 3.13) contribute to this \n complexity:\n\n\n94  Chapter 3 \u25a0 Agile software development\n1. Large systems are usually systems of systems\u2014collections of separate, com-\nmunicating systems, where separate teams develop each system. Frequently, \nthese teams are working in different places, sometimes in different time zones. \nIt is practically impossible for each team to have a view of the whole system. \nConsequently, their priorities are usually to complete their part of the system \nwithout regard for wider systems issues.\n2. \nLarge systems are brownfield systems (Hopkins and Jenkins 2008); that is, they \ninclude and interact with a number of existing systems. Many of the system require-\nments are concerned with this interaction and so don\u2019t really lend themselves to \nflexibility and incremental development. Political issues can also be significant \nhere\u2014often the easiest solution to a problem is to change an existing system. \nHowever, this requires negotiation with the managers of that system to convince \nthem that the changes can be implemented without risk to the system\u2019s operation.\n3. Where several systems are integrated to create a system, a significant fraction of \nthe development is concerned with system configuration rather than original \ncode development. This is not necessarily compatible with incremental devel-\nopment and frequent system integration.\n4. Large systems and their development processes are often constrained by exter-\nnal rules and regulations limiting the way that they can be developed, that \nrequire certain types of system documentation to be produced, and so on. \nCustomers may have specific compliance requirements that may have to be fol-\nlowed, and these may require process documentation to be completed.\n5. Large systems have a long procurement and development time. It is difficult to \nmaintain coherent teams who know about the system over that period as, inevi-\ntably, people move on to other jobs and projects.\n6. Large systems usually have a diverse set of stakeholders with different perspec-\ntives and objectives. For example, nurses and administrators may be the end-users \nof a medical system, but senior medical staff, hospital managers, and others, are \nalso stakeholders in the system. It is practically impossible to involve all of \nthese different stakeholders in the development process.\nLarge software system\nSystem of\nsystems\nBrownfield\ndevelopment\nDiverse\nstakeholders\nProlonged\nprocurement\nSystem\nconfiguration\nRegulatory\nconstraints\nFigure 3.13 Large \nproject characteristics"}
{"query": "What are some factors contributing to the complexity of large-scale software systems?", "response": "Large-scale software systems are complex due to several factors. Firstly, large systems are often composed of multiple separate systems, each developed by different teams. These teams may be located in different places and time zones, making it difficult for each team to have a complete view of the entire system. This can lead to prioritizing individual system components without considering the wider system issues.\n\nSecondly, large systems are often \"brownfield\" systems, meaning they interact with existing systems. This interaction and the associated requirements may not lend themselves well to flexibility and incremental development. Political issues can also arise when changes need to be made to existing systems, requiring negotiation with system managers.\n\nThirdly, system configuration becomes a significant part of development when integrating multiple systems. This may not align well with incremental development and frequent system integration.\n\nAdditionally, large systems are often subject to external rules and regulations that impose constraints on their development. Compliance requirements may necessitate the production of specific system documentation.\n\nFurthermore, the procurement and development time for large systems is typically long. This makes it challenging to maintain coherent teams with knowledge of the system over an extended period, as people may move on to other jobs and projects.\n\nLastly, large systems usually have a diverse set of stakeholders with different perspectives and objectives. Involving all these stakeholders in the development process is practically impossible.\n\nThese factors contribute to the complexity of large-scale software systems.", "context": "3.4  \u25a0 Scaling agile methods  93\n2. How is the development team organized? If the development team is distributed \nor if part of the development is being outsourced, then you may need to develop \ndesign documents to communicate across the development teams.\n3. What technologies are available to support system development? Agile methods \noften rely on good tools to keep track of an evolving design. If you are develop-\ning a system using an IDE that does not have good tools for program visualiza-\ntion and analysis, then more design documentation may be required.\nTelevision and films have created a popular vision of software companies as \ninformal organizations run by young men (mostly) who provide a fashionable work-\ning environment, with a minimum of bureaucracy and organizational procedures. \nThis is far from the truth. Most software is developed in large companies that have \nestablished their own working practices and procedures. Management in these \n companies may be uncomfortable with the lack of documentation and the informal \ndecision making in agile methods. Key issues are:\n1. Is it important to have a very detailed specification and design before moving to \nimplementation, perhaps for contractual reasons? If so, you probably need to \nuse a plan-driven approach for requirements engineering but may use agile \ndevelopment practices during system implementation.\n2. Is an incremental delivery strategy, where you deliver the software to customers \nor other system stakeholders and get rapid feedback from them, realistic? Will \ncustomer representatives be available, and are they willing to participate in the \ndevelopment team?\n3. Are there cultural issues that may affect system development? Traditional engi-\nneering organizations have a culture of plan-based development, as this is the \nnorm in engineering. This usually requires extensive design documentation \nrather than the informal knowledge used in agile processes.\nIn reality, the issue of whether a project can be labeled as plan-driven or agile \nis\u00a0not very important. Ultimately, the primary concern of buyers of a software  system \nis whether or not they have an executable software system that meets their needs and \ndoes useful things for the individual user or the organization. Software developers \nshould be pragmatic and should choose those methods that are most effective for the \ntype of system being developed, whether or not these are labeled agile or plan-driven.\n \n3.4.3  Agile methods for large systems\nAgile methods have to evolve to be used for large-scale software development. \nThe fundamental reason for this is that large-scale software systems are much \nmore complex and difficult to understand and manage than small-scale systems \nor software products. Six principal factors (Figure 3.13) contribute to this \n complexity:\n\n\n94  Chapter 3 \u25a0 Agile software development\n1. Large systems are usually systems of systems\u2014collections of separate, com-\nmunicating systems, where separate teams develop each system. Frequently, \nthese teams are working in different places, sometimes in different time zones. \nIt is practically impossible for each team to have a view of the whole system. \nConsequently, their priorities are usually to complete their part of the system \nwithout regard for wider systems issues.\n2. \nLarge systems are brownfield systems (Hopkins and Jenkins 2008); that is, they \ninclude and interact with a number of existing systems. Many of the system require-\nments are concerned with this interaction and so don\u2019t really lend themselves to \nflexibility and incremental development. Political issues can also be significant \nhere\u2014often the easiest solution to a problem is to change an existing system. \nHowever, this requires negotiation with the managers of that system to convince \nthem that the changes can be implemented without risk to the system\u2019s operation.\n3. Where several systems are integrated to create a system, a significant fraction of \nthe development is concerned with system configuration rather than original \ncode development. This is not necessarily compatible with incremental devel-\nopment and frequent system integration.\n4. Large systems and their development processes are often constrained by exter-\nnal rules and regulations limiting the way that they can be developed, that \nrequire certain types of system documentation to be produced, and so on. \nCustomers may have specific compliance requirements that may have to be fol-\nlowed, and these may require process documentation to be completed.\n5. Large systems have a long procurement and development time. It is difficult to \nmaintain coherent teams who know about the system over that period as, inevi-\ntably, people move on to other jobs and projects.\n6. Large systems usually have a diverse set of stakeholders with different perspec-\ntives and objectives. For example, nurses and administrators may be the end-users \nof a medical system, but senior medical staff, hospital managers, and others, are \nalso stakeholders in the system. It is practically impossible to involve all of \nthese different stakeholders in the development process.\nLarge software system\nSystem of\nsystems\nBrownfield\ndevelopment\nDiverse\nstakeholders\nProlonged\nprocurement\nSystem\nconfiguration\nRegulatory\nconstraints\nFigure 3.13 Large \nproject characteristics"}
{"query": "What does it mean for large systems to be systems of systems?", "response": "Large systems being referred to as \"systems of systems\" means that they are collections of separate, communicating systems. In other words, a large system is composed of multiple smaller systems that work together to achieve a common goal. Each of these smaller systems may be developed by separate teams, often working in different locations or time zones. Due to the complexity and scale of these systems, it is practically impossible for each team to have a complete view of the entire system. Therefore, their focus is usually on completing their specific part of the system without considering the wider systems issues.", "context": "3.4  \u25a0 Scaling agile methods  93\n2. How is the development team organized? If the development team is distributed \nor if part of the development is being outsourced, then you may need to develop \ndesign documents to communicate across the development teams.\n3. What technologies are available to support system development? Agile methods \noften rely on good tools to keep track of an evolving design. If you are develop-\ning a system using an IDE that does not have good tools for program visualiza-\ntion and analysis, then more design documentation may be required.\nTelevision and films have created a popular vision of software companies as \ninformal organizations run by young men (mostly) who provide a fashionable work-\ning environment, with a minimum of bureaucracy and organizational procedures. \nThis is far from the truth. Most software is developed in large companies that have \nestablished their own working practices and procedures. Management in these \n companies may be uncomfortable with the lack of documentation and the informal \ndecision making in agile methods. Key issues are:\n1. Is it important to have a very detailed specification and design before moving to \nimplementation, perhaps for contractual reasons? If so, you probably need to \nuse a plan-driven approach for requirements engineering but may use agile \ndevelopment practices during system implementation.\n2. Is an incremental delivery strategy, where you deliver the software to customers \nor other system stakeholders and get rapid feedback from them, realistic? Will \ncustomer representatives be available, and are they willing to participate in the \ndevelopment team?\n3. Are there cultural issues that may affect system development? Traditional engi-\nneering organizations have a culture of plan-based development, as this is the \nnorm in engineering. This usually requires extensive design documentation \nrather than the informal knowledge used in agile processes.\nIn reality, the issue of whether a project can be labeled as plan-driven or agile \nis\u00a0not very important. Ultimately, the primary concern of buyers of a software  system \nis whether or not they have an executable software system that meets their needs and \ndoes useful things for the individual user or the organization. Software developers \nshould be pragmatic and should choose those methods that are most effective for the \ntype of system being developed, whether or not these are labeled agile or plan-driven.\n \n3.4.3  Agile methods for large systems\nAgile methods have to evolve to be used for large-scale software development. \nThe fundamental reason for this is that large-scale software systems are much \nmore complex and difficult to understand and manage than small-scale systems \nor software products. Six principal factors (Figure 3.13) contribute to this \n complexity:\n\n\n94  Chapter 3 \u25a0 Agile software development\n1. Large systems are usually systems of systems\u2014collections of separate, com-\nmunicating systems, where separate teams develop each system. Frequently, \nthese teams are working in different places, sometimes in different time zones. \nIt is practically impossible for each team to have a view of the whole system. \nConsequently, their priorities are usually to complete their part of the system \nwithout regard for wider systems issues.\n2. \nLarge systems are brownfield systems (Hopkins and Jenkins 2008); that is, they \ninclude and interact with a number of existing systems. Many of the system require-\nments are concerned with this interaction and so don\u2019t really lend themselves to \nflexibility and incremental development. Political issues can also be significant \nhere\u2014often the easiest solution to a problem is to change an existing system. \nHowever, this requires negotiation with the managers of that system to convince \nthem that the changes can be implemented without risk to the system\u2019s operation.\n3. Where several systems are integrated to create a system, a significant fraction of \nthe development is concerned with system configuration rather than original \ncode development. This is not necessarily compatible with incremental devel-\nopment and frequent system integration.\n4. Large systems and their development processes are often constrained by exter-\nnal rules and regulations limiting the way that they can be developed, that \nrequire certain types of system documentation to be produced, and so on. \nCustomers may have specific compliance requirements that may have to be fol-\nlowed, and these may require process documentation to be completed.\n5. Large systems have a long procurement and development time. It is difficult to \nmaintain coherent teams who know about the system over that period as, inevi-\ntably, people move on to other jobs and projects.\n6. Large systems usually have a diverse set of stakeholders with different perspec-\ntives and objectives. For example, nurses and administrators may be the end-users \nof a medical system, but senior medical staff, hospital managers, and others, are \nalso stakeholders in the system. It is practically impossible to involve all of \nthese different stakeholders in the development process.\nLarge software system\nSystem of\nsystems\nBrownfield\ndevelopment\nDiverse\nstakeholders\nProlonged\nprocurement\nSystem\nconfiguration\nRegulatory\nconstraints\nFigure 3.13 Large \nproject characteristics"}
{"query": "What are brownfield systems in software development?", "response": "Brownfield systems in software development refer to systems that include and interact with existing systems. These existing systems may have their own set of rules, regulations, and constraints that need to be considered during the development process. Brownfield systems often require negotiation with the managers of the existing systems to implement changes without risking the operation of those systems.", "context": "3.4  \u25a0 Scaling agile methods  93\n2. How is the development team organized? If the development team is distributed \nor if part of the development is being outsourced, then you may need to develop \ndesign documents to communicate across the development teams.\n3. What technologies are available to support system development? Agile methods \noften rely on good tools to keep track of an evolving design. If you are develop-\ning a system using an IDE that does not have good tools for program visualiza-\ntion and analysis, then more design documentation may be required.\nTelevision and films have created a popular vision of software companies as \ninformal organizations run by young men (mostly) who provide a fashionable work-\ning environment, with a minimum of bureaucracy and organizational procedures. \nThis is far from the truth. Most software is developed in large companies that have \nestablished their own working practices and procedures. Management in these \n companies may be uncomfortable with the lack of documentation and the informal \ndecision making in agile methods. Key issues are:\n1. Is it important to have a very detailed specification and design before moving to \nimplementation, perhaps for contractual reasons? If so, you probably need to \nuse a plan-driven approach for requirements engineering but may use agile \ndevelopment practices during system implementation.\n2. Is an incremental delivery strategy, where you deliver the software to customers \nor other system stakeholders and get rapid feedback from them, realistic? Will \ncustomer representatives be available, and are they willing to participate in the \ndevelopment team?\n3. Are there cultural issues that may affect system development? Traditional engi-\nneering organizations have a culture of plan-based development, as this is the \nnorm in engineering. This usually requires extensive design documentation \nrather than the informal knowledge used in agile processes.\nIn reality, the issue of whether a project can be labeled as plan-driven or agile \nis\u00a0not very important. Ultimately, the primary concern of buyers of a software  system \nis whether or not they have an executable software system that meets their needs and \ndoes useful things for the individual user or the organization. Software developers \nshould be pragmatic and should choose those methods that are most effective for the \ntype of system being developed, whether or not these are labeled agile or plan-driven.\n \n3.4.3  Agile methods for large systems\nAgile methods have to evolve to be used for large-scale software development. \nThe fundamental reason for this is that large-scale software systems are much \nmore complex and difficult to understand and manage than small-scale systems \nor software products. Six principal factors (Figure 3.13) contribute to this \n complexity:\n\n\n94  Chapter 3 \u25a0 Agile software development\n1. Large systems are usually systems of systems\u2014collections of separate, com-\nmunicating systems, where separate teams develop each system. Frequently, \nthese teams are working in different places, sometimes in different time zones. \nIt is practically impossible for each team to have a view of the whole system. \nConsequently, their priorities are usually to complete their part of the system \nwithout regard for wider systems issues.\n2. \nLarge systems are brownfield systems (Hopkins and Jenkins 2008); that is, they \ninclude and interact with a number of existing systems. Many of the system require-\nments are concerned with this interaction and so don\u2019t really lend themselves to \nflexibility and incremental development. Political issues can also be significant \nhere\u2014often the easiest solution to a problem is to change an existing system. \nHowever, this requires negotiation with the managers of that system to convince \nthem that the changes can be implemented without risk to the system\u2019s operation.\n3. Where several systems are integrated to create a system, a significant fraction of \nthe development is concerned with system configuration rather than original \ncode development. This is not necessarily compatible with incremental devel-\nopment and frequent system integration.\n4. Large systems and their development processes are often constrained by exter-\nnal rules and regulations limiting the way that they can be developed, that \nrequire certain types of system documentation to be produced, and so on. \nCustomers may have specific compliance requirements that may have to be fol-\nlowed, and these may require process documentation to be completed.\n5. Large systems have a long procurement and development time. It is difficult to \nmaintain coherent teams who know about the system over that period as, inevi-\ntably, people move on to other jobs and projects.\n6. Large systems usually have a diverse set of stakeholders with different perspec-\ntives and objectives. For example, nurses and administrators may be the end-users \nof a medical system, but senior medical staff, hospital managers, and others, are \nalso stakeholders in the system. It is practically impossible to involve all of \nthese different stakeholders in the development process.\nLarge software system\nSystem of\nsystems\nBrownfield\ndevelopment\nDiverse\nstakeholders\nProlonged\nprocurement\nSystem\nconfiguration\nRegulatory\nconstraints\nFigure 3.13 Large \nproject characteristics"}
{"query": "How do political issues affect the development of large systems?", "response": "Political issues can significantly affect the development of large systems. In the context of large-scale software development, political issues can arise when dealing with existing systems that need to be integrated or interact with the new system. Sometimes, the easiest solution to a problem is to make changes to an existing system, but this requires negotiation with the managers of that system to ensure that the changes can be implemented without risking the operation of the system. Therefore, political issues can introduce complexities and delays in the development process of large systems.", "context": "3.4  \u25a0 Scaling agile methods  93\n2. How is the development team organized? If the development team is distributed \nor if part of the development is being outsourced, then you may need to develop \ndesign documents to communicate across the development teams.\n3. What technologies are available to support system development? Agile methods \noften rely on good tools to keep track of an evolving design. If you are develop-\ning a system using an IDE that does not have good tools for program visualiza-\ntion and analysis, then more design documentation may be required.\nTelevision and films have created a popular vision of software companies as \ninformal organizations run by young men (mostly) who provide a fashionable work-\ning environment, with a minimum of bureaucracy and organizational procedures. \nThis is far from the truth. Most software is developed in large companies that have \nestablished their own working practices and procedures. Management in these \n companies may be uncomfortable with the lack of documentation and the informal \ndecision making in agile methods. Key issues are:\n1. Is it important to have a very detailed specification and design before moving to \nimplementation, perhaps for contractual reasons? If so, you probably need to \nuse a plan-driven approach for requirements engineering but may use agile \ndevelopment practices during system implementation.\n2. Is an incremental delivery strategy, where you deliver the software to customers \nor other system stakeholders and get rapid feedback from them, realistic? Will \ncustomer representatives be available, and are they willing to participate in the \ndevelopment team?\n3. Are there cultural issues that may affect system development? Traditional engi-\nneering organizations have a culture of plan-based development, as this is the \nnorm in engineering. This usually requires extensive design documentation \nrather than the informal knowledge used in agile processes.\nIn reality, the issue of whether a project can be labeled as plan-driven or agile \nis\u00a0not very important. Ultimately, the primary concern of buyers of a software  system \nis whether or not they have an executable software system that meets their needs and \ndoes useful things for the individual user or the organization. Software developers \nshould be pragmatic and should choose those methods that are most effective for the \ntype of system being developed, whether or not these are labeled agile or plan-driven.\n \n3.4.3  Agile methods for large systems\nAgile methods have to evolve to be used for large-scale software development. \nThe fundamental reason for this is that large-scale software systems are much \nmore complex and difficult to understand and manage than small-scale systems \nor software products. Six principal factors (Figure 3.13) contribute to this \n complexity:\n\n\n94  Chapter 3 \u25a0 Agile software development\n1. Large systems are usually systems of systems\u2014collections of separate, com-\nmunicating systems, where separate teams develop each system. Frequently, \nthese teams are working in different places, sometimes in different time zones. \nIt is practically impossible for each team to have a view of the whole system. \nConsequently, their priorities are usually to complete their part of the system \nwithout regard for wider systems issues.\n2. \nLarge systems are brownfield systems (Hopkins and Jenkins 2008); that is, they \ninclude and interact with a number of existing systems. Many of the system require-\nments are concerned with this interaction and so don\u2019t really lend themselves to \nflexibility and incremental development. Political issues can also be significant \nhere\u2014often the easiest solution to a problem is to change an existing system. \nHowever, this requires negotiation with the managers of that system to convince \nthem that the changes can be implemented without risk to the system\u2019s operation.\n3. Where several systems are integrated to create a system, a significant fraction of \nthe development is concerned with system configuration rather than original \ncode development. This is not necessarily compatible with incremental devel-\nopment and frequent system integration.\n4. Large systems and their development processes are often constrained by exter-\nnal rules and regulations limiting the way that they can be developed, that \nrequire certain types of system documentation to be produced, and so on. \nCustomers may have specific compliance requirements that may have to be fol-\nlowed, and these may require process documentation to be completed.\n5. Large systems have a long procurement and development time. It is difficult to \nmaintain coherent teams who know about the system over that period as, inevi-\ntably, people move on to other jobs and projects.\n6. Large systems usually have a diverse set of stakeholders with different perspec-\ntives and objectives. For example, nurses and administrators may be the end-users \nof a medical system, but senior medical staff, hospital managers, and others, are \nalso stakeholders in the system. It is practically impossible to involve all of \nthese different stakeholders in the development process.\nLarge software system\nSystem of\nsystems\nBrownfield\ndevelopment\nDiverse\nstakeholders\nProlonged\nprocurement\nSystem\nconfiguration\nRegulatory\nconstraints\nFigure 3.13 Large \nproject characteristics"}
{"query": "How does system configuration factor into the development of large systems?", "response": "System configuration is a significant factor in the development of large systems. When several systems are integrated to create a system, a significant portion of the development process is focused on system configuration rather than original code development. This means that the configuration of the integrated systems needs to be carefully managed and coordinated, which may not be compatible with incremental development and frequent system integration. Therefore, system configuration adds complexity to the development of large systems.", "context": "3.4  \u25a0 Scaling agile methods  93\n2. How is the development team organized? If the development team is distributed \nor if part of the development is being outsourced, then you may need to develop \ndesign documents to communicate across the development teams.\n3. What technologies are available to support system development? Agile methods \noften rely on good tools to keep track of an evolving design. If you are develop-\ning a system using an IDE that does not have good tools for program visualiza-\ntion and analysis, then more design documentation may be required.\nTelevision and films have created a popular vision of software companies as \ninformal organizations run by young men (mostly) who provide a fashionable work-\ning environment, with a minimum of bureaucracy and organizational procedures. \nThis is far from the truth. Most software is developed in large companies that have \nestablished their own working practices and procedures. Management in these \n companies may be uncomfortable with the lack of documentation and the informal \ndecision making in agile methods. Key issues are:\n1. Is it important to have a very detailed specification and design before moving to \nimplementation, perhaps for contractual reasons? If so, you probably need to \nuse a plan-driven approach for requirements engineering but may use agile \ndevelopment practices during system implementation.\n2. Is an incremental delivery strategy, where you deliver the software to customers \nor other system stakeholders and get rapid feedback from them, realistic? Will \ncustomer representatives be available, and are they willing to participate in the \ndevelopment team?\n3. Are there cultural issues that may affect system development? Traditional engi-\nneering organizations have a culture of plan-based development, as this is the \nnorm in engineering. This usually requires extensive design documentation \nrather than the informal knowledge used in agile processes.\nIn reality, the issue of whether a project can be labeled as plan-driven or agile \nis\u00a0not very important. Ultimately, the primary concern of buyers of a software  system \nis whether or not they have an executable software system that meets their needs and \ndoes useful things for the individual user or the organization. Software developers \nshould be pragmatic and should choose those methods that are most effective for the \ntype of system being developed, whether or not these are labeled agile or plan-driven.\n \n3.4.3  Agile methods for large systems\nAgile methods have to evolve to be used for large-scale software development. \nThe fundamental reason for this is that large-scale software systems are much \nmore complex and difficult to understand and manage than small-scale systems \nor software products. Six principal factors (Figure 3.13) contribute to this \n complexity:\n\n\n94  Chapter 3 \u25a0 Agile software development\n1. Large systems are usually systems of systems\u2014collections of separate, com-\nmunicating systems, where separate teams develop each system. Frequently, \nthese teams are working in different places, sometimes in different time zones. \nIt is practically impossible for each team to have a view of the whole system. \nConsequently, their priorities are usually to complete their part of the system \nwithout regard for wider systems issues.\n2. \nLarge systems are brownfield systems (Hopkins and Jenkins 2008); that is, they \ninclude and interact with a number of existing systems. Many of the system require-\nments are concerned with this interaction and so don\u2019t really lend themselves to \nflexibility and incremental development. Political issues can also be significant \nhere\u2014often the easiest solution to a problem is to change an existing system. \nHowever, this requires negotiation with the managers of that system to convince \nthem that the changes can be implemented without risk to the system\u2019s operation.\n3. Where several systems are integrated to create a system, a significant fraction of \nthe development is concerned with system configuration rather than original \ncode development. This is not necessarily compatible with incremental devel-\nopment and frequent system integration.\n4. Large systems and their development processes are often constrained by exter-\nnal rules and regulations limiting the way that they can be developed, that \nrequire certain types of system documentation to be produced, and so on. \nCustomers may have specific compliance requirements that may have to be fol-\nlowed, and these may require process documentation to be completed.\n5. Large systems have a long procurement and development time. It is difficult to \nmaintain coherent teams who know about the system over that period as, inevi-\ntably, people move on to other jobs and projects.\n6. Large systems usually have a diverse set of stakeholders with different perspec-\ntives and objectives. For example, nurses and administrators may be the end-users \nof a medical system, but senior medical staff, hospital managers, and others, are \nalso stakeholders in the system. It is practically impossible to involve all of \nthese different stakeholders in the development process.\nLarge software system\nSystem of\nsystems\nBrownfield\ndevelopment\nDiverse\nstakeholders\nProlonged\nprocurement\nSystem\nconfiguration\nRegulatory\nconstraints\nFigure 3.13 Large \nproject characteristics"}
{"query": "How can external rules and regulations constrain the development process of large systems?", "response": "External rules and regulations can constrain the development process of large systems by imposing certain requirements and guidelines that must be followed. These rules and regulations may dictate the types of system documentation that need to be produced, the specific compliance requirements that must be met, and the overall development approach that should be followed. These constraints can limit the flexibility and agility of the development process, as developers may need to adhere to specific procedures and documentation standards. Additionally, the need to comply with external rules and regulations may require additional time and effort to ensure that all necessary documentation is completed and that the system meets the required standards.", "context": "3.4  \u25a0 Scaling agile methods  93\n2. How is the development team organized? If the development team is distributed \nor if part of the development is being outsourced, then you may need to develop \ndesign documents to communicate across the development teams.\n3. What technologies are available to support system development? Agile methods \noften rely on good tools to keep track of an evolving design. If you are develop-\ning a system using an IDE that does not have good tools for program visualiza-\ntion and analysis, then more design documentation may be required.\nTelevision and films have created a popular vision of software companies as \ninformal organizations run by young men (mostly) who provide a fashionable work-\ning environment, with a minimum of bureaucracy and organizational procedures. \nThis is far from the truth. Most software is developed in large companies that have \nestablished their own working practices and procedures. Management in these \n companies may be uncomfortable with the lack of documentation and the informal \ndecision making in agile methods. Key issues are:\n1. Is it important to have a very detailed specification and design before moving to \nimplementation, perhaps for contractual reasons? If so, you probably need to \nuse a plan-driven approach for requirements engineering but may use agile \ndevelopment practices during system implementation.\n2. Is an incremental delivery strategy, where you deliver the software to customers \nor other system stakeholders and get rapid feedback from them, realistic? Will \ncustomer representatives be available, and are they willing to participate in the \ndevelopment team?\n3. Are there cultural issues that may affect system development? Traditional engi-\nneering organizations have a culture of plan-based development, as this is the \nnorm in engineering. This usually requires extensive design documentation \nrather than the informal knowledge used in agile processes.\nIn reality, the issue of whether a project can be labeled as plan-driven or agile \nis\u00a0not very important. Ultimately, the primary concern of buyers of a software  system \nis whether or not they have an executable software system that meets their needs and \ndoes useful things for the individual user or the organization. Software developers \nshould be pragmatic and should choose those methods that are most effective for the \ntype of system being developed, whether or not these are labeled agile or plan-driven.\n \n3.4.3  Agile methods for large systems\nAgile methods have to evolve to be used for large-scale software development. \nThe fundamental reason for this is that large-scale software systems are much \nmore complex and difficult to understand and manage than small-scale systems \nor software products. Six principal factors (Figure 3.13) contribute to this \n complexity:\n\n\n94  Chapter 3 \u25a0 Agile software development\n1. Large systems are usually systems of systems\u2014collections of separate, com-\nmunicating systems, where separate teams develop each system. Frequently, \nthese teams are working in different places, sometimes in different time zones. \nIt is practically impossible for each team to have a view of the whole system. \nConsequently, their priorities are usually to complete their part of the system \nwithout regard for wider systems issues.\n2. \nLarge systems are brownfield systems (Hopkins and Jenkins 2008); that is, they \ninclude and interact with a number of existing systems. Many of the system require-\nments are concerned with this interaction and so don\u2019t really lend themselves to \nflexibility and incremental development. Political issues can also be significant \nhere\u2014often the easiest solution to a problem is to change an existing system. \nHowever, this requires negotiation with the managers of that system to convince \nthem that the changes can be implemented without risk to the system\u2019s operation.\n3. Where several systems are integrated to create a system, a significant fraction of \nthe development is concerned with system configuration rather than original \ncode development. This is not necessarily compatible with incremental devel-\nopment and frequent system integration.\n4. Large systems and their development processes are often constrained by exter-\nnal rules and regulations limiting the way that they can be developed, that \nrequire certain types of system documentation to be produced, and so on. \nCustomers may have specific compliance requirements that may have to be fol-\nlowed, and these may require process documentation to be completed.\n5. Large systems have a long procurement and development time. It is difficult to \nmaintain coherent teams who know about the system over that period as, inevi-\ntably, people move on to other jobs and projects.\n6. Large systems usually have a diverse set of stakeholders with different perspec-\ntives and objectives. For example, nurses and administrators may be the end-users \nof a medical system, but senior medical staff, hospital managers, and others, are \nalso stakeholders in the system. It is practically impossible to involve all of \nthese different stakeholders in the development process.\nLarge software system\nSystem of\nsystems\nBrownfield\ndevelopment\nDiverse\nstakeholders\nProlonged\nprocurement\nSystem\nconfiguration\nRegulatory\nconstraints\nFigure 3.13 Large \nproject characteristics"}
{"query": "What challenges are associated with the long procurement and development time of large systems?", "response": "The challenges associated with the long procurement and development time of large systems include the difficulty of maintaining coherent teams over that period, as people inevitably move on to other jobs and projects. Additionally, the diverse set of stakeholders with different perspectives and objectives makes it practically impossible to involve all of them in the development process.", "context": "3.4  \u25a0 Scaling agile methods  93\n2. How is the development team organized? If the development team is distributed \nor if part of the development is being outsourced, then you may need to develop \ndesign documents to communicate across the development teams.\n3. What technologies are available to support system development? Agile methods \noften rely on good tools to keep track of an evolving design. If you are develop-\ning a system using an IDE that does not have good tools for program visualiza-\ntion and analysis, then more design documentation may be required.\nTelevision and films have created a popular vision of software companies as \ninformal organizations run by young men (mostly) who provide a fashionable work-\ning environment, with a minimum of bureaucracy and organizational procedures. \nThis is far from the truth. Most software is developed in large companies that have \nestablished their own working practices and procedures. Management in these \n companies may be uncomfortable with the lack of documentation and the informal \ndecision making in agile methods. Key issues are:\n1. Is it important to have a very detailed specification and design before moving to \nimplementation, perhaps for contractual reasons? If so, you probably need to \nuse a plan-driven approach for requirements engineering but may use agile \ndevelopment practices during system implementation.\n2. Is an incremental delivery strategy, where you deliver the software to customers \nor other system stakeholders and get rapid feedback from them, realistic? Will \ncustomer representatives be available, and are they willing to participate in the \ndevelopment team?\n3. Are there cultural issues that may affect system development? Traditional engi-\nneering organizations have a culture of plan-based development, as this is the \nnorm in engineering. This usually requires extensive design documentation \nrather than the informal knowledge used in agile processes.\nIn reality, the issue of whether a project can be labeled as plan-driven or agile \nis\u00a0not very important. Ultimately, the primary concern of buyers of a software  system \nis whether or not they have an executable software system that meets their needs and \ndoes useful things for the individual user or the organization. Software developers \nshould be pragmatic and should choose those methods that are most effective for the \ntype of system being developed, whether or not these are labeled agile or plan-driven.\n \n3.4.3  Agile methods for large systems\nAgile methods have to evolve to be used for large-scale software development. \nThe fundamental reason for this is that large-scale software systems are much \nmore complex and difficult to understand and manage than small-scale systems \nor software products. Six principal factors (Figure 3.13) contribute to this \n complexity:\n\n\n94  Chapter 3 \u25a0 Agile software development\n1. Large systems are usually systems of systems\u2014collections of separate, com-\nmunicating systems, where separate teams develop each system. Frequently, \nthese teams are working in different places, sometimes in different time zones. \nIt is practically impossible for each team to have a view of the whole system. \nConsequently, their priorities are usually to complete their part of the system \nwithout regard for wider systems issues.\n2. \nLarge systems are brownfield systems (Hopkins and Jenkins 2008); that is, they \ninclude and interact with a number of existing systems. Many of the system require-\nments are concerned with this interaction and so don\u2019t really lend themselves to \nflexibility and incremental development. Political issues can also be significant \nhere\u2014often the easiest solution to a problem is to change an existing system. \nHowever, this requires negotiation with the managers of that system to convince \nthem that the changes can be implemented without risk to the system\u2019s operation.\n3. Where several systems are integrated to create a system, a significant fraction of \nthe development is concerned with system configuration rather than original \ncode development. This is not necessarily compatible with incremental devel-\nopment and frequent system integration.\n4. Large systems and their development processes are often constrained by exter-\nnal rules and regulations limiting the way that they can be developed, that \nrequire certain types of system documentation to be produced, and so on. \nCustomers may have specific compliance requirements that may have to be fol-\nlowed, and these may require process documentation to be completed.\n5. Large systems have a long procurement and development time. It is difficult to \nmaintain coherent teams who know about the system over that period as, inevi-\ntably, people move on to other jobs and projects.\n6. Large systems usually have a diverse set of stakeholders with different perspec-\ntives and objectives. For example, nurses and administrators may be the end-users \nof a medical system, but senior medical staff, hospital managers, and others, are \nalso stakeholders in the system. It is practically impossible to involve all of \nthese different stakeholders in the development process.\nLarge software system\nSystem of\nsystems\nBrownfield\ndevelopment\nDiverse\nstakeholders\nProlonged\nprocurement\nSystem\nconfiguration\nRegulatory\nconstraints\nFigure 3.13 Large \nproject characteristics"}
{"query": "How do diverse stakeholders affect the development process of large systems?", "response": "The presence of diverse stakeholders in the development process of large systems can have an impact. These stakeholders may have different perspectives and objectives, which can lead to conflicting requirements and priorities. It can be challenging to involve all of these stakeholders in the development process and ensure that their needs are adequately addressed. This complexity can make it difficult to achieve consensus and make timely decisions, potentially leading to delays and inefficiencies in the development process.", "context": "3.4  \u25a0 Scaling agile methods  93\n2. How is the development team organized? If the development team is distributed \nor if part of the development is being outsourced, then you may need to develop \ndesign documents to communicate across the development teams.\n3. What technologies are available to support system development? Agile methods \noften rely on good tools to keep track of an evolving design. If you are develop-\ning a system using an IDE that does not have good tools for program visualiza-\ntion and analysis, then more design documentation may be required.\nTelevision and films have created a popular vision of software companies as \ninformal organizations run by young men (mostly) who provide a fashionable work-\ning environment, with a minimum of bureaucracy and organizational procedures. \nThis is far from the truth. Most software is developed in large companies that have \nestablished their own working practices and procedures. Management in these \n companies may be uncomfortable with the lack of documentation and the informal \ndecision making in agile methods. Key issues are:\n1. Is it important to have a very detailed specification and design before moving to \nimplementation, perhaps for contractual reasons? If so, you probably need to \nuse a plan-driven approach for requirements engineering but may use agile \ndevelopment practices during system implementation.\n2. Is an incremental delivery strategy, where you deliver the software to customers \nor other system stakeholders and get rapid feedback from them, realistic? Will \ncustomer representatives be available, and are they willing to participate in the \ndevelopment team?\n3. Are there cultural issues that may affect system development? Traditional engi-\nneering organizations have a culture of plan-based development, as this is the \nnorm in engineering. This usually requires extensive design documentation \nrather than the informal knowledge used in agile processes.\nIn reality, the issue of whether a project can be labeled as plan-driven or agile \nis\u00a0not very important. Ultimately, the primary concern of buyers of a software  system \nis whether or not they have an executable software system that meets their needs and \ndoes useful things for the individual user or the organization. Software developers \nshould be pragmatic and should choose those methods that are most effective for the \ntype of system being developed, whether or not these are labeled agile or plan-driven.\n \n3.4.3  Agile methods for large systems\nAgile methods have to evolve to be used for large-scale software development. \nThe fundamental reason for this is that large-scale software systems are much \nmore complex and difficult to understand and manage than small-scale systems \nor software products. Six principal factors (Figure 3.13) contribute to this \n complexity:\n\n\n94  Chapter 3 \u25a0 Agile software development\n1. Large systems are usually systems of systems\u2014collections of separate, com-\nmunicating systems, where separate teams develop each system. Frequently, \nthese teams are working in different places, sometimes in different time zones. \nIt is practically impossible for each team to have a view of the whole system. \nConsequently, their priorities are usually to complete their part of the system \nwithout regard for wider systems issues.\n2. \nLarge systems are brownfield systems (Hopkins and Jenkins 2008); that is, they \ninclude and interact with a number of existing systems. Many of the system require-\nments are concerned with this interaction and so don\u2019t really lend themselves to \nflexibility and incremental development. Political issues can also be significant \nhere\u2014often the easiest solution to a problem is to change an existing system. \nHowever, this requires negotiation with the managers of that system to convince \nthem that the changes can be implemented without risk to the system\u2019s operation.\n3. Where several systems are integrated to create a system, a significant fraction of \nthe development is concerned with system configuration rather than original \ncode development. This is not necessarily compatible with incremental devel-\nopment and frequent system integration.\n4. Large systems and their development processes are often constrained by exter-\nnal rules and regulations limiting the way that they can be developed, that \nrequire certain types of system documentation to be produced, and so on. \nCustomers may have specific compliance requirements that may have to be fol-\nlowed, and these may require process documentation to be completed.\n5. Large systems have a long procurement and development time. It is difficult to \nmaintain coherent teams who know about the system over that period as, inevi-\ntably, people move on to other jobs and projects.\n6. Large systems usually have a diverse set of stakeholders with different perspec-\ntives and objectives. For example, nurses and administrators may be the end-users \nof a medical system, but senior medical staff, hospital managers, and others, are \nalso stakeholders in the system. It is practically impossible to involve all of \nthese different stakeholders in the development process.\nLarge software system\nSystem of\nsystems\nBrownfield\ndevelopment\nDiverse\nstakeholders\nProlonged\nprocurement\nSystem\nconfiguration\nRegulatory\nconstraints\nFigure 3.13 Large \nproject characteristics"}
{"query": "What is the role of system documentation in meeting compliance requirements?", "response": "System documentation plays a role in meeting compliance requirements by providing evidence that the system has been developed in accordance with the required regulations and standards. Compliance requirements often mandate the production of specific types of documentation, such as design documents, test plans, and configuration management records. These documents serve as proof that the system has been developed and maintained in a controlled and traceable manner. They provide transparency and accountability, allowing regulatory bodies to assess whether the system meets the necessary standards and regulations.", "context": "3.4  \u25a0 Scaling agile methods  93\n2. How is the development team organized? If the development team is distributed \nor if part of the development is being outsourced, then you may need to develop \ndesign documents to communicate across the development teams.\n3. What technologies are available to support system development? Agile methods \noften rely on good tools to keep track of an evolving design. If you are develop-\ning a system using an IDE that does not have good tools for program visualiza-\ntion and analysis, then more design documentation may be required.\nTelevision and films have created a popular vision of software companies as \ninformal organizations run by young men (mostly) who provide a fashionable work-\ning environment, with a minimum of bureaucracy and organizational procedures. \nThis is far from the truth. Most software is developed in large companies that have \nestablished their own working practices and procedures. Management in these \n companies may be uncomfortable with the lack of documentation and the informal \ndecision making in agile methods. Key issues are:\n1. Is it important to have a very detailed specification and design before moving to \nimplementation, perhaps for contractual reasons? If so, you probably need to \nuse a plan-driven approach for requirements engineering but may use agile \ndevelopment practices during system implementation.\n2. Is an incremental delivery strategy, where you deliver the software to customers \nor other system stakeholders and get rapid feedback from them, realistic? Will \ncustomer representatives be available, and are they willing to participate in the \ndevelopment team?\n3. Are there cultural issues that may affect system development? Traditional engi-\nneering organizations have a culture of plan-based development, as this is the \nnorm in engineering. This usually requires extensive design documentation \nrather than the informal knowledge used in agile processes.\nIn reality, the issue of whether a project can be labeled as plan-driven or agile \nis\u00a0not very important. Ultimately, the primary concern of buyers of a software  system \nis whether or not they have an executable software system that meets their needs and \ndoes useful things for the individual user or the organization. Software developers \nshould be pragmatic and should choose those methods that are most effective for the \ntype of system being developed, whether or not these are labeled agile or plan-driven.\n \n3.4.3  Agile methods for large systems\nAgile methods have to evolve to be used for large-scale software development. \nThe fundamental reason for this is that large-scale software systems are much \nmore complex and difficult to understand and manage than small-scale systems \nor software products. Six principal factors (Figure 3.13) contribute to this \n complexity:\n\n\n94  Chapter 3 \u25a0 Agile software development\n1. Large systems are usually systems of systems\u2014collections of separate, com-\nmunicating systems, where separate teams develop each system. Frequently, \nthese teams are working in different places, sometimes in different time zones. \nIt is practically impossible for each team to have a view of the whole system. \nConsequently, their priorities are usually to complete their part of the system \nwithout regard for wider systems issues.\n2. \nLarge systems are brownfield systems (Hopkins and Jenkins 2008); that is, they \ninclude and interact with a number of existing systems. Many of the system require-\nments are concerned with this interaction and so don\u2019t really lend themselves to \nflexibility and incremental development. Political issues can also be significant \nhere\u2014often the easiest solution to a problem is to change an existing system. \nHowever, this requires negotiation with the managers of that system to convince \nthem that the changes can be implemented without risk to the system\u2019s operation.\n3. Where several systems are integrated to create a system, a significant fraction of \nthe development is concerned with system configuration rather than original \ncode development. This is not necessarily compatible with incremental devel-\nopment and frequent system integration.\n4. Large systems and their development processes are often constrained by exter-\nnal rules and regulations limiting the way that they can be developed, that \nrequire certain types of system documentation to be produced, and so on. \nCustomers may have specific compliance requirements that may have to be fol-\nlowed, and these may require process documentation to be completed.\n5. Large systems have a long procurement and development time. It is difficult to \nmaintain coherent teams who know about the system over that period as, inevi-\ntably, people move on to other jobs and projects.\n6. Large systems usually have a diverse set of stakeholders with different perspec-\ntives and objectives. For example, nurses and administrators may be the end-users \nof a medical system, but senior medical staff, hospital managers, and others, are \nalso stakeholders in the system. It is practically impossible to involve all of \nthese different stakeholders in the development process.\nLarge software system\nSystem of\nsystems\nBrownfield\ndevelopment\nDiverse\nstakeholders\nProlonged\nprocurement\nSystem\nconfiguration\nRegulatory\nconstraints\nFigure 3.13 Large \nproject characteristics"}
{"query": "What is the impact of team coherence on the development of large systems?", "response": "The impact of team coherence on the development of large systems is significant. In large-scale software development, it is difficult to maintain coherent teams who have a comprehensive understanding of the system over a prolonged period of time. As people move on to other jobs and projects, the knowledge and expertise about the system can be lost. This lack of team coherence can lead to challenges in communication, coordination, and collaboration among team members, which can ultimately affect the overall development process and the quality of the system being developed.", "context": "3.4  \u25a0 Scaling agile methods  93\n2. How is the development team organized? If the development team is distributed \nor if part of the development is being outsourced, then you may need to develop \ndesign documents to communicate across the development teams.\n3. What technologies are available to support system development? Agile methods \noften rely on good tools to keep track of an evolving design. If you are develop-\ning a system using an IDE that does not have good tools for program visualiza-\ntion and analysis, then more design documentation may be required.\nTelevision and films have created a popular vision of software companies as \ninformal organizations run by young men (mostly) who provide a fashionable work-\ning environment, with a minimum of bureaucracy and organizational procedures. \nThis is far from the truth. Most software is developed in large companies that have \nestablished their own working practices and procedures. Management in these \n companies may be uncomfortable with the lack of documentation and the informal \ndecision making in agile methods. Key issues are:\n1. Is it important to have a very detailed specification and design before moving to \nimplementation, perhaps for contractual reasons? If so, you probably need to \nuse a plan-driven approach for requirements engineering but may use agile \ndevelopment practices during system implementation.\n2. Is an incremental delivery strategy, where you deliver the software to customers \nor other system stakeholders and get rapid feedback from them, realistic? Will \ncustomer representatives be available, and are they willing to participate in the \ndevelopment team?\n3. Are there cultural issues that may affect system development? Traditional engi-\nneering organizations have a culture of plan-based development, as this is the \nnorm in engineering. This usually requires extensive design documentation \nrather than the informal knowledge used in agile processes.\nIn reality, the issue of whether a project can be labeled as plan-driven or agile \nis\u00a0not very important. Ultimately, the primary concern of buyers of a software  system \nis whether or not they have an executable software system that meets their needs and \ndoes useful things for the individual user or the organization. Software developers \nshould be pragmatic and should choose those methods that are most effective for the \ntype of system being developed, whether or not these are labeled agile or plan-driven.\n \n3.4.3  Agile methods for large systems\nAgile methods have to evolve to be used for large-scale software development. \nThe fundamental reason for this is that large-scale software systems are much \nmore complex and difficult to understand and manage than small-scale systems \nor software products. Six principal factors (Figure 3.13) contribute to this \n complexity:\n\n\n94  Chapter 3 \u25a0 Agile software development\n1. Large systems are usually systems of systems\u2014collections of separate, com-\nmunicating systems, where separate teams develop each system. Frequently, \nthese teams are working in different places, sometimes in different time zones. \nIt is practically impossible for each team to have a view of the whole system. \nConsequently, their priorities are usually to complete their part of the system \nwithout regard for wider systems issues.\n2. \nLarge systems are brownfield systems (Hopkins and Jenkins 2008); that is, they \ninclude and interact with a number of existing systems. Many of the system require-\nments are concerned with this interaction and so don\u2019t really lend themselves to \nflexibility and incremental development. Political issues can also be significant \nhere\u2014often the easiest solution to a problem is to change an existing system. \nHowever, this requires negotiation with the managers of that system to convince \nthem that the changes can be implemented without risk to the system\u2019s operation.\n3. Where several systems are integrated to create a system, a significant fraction of \nthe development is concerned with system configuration rather than original \ncode development. This is not necessarily compatible with incremental devel-\nopment and frequent system integration.\n4. Large systems and their development processes are often constrained by exter-\nnal rules and regulations limiting the way that they can be developed, that \nrequire certain types of system documentation to be produced, and so on. \nCustomers may have specific compliance requirements that may have to be fol-\nlowed, and these may require process documentation to be completed.\n5. Large systems have a long procurement and development time. It is difficult to \nmaintain coherent teams who know about the system over that period as, inevi-\ntably, people move on to other jobs and projects.\n6. Large systems usually have a diverse set of stakeholders with different perspec-\ntives and objectives. For example, nurses and administrators may be the end-users \nof a medical system, but senior medical staff, hospital managers, and others, are \nalso stakeholders in the system. It is practically impossible to involve all of \nthese different stakeholders in the development process.\nLarge software system\nSystem of\nsystems\nBrownfield\ndevelopment\nDiverse\nstakeholders\nProlonged\nprocurement\nSystem\nconfiguration\nRegulatory\nconstraints\nFigure 3.13 Large \nproject characteristics"}
{"query": "Why is it difficult to involve all stakeholders in the development process of large systems?", "response": "In large systems, there are usually a diverse set of stakeholders with different perspectives and objectives. For example, nurses, administrators, senior medical staff, hospital managers, and others may all be stakeholders in a medical system. However, it is practically impossible to involve all of these different stakeholders in the development process.", "context": "3.4  \u25a0 Scaling agile methods  93\n2. How is the development team organized? If the development team is distributed \nor if part of the development is being outsourced, then you may need to develop \ndesign documents to communicate across the development teams.\n3. What technologies are available to support system development? Agile methods \noften rely on good tools to keep track of an evolving design. If you are develop-\ning a system using an IDE that does not have good tools for program visualiza-\ntion and analysis, then more design documentation may be required.\nTelevision and films have created a popular vision of software companies as \ninformal organizations run by young men (mostly) who provide a fashionable work-\ning environment, with a minimum of bureaucracy and organizational procedures. \nThis is far from the truth. Most software is developed in large companies that have \nestablished their own working practices and procedures. Management in these \n companies may be uncomfortable with the lack of documentation and the informal \ndecision making in agile methods. Key issues are:\n1. Is it important to have a very detailed specification and design before moving to \nimplementation, perhaps for contractual reasons? If so, you probably need to \nuse a plan-driven approach for requirements engineering but may use agile \ndevelopment practices during system implementation.\n2. Is an incremental delivery strategy, where you deliver the software to customers \nor other system stakeholders and get rapid feedback from them, realistic? Will \ncustomer representatives be available, and are they willing to participate in the \ndevelopment team?\n3. Are there cultural issues that may affect system development? Traditional engi-\nneering organizations have a culture of plan-based development, as this is the \nnorm in engineering. This usually requires extensive design documentation \nrather than the informal knowledge used in agile processes.\nIn reality, the issue of whether a project can be labeled as plan-driven or agile \nis\u00a0not very important. Ultimately, the primary concern of buyers of a software  system \nis whether or not they have an executable software system that meets their needs and \ndoes useful things for the individual user or the organization. Software developers \nshould be pragmatic and should choose those methods that are most effective for the \ntype of system being developed, whether or not these are labeled agile or plan-driven.\n \n3.4.3  Agile methods for large systems\nAgile methods have to evolve to be used for large-scale software development. \nThe fundamental reason for this is that large-scale software systems are much \nmore complex and difficult to understand and manage than small-scale systems \nor software products. Six principal factors (Figure 3.13) contribute to this \n complexity:\n\n\n94  Chapter 3 \u25a0 Agile software development\n1. Large systems are usually systems of systems\u2014collections of separate, com-\nmunicating systems, where separate teams develop each system. Frequently, \nthese teams are working in different places, sometimes in different time zones. \nIt is practically impossible for each team to have a view of the whole system. \nConsequently, their priorities are usually to complete their part of the system \nwithout regard for wider systems issues.\n2. \nLarge systems are brownfield systems (Hopkins and Jenkins 2008); that is, they \ninclude and interact with a number of existing systems. Many of the system require-\nments are concerned with this interaction and so don\u2019t really lend themselves to \nflexibility and incremental development. Political issues can also be significant \nhere\u2014often the easiest solution to a problem is to change an existing system. \nHowever, this requires negotiation with the managers of that system to convince \nthem that the changes can be implemented without risk to the system\u2019s operation.\n3. Where several systems are integrated to create a system, a significant fraction of \nthe development is concerned with system configuration rather than original \ncode development. This is not necessarily compatible with incremental devel-\nopment and frequent system integration.\n4. Large systems and their development processes are often constrained by exter-\nnal rules and regulations limiting the way that they can be developed, that \nrequire certain types of system documentation to be produced, and so on. \nCustomers may have specific compliance requirements that may have to be fol-\nlowed, and these may require process documentation to be completed.\n5. Large systems have a long procurement and development time. It is difficult to \nmaintain coherent teams who know about the system over that period as, inevi-\ntably, people move on to other jobs and projects.\n6. Large systems usually have a diverse set of stakeholders with different perspec-\ntives and objectives. For example, nurses and administrators may be the end-users \nof a medical system, but senior medical staff, hospital managers, and others, are \nalso stakeholders in the system. It is practically impossible to involve all of \nthese different stakeholders in the development process.\nLarge software system\nSystem of\nsystems\nBrownfield\ndevelopment\nDiverse\nstakeholders\nProlonged\nprocurement\nSystem\nconfiguration\nRegulatory\nconstraints\nFigure 3.13 Large \nproject characteristics"}
{"query": "How does the location of development teams affect the development of large systems?", "response": "The location of development teams can affect the development of large systems in several ways. Firstly, if the development teams are distributed or working in different places, it can be challenging for each team to have a comprehensive view of the whole system. This can lead to a lack of coordination and prioritization of tasks, as each team may focus solely on completing their part of the system without considering wider systems issues.\n\nSecondly, if the development teams are working in different time zones, it can further complicate communication and collaboration. Scheduling meetings and resolving issues in a timely manner may become more difficult, potentially leading to delays in the development process.\n\nOverall, the location of development teams in large systems can introduce challenges in terms of coordination, communication, and collaboration, which may impact the overall efficiency and effectiveness of the development process.", "context": "3.4  \u25a0 Scaling agile methods  93\n2. How is the development team organized? If the development team is distributed \nor if part of the development is being outsourced, then you may need to develop \ndesign documents to communicate across the development teams.\n3. What technologies are available to support system development? Agile methods \noften rely on good tools to keep track of an evolving design. If you are develop-\ning a system using an IDE that does not have good tools for program visualiza-\ntion and analysis, then more design documentation may be required.\nTelevision and films have created a popular vision of software companies as \ninformal organizations run by young men (mostly) who provide a fashionable work-\ning environment, with a minimum of bureaucracy and organizational procedures. \nThis is far from the truth. Most software is developed in large companies that have \nestablished their own working practices and procedures. Management in these \n companies may be uncomfortable with the lack of documentation and the informal \ndecision making in agile methods. Key issues are:\n1. Is it important to have a very detailed specification and design before moving to \nimplementation, perhaps for contractual reasons? If so, you probably need to \nuse a plan-driven approach for requirements engineering but may use agile \ndevelopment practices during system implementation.\n2. Is an incremental delivery strategy, where you deliver the software to customers \nor other system stakeholders and get rapid feedback from them, realistic? Will \ncustomer representatives be available, and are they willing to participate in the \ndevelopment team?\n3. Are there cultural issues that may affect system development? Traditional engi-\nneering organizations have a culture of plan-based development, as this is the \nnorm in engineering. This usually requires extensive design documentation \nrather than the informal knowledge used in agile processes.\nIn reality, the issue of whether a project can be labeled as plan-driven or agile \nis\u00a0not very important. Ultimately, the primary concern of buyers of a software  system \nis whether or not they have an executable software system that meets their needs and \ndoes useful things for the individual user or the organization. Software developers \nshould be pragmatic and should choose those methods that are most effective for the \ntype of system being developed, whether or not these are labeled agile or plan-driven.\n \n3.4.3  Agile methods for large systems\nAgile methods have to evolve to be used for large-scale software development. \nThe fundamental reason for this is that large-scale software systems are much \nmore complex and difficult to understand and manage than small-scale systems \nor software products. Six principal factors (Figure 3.13) contribute to this \n complexity:\n\n\n94  Chapter 3 \u25a0 Agile software development\n1. Large systems are usually systems of systems\u2014collections of separate, com-\nmunicating systems, where separate teams develop each system. Frequently, \nthese teams are working in different places, sometimes in different time zones. \nIt is practically impossible for each team to have a view of the whole system. \nConsequently, their priorities are usually to complete their part of the system \nwithout regard for wider systems issues.\n2. \nLarge systems are brownfield systems (Hopkins and Jenkins 2008); that is, they \ninclude and interact with a number of existing systems. Many of the system require-\nments are concerned with this interaction and so don\u2019t really lend themselves to \nflexibility and incremental development. Political issues can also be significant \nhere\u2014often the easiest solution to a problem is to change an existing system. \nHowever, this requires negotiation with the managers of that system to convince \nthem that the changes can be implemented without risk to the system\u2019s operation.\n3. Where several systems are integrated to create a system, a significant fraction of \nthe development is concerned with system configuration rather than original \ncode development. This is not necessarily compatible with incremental devel-\nopment and frequent system integration.\n4. Large systems and their development processes are often constrained by exter-\nnal rules and regulations limiting the way that they can be developed, that \nrequire certain types of system documentation to be produced, and so on. \nCustomers may have specific compliance requirements that may have to be fol-\nlowed, and these may require process documentation to be completed.\n5. Large systems have a long procurement and development time. It is difficult to \nmaintain coherent teams who know about the system over that period as, inevi-\ntably, people move on to other jobs and projects.\n6. Large systems usually have a diverse set of stakeholders with different perspec-\ntives and objectives. For example, nurses and administrators may be the end-users \nof a medical system, but senior medical staff, hospital managers, and others, are \nalso stakeholders in the system. It is practically impossible to involve all of \nthese different stakeholders in the development process.\nLarge software system\nSystem of\nsystems\nBrownfield\ndevelopment\nDiverse\nstakeholders\nProlonged\nprocurement\nSystem\nconfiguration\nRegulatory\nconstraints\nFigure 3.13 Large \nproject characteristics"}
{"query": "What are the implications of developing a system using an IDE without good tools for program visualization and analysis?", "response": "More design documentation may be required.", "context": "3.4  \u25a0 Scaling agile methods  93\n2. How is the development team organized? If the development team is distributed \nor if part of the development is being outsourced, then you may need to develop \ndesign documents to communicate across the development teams.\n3. What technologies are available to support system development? Agile methods \noften rely on good tools to keep track of an evolving design. If you are develop-\ning a system using an IDE that does not have good tools for program visualiza-\ntion and analysis, then more design documentation may be required.\nTelevision and films have created a popular vision of software companies as \ninformal organizations run by young men (mostly) who provide a fashionable work-\ning environment, with a minimum of bureaucracy and organizational procedures. \nThis is far from the truth. Most software is developed in large companies that have \nestablished their own working practices and procedures. Management in these \n companies may be uncomfortable with the lack of documentation and the informal \ndecision making in agile methods. Key issues are:\n1. Is it important to have a very detailed specification and design before moving to \nimplementation, perhaps for contractual reasons? If so, you probably need to \nuse a plan-driven approach for requirements engineering but may use agile \ndevelopment practices during system implementation.\n2. Is an incremental delivery strategy, where you deliver the software to customers \nor other system stakeholders and get rapid feedback from them, realistic? Will \ncustomer representatives be available, and are they willing to participate in the \ndevelopment team?\n3. Are there cultural issues that may affect system development? Traditional engi-\nneering organizations have a culture of plan-based development, as this is the \nnorm in engineering. This usually requires extensive design documentation \nrather than the informal knowledge used in agile processes.\nIn reality, the issue of whether a project can be labeled as plan-driven or agile \nis\u00a0not very important. Ultimately, the primary concern of buyers of a software  system \nis whether or not they have an executable software system that meets their needs and \ndoes useful things for the individual user or the organization. Software developers \nshould be pragmatic and should choose those methods that are most effective for the \ntype of system being developed, whether or not these are labeled agile or plan-driven.\n \n3.4.3  Agile methods for large systems\nAgile methods have to evolve to be used for large-scale software development. \nThe fundamental reason for this is that large-scale software systems are much \nmore complex and difficult to understand and manage than small-scale systems \nor software products. Six principal factors (Figure 3.13) contribute to this \n complexity:\n\n\n94  Chapter 3 \u25a0 Agile software development\n1. Large systems are usually systems of systems\u2014collections of separate, com-\nmunicating systems, where separate teams develop each system. Frequently, \nthese teams are working in different places, sometimes in different time zones. \nIt is practically impossible for each team to have a view of the whole system. \nConsequently, their priorities are usually to complete their part of the system \nwithout regard for wider systems issues.\n2. \nLarge systems are brownfield systems (Hopkins and Jenkins 2008); that is, they \ninclude and interact with a number of existing systems. Many of the system require-\nments are concerned with this interaction and so don\u2019t really lend themselves to \nflexibility and incremental development. Political issues can also be significant \nhere\u2014often the easiest solution to a problem is to change an existing system. \nHowever, this requires negotiation with the managers of that system to convince \nthem that the changes can be implemented without risk to the system\u2019s operation.\n3. Where several systems are integrated to create a system, a significant fraction of \nthe development is concerned with system configuration rather than original \ncode development. This is not necessarily compatible with incremental devel-\nopment and frequent system integration.\n4. Large systems and their development processes are often constrained by exter-\nnal rules and regulations limiting the way that they can be developed, that \nrequire certain types of system documentation to be produced, and so on. \nCustomers may have specific compliance requirements that may have to be fol-\nlowed, and these may require process documentation to be completed.\n5. Large systems have a long procurement and development time. It is difficult to \nmaintain coherent teams who know about the system over that period as, inevi-\ntably, people move on to other jobs and projects.\n6. Large systems usually have a diverse set of stakeholders with different perspec-\ntives and objectives. For example, nurses and administrators may be the end-users \nof a medical system, but senior medical staff, hospital managers, and others, are \nalso stakeholders in the system. It is practically impossible to involve all of \nthese different stakeholders in the development process.\nLarge software system\nSystem of\nsystems\nBrownfield\ndevelopment\nDiverse\nstakeholders\nProlonged\nprocurement\nSystem\nconfiguration\nRegulatory\nconstraints\nFigure 3.13 Large \nproject characteristics"}
{"query": "How does the culture of traditional engineering organizations affect system development?", "response": "The culture of traditional engineering organizations typically favors plan-based development and extensive design documentation. This can affect system development by creating a preference for detailed specifications and designs before moving to implementation. It may also lead to a reluctance to adopt agile methods, which rely on more informal knowledge and decision-making processes. Additionally, cultural issues may arise when trying to integrate agile practices into organizations that are accustomed to plan-driven approaches.", "context": "3.4  \u25a0 Scaling agile methods  93\n2. How is the development team organized? If the development team is distributed \nor if part of the development is being outsourced, then you may need to develop \ndesign documents to communicate across the development teams.\n3. What technologies are available to support system development? Agile methods \noften rely on good tools to keep track of an evolving design. If you are develop-\ning a system using an IDE that does not have good tools for program visualiza-\ntion and analysis, then more design documentation may be required.\nTelevision and films have created a popular vision of software companies as \ninformal organizations run by young men (mostly) who provide a fashionable work-\ning environment, with a minimum of bureaucracy and organizational procedures. \nThis is far from the truth. Most software is developed in large companies that have \nestablished their own working practices and procedures. Management in these \n companies may be uncomfortable with the lack of documentation and the informal \ndecision making in agile methods. Key issues are:\n1. Is it important to have a very detailed specification and design before moving to \nimplementation, perhaps for contractual reasons? If so, you probably need to \nuse a plan-driven approach for requirements engineering but may use agile \ndevelopment practices during system implementation.\n2. Is an incremental delivery strategy, where you deliver the software to customers \nor other system stakeholders and get rapid feedback from them, realistic? Will \ncustomer representatives be available, and are they willing to participate in the \ndevelopment team?\n3. Are there cultural issues that may affect system development? Traditional engi-\nneering organizations have a culture of plan-based development, as this is the \nnorm in engineering. This usually requires extensive design documentation \nrather than the informal knowledge used in agile processes.\nIn reality, the issue of whether a project can be labeled as plan-driven or agile \nis\u00a0not very important. Ultimately, the primary concern of buyers of a software  system \nis whether or not they have an executable software system that meets their needs and \ndoes useful things for the individual user or the organization. Software developers \nshould be pragmatic and should choose those methods that are most effective for the \ntype of system being developed, whether or not these are labeled agile or plan-driven.\n \n3.4.3  Agile methods for large systems\nAgile methods have to evolve to be used for large-scale software development. \nThe fundamental reason for this is that large-scale software systems are much \nmore complex and difficult to understand and manage than small-scale systems \nor software products. Six principal factors (Figure 3.13) contribute to this \n complexity:\n\n\n94  Chapter 3 \u25a0 Agile software development\n1. Large systems are usually systems of systems\u2014collections of separate, com-\nmunicating systems, where separate teams develop each system. Frequently, \nthese teams are working in different places, sometimes in different time zones. \nIt is practically impossible for each team to have a view of the whole system. \nConsequently, their priorities are usually to complete their part of the system \nwithout regard for wider systems issues.\n2. \nLarge systems are brownfield systems (Hopkins and Jenkins 2008); that is, they \ninclude and interact with a number of existing systems. Many of the system require-\nments are concerned with this interaction and so don\u2019t really lend themselves to \nflexibility and incremental development. Political issues can also be significant \nhere\u2014often the easiest solution to a problem is to change an existing system. \nHowever, this requires negotiation with the managers of that system to convince \nthem that the changes can be implemented without risk to the system\u2019s operation.\n3. Where several systems are integrated to create a system, a significant fraction of \nthe development is concerned with system configuration rather than original \ncode development. This is not necessarily compatible with incremental devel-\nopment and frequent system integration.\n4. Large systems and their development processes are often constrained by exter-\nnal rules and regulations limiting the way that they can be developed, that \nrequire certain types of system documentation to be produced, and so on. \nCustomers may have specific compliance requirements that may have to be fol-\nlowed, and these may require process documentation to be completed.\n5. Large systems have a long procurement and development time. It is difficult to \nmaintain coherent teams who know about the system over that period as, inevi-\ntably, people move on to other jobs and projects.\n6. Large systems usually have a diverse set of stakeholders with different perspec-\ntives and objectives. For example, nurses and administrators may be the end-users \nof a medical system, but senior medical staff, hospital managers, and others, are \nalso stakeholders in the system. It is practically impossible to involve all of \nthese different stakeholders in the development process.\nLarge software system\nSystem of\nsystems\nBrownfield\ndevelopment\nDiverse\nstakeholders\nProlonged\nprocurement\nSystem\nconfiguration\nRegulatory\nconstraints\nFigure 3.13 Large \nproject characteristics"}
{"query": "How can the lack of documentation and informal decision making in agile methods be a concern for management in large companies?", "response": "Management in large companies may be uncomfortable with the lack of documentation and the informal decision making in agile methods because they have established their own working practices and procedures. These companies may prefer a more detailed specification and design before moving to implementation, which may require a plan-driven approach for requirements engineering. Additionally, traditional engineering organizations typically have a culture of plan-based development, which relies on extensive design documentation. The lack of documentation and informal decision making in agile methods may not align with these established practices and cultural norms, causing concern for management in large companies.", "context": "3.4  \u25a0 Scaling agile methods  93\n2. How is the development team organized? If the development team is distributed \nor if part of the development is being outsourced, then you may need to develop \ndesign documents to communicate across the development teams.\n3. What technologies are available to support system development? Agile methods \noften rely on good tools to keep track of an evolving design. If you are develop-\ning a system using an IDE that does not have good tools for program visualiza-\ntion and analysis, then more design documentation may be required.\nTelevision and films have created a popular vision of software companies as \ninformal organizations run by young men (mostly) who provide a fashionable work-\ning environment, with a minimum of bureaucracy and organizational procedures. \nThis is far from the truth. Most software is developed in large companies that have \nestablished their own working practices and procedures. Management in these \n companies may be uncomfortable with the lack of documentation and the informal \ndecision making in agile methods. Key issues are:\n1. Is it important to have a very detailed specification and design before moving to \nimplementation, perhaps for contractual reasons? If so, you probably need to \nuse a plan-driven approach for requirements engineering but may use agile \ndevelopment practices during system implementation.\n2. Is an incremental delivery strategy, where you deliver the software to customers \nor other system stakeholders and get rapid feedback from them, realistic? Will \ncustomer representatives be available, and are they willing to participate in the \ndevelopment team?\n3. Are there cultural issues that may affect system development? Traditional engi-\nneering organizations have a culture of plan-based development, as this is the \nnorm in engineering. This usually requires extensive design documentation \nrather than the informal knowledge used in agile processes.\nIn reality, the issue of whether a project can be labeled as plan-driven or agile \nis\u00a0not very important. Ultimately, the primary concern of buyers of a software  system \nis whether or not they have an executable software system that meets their needs and \ndoes useful things for the individual user or the organization. Software developers \nshould be pragmatic and should choose those methods that are most effective for the \ntype of system being developed, whether or not these are labeled agile or plan-driven.\n \n3.4.3  Agile methods for large systems\nAgile methods have to evolve to be used for large-scale software development. \nThe fundamental reason for this is that large-scale software systems are much \nmore complex and difficult to understand and manage than small-scale systems \nor software products. Six principal factors (Figure 3.13) contribute to this \n complexity:\n\n\n94  Chapter 3 \u25a0 Agile software development\n1. Large systems are usually systems of systems\u2014collections of separate, com-\nmunicating systems, where separate teams develop each system. Frequently, \nthese teams are working in different places, sometimes in different time zones. \nIt is practically impossible for each team to have a view of the whole system. \nConsequently, their priorities are usually to complete their part of the system \nwithout regard for wider systems issues.\n2. \nLarge systems are brownfield systems (Hopkins and Jenkins 2008); that is, they \ninclude and interact with a number of existing systems. Many of the system require-\nments are concerned with this interaction and so don\u2019t really lend themselves to \nflexibility and incremental development. Political issues can also be significant \nhere\u2014often the easiest solution to a problem is to change an existing system. \nHowever, this requires negotiation with the managers of that system to convince \nthem that the changes can be implemented without risk to the system\u2019s operation.\n3. Where several systems are integrated to create a system, a significant fraction of \nthe development is concerned with system configuration rather than original \ncode development. This is not necessarily compatible with incremental devel-\nopment and frequent system integration.\n4. Large systems and their development processes are often constrained by exter-\nnal rules and regulations limiting the way that they can be developed, that \nrequire certain types of system documentation to be produced, and so on. \nCustomers may have specific compliance requirements that may have to be fol-\nlowed, and these may require process documentation to be completed.\n5. Large systems have a long procurement and development time. It is difficult to \nmaintain coherent teams who know about the system over that period as, inevi-\ntably, people move on to other jobs and projects.\n6. Large systems usually have a diverse set of stakeholders with different perspec-\ntives and objectives. For example, nurses and administrators may be the end-users \nof a medical system, but senior medical staff, hospital managers, and others, are \nalso stakeholders in the system. It is practically impossible to involve all of \nthese different stakeholders in the development process.\nLarge software system\nSystem of\nsystems\nBrownfield\ndevelopment\nDiverse\nstakeholders\nProlonged\nprocurement\nSystem\nconfiguration\nRegulatory\nconstraints\nFigure 3.13 Large \nproject characteristics"}
{"query": "How does the interaction with existing systems affect the requirements of large systems?", "response": "The interaction with existing systems can significantly impact the requirements of large systems. Many of the system requirements are concerned with this interaction and may not lend themselves to flexibility and incremental development. Additionally, political issues can arise as changing an existing system may require negotiation with the managers of that system to ensure that the changes can be implemented without risking its operation. Therefore, the interaction with existing systems can introduce constraints and considerations that need to be taken into account when defining the requirements of large systems.", "context": "3.4  \u25a0 Scaling agile methods  93\n2. How is the development team organized? If the development team is distributed \nor if part of the development is being outsourced, then you may need to develop \ndesign documents to communicate across the development teams.\n3. What technologies are available to support system development? Agile methods \noften rely on good tools to keep track of an evolving design. If you are develop-\ning a system using an IDE that does not have good tools for program visualiza-\ntion and analysis, then more design documentation may be required.\nTelevision and films have created a popular vision of software companies as \ninformal organizations run by young men (mostly) who provide a fashionable work-\ning environment, with a minimum of bureaucracy and organizational procedures. \nThis is far from the truth. Most software is developed in large companies that have \nestablished their own working practices and procedures. Management in these \n companies may be uncomfortable with the lack of documentation and the informal \ndecision making in agile methods. Key issues are:\n1. Is it important to have a very detailed specification and design before moving to \nimplementation, perhaps for contractual reasons? If so, you probably need to \nuse a plan-driven approach for requirements engineering but may use agile \ndevelopment practices during system implementation.\n2. Is an incremental delivery strategy, where you deliver the software to customers \nor other system stakeholders and get rapid feedback from them, realistic? Will \ncustomer representatives be available, and are they willing to participate in the \ndevelopment team?\n3. Are there cultural issues that may affect system development? Traditional engi-\nneering organizations have a culture of plan-based development, as this is the \nnorm in engineering. This usually requires extensive design documentation \nrather than the informal knowledge used in agile processes.\nIn reality, the issue of whether a project can be labeled as plan-driven or agile \nis\u00a0not very important. Ultimately, the primary concern of buyers of a software  system \nis whether or not they have an executable software system that meets their needs and \ndoes useful things for the individual user or the organization. Software developers \nshould be pragmatic and should choose those methods that are most effective for the \ntype of system being developed, whether or not these are labeled agile or plan-driven.\n \n3.4.3  Agile methods for large systems\nAgile methods have to evolve to be used for large-scale software development. \nThe fundamental reason for this is that large-scale software systems are much \nmore complex and difficult to understand and manage than small-scale systems \nor software products. Six principal factors (Figure 3.13) contribute to this \n complexity:\n\n\n94  Chapter 3 \u25a0 Agile software development\n1. Large systems are usually systems of systems\u2014collections of separate, com-\nmunicating systems, where separate teams develop each system. Frequently, \nthese teams are working in different places, sometimes in different time zones. \nIt is practically impossible for each team to have a view of the whole system. \nConsequently, their priorities are usually to complete their part of the system \nwithout regard for wider systems issues.\n2. \nLarge systems are brownfield systems (Hopkins and Jenkins 2008); that is, they \ninclude and interact with a number of existing systems. Many of the system require-\nments are concerned with this interaction and so don\u2019t really lend themselves to \nflexibility and incremental development. Political issues can also be significant \nhere\u2014often the easiest solution to a problem is to change an existing system. \nHowever, this requires negotiation with the managers of that system to convince \nthem that the changes can be implemented without risk to the system\u2019s operation.\n3. Where several systems are integrated to create a system, a significant fraction of \nthe development is concerned with system configuration rather than original \ncode development. This is not necessarily compatible with incremental devel-\nopment and frequent system integration.\n4. Large systems and their development processes are often constrained by exter-\nnal rules and regulations limiting the way that they can be developed, that \nrequire certain types of system documentation to be produced, and so on. \nCustomers may have specific compliance requirements that may have to be fol-\nlowed, and these may require process documentation to be completed.\n5. Large systems have a long procurement and development time. It is difficult to \nmaintain coherent teams who know about the system over that period as, inevi-\ntably, people move on to other jobs and projects.\n6. Large systems usually have a diverse set of stakeholders with different perspec-\ntives and objectives. For example, nurses and administrators may be the end-users \nof a medical system, but senior medical staff, hospital managers, and others, are \nalso stakeholders in the system. It is practically impossible to involve all of \nthese different stakeholders in the development process.\nLarge software system\nSystem of\nsystems\nBrownfield\ndevelopment\nDiverse\nstakeholders\nProlonged\nprocurement\nSystem\nconfiguration\nRegulatory\nconstraints\nFigure 3.13 Large \nproject characteristics"}
{"query": "What is the Scaled Agile Framework?", "response": "The Scaled Agile Framework (SAFe) is a method developed by Dean Leffingwell to support large-scale, multi-team software development. It is designed to scale agile methods and has been successfully used in a number of large companies. SAFe recognizes that scaling is a staged process, starting with core agile practices and moving towards disciplined agile delivery and agility at scale. It takes into account factors such as distributed development, complex legacy environments, and regulatory compliance requirements. SAFe emphasizes the need for adapting agile practices to a disciplined organizational setting and may involve modifying practices on a project-by-project basis.", "context": "3.4  \u25a0 Scaling agile methods  95\nDean Leffingwell, who has a great deal of experience in scaling agile methods, \nhas developed the Scaled Agile Framework (Leffingwell 2007, 2011) to support \nlarge-scale, multi-team software development. He reports how this method has been \nused successfully in a number of large companies. IBM has also developed a frame-\nwork for the large-scale use of agile methods called the Agile Scaling Model (ASM). \nFigure 3.14, taken from Ambler\u2019s white paper that discusses ASM (Ambler 2010), \nshows an overview of this model.\nThe ASM recognizes that scaling is a staged process where development teams \nmove from the core agile practices discussed here to what is called Disciplined Agile \nDelivery. Essentially, this stage involves adapting these practices to a disciplined \norganizational setting and recognizing that teams cannot simply focus on develop-\nment but must also take into account other stages of the software engineering \n process, such as requirements and architectural design.\nThe final scaling stage in ASM is to move to Agility at Scale where the com-\nplexity that is inherent in large projects is recognized. This involves taking account \nof factors such as distributed development, complex legacy environments, and \nregulatory compliance requirements. The practices used for disciplined agile \ndelivery may have to be modified on a project-by-project basis to take these into \naccount and, sometimes, additional plan-based practices added to the process.\nNo single model is appropriate for all large-scale agile products as the type of \nproduct, the customer requirements, and the people available are all different. \nHowever, approaches to scaling agile methods have a number of things in common:\nCore agile \ndevelopment\nDisciplined \nagile delivery\nAgility at\nscale\nAgility at scale\nDisciplined agile delivery where \nscaling factors apply:\nLarge team size\nGeographic distribution\nRegulatory compliance\nDomain complexity\nOrganization distribution\nTechnical complexity\nOrganizational complexity\nEnterprise discipline\nDisciplined agile delivery\nRisk+value driven life-cycle\nSelf-organizing with appropriate\ngovernance framework\nFull delivery life-cycle\nCore agile development\nValue-driven life-cycle\nSelf-organizing teams\nFocus on construction\nFigure 3.14 IBM\u2019s  \nAgility at Scale model  \n(\u00a9 IBM 2010)\n\n\n96  Chapter 3 \u25a0 Agile software development\n1. A completely incremental approach to requirements engineering is impossible. \nSome early work on initial software requirements is essential. You need this \nwork to identify the different parts of the system that may be developed by \n different teams and, often, to be part of the contract for the system development. \nHowever, these requirements should not normally be specified in detail; details \nare best developed incrementally.\n2. There cannot be a single product owner or customer representative. Different \npeople have to be involved for different parts of the system, and they have to \ncontinuously communicate and negotiate throughout the development process.\n3. It is not possible to focus only on the code of the system. You need to do more \nup-front design and system documentation. The software architecture has to be \ndesigned, and there has to be documentation produced to describe critical \naspects of the system, such as database schemas and the work breakdown \nacross teams.\n4. Cross-team communication mechanisms have to be designed and used. This \nshould involve regular phone and videoconferences between team members and \nfrequent, short electronic meetings where teams update each other on progress. \nA range of communication channels such as email, instant messaging, wikis, \nand social networking systems should be provided to facilitate communications.\n5. \nContinuous integration, where the whole system is built every time any devel-\noper checks in a change, is practically impossible when several separate \nprograms have to be integrated to create the system. However, it is essential \nto maintain frequent system builds and regular releases of the system. \nConfiguration management tools that support multi-team software develop-\nment are essential.\nScrum has been adapted for large-scale development. In essence, the Scrum team \nmodel described in Section 3.3 is maintained, but multiple Scrum teams are set up. \nThe key characteristics of multi-team Scrum are:\n1. Role replication Each team has a Product Owner for its work component and \nScrumMaster. There may be a chief Product Owner and ScrumMaster for the \nentire project.\n2. Product architects Each team chooses a product architect, and these architects \ncollaborate to design and evolve the overall system architecture.\n3. Release alignment The dates of product releases from each team are aligned so \nthat a demonstrable and complete system is produced.\n4. Scrum of Scrums There is a daily Scrum of Scrums where representatives from \neach team meet to discuss progress, identify problems, and plan the work to be \ndone that day. Individual team Scrums may be staggered in time so that repre-\nsentatives from other teams can attend if necessary."}
{"query": "Who developed the Scaled Agile Framework?", "response": "Dean Leffingwell developed the Scaled Agile Framework.", "context": "3.4  \u25a0 Scaling agile methods  95\nDean Leffingwell, who has a great deal of experience in scaling agile methods, \nhas developed the Scaled Agile Framework (Leffingwell 2007, 2011) to support \nlarge-scale, multi-team software development. He reports how this method has been \nused successfully in a number of large companies. IBM has also developed a frame-\nwork for the large-scale use of agile methods called the Agile Scaling Model (ASM). \nFigure 3.14, taken from Ambler\u2019s white paper that discusses ASM (Ambler 2010), \nshows an overview of this model.\nThe ASM recognizes that scaling is a staged process where development teams \nmove from the core agile practices discussed here to what is called Disciplined Agile \nDelivery. Essentially, this stage involves adapting these practices to a disciplined \norganizational setting and recognizing that teams cannot simply focus on develop-\nment but must also take into account other stages of the software engineering \n process, such as requirements and architectural design.\nThe final scaling stage in ASM is to move to Agility at Scale where the com-\nplexity that is inherent in large projects is recognized. This involves taking account \nof factors such as distributed development, complex legacy environments, and \nregulatory compliance requirements. The practices used for disciplined agile \ndelivery may have to be modified on a project-by-project basis to take these into \naccount and, sometimes, additional plan-based practices added to the process.\nNo single model is appropriate for all large-scale agile products as the type of \nproduct, the customer requirements, and the people available are all different. \nHowever, approaches to scaling agile methods have a number of things in common:\nCore agile \ndevelopment\nDisciplined \nagile delivery\nAgility at\nscale\nAgility at scale\nDisciplined agile delivery where \nscaling factors apply:\nLarge team size\nGeographic distribution\nRegulatory compliance\nDomain complexity\nOrganization distribution\nTechnical complexity\nOrganizational complexity\nEnterprise discipline\nDisciplined agile delivery\nRisk+value driven life-cycle\nSelf-organizing with appropriate\ngovernance framework\nFull delivery life-cycle\nCore agile development\nValue-driven life-cycle\nSelf-organizing teams\nFocus on construction\nFigure 3.14 IBM\u2019s  \nAgility at Scale model  \n(\u00a9 IBM 2010)\n\n\n96  Chapter 3 \u25a0 Agile software development\n1. A completely incremental approach to requirements engineering is impossible. \nSome early work on initial software requirements is essential. You need this \nwork to identify the different parts of the system that may be developed by \n different teams and, often, to be part of the contract for the system development. \nHowever, these requirements should not normally be specified in detail; details \nare best developed incrementally.\n2. There cannot be a single product owner or customer representative. Different \npeople have to be involved for different parts of the system, and they have to \ncontinuously communicate and negotiate throughout the development process.\n3. It is not possible to focus only on the code of the system. You need to do more \nup-front design and system documentation. The software architecture has to be \ndesigned, and there has to be documentation produced to describe critical \naspects of the system, such as database schemas and the work breakdown \nacross teams.\n4. Cross-team communication mechanisms have to be designed and used. This \nshould involve regular phone and videoconferences between team members and \nfrequent, short electronic meetings where teams update each other on progress. \nA range of communication channels such as email, instant messaging, wikis, \nand social networking systems should be provided to facilitate communications.\n5. \nContinuous integration, where the whole system is built every time any devel-\noper checks in a change, is practically impossible when several separate \nprograms have to be integrated to create the system. However, it is essential \nto maintain frequent system builds and regular releases of the system. \nConfiguration management tools that support multi-team software develop-\nment are essential.\nScrum has been adapted for large-scale development. In essence, the Scrum team \nmodel described in Section 3.3 is maintained, but multiple Scrum teams are set up. \nThe key characteristics of multi-team Scrum are:\n1. Role replication Each team has a Product Owner for its work component and \nScrumMaster. There may be a chief Product Owner and ScrumMaster for the \nentire project.\n2. Product architects Each team chooses a product architect, and these architects \ncollaborate to design and evolve the overall system architecture.\n3. Release alignment The dates of product releases from each team are aligned so \nthat a demonstrable and complete system is produced.\n4. Scrum of Scrums There is a daily Scrum of Scrums where representatives from \neach team meet to discuss progress, identify problems, and plan the work to be \ndone that day. Individual team Scrums may be staggered in time so that repre-\nsentatives from other teams can attend if necessary."}
{"query": "What is the purpose of the Scaled Agile Framework?", "response": "The purpose of the Scaled Agile Framework (SAFe) is to support large-scale, multi-team software development. It provides a method for scaling agile methods and has been used successfully in a number of large companies. SAFe helps organizations adapt agile practices to a disciplined organizational setting and take into account other stages of the software engineering process, such as requirements and architectural design. It also addresses the complexity inherent in large projects, including factors like distributed development, complex legacy environments, and regulatory compliance requirements.", "context": "3.4  \u25a0 Scaling agile methods  95\nDean Leffingwell, who has a great deal of experience in scaling agile methods, \nhas developed the Scaled Agile Framework (Leffingwell 2007, 2011) to support \nlarge-scale, multi-team software development. He reports how this method has been \nused successfully in a number of large companies. IBM has also developed a frame-\nwork for the large-scale use of agile methods called the Agile Scaling Model (ASM). \nFigure 3.14, taken from Ambler\u2019s white paper that discusses ASM (Ambler 2010), \nshows an overview of this model.\nThe ASM recognizes that scaling is a staged process where development teams \nmove from the core agile practices discussed here to what is called Disciplined Agile \nDelivery. Essentially, this stage involves adapting these practices to a disciplined \norganizational setting and recognizing that teams cannot simply focus on develop-\nment but must also take into account other stages of the software engineering \n process, such as requirements and architectural design.\nThe final scaling stage in ASM is to move to Agility at Scale where the com-\nplexity that is inherent in large projects is recognized. This involves taking account \nof factors such as distributed development, complex legacy environments, and \nregulatory compliance requirements. The practices used for disciplined agile \ndelivery may have to be modified on a project-by-project basis to take these into \naccount and, sometimes, additional plan-based practices added to the process.\nNo single model is appropriate for all large-scale agile products as the type of \nproduct, the customer requirements, and the people available are all different. \nHowever, approaches to scaling agile methods have a number of things in common:\nCore agile \ndevelopment\nDisciplined \nagile delivery\nAgility at\nscale\nAgility at scale\nDisciplined agile delivery where \nscaling factors apply:\nLarge team size\nGeographic distribution\nRegulatory compliance\nDomain complexity\nOrganization distribution\nTechnical complexity\nOrganizational complexity\nEnterprise discipline\nDisciplined agile delivery\nRisk+value driven life-cycle\nSelf-organizing with appropriate\ngovernance framework\nFull delivery life-cycle\nCore agile development\nValue-driven life-cycle\nSelf-organizing teams\nFocus on construction\nFigure 3.14 IBM\u2019s  \nAgility at Scale model  \n(\u00a9 IBM 2010)\n\n\n96  Chapter 3 \u25a0 Agile software development\n1. A completely incremental approach to requirements engineering is impossible. \nSome early work on initial software requirements is essential. You need this \nwork to identify the different parts of the system that may be developed by \n different teams and, often, to be part of the contract for the system development. \nHowever, these requirements should not normally be specified in detail; details \nare best developed incrementally.\n2. There cannot be a single product owner or customer representative. Different \npeople have to be involved for different parts of the system, and they have to \ncontinuously communicate and negotiate throughout the development process.\n3. It is not possible to focus only on the code of the system. You need to do more \nup-front design and system documentation. The software architecture has to be \ndesigned, and there has to be documentation produced to describe critical \naspects of the system, such as database schemas and the work breakdown \nacross teams.\n4. Cross-team communication mechanisms have to be designed and used. This \nshould involve regular phone and videoconferences between team members and \nfrequent, short electronic meetings where teams update each other on progress. \nA range of communication channels such as email, instant messaging, wikis, \nand social networking systems should be provided to facilitate communications.\n5. \nContinuous integration, where the whole system is built every time any devel-\noper checks in a change, is practically impossible when several separate \nprograms have to be integrated to create the system. However, it is essential \nto maintain frequent system builds and regular releases of the system. \nConfiguration management tools that support multi-team software develop-\nment are essential.\nScrum has been adapted for large-scale development. In essence, the Scrum team \nmodel described in Section 3.3 is maintained, but multiple Scrum teams are set up. \nThe key characteristics of multi-team Scrum are:\n1. Role replication Each team has a Product Owner for its work component and \nScrumMaster. There may be a chief Product Owner and ScrumMaster for the \nentire project.\n2. Product architects Each team chooses a product architect, and these architects \ncollaborate to design and evolve the overall system architecture.\n3. Release alignment The dates of product releases from each team are aligned so \nthat a demonstrable and complete system is produced.\n4. Scrum of Scrums There is a daily Scrum of Scrums where representatives from \neach team meet to discuss progress, identify problems, and plan the work to be \ndone that day. Individual team Scrums may be staggered in time so that repre-\nsentatives from other teams can attend if necessary."}
{"query": "What is the Agile Scaling Model (ASM)?", "response": "The Agile Scaling Model (ASM) is a framework developed by IBM for the large-scale use of agile methods in software development. It recognizes that scaling agile practices is a staged process, starting with core agile development and moving towards disciplined agile delivery. The final stage in ASM is Agility at Scale, where the complexity of large projects is taken into account. This involves considering factors such as distributed development, complex legacy environments, and regulatory compliance requirements. The practices used in disciplined agile delivery may need to be modified on a project-by-project basis to accommodate these factors.", "context": "3.4  \u25a0 Scaling agile methods  95\nDean Leffingwell, who has a great deal of experience in scaling agile methods, \nhas developed the Scaled Agile Framework (Leffingwell 2007, 2011) to support \nlarge-scale, multi-team software development. He reports how this method has been \nused successfully in a number of large companies. IBM has also developed a frame-\nwork for the large-scale use of agile methods called the Agile Scaling Model (ASM). \nFigure 3.14, taken from Ambler\u2019s white paper that discusses ASM (Ambler 2010), \nshows an overview of this model.\nThe ASM recognizes that scaling is a staged process where development teams \nmove from the core agile practices discussed here to what is called Disciplined Agile \nDelivery. Essentially, this stage involves adapting these practices to a disciplined \norganizational setting and recognizing that teams cannot simply focus on develop-\nment but must also take into account other stages of the software engineering \n process, such as requirements and architectural design.\nThe final scaling stage in ASM is to move to Agility at Scale where the com-\nplexity that is inherent in large projects is recognized. This involves taking account \nof factors such as distributed development, complex legacy environments, and \nregulatory compliance requirements. The practices used for disciplined agile \ndelivery may have to be modified on a project-by-project basis to take these into \naccount and, sometimes, additional plan-based practices added to the process.\nNo single model is appropriate for all large-scale agile products as the type of \nproduct, the customer requirements, and the people available are all different. \nHowever, approaches to scaling agile methods have a number of things in common:\nCore agile \ndevelopment\nDisciplined \nagile delivery\nAgility at\nscale\nAgility at scale\nDisciplined agile delivery where \nscaling factors apply:\nLarge team size\nGeographic distribution\nRegulatory compliance\nDomain complexity\nOrganization distribution\nTechnical complexity\nOrganizational complexity\nEnterprise discipline\nDisciplined agile delivery\nRisk+value driven life-cycle\nSelf-organizing with appropriate\ngovernance framework\nFull delivery life-cycle\nCore agile development\nValue-driven life-cycle\nSelf-organizing teams\nFocus on construction\nFigure 3.14 IBM\u2019s  \nAgility at Scale model  \n(\u00a9 IBM 2010)\n\n\n96  Chapter 3 \u25a0 Agile software development\n1. A completely incremental approach to requirements engineering is impossible. \nSome early work on initial software requirements is essential. You need this \nwork to identify the different parts of the system that may be developed by \n different teams and, often, to be part of the contract for the system development. \nHowever, these requirements should not normally be specified in detail; details \nare best developed incrementally.\n2. There cannot be a single product owner or customer representative. Different \npeople have to be involved for different parts of the system, and they have to \ncontinuously communicate and negotiate throughout the development process.\n3. It is not possible to focus only on the code of the system. You need to do more \nup-front design and system documentation. The software architecture has to be \ndesigned, and there has to be documentation produced to describe critical \naspects of the system, such as database schemas and the work breakdown \nacross teams.\n4. Cross-team communication mechanisms have to be designed and used. This \nshould involve regular phone and videoconferences between team members and \nfrequent, short electronic meetings where teams update each other on progress. \nA range of communication channels such as email, instant messaging, wikis, \nand social networking systems should be provided to facilitate communications.\n5. \nContinuous integration, where the whole system is built every time any devel-\noper checks in a change, is practically impossible when several separate \nprograms have to be integrated to create the system. However, it is essential \nto maintain frequent system builds and regular releases of the system. \nConfiguration management tools that support multi-team software develop-\nment are essential.\nScrum has been adapted for large-scale development. In essence, the Scrum team \nmodel described in Section 3.3 is maintained, but multiple Scrum teams are set up. \nThe key characteristics of multi-team Scrum are:\n1. Role replication Each team has a Product Owner for its work component and \nScrumMaster. There may be a chief Product Owner and ScrumMaster for the \nentire project.\n2. Product architects Each team chooses a product architect, and these architects \ncollaborate to design and evolve the overall system architecture.\n3. Release alignment The dates of product releases from each team are aligned so \nthat a demonstrable and complete system is produced.\n4. Scrum of Scrums There is a daily Scrum of Scrums where representatives from \neach team meet to discuss progress, identify problems, and plan the work to be \ndone that day. Individual team Scrums may be staggered in time so that repre-\nsentatives from other teams can attend if necessary."}
{"query": "Who developed the Agile Scaling Model?", "response": "The Agile Scaling Model (ASM) was developed by IBM.", "context": "3.4  \u25a0 Scaling agile methods  95\nDean Leffingwell, who has a great deal of experience in scaling agile methods, \nhas developed the Scaled Agile Framework (Leffingwell 2007, 2011) to support \nlarge-scale, multi-team software development. He reports how this method has been \nused successfully in a number of large companies. IBM has also developed a frame-\nwork for the large-scale use of agile methods called the Agile Scaling Model (ASM). \nFigure 3.14, taken from Ambler\u2019s white paper that discusses ASM (Ambler 2010), \nshows an overview of this model.\nThe ASM recognizes that scaling is a staged process where development teams \nmove from the core agile practices discussed here to what is called Disciplined Agile \nDelivery. Essentially, this stage involves adapting these practices to a disciplined \norganizational setting and recognizing that teams cannot simply focus on develop-\nment but must also take into account other stages of the software engineering \n process, such as requirements and architectural design.\nThe final scaling stage in ASM is to move to Agility at Scale where the com-\nplexity that is inherent in large projects is recognized. This involves taking account \nof factors such as distributed development, complex legacy environments, and \nregulatory compliance requirements. The practices used for disciplined agile \ndelivery may have to be modified on a project-by-project basis to take these into \naccount and, sometimes, additional plan-based practices added to the process.\nNo single model is appropriate for all large-scale agile products as the type of \nproduct, the customer requirements, and the people available are all different. \nHowever, approaches to scaling agile methods have a number of things in common:\nCore agile \ndevelopment\nDisciplined \nagile delivery\nAgility at\nscale\nAgility at scale\nDisciplined agile delivery where \nscaling factors apply:\nLarge team size\nGeographic distribution\nRegulatory compliance\nDomain complexity\nOrganization distribution\nTechnical complexity\nOrganizational complexity\nEnterprise discipline\nDisciplined agile delivery\nRisk+value driven life-cycle\nSelf-organizing with appropriate\ngovernance framework\nFull delivery life-cycle\nCore agile development\nValue-driven life-cycle\nSelf-organizing teams\nFocus on construction\nFigure 3.14 IBM\u2019s  \nAgility at Scale model  \n(\u00a9 IBM 2010)\n\n\n96  Chapter 3 \u25a0 Agile software development\n1. A completely incremental approach to requirements engineering is impossible. \nSome early work on initial software requirements is essential. You need this \nwork to identify the different parts of the system that may be developed by \n different teams and, often, to be part of the contract for the system development. \nHowever, these requirements should not normally be specified in detail; details \nare best developed incrementally.\n2. There cannot be a single product owner or customer representative. Different \npeople have to be involved for different parts of the system, and they have to \ncontinuously communicate and negotiate throughout the development process.\n3. It is not possible to focus only on the code of the system. You need to do more \nup-front design and system documentation. The software architecture has to be \ndesigned, and there has to be documentation produced to describe critical \naspects of the system, such as database schemas and the work breakdown \nacross teams.\n4. Cross-team communication mechanisms have to be designed and used. This \nshould involve regular phone and videoconferences between team members and \nfrequent, short electronic meetings where teams update each other on progress. \nA range of communication channels such as email, instant messaging, wikis, \nand social networking systems should be provided to facilitate communications.\n5. \nContinuous integration, where the whole system is built every time any devel-\noper checks in a change, is practically impossible when several separate \nprograms have to be integrated to create the system. However, it is essential \nto maintain frequent system builds and regular releases of the system. \nConfiguration management tools that support multi-team software develop-\nment are essential.\nScrum has been adapted for large-scale development. In essence, the Scrum team \nmodel described in Section 3.3 is maintained, but multiple Scrum teams are set up. \nThe key characteristics of multi-team Scrum are:\n1. Role replication Each team has a Product Owner for its work component and \nScrumMaster. There may be a chief Product Owner and ScrumMaster for the \nentire project.\n2. Product architects Each team chooses a product architect, and these architects \ncollaborate to design and evolve the overall system architecture.\n3. Release alignment The dates of product releases from each team are aligned so \nthat a demonstrable and complete system is produced.\n4. Scrum of Scrums There is a daily Scrum of Scrums where representatives from \neach team meet to discuss progress, identify problems, and plan the work to be \ndone that day. Individual team Scrums may be staggered in time so that repre-\nsentatives from other teams can attend if necessary."}
{"query": "What is the purpose of the Agile Scaling Model?", "response": "The purpose of the Agile Scaling Model is to support large-scale, multi-team software development by providing a framework for scaling agile methods. It recognizes that scaling is a staged process and helps teams move from core agile practices to disciplined agile delivery and eventually to agility at scale. The model takes into account factors such as distributed development, complex legacy environments, and regulatory compliance requirements, and provides guidance on adapting and modifying agile practices to suit the specific needs of large projects.", "context": "3.4  \u25a0 Scaling agile methods  95\nDean Leffingwell, who has a great deal of experience in scaling agile methods, \nhas developed the Scaled Agile Framework (Leffingwell 2007, 2011) to support \nlarge-scale, multi-team software development. He reports how this method has been \nused successfully in a number of large companies. IBM has also developed a frame-\nwork for the large-scale use of agile methods called the Agile Scaling Model (ASM). \nFigure 3.14, taken from Ambler\u2019s white paper that discusses ASM (Ambler 2010), \nshows an overview of this model.\nThe ASM recognizes that scaling is a staged process where development teams \nmove from the core agile practices discussed here to what is called Disciplined Agile \nDelivery. Essentially, this stage involves adapting these practices to a disciplined \norganizational setting and recognizing that teams cannot simply focus on develop-\nment but must also take into account other stages of the software engineering \n process, such as requirements and architectural design.\nThe final scaling stage in ASM is to move to Agility at Scale where the com-\nplexity that is inherent in large projects is recognized. This involves taking account \nof factors such as distributed development, complex legacy environments, and \nregulatory compliance requirements. The practices used for disciplined agile \ndelivery may have to be modified on a project-by-project basis to take these into \naccount and, sometimes, additional plan-based practices added to the process.\nNo single model is appropriate for all large-scale agile products as the type of \nproduct, the customer requirements, and the people available are all different. \nHowever, approaches to scaling agile methods have a number of things in common:\nCore agile \ndevelopment\nDisciplined \nagile delivery\nAgility at\nscale\nAgility at scale\nDisciplined agile delivery where \nscaling factors apply:\nLarge team size\nGeographic distribution\nRegulatory compliance\nDomain complexity\nOrganization distribution\nTechnical complexity\nOrganizational complexity\nEnterprise discipline\nDisciplined agile delivery\nRisk+value driven life-cycle\nSelf-organizing with appropriate\ngovernance framework\nFull delivery life-cycle\nCore agile development\nValue-driven life-cycle\nSelf-organizing teams\nFocus on construction\nFigure 3.14 IBM\u2019s  \nAgility at Scale model  \n(\u00a9 IBM 2010)\n\n\n96  Chapter 3 \u25a0 Agile software development\n1. A completely incremental approach to requirements engineering is impossible. \nSome early work on initial software requirements is essential. You need this \nwork to identify the different parts of the system that may be developed by \n different teams and, often, to be part of the contract for the system development. \nHowever, these requirements should not normally be specified in detail; details \nare best developed incrementally.\n2. There cannot be a single product owner or customer representative. Different \npeople have to be involved for different parts of the system, and they have to \ncontinuously communicate and negotiate throughout the development process.\n3. It is not possible to focus only on the code of the system. You need to do more \nup-front design and system documentation. The software architecture has to be \ndesigned, and there has to be documentation produced to describe critical \naspects of the system, such as database schemas and the work breakdown \nacross teams.\n4. Cross-team communication mechanisms have to be designed and used. This \nshould involve regular phone and videoconferences between team members and \nfrequent, short electronic meetings where teams update each other on progress. \nA range of communication channels such as email, instant messaging, wikis, \nand social networking systems should be provided to facilitate communications.\n5. \nContinuous integration, where the whole system is built every time any devel-\noper checks in a change, is practically impossible when several separate \nprograms have to be integrated to create the system. However, it is essential \nto maintain frequent system builds and regular releases of the system. \nConfiguration management tools that support multi-team software develop-\nment are essential.\nScrum has been adapted for large-scale development. In essence, the Scrum team \nmodel described in Section 3.3 is maintained, but multiple Scrum teams are set up. \nThe key characteristics of multi-team Scrum are:\n1. Role replication Each team has a Product Owner for its work component and \nScrumMaster. There may be a chief Product Owner and ScrumMaster for the \nentire project.\n2. Product architects Each team chooses a product architect, and these architects \ncollaborate to design and evolve the overall system architecture.\n3. Release alignment The dates of product releases from each team are aligned so \nthat a demonstrable and complete system is produced.\n4. Scrum of Scrums There is a daily Scrum of Scrums where representatives from \neach team meet to discuss progress, identify problems, and plan the work to be \ndone that day. Individual team Scrums may be staggered in time so that repre-\nsentatives from other teams can attend if necessary."}
{"query": "What is the final scaling stage in ASM?", "response": "The final scaling stage in ASM is Agility at Scale.", "context": "3.4  \u25a0 Scaling agile methods  95\nDean Leffingwell, who has a great deal of experience in scaling agile methods, \nhas developed the Scaled Agile Framework (Leffingwell 2007, 2011) to support \nlarge-scale, multi-team software development. He reports how this method has been \nused successfully in a number of large companies. IBM has also developed a frame-\nwork for the large-scale use of agile methods called the Agile Scaling Model (ASM). \nFigure 3.14, taken from Ambler\u2019s white paper that discusses ASM (Ambler 2010), \nshows an overview of this model.\nThe ASM recognizes that scaling is a staged process where development teams \nmove from the core agile practices discussed here to what is called Disciplined Agile \nDelivery. Essentially, this stage involves adapting these practices to a disciplined \norganizational setting and recognizing that teams cannot simply focus on develop-\nment but must also take into account other stages of the software engineering \n process, such as requirements and architectural design.\nThe final scaling stage in ASM is to move to Agility at Scale where the com-\nplexity that is inherent in large projects is recognized. This involves taking account \nof factors such as distributed development, complex legacy environments, and \nregulatory compliance requirements. The practices used for disciplined agile \ndelivery may have to be modified on a project-by-project basis to take these into \naccount and, sometimes, additional plan-based practices added to the process.\nNo single model is appropriate for all large-scale agile products as the type of \nproduct, the customer requirements, and the people available are all different. \nHowever, approaches to scaling agile methods have a number of things in common:\nCore agile \ndevelopment\nDisciplined \nagile delivery\nAgility at\nscale\nAgility at scale\nDisciplined agile delivery where \nscaling factors apply:\nLarge team size\nGeographic distribution\nRegulatory compliance\nDomain complexity\nOrganization distribution\nTechnical complexity\nOrganizational complexity\nEnterprise discipline\nDisciplined agile delivery\nRisk+value driven life-cycle\nSelf-organizing with appropriate\ngovernance framework\nFull delivery life-cycle\nCore agile development\nValue-driven life-cycle\nSelf-organizing teams\nFocus on construction\nFigure 3.14 IBM\u2019s  \nAgility at Scale model  \n(\u00a9 IBM 2010)\n\n\n96  Chapter 3 \u25a0 Agile software development\n1. A completely incremental approach to requirements engineering is impossible. \nSome early work on initial software requirements is essential. You need this \nwork to identify the different parts of the system that may be developed by \n different teams and, often, to be part of the contract for the system development. \nHowever, these requirements should not normally be specified in detail; details \nare best developed incrementally.\n2. There cannot be a single product owner or customer representative. Different \npeople have to be involved for different parts of the system, and they have to \ncontinuously communicate and negotiate throughout the development process.\n3. It is not possible to focus only on the code of the system. You need to do more \nup-front design and system documentation. The software architecture has to be \ndesigned, and there has to be documentation produced to describe critical \naspects of the system, such as database schemas and the work breakdown \nacross teams.\n4. Cross-team communication mechanisms have to be designed and used. This \nshould involve regular phone and videoconferences between team members and \nfrequent, short electronic meetings where teams update each other on progress. \nA range of communication channels such as email, instant messaging, wikis, \nand social networking systems should be provided to facilitate communications.\n5. \nContinuous integration, where the whole system is built every time any devel-\noper checks in a change, is practically impossible when several separate \nprograms have to be integrated to create the system. However, it is essential \nto maintain frequent system builds and regular releases of the system. \nConfiguration management tools that support multi-team software develop-\nment are essential.\nScrum has been adapted for large-scale development. In essence, the Scrum team \nmodel described in Section 3.3 is maintained, but multiple Scrum teams are set up. \nThe key characteristics of multi-team Scrum are:\n1. Role replication Each team has a Product Owner for its work component and \nScrumMaster. There may be a chief Product Owner and ScrumMaster for the \nentire project.\n2. Product architects Each team chooses a product architect, and these architects \ncollaborate to design and evolve the overall system architecture.\n3. Release alignment The dates of product releases from each team are aligned so \nthat a demonstrable and complete system is produced.\n4. Scrum of Scrums There is a daily Scrum of Scrums where representatives from \neach team meet to discuss progress, identify problems, and plan the work to be \ndone that day. Individual team Scrums may be staggered in time so that repre-\nsentatives from other teams can attend if necessary."}
{"query": "What factors need to be considered in the Agility at Scale stage?", "response": "Factors that need to be considered in the Agility at Scale stage include large team size, geographic distribution, regulatory compliance, domain complexity, organization distribution, technical complexity, organizational complexity, and enterprise discipline. These factors may require modifying the practices used for disciplined agile delivery on a project-by-project basis and potentially adding additional plan-based practices to the process.", "context": "3.4  \u25a0 Scaling agile methods  95\nDean Leffingwell, who has a great deal of experience in scaling agile methods, \nhas developed the Scaled Agile Framework (Leffingwell 2007, 2011) to support \nlarge-scale, multi-team software development. He reports how this method has been \nused successfully in a number of large companies. IBM has also developed a frame-\nwork for the large-scale use of agile methods called the Agile Scaling Model (ASM). \nFigure 3.14, taken from Ambler\u2019s white paper that discusses ASM (Ambler 2010), \nshows an overview of this model.\nThe ASM recognizes that scaling is a staged process where development teams \nmove from the core agile practices discussed here to what is called Disciplined Agile \nDelivery. Essentially, this stage involves adapting these practices to a disciplined \norganizational setting and recognizing that teams cannot simply focus on develop-\nment but must also take into account other stages of the software engineering \n process, such as requirements and architectural design.\nThe final scaling stage in ASM is to move to Agility at Scale where the com-\nplexity that is inherent in large projects is recognized. This involves taking account \nof factors such as distributed development, complex legacy environments, and \nregulatory compliance requirements. The practices used for disciplined agile \ndelivery may have to be modified on a project-by-project basis to take these into \naccount and, sometimes, additional plan-based practices added to the process.\nNo single model is appropriate for all large-scale agile products as the type of \nproduct, the customer requirements, and the people available are all different. \nHowever, approaches to scaling agile methods have a number of things in common:\nCore agile \ndevelopment\nDisciplined \nagile delivery\nAgility at\nscale\nAgility at scale\nDisciplined agile delivery where \nscaling factors apply:\nLarge team size\nGeographic distribution\nRegulatory compliance\nDomain complexity\nOrganization distribution\nTechnical complexity\nOrganizational complexity\nEnterprise discipline\nDisciplined agile delivery\nRisk+value driven life-cycle\nSelf-organizing with appropriate\ngovernance framework\nFull delivery life-cycle\nCore agile development\nValue-driven life-cycle\nSelf-organizing teams\nFocus on construction\nFigure 3.14 IBM\u2019s  \nAgility at Scale model  \n(\u00a9 IBM 2010)\n\n\n96  Chapter 3 \u25a0 Agile software development\n1. A completely incremental approach to requirements engineering is impossible. \nSome early work on initial software requirements is essential. You need this \nwork to identify the different parts of the system that may be developed by \n different teams and, often, to be part of the contract for the system development. \nHowever, these requirements should not normally be specified in detail; details \nare best developed incrementally.\n2. There cannot be a single product owner or customer representative. Different \npeople have to be involved for different parts of the system, and they have to \ncontinuously communicate and negotiate throughout the development process.\n3. It is not possible to focus only on the code of the system. You need to do more \nup-front design and system documentation. The software architecture has to be \ndesigned, and there has to be documentation produced to describe critical \naspects of the system, such as database schemas and the work breakdown \nacross teams.\n4. Cross-team communication mechanisms have to be designed and used. This \nshould involve regular phone and videoconferences between team members and \nfrequent, short electronic meetings where teams update each other on progress. \nA range of communication channels such as email, instant messaging, wikis, \nand social networking systems should be provided to facilitate communications.\n5. \nContinuous integration, where the whole system is built every time any devel-\noper checks in a change, is practically impossible when several separate \nprograms have to be integrated to create the system. However, it is essential \nto maintain frequent system builds and regular releases of the system. \nConfiguration management tools that support multi-team software develop-\nment are essential.\nScrum has been adapted for large-scale development. In essence, the Scrum team \nmodel described in Section 3.3 is maintained, but multiple Scrum teams are set up. \nThe key characteristics of multi-team Scrum are:\n1. Role replication Each team has a Product Owner for its work component and \nScrumMaster. There may be a chief Product Owner and ScrumMaster for the \nentire project.\n2. Product architects Each team chooses a product architect, and these architects \ncollaborate to design and evolve the overall system architecture.\n3. Release alignment The dates of product releases from each team are aligned so \nthat a demonstrable and complete system is produced.\n4. Scrum of Scrums There is a daily Scrum of Scrums where representatives from \neach team meet to discuss progress, identify problems, and plan the work to be \ndone that day. Individual team Scrums may be staggered in time so that repre-\nsentatives from other teams can attend if necessary."}
{"query": "How might the practices used for disciplined agile delivery need to be modified?", "response": "The practices used for disciplined agile delivery may need to be modified on a project-by-project basis to take into account factors such as distributed development, complex legacy environments, and regulatory compliance requirements. Additionally, sometimes additional plan-based practices may need to be added to the process.", "context": "3.4  \u25a0 Scaling agile methods  95\nDean Leffingwell, who has a great deal of experience in scaling agile methods, \nhas developed the Scaled Agile Framework (Leffingwell 2007, 2011) to support \nlarge-scale, multi-team software development. He reports how this method has been \nused successfully in a number of large companies. IBM has also developed a frame-\nwork for the large-scale use of agile methods called the Agile Scaling Model (ASM). \nFigure 3.14, taken from Ambler\u2019s white paper that discusses ASM (Ambler 2010), \nshows an overview of this model.\nThe ASM recognizes that scaling is a staged process where development teams \nmove from the core agile practices discussed here to what is called Disciplined Agile \nDelivery. Essentially, this stage involves adapting these practices to a disciplined \norganizational setting and recognizing that teams cannot simply focus on develop-\nment but must also take into account other stages of the software engineering \n process, such as requirements and architectural design.\nThe final scaling stage in ASM is to move to Agility at Scale where the com-\nplexity that is inherent in large projects is recognized. This involves taking account \nof factors such as distributed development, complex legacy environments, and \nregulatory compliance requirements. The practices used for disciplined agile \ndelivery may have to be modified on a project-by-project basis to take these into \naccount and, sometimes, additional plan-based practices added to the process.\nNo single model is appropriate for all large-scale agile products as the type of \nproduct, the customer requirements, and the people available are all different. \nHowever, approaches to scaling agile methods have a number of things in common:\nCore agile \ndevelopment\nDisciplined \nagile delivery\nAgility at\nscale\nAgility at scale\nDisciplined agile delivery where \nscaling factors apply:\nLarge team size\nGeographic distribution\nRegulatory compliance\nDomain complexity\nOrganization distribution\nTechnical complexity\nOrganizational complexity\nEnterprise discipline\nDisciplined agile delivery\nRisk+value driven life-cycle\nSelf-organizing with appropriate\ngovernance framework\nFull delivery life-cycle\nCore agile development\nValue-driven life-cycle\nSelf-organizing teams\nFocus on construction\nFigure 3.14 IBM\u2019s  \nAgility at Scale model  \n(\u00a9 IBM 2010)\n\n\n96  Chapter 3 \u25a0 Agile software development\n1. A completely incremental approach to requirements engineering is impossible. \nSome early work on initial software requirements is essential. You need this \nwork to identify the different parts of the system that may be developed by \n different teams and, often, to be part of the contract for the system development. \nHowever, these requirements should not normally be specified in detail; details \nare best developed incrementally.\n2. There cannot be a single product owner or customer representative. Different \npeople have to be involved for different parts of the system, and they have to \ncontinuously communicate and negotiate throughout the development process.\n3. It is not possible to focus only on the code of the system. You need to do more \nup-front design and system documentation. The software architecture has to be \ndesigned, and there has to be documentation produced to describe critical \naspects of the system, such as database schemas and the work breakdown \nacross teams.\n4. Cross-team communication mechanisms have to be designed and used. This \nshould involve regular phone and videoconferences between team members and \nfrequent, short electronic meetings where teams update each other on progress. \nA range of communication channels such as email, instant messaging, wikis, \nand social networking systems should be provided to facilitate communications.\n5. \nContinuous integration, where the whole system is built every time any devel-\noper checks in a change, is practically impossible when several separate \nprograms have to be integrated to create the system. However, it is essential \nto maintain frequent system builds and regular releases of the system. \nConfiguration management tools that support multi-team software develop-\nment are essential.\nScrum has been adapted for large-scale development. In essence, the Scrum team \nmodel described in Section 3.3 is maintained, but multiple Scrum teams are set up. \nThe key characteristics of multi-team Scrum are:\n1. Role replication Each team has a Product Owner for its work component and \nScrumMaster. There may be a chief Product Owner and ScrumMaster for the \nentire project.\n2. Product architects Each team chooses a product architect, and these architects \ncollaborate to design and evolve the overall system architecture.\n3. Release alignment The dates of product releases from each team are aligned so \nthat a demonstrable and complete system is produced.\n4. Scrum of Scrums There is a daily Scrum of Scrums where representatives from \neach team meet to discuss progress, identify problems, and plan the work to be \ndone that day. Individual team Scrums may be staggered in time so that repre-\nsentatives from other teams can attend if necessary."}
{"query": "Why might additional plan-based practices need to be added to the process?", "response": "Additional plan-based practices may need to be added to the process in order to address factors such as distributed development, complex legacy environments, and regulatory compliance requirements. These factors are recognized in the Agility at Scale stage of the Agile Scaling Model (ASM), and they may require modifications to the disciplined agile delivery practices used in the earlier stages. By incorporating additional plan-based practices, the development teams can effectively manage the complexity and specific challenges associated with large-scale projects.", "context": "3.4  \u25a0 Scaling agile methods  95\nDean Leffingwell, who has a great deal of experience in scaling agile methods, \nhas developed the Scaled Agile Framework (Leffingwell 2007, 2011) to support \nlarge-scale, multi-team software development. He reports how this method has been \nused successfully in a number of large companies. IBM has also developed a frame-\nwork for the large-scale use of agile methods called the Agile Scaling Model (ASM). \nFigure 3.14, taken from Ambler\u2019s white paper that discusses ASM (Ambler 2010), \nshows an overview of this model.\nThe ASM recognizes that scaling is a staged process where development teams \nmove from the core agile practices discussed here to what is called Disciplined Agile \nDelivery. Essentially, this stage involves adapting these practices to a disciplined \norganizational setting and recognizing that teams cannot simply focus on develop-\nment but must also take into account other stages of the software engineering \n process, such as requirements and architectural design.\nThe final scaling stage in ASM is to move to Agility at Scale where the com-\nplexity that is inherent in large projects is recognized. This involves taking account \nof factors such as distributed development, complex legacy environments, and \nregulatory compliance requirements. The practices used for disciplined agile \ndelivery may have to be modified on a project-by-project basis to take these into \naccount and, sometimes, additional plan-based practices added to the process.\nNo single model is appropriate for all large-scale agile products as the type of \nproduct, the customer requirements, and the people available are all different. \nHowever, approaches to scaling agile methods have a number of things in common:\nCore agile \ndevelopment\nDisciplined \nagile delivery\nAgility at\nscale\nAgility at scale\nDisciplined agile delivery where \nscaling factors apply:\nLarge team size\nGeographic distribution\nRegulatory compliance\nDomain complexity\nOrganization distribution\nTechnical complexity\nOrganizational complexity\nEnterprise discipline\nDisciplined agile delivery\nRisk+value driven life-cycle\nSelf-organizing with appropriate\ngovernance framework\nFull delivery life-cycle\nCore agile development\nValue-driven life-cycle\nSelf-organizing teams\nFocus on construction\nFigure 3.14 IBM\u2019s  \nAgility at Scale model  \n(\u00a9 IBM 2010)\n\n\n96  Chapter 3 \u25a0 Agile software development\n1. A completely incremental approach to requirements engineering is impossible. \nSome early work on initial software requirements is essential. You need this \nwork to identify the different parts of the system that may be developed by \n different teams and, often, to be part of the contract for the system development. \nHowever, these requirements should not normally be specified in detail; details \nare best developed incrementally.\n2. There cannot be a single product owner or customer representative. Different \npeople have to be involved for different parts of the system, and they have to \ncontinuously communicate and negotiate throughout the development process.\n3. It is not possible to focus only on the code of the system. You need to do more \nup-front design and system documentation. The software architecture has to be \ndesigned, and there has to be documentation produced to describe critical \naspects of the system, such as database schemas and the work breakdown \nacross teams.\n4. Cross-team communication mechanisms have to be designed and used. This \nshould involve regular phone and videoconferences between team members and \nfrequent, short electronic meetings where teams update each other on progress. \nA range of communication channels such as email, instant messaging, wikis, \nand social networking systems should be provided to facilitate communications.\n5. \nContinuous integration, where the whole system is built every time any devel-\noper checks in a change, is practically impossible when several separate \nprograms have to be integrated to create the system. However, it is essential \nto maintain frequent system builds and regular releases of the system. \nConfiguration management tools that support multi-team software develop-\nment are essential.\nScrum has been adapted for large-scale development. In essence, the Scrum team \nmodel described in Section 3.3 is maintained, but multiple Scrum teams are set up. \nThe key characteristics of multi-team Scrum are:\n1. Role replication Each team has a Product Owner for its work component and \nScrumMaster. There may be a chief Product Owner and ScrumMaster for the \nentire project.\n2. Product architects Each team chooses a product architect, and these architects \ncollaborate to design and evolve the overall system architecture.\n3. Release alignment The dates of product releases from each team are aligned so \nthat a demonstrable and complete system is produced.\n4. Scrum of Scrums There is a daily Scrum of Scrums where representatives from \neach team meet to discuss progress, identify problems, and plan the work to be \ndone that day. Individual team Scrums may be staggered in time so that repre-\nsentatives from other teams can attend if necessary."}
{"query": "What factors determine the appropriateness of a model for large-scale agile products?", "response": "The appropriateness of a model for large-scale agile products is determined by factors such as the type of product, customer requirements, and the available resources. These factors vary from project to project, and therefore, no single model is suitable for all large-scale agile products. However, approaches to scaling agile methods commonly consider factors such as team size, geographic distribution, regulatory compliance, domain complexity, organizational distribution, technical complexity, organizational complexity, and enterprise discipline. These factors need to be taken into account when selecting and adapting a model for large-scale agile development.", "context": "3.4  \u25a0 Scaling agile methods  95\nDean Leffingwell, who has a great deal of experience in scaling agile methods, \nhas developed the Scaled Agile Framework (Leffingwell 2007, 2011) to support \nlarge-scale, multi-team software development. He reports how this method has been \nused successfully in a number of large companies. IBM has also developed a frame-\nwork for the large-scale use of agile methods called the Agile Scaling Model (ASM). \nFigure 3.14, taken from Ambler\u2019s white paper that discusses ASM (Ambler 2010), \nshows an overview of this model.\nThe ASM recognizes that scaling is a staged process where development teams \nmove from the core agile practices discussed here to what is called Disciplined Agile \nDelivery. Essentially, this stage involves adapting these practices to a disciplined \norganizational setting and recognizing that teams cannot simply focus on develop-\nment but must also take into account other stages of the software engineering \n process, such as requirements and architectural design.\nThe final scaling stage in ASM is to move to Agility at Scale where the com-\nplexity that is inherent in large projects is recognized. This involves taking account \nof factors such as distributed development, complex legacy environments, and \nregulatory compliance requirements. The practices used for disciplined agile \ndelivery may have to be modified on a project-by-project basis to take these into \naccount and, sometimes, additional plan-based practices added to the process.\nNo single model is appropriate for all large-scale agile products as the type of \nproduct, the customer requirements, and the people available are all different. \nHowever, approaches to scaling agile methods have a number of things in common:\nCore agile \ndevelopment\nDisciplined \nagile delivery\nAgility at\nscale\nAgility at scale\nDisciplined agile delivery where \nscaling factors apply:\nLarge team size\nGeographic distribution\nRegulatory compliance\nDomain complexity\nOrganization distribution\nTechnical complexity\nOrganizational complexity\nEnterprise discipline\nDisciplined agile delivery\nRisk+value driven life-cycle\nSelf-organizing with appropriate\ngovernance framework\nFull delivery life-cycle\nCore agile development\nValue-driven life-cycle\nSelf-organizing teams\nFocus on construction\nFigure 3.14 IBM\u2019s  \nAgility at Scale model  \n(\u00a9 IBM 2010)\n\n\n96  Chapter 3 \u25a0 Agile software development\n1. A completely incremental approach to requirements engineering is impossible. \nSome early work on initial software requirements is essential. You need this \nwork to identify the different parts of the system that may be developed by \n different teams and, often, to be part of the contract for the system development. \nHowever, these requirements should not normally be specified in detail; details \nare best developed incrementally.\n2. There cannot be a single product owner or customer representative. Different \npeople have to be involved for different parts of the system, and they have to \ncontinuously communicate and negotiate throughout the development process.\n3. It is not possible to focus only on the code of the system. You need to do more \nup-front design and system documentation. The software architecture has to be \ndesigned, and there has to be documentation produced to describe critical \naspects of the system, such as database schemas and the work breakdown \nacross teams.\n4. Cross-team communication mechanisms have to be designed and used. This \nshould involve regular phone and videoconferences between team members and \nfrequent, short electronic meetings where teams update each other on progress. \nA range of communication channels such as email, instant messaging, wikis, \nand social networking systems should be provided to facilitate communications.\n5. \nContinuous integration, where the whole system is built every time any devel-\noper checks in a change, is practically impossible when several separate \nprograms have to be integrated to create the system. However, it is essential \nto maintain frequent system builds and regular releases of the system. \nConfiguration management tools that support multi-team software develop-\nment are essential.\nScrum has been adapted for large-scale development. In essence, the Scrum team \nmodel described in Section 3.3 is maintained, but multiple Scrum teams are set up. \nThe key characteristics of multi-team Scrum are:\n1. Role replication Each team has a Product Owner for its work component and \nScrumMaster. There may be a chief Product Owner and ScrumMaster for the \nentire project.\n2. Product architects Each team chooses a product architect, and these architects \ncollaborate to design and evolve the overall system architecture.\n3. Release alignment The dates of product releases from each team are aligned so \nthat a demonstrable and complete system is produced.\n4. Scrum of Scrums There is a daily Scrum of Scrums where representatives from \neach team meet to discuss progress, identify problems, and plan the work to be \ndone that day. Individual team Scrums may be staggered in time so that repre-\nsentatives from other teams can attend if necessary."}
{"query": "What is Disciplined Agile Delivery?", "response": "Disciplined Agile Delivery is a stage in the scaling process of agile methods, as recognized by the Agile Scaling Model (ASM). It involves adapting core agile practices to a disciplined organizational setting and considering other stages of the software engineering process, such as requirements and architectural design. In this stage, teams must also take into account factors like distributed development, complex legacy environments, and regulatory compliance requirements. The practices used for disciplined agile delivery may need to be modified on a project-by-project basis to accommodate these factors, and additional plan-based practices may be added to the process.", "context": "3.4  \u25a0 Scaling agile methods  95\nDean Leffingwell, who has a great deal of experience in scaling agile methods, \nhas developed the Scaled Agile Framework (Leffingwell 2007, 2011) to support \nlarge-scale, multi-team software development. He reports how this method has been \nused successfully in a number of large companies. IBM has also developed a frame-\nwork for the large-scale use of agile methods called the Agile Scaling Model (ASM). \nFigure 3.14, taken from Ambler\u2019s white paper that discusses ASM (Ambler 2010), \nshows an overview of this model.\nThe ASM recognizes that scaling is a staged process where development teams \nmove from the core agile practices discussed here to what is called Disciplined Agile \nDelivery. Essentially, this stage involves adapting these practices to a disciplined \norganizational setting and recognizing that teams cannot simply focus on develop-\nment but must also take into account other stages of the software engineering \n process, such as requirements and architectural design.\nThe final scaling stage in ASM is to move to Agility at Scale where the com-\nplexity that is inherent in large projects is recognized. This involves taking account \nof factors such as distributed development, complex legacy environments, and \nregulatory compliance requirements. The practices used for disciplined agile \ndelivery may have to be modified on a project-by-project basis to take these into \naccount and, sometimes, additional plan-based practices added to the process.\nNo single model is appropriate for all large-scale agile products as the type of \nproduct, the customer requirements, and the people available are all different. \nHowever, approaches to scaling agile methods have a number of things in common:\nCore agile \ndevelopment\nDisciplined \nagile delivery\nAgility at\nscale\nAgility at scale\nDisciplined agile delivery where \nscaling factors apply:\nLarge team size\nGeographic distribution\nRegulatory compliance\nDomain complexity\nOrganization distribution\nTechnical complexity\nOrganizational complexity\nEnterprise discipline\nDisciplined agile delivery\nRisk+value driven life-cycle\nSelf-organizing with appropriate\ngovernance framework\nFull delivery life-cycle\nCore agile development\nValue-driven life-cycle\nSelf-organizing teams\nFocus on construction\nFigure 3.14 IBM\u2019s  \nAgility at Scale model  \n(\u00a9 IBM 2010)\n\n\n96  Chapter 3 \u25a0 Agile software development\n1. A completely incremental approach to requirements engineering is impossible. \nSome early work on initial software requirements is essential. You need this \nwork to identify the different parts of the system that may be developed by \n different teams and, often, to be part of the contract for the system development. \nHowever, these requirements should not normally be specified in detail; details \nare best developed incrementally.\n2. There cannot be a single product owner or customer representative. Different \npeople have to be involved for different parts of the system, and they have to \ncontinuously communicate and negotiate throughout the development process.\n3. It is not possible to focus only on the code of the system. You need to do more \nup-front design and system documentation. The software architecture has to be \ndesigned, and there has to be documentation produced to describe critical \naspects of the system, such as database schemas and the work breakdown \nacross teams.\n4. Cross-team communication mechanisms have to be designed and used. This \nshould involve regular phone and videoconferences between team members and \nfrequent, short electronic meetings where teams update each other on progress. \nA range of communication channels such as email, instant messaging, wikis, \nand social networking systems should be provided to facilitate communications.\n5. \nContinuous integration, where the whole system is built every time any devel-\noper checks in a change, is practically impossible when several separate \nprograms have to be integrated to create the system. However, it is essential \nto maintain frequent system builds and regular releases of the system. \nConfiguration management tools that support multi-team software develop-\nment are essential.\nScrum has been adapted for large-scale development. In essence, the Scrum team \nmodel described in Section 3.3 is maintained, but multiple Scrum teams are set up. \nThe key characteristics of multi-team Scrum are:\n1. Role replication Each team has a Product Owner for its work component and \nScrumMaster. There may be a chief Product Owner and ScrumMaster for the \nentire project.\n2. Product architects Each team chooses a product architect, and these architects \ncollaborate to design and evolve the overall system architecture.\n3. Release alignment The dates of product releases from each team are aligned so \nthat a demonstrable and complete system is produced.\n4. Scrum of Scrums There is a daily Scrum of Scrums where representatives from \neach team meet to discuss progress, identify problems, and plan the work to be \ndone that day. Individual team Scrums may be staggered in time so that repre-\nsentatives from other teams can attend if necessary."}
{"query": "What is the role of requirements engineering in agile methods?", "response": "The role of requirements engineering in agile methods is to provide early work on initial software requirements. This work is essential for identifying different parts of the system that may be developed by different teams and for being part of the contract for system development. However, these requirements should not be specified in detail initially, as details are best developed incrementally.", "context": "3.4  \u25a0 Scaling agile methods  95\nDean Leffingwell, who has a great deal of experience in scaling agile methods, \nhas developed the Scaled Agile Framework (Leffingwell 2007, 2011) to support \nlarge-scale, multi-team software development. He reports how this method has been \nused successfully in a number of large companies. IBM has also developed a frame-\nwork for the large-scale use of agile methods called the Agile Scaling Model (ASM). \nFigure 3.14, taken from Ambler\u2019s white paper that discusses ASM (Ambler 2010), \nshows an overview of this model.\nThe ASM recognizes that scaling is a staged process where development teams \nmove from the core agile practices discussed here to what is called Disciplined Agile \nDelivery. Essentially, this stage involves adapting these practices to a disciplined \norganizational setting and recognizing that teams cannot simply focus on develop-\nment but must also take into account other stages of the software engineering \n process, such as requirements and architectural design.\nThe final scaling stage in ASM is to move to Agility at Scale where the com-\nplexity that is inherent in large projects is recognized. This involves taking account \nof factors such as distributed development, complex legacy environments, and \nregulatory compliance requirements. The practices used for disciplined agile \ndelivery may have to be modified on a project-by-project basis to take these into \naccount and, sometimes, additional plan-based practices added to the process.\nNo single model is appropriate for all large-scale agile products as the type of \nproduct, the customer requirements, and the people available are all different. \nHowever, approaches to scaling agile methods have a number of things in common:\nCore agile \ndevelopment\nDisciplined \nagile delivery\nAgility at\nscale\nAgility at scale\nDisciplined agile delivery where \nscaling factors apply:\nLarge team size\nGeographic distribution\nRegulatory compliance\nDomain complexity\nOrganization distribution\nTechnical complexity\nOrganizational complexity\nEnterprise discipline\nDisciplined agile delivery\nRisk+value driven life-cycle\nSelf-organizing with appropriate\ngovernance framework\nFull delivery life-cycle\nCore agile development\nValue-driven life-cycle\nSelf-organizing teams\nFocus on construction\nFigure 3.14 IBM\u2019s  \nAgility at Scale model  \n(\u00a9 IBM 2010)\n\n\n96  Chapter 3 \u25a0 Agile software development\n1. A completely incremental approach to requirements engineering is impossible. \nSome early work on initial software requirements is essential. You need this \nwork to identify the different parts of the system that may be developed by \n different teams and, often, to be part of the contract for the system development. \nHowever, these requirements should not normally be specified in detail; details \nare best developed incrementally.\n2. There cannot be a single product owner or customer representative. Different \npeople have to be involved for different parts of the system, and they have to \ncontinuously communicate and negotiate throughout the development process.\n3. It is not possible to focus only on the code of the system. You need to do more \nup-front design and system documentation. The software architecture has to be \ndesigned, and there has to be documentation produced to describe critical \naspects of the system, such as database schemas and the work breakdown \nacross teams.\n4. Cross-team communication mechanisms have to be designed and used. This \nshould involve regular phone and videoconferences between team members and \nfrequent, short electronic meetings where teams update each other on progress. \nA range of communication channels such as email, instant messaging, wikis, \nand social networking systems should be provided to facilitate communications.\n5. \nContinuous integration, where the whole system is built every time any devel-\noper checks in a change, is practically impossible when several separate \nprograms have to be integrated to create the system. However, it is essential \nto maintain frequent system builds and regular releases of the system. \nConfiguration management tools that support multi-team software develop-\nment are essential.\nScrum has been adapted for large-scale development. In essence, the Scrum team \nmodel described in Section 3.3 is maintained, but multiple Scrum teams are set up. \nThe key characteristics of multi-team Scrum are:\n1. Role replication Each team has a Product Owner for its work component and \nScrumMaster. There may be a chief Product Owner and ScrumMaster for the \nentire project.\n2. Product architects Each team chooses a product architect, and these architects \ncollaborate to design and evolve the overall system architecture.\n3. Release alignment The dates of product releases from each team are aligned so \nthat a demonstrable and complete system is produced.\n4. Scrum of Scrums There is a daily Scrum of Scrums where representatives from \neach team meet to discuss progress, identify problems, and plan the work to be \ndone that day. Individual team Scrums may be staggered in time so that repre-\nsentatives from other teams can attend if necessary."}
{"query": "Why is a completely incremental approach to requirements engineering impossible?", "response": "A completely incremental approach to requirements engineering is impossible because some early work on initial software requirements is essential. This initial work helps identify the different parts of the system that may be developed by different teams and is often part of the contract for system development. While these requirements should not be specified in detail, they provide a foundation for the incremental development process.", "context": "3.4  \u25a0 Scaling agile methods  95\nDean Leffingwell, who has a great deal of experience in scaling agile methods, \nhas developed the Scaled Agile Framework (Leffingwell 2007, 2011) to support \nlarge-scale, multi-team software development. He reports how this method has been \nused successfully in a number of large companies. IBM has also developed a frame-\nwork for the large-scale use of agile methods called the Agile Scaling Model (ASM). \nFigure 3.14, taken from Ambler\u2019s white paper that discusses ASM (Ambler 2010), \nshows an overview of this model.\nThe ASM recognizes that scaling is a staged process where development teams \nmove from the core agile practices discussed here to what is called Disciplined Agile \nDelivery. Essentially, this stage involves adapting these practices to a disciplined \norganizational setting and recognizing that teams cannot simply focus on develop-\nment but must also take into account other stages of the software engineering \n process, such as requirements and architectural design.\nThe final scaling stage in ASM is to move to Agility at Scale where the com-\nplexity that is inherent in large projects is recognized. This involves taking account \nof factors such as distributed development, complex legacy environments, and \nregulatory compliance requirements. The practices used for disciplined agile \ndelivery may have to be modified on a project-by-project basis to take these into \naccount and, sometimes, additional plan-based practices added to the process.\nNo single model is appropriate for all large-scale agile products as the type of \nproduct, the customer requirements, and the people available are all different. \nHowever, approaches to scaling agile methods have a number of things in common:\nCore agile \ndevelopment\nDisciplined \nagile delivery\nAgility at\nscale\nAgility at scale\nDisciplined agile delivery where \nscaling factors apply:\nLarge team size\nGeographic distribution\nRegulatory compliance\nDomain complexity\nOrganization distribution\nTechnical complexity\nOrganizational complexity\nEnterprise discipline\nDisciplined agile delivery\nRisk+value driven life-cycle\nSelf-organizing with appropriate\ngovernance framework\nFull delivery life-cycle\nCore agile development\nValue-driven life-cycle\nSelf-organizing teams\nFocus on construction\nFigure 3.14 IBM\u2019s  \nAgility at Scale model  \n(\u00a9 IBM 2010)\n\n\n96  Chapter 3 \u25a0 Agile software development\n1. A completely incremental approach to requirements engineering is impossible. \nSome early work on initial software requirements is essential. You need this \nwork to identify the different parts of the system that may be developed by \n different teams and, often, to be part of the contract for the system development. \nHowever, these requirements should not normally be specified in detail; details \nare best developed incrementally.\n2. There cannot be a single product owner or customer representative. Different \npeople have to be involved for different parts of the system, and they have to \ncontinuously communicate and negotiate throughout the development process.\n3. It is not possible to focus only on the code of the system. You need to do more \nup-front design and system documentation. The software architecture has to be \ndesigned, and there has to be documentation produced to describe critical \naspects of the system, such as database schemas and the work breakdown \nacross teams.\n4. Cross-team communication mechanisms have to be designed and used. This \nshould involve regular phone and videoconferences between team members and \nfrequent, short electronic meetings where teams update each other on progress. \nA range of communication channels such as email, instant messaging, wikis, \nand social networking systems should be provided to facilitate communications.\n5. \nContinuous integration, where the whole system is built every time any devel-\noper checks in a change, is practically impossible when several separate \nprograms have to be integrated to create the system. However, it is essential \nto maintain frequent system builds and regular releases of the system. \nConfiguration management tools that support multi-team software develop-\nment are essential.\nScrum has been adapted for large-scale development. In essence, the Scrum team \nmodel described in Section 3.3 is maintained, but multiple Scrum teams are set up. \nThe key characteristics of multi-team Scrum are:\n1. Role replication Each team has a Product Owner for its work component and \nScrumMaster. There may be a chief Product Owner and ScrumMaster for the \nentire project.\n2. Product architects Each team chooses a product architect, and these architects \ncollaborate to design and evolve the overall system architecture.\n3. Release alignment The dates of product releases from each team are aligned so \nthat a demonstrable and complete system is produced.\n4. Scrum of Scrums There is a daily Scrum of Scrums where representatives from \neach team meet to discuss progress, identify problems, and plan the work to be \ndone that day. Individual team Scrums may be staggered in time so that repre-\nsentatives from other teams can attend if necessary."}
{"query": "Why is it necessary to involve different people for different parts of the system?", "response": "Involving different people for different parts of the system is necessary because each part of the system may require specific expertise and knowledge. By involving different people, the development process can benefit from their specialized skills and perspectives, leading to a more comprehensive and effective system. Additionally, involving different people allows for continuous communication and negotiation throughout the development process, ensuring that all aspects of the system are properly addressed and aligned with the requirements and goals.", "context": "3.4  \u25a0 Scaling agile methods  95\nDean Leffingwell, who has a great deal of experience in scaling agile methods, \nhas developed the Scaled Agile Framework (Leffingwell 2007, 2011) to support \nlarge-scale, multi-team software development. He reports how this method has been \nused successfully in a number of large companies. IBM has also developed a frame-\nwork for the large-scale use of agile methods called the Agile Scaling Model (ASM). \nFigure 3.14, taken from Ambler\u2019s white paper that discusses ASM (Ambler 2010), \nshows an overview of this model.\nThe ASM recognizes that scaling is a staged process where development teams \nmove from the core agile practices discussed here to what is called Disciplined Agile \nDelivery. Essentially, this stage involves adapting these practices to a disciplined \norganizational setting and recognizing that teams cannot simply focus on develop-\nment but must also take into account other stages of the software engineering \n process, such as requirements and architectural design.\nThe final scaling stage in ASM is to move to Agility at Scale where the com-\nplexity that is inherent in large projects is recognized. This involves taking account \nof factors such as distributed development, complex legacy environments, and \nregulatory compliance requirements. The practices used for disciplined agile \ndelivery may have to be modified on a project-by-project basis to take these into \naccount and, sometimes, additional plan-based practices added to the process.\nNo single model is appropriate for all large-scale agile products as the type of \nproduct, the customer requirements, and the people available are all different. \nHowever, approaches to scaling agile methods have a number of things in common:\nCore agile \ndevelopment\nDisciplined \nagile delivery\nAgility at\nscale\nAgility at scale\nDisciplined agile delivery where \nscaling factors apply:\nLarge team size\nGeographic distribution\nRegulatory compliance\nDomain complexity\nOrganization distribution\nTechnical complexity\nOrganizational complexity\nEnterprise discipline\nDisciplined agile delivery\nRisk+value driven life-cycle\nSelf-organizing with appropriate\ngovernance framework\nFull delivery life-cycle\nCore agile development\nValue-driven life-cycle\nSelf-organizing teams\nFocus on construction\nFigure 3.14 IBM\u2019s  \nAgility at Scale model  \n(\u00a9 IBM 2010)\n\n\n96  Chapter 3 \u25a0 Agile software development\n1. A completely incremental approach to requirements engineering is impossible. \nSome early work on initial software requirements is essential. You need this \nwork to identify the different parts of the system that may be developed by \n different teams and, often, to be part of the contract for the system development. \nHowever, these requirements should not normally be specified in detail; details \nare best developed incrementally.\n2. There cannot be a single product owner or customer representative. Different \npeople have to be involved for different parts of the system, and they have to \ncontinuously communicate and negotiate throughout the development process.\n3. It is not possible to focus only on the code of the system. You need to do more \nup-front design and system documentation. The software architecture has to be \ndesigned, and there has to be documentation produced to describe critical \naspects of the system, such as database schemas and the work breakdown \nacross teams.\n4. Cross-team communication mechanisms have to be designed and used. This \nshould involve regular phone and videoconferences between team members and \nfrequent, short electronic meetings where teams update each other on progress. \nA range of communication channels such as email, instant messaging, wikis, \nand social networking systems should be provided to facilitate communications.\n5. \nContinuous integration, where the whole system is built every time any devel-\noper checks in a change, is practically impossible when several separate \nprograms have to be integrated to create the system. However, it is essential \nto maintain frequent system builds and regular releases of the system. \nConfiguration management tools that support multi-team software develop-\nment are essential.\nScrum has been adapted for large-scale development. In essence, the Scrum team \nmodel described in Section 3.3 is maintained, but multiple Scrum teams are set up. \nThe key characteristics of multi-team Scrum are:\n1. Role replication Each team has a Product Owner for its work component and \nScrumMaster. There may be a chief Product Owner and ScrumMaster for the \nentire project.\n2. Product architects Each team chooses a product architect, and these architects \ncollaborate to design and evolve the overall system architecture.\n3. Release alignment The dates of product releases from each team are aligned so \nthat a demonstrable and complete system is produced.\n4. Scrum of Scrums There is a daily Scrum of Scrums where representatives from \neach team meet to discuss progress, identify problems, and plan the work to be \ndone that day. Individual team Scrums may be staggered in time so that repre-\nsentatives from other teams can attend if necessary."}
{"query": "Why is it necessary to do more up-front design and system documentation in large-scale agile projects?", "response": "In large-scale agile projects, it is necessary to do more up-front design and system documentation because the software architecture needs to be designed and critical aspects of the system, such as database schemas and work breakdown across teams, need to be documented. This is important to ensure that different parts of the system can be developed by different teams and to facilitate cross-team communication and coordination. Additionally, having up-front design and documentation helps in maintaining frequent system builds and regular releases of the system, which are essential in large-scale agile projects.", "context": "3.4  \u25a0 Scaling agile methods  95\nDean Leffingwell, who has a great deal of experience in scaling agile methods, \nhas developed the Scaled Agile Framework (Leffingwell 2007, 2011) to support \nlarge-scale, multi-team software development. He reports how this method has been \nused successfully in a number of large companies. IBM has also developed a frame-\nwork for the large-scale use of agile methods called the Agile Scaling Model (ASM). \nFigure 3.14, taken from Ambler\u2019s white paper that discusses ASM (Ambler 2010), \nshows an overview of this model.\nThe ASM recognizes that scaling is a staged process where development teams \nmove from the core agile practices discussed here to what is called Disciplined Agile \nDelivery. Essentially, this stage involves adapting these practices to a disciplined \norganizational setting and recognizing that teams cannot simply focus on develop-\nment but must also take into account other stages of the software engineering \n process, such as requirements and architectural design.\nThe final scaling stage in ASM is to move to Agility at Scale where the com-\nplexity that is inherent in large projects is recognized. This involves taking account \nof factors such as distributed development, complex legacy environments, and \nregulatory compliance requirements. The practices used for disciplined agile \ndelivery may have to be modified on a project-by-project basis to take these into \naccount and, sometimes, additional plan-based practices added to the process.\nNo single model is appropriate for all large-scale agile products as the type of \nproduct, the customer requirements, and the people available are all different. \nHowever, approaches to scaling agile methods have a number of things in common:\nCore agile \ndevelopment\nDisciplined \nagile delivery\nAgility at\nscale\nAgility at scale\nDisciplined agile delivery where \nscaling factors apply:\nLarge team size\nGeographic distribution\nRegulatory compliance\nDomain complexity\nOrganization distribution\nTechnical complexity\nOrganizational complexity\nEnterprise discipline\nDisciplined agile delivery\nRisk+value driven life-cycle\nSelf-organizing with appropriate\ngovernance framework\nFull delivery life-cycle\nCore agile development\nValue-driven life-cycle\nSelf-organizing teams\nFocus on construction\nFigure 3.14 IBM\u2019s  \nAgility at Scale model  \n(\u00a9 IBM 2010)\n\n\n96  Chapter 3 \u25a0 Agile software development\n1. A completely incremental approach to requirements engineering is impossible. \nSome early work on initial software requirements is essential. You need this \nwork to identify the different parts of the system that may be developed by \n different teams and, often, to be part of the contract for the system development. \nHowever, these requirements should not normally be specified in detail; details \nare best developed incrementally.\n2. There cannot be a single product owner or customer representative. Different \npeople have to be involved for different parts of the system, and they have to \ncontinuously communicate and negotiate throughout the development process.\n3. It is not possible to focus only on the code of the system. You need to do more \nup-front design and system documentation. The software architecture has to be \ndesigned, and there has to be documentation produced to describe critical \naspects of the system, such as database schemas and the work breakdown \nacross teams.\n4. Cross-team communication mechanisms have to be designed and used. This \nshould involve regular phone and videoconferences between team members and \nfrequent, short electronic meetings where teams update each other on progress. \nA range of communication channels such as email, instant messaging, wikis, \nand social networking systems should be provided to facilitate communications.\n5. \nContinuous integration, where the whole system is built every time any devel-\noper checks in a change, is practically impossible when several separate \nprograms have to be integrated to create the system. However, it is essential \nto maintain frequent system builds and regular releases of the system. \nConfiguration management tools that support multi-team software develop-\nment are essential.\nScrum has been adapted for large-scale development. In essence, the Scrum team \nmodel described in Section 3.3 is maintained, but multiple Scrum teams are set up. \nThe key characteristics of multi-team Scrum are:\n1. Role replication Each team has a Product Owner for its work component and \nScrumMaster. There may be a chief Product Owner and ScrumMaster for the \nentire project.\n2. Product architects Each team chooses a product architect, and these architects \ncollaborate to design and evolve the overall system architecture.\n3. Release alignment The dates of product releases from each team are aligned so \nthat a demonstrable and complete system is produced.\n4. Scrum of Scrums There is a daily Scrum of Scrums where representatives from \neach team meet to discuss progress, identify problems, and plan the work to be \ndone that day. Individual team Scrums may be staggered in time so that repre-\nsentatives from other teams can attend if necessary."}
{"query": "What are some examples of cross-team communication mechanisms that need to be designed and used?", "response": "Regular phone and videoconferences between team members and frequent, short electronic meetings where teams update each other on progress are examples of cross-team communication mechanisms that need to be designed and used. Additionally, a range of communication channels such as email, instant messaging, wikis, and social networking systems should be provided to facilitate communications.", "context": "3.4  \u25a0 Scaling agile methods  95\nDean Leffingwell, who has a great deal of experience in scaling agile methods, \nhas developed the Scaled Agile Framework (Leffingwell 2007, 2011) to support \nlarge-scale, multi-team software development. He reports how this method has been \nused successfully in a number of large companies. IBM has also developed a frame-\nwork for the large-scale use of agile methods called the Agile Scaling Model (ASM). \nFigure 3.14, taken from Ambler\u2019s white paper that discusses ASM (Ambler 2010), \nshows an overview of this model.\nThe ASM recognizes that scaling is a staged process where development teams \nmove from the core agile practices discussed here to what is called Disciplined Agile \nDelivery. Essentially, this stage involves adapting these practices to a disciplined \norganizational setting and recognizing that teams cannot simply focus on develop-\nment but must also take into account other stages of the software engineering \n process, such as requirements and architectural design.\nThe final scaling stage in ASM is to move to Agility at Scale where the com-\nplexity that is inherent in large projects is recognized. This involves taking account \nof factors such as distributed development, complex legacy environments, and \nregulatory compliance requirements. The practices used for disciplined agile \ndelivery may have to be modified on a project-by-project basis to take these into \naccount and, sometimes, additional plan-based practices added to the process.\nNo single model is appropriate for all large-scale agile products as the type of \nproduct, the customer requirements, and the people available are all different. \nHowever, approaches to scaling agile methods have a number of things in common:\nCore agile \ndevelopment\nDisciplined \nagile delivery\nAgility at\nscale\nAgility at scale\nDisciplined agile delivery where \nscaling factors apply:\nLarge team size\nGeographic distribution\nRegulatory compliance\nDomain complexity\nOrganization distribution\nTechnical complexity\nOrganizational complexity\nEnterprise discipline\nDisciplined agile delivery\nRisk+value driven life-cycle\nSelf-organizing with appropriate\ngovernance framework\nFull delivery life-cycle\nCore agile development\nValue-driven life-cycle\nSelf-organizing teams\nFocus on construction\nFigure 3.14 IBM\u2019s  \nAgility at Scale model  \n(\u00a9 IBM 2010)\n\n\n96  Chapter 3 \u25a0 Agile software development\n1. A completely incremental approach to requirements engineering is impossible. \nSome early work on initial software requirements is essential. You need this \nwork to identify the different parts of the system that may be developed by \n different teams and, often, to be part of the contract for the system development. \nHowever, these requirements should not normally be specified in detail; details \nare best developed incrementally.\n2. There cannot be a single product owner or customer representative. Different \npeople have to be involved for different parts of the system, and they have to \ncontinuously communicate and negotiate throughout the development process.\n3. It is not possible to focus only on the code of the system. You need to do more \nup-front design and system documentation. The software architecture has to be \ndesigned, and there has to be documentation produced to describe critical \naspects of the system, such as database schemas and the work breakdown \nacross teams.\n4. Cross-team communication mechanisms have to be designed and used. This \nshould involve regular phone and videoconferences between team members and \nfrequent, short electronic meetings where teams update each other on progress. \nA range of communication channels such as email, instant messaging, wikis, \nand social networking systems should be provided to facilitate communications.\n5. \nContinuous integration, where the whole system is built every time any devel-\noper checks in a change, is practically impossible when several separate \nprograms have to be integrated to create the system. However, it is essential \nto maintain frequent system builds and regular releases of the system. \nConfiguration management tools that support multi-team software develop-\nment are essential.\nScrum has been adapted for large-scale development. In essence, the Scrum team \nmodel described in Section 3.3 is maintained, but multiple Scrum teams are set up. \nThe key characteristics of multi-team Scrum are:\n1. Role replication Each team has a Product Owner for its work component and \nScrumMaster. There may be a chief Product Owner and ScrumMaster for the \nentire project.\n2. Product architects Each team chooses a product architect, and these architects \ncollaborate to design and evolve the overall system architecture.\n3. Release alignment The dates of product releases from each team are aligned so \nthat a demonstrable and complete system is produced.\n4. Scrum of Scrums There is a daily Scrum of Scrums where representatives from \neach team meet to discuss progress, identify problems, and plan the work to be \ndone that day. Individual team Scrums may be staggered in time so that repre-\nsentatives from other teams can attend if necessary."}
{"query": "What is the role of continuous integration in large-scale agile projects?", "response": "Continuous integration plays an essential role in large-scale agile projects. While it may be practically impossible to achieve continuous integration when multiple separate programs need to be integrated, it is still crucial to maintain frequent system builds and regular releases of the system. Configuration management tools that support multi-team software development are necessary to facilitate this process.", "context": "3.4  \u25a0 Scaling agile methods  95\nDean Leffingwell, who has a great deal of experience in scaling agile methods, \nhas developed the Scaled Agile Framework (Leffingwell 2007, 2011) to support \nlarge-scale, multi-team software development. He reports how this method has been \nused successfully in a number of large companies. IBM has also developed a frame-\nwork for the large-scale use of agile methods called the Agile Scaling Model (ASM). \nFigure 3.14, taken from Ambler\u2019s white paper that discusses ASM (Ambler 2010), \nshows an overview of this model.\nThe ASM recognizes that scaling is a staged process where development teams \nmove from the core agile practices discussed here to what is called Disciplined Agile \nDelivery. Essentially, this stage involves adapting these practices to a disciplined \norganizational setting and recognizing that teams cannot simply focus on develop-\nment but must also take into account other stages of the software engineering \n process, such as requirements and architectural design.\nThe final scaling stage in ASM is to move to Agility at Scale where the com-\nplexity that is inherent in large projects is recognized. This involves taking account \nof factors such as distributed development, complex legacy environments, and \nregulatory compliance requirements. The practices used for disciplined agile \ndelivery may have to be modified on a project-by-project basis to take these into \naccount and, sometimes, additional plan-based practices added to the process.\nNo single model is appropriate for all large-scale agile products as the type of \nproduct, the customer requirements, and the people available are all different. \nHowever, approaches to scaling agile methods have a number of things in common:\nCore agile \ndevelopment\nDisciplined \nagile delivery\nAgility at\nscale\nAgility at scale\nDisciplined agile delivery where \nscaling factors apply:\nLarge team size\nGeographic distribution\nRegulatory compliance\nDomain complexity\nOrganization distribution\nTechnical complexity\nOrganizational complexity\nEnterprise discipline\nDisciplined agile delivery\nRisk+value driven life-cycle\nSelf-organizing with appropriate\ngovernance framework\nFull delivery life-cycle\nCore agile development\nValue-driven life-cycle\nSelf-organizing teams\nFocus on construction\nFigure 3.14 IBM\u2019s  \nAgility at Scale model  \n(\u00a9 IBM 2010)\n\n\n96  Chapter 3 \u25a0 Agile software development\n1. A completely incremental approach to requirements engineering is impossible. \nSome early work on initial software requirements is essential. You need this \nwork to identify the different parts of the system that may be developed by \n different teams and, often, to be part of the contract for the system development. \nHowever, these requirements should not normally be specified in detail; details \nare best developed incrementally.\n2. There cannot be a single product owner or customer representative. Different \npeople have to be involved for different parts of the system, and they have to \ncontinuously communicate and negotiate throughout the development process.\n3. It is not possible to focus only on the code of the system. You need to do more \nup-front design and system documentation. The software architecture has to be \ndesigned, and there has to be documentation produced to describe critical \naspects of the system, such as database schemas and the work breakdown \nacross teams.\n4. Cross-team communication mechanisms have to be designed and used. This \nshould involve regular phone and videoconferences between team members and \nfrequent, short electronic meetings where teams update each other on progress. \nA range of communication channels such as email, instant messaging, wikis, \nand social networking systems should be provided to facilitate communications.\n5. \nContinuous integration, where the whole system is built every time any devel-\noper checks in a change, is practically impossible when several separate \nprograms have to be integrated to create the system. However, it is essential \nto maintain frequent system builds and regular releases of the system. \nConfiguration management tools that support multi-team software develop-\nment are essential.\nScrum has been adapted for large-scale development. In essence, the Scrum team \nmodel described in Section 3.3 is maintained, but multiple Scrum teams are set up. \nThe key characteristics of multi-team Scrum are:\n1. Role replication Each team has a Product Owner for its work component and \nScrumMaster. There may be a chief Product Owner and ScrumMaster for the \nentire project.\n2. Product architects Each team chooses a product architect, and these architects \ncollaborate to design and evolve the overall system architecture.\n3. Release alignment The dates of product releases from each team are aligned so \nthat a demonstrable and complete system is produced.\n4. Scrum of Scrums There is a daily Scrum of Scrums where representatives from \neach team meet to discuss progress, identify problems, and plan the work to be \ndone that day. Individual team Scrums may be staggered in time so that repre-\nsentatives from other teams can attend if necessary."}
{"query": "Why is continuous integration practically impossible when several separate programs have to be integrated?", "response": "Continuous integration is practically impossible when several separate programs have to be integrated because integrating multiple programs into a single system can be complex and time-consuming. Each program may have its own dependencies, interfaces, and compatibility issues that need to be resolved during the integration process. This can lead to conflicts and errors that may require significant effort to resolve. Additionally, integrating multiple programs requires coordination and collaboration among different development teams, which can further complicate the process. Therefore, achieving continuous integration in such scenarios becomes challenging and may not be feasible.", "context": "3.4  \u25a0 Scaling agile methods  95\nDean Leffingwell, who has a great deal of experience in scaling agile methods, \nhas developed the Scaled Agile Framework (Leffingwell 2007, 2011) to support \nlarge-scale, multi-team software development. He reports how this method has been \nused successfully in a number of large companies. IBM has also developed a frame-\nwork for the large-scale use of agile methods called the Agile Scaling Model (ASM). \nFigure 3.14, taken from Ambler\u2019s white paper that discusses ASM (Ambler 2010), \nshows an overview of this model.\nThe ASM recognizes that scaling is a staged process where development teams \nmove from the core agile practices discussed here to what is called Disciplined Agile \nDelivery. Essentially, this stage involves adapting these practices to a disciplined \norganizational setting and recognizing that teams cannot simply focus on develop-\nment but must also take into account other stages of the software engineering \n process, such as requirements and architectural design.\nThe final scaling stage in ASM is to move to Agility at Scale where the com-\nplexity that is inherent in large projects is recognized. This involves taking account \nof factors such as distributed development, complex legacy environments, and \nregulatory compliance requirements. The practices used for disciplined agile \ndelivery may have to be modified on a project-by-project basis to take these into \naccount and, sometimes, additional plan-based practices added to the process.\nNo single model is appropriate for all large-scale agile products as the type of \nproduct, the customer requirements, and the people available are all different. \nHowever, approaches to scaling agile methods have a number of things in common:\nCore agile \ndevelopment\nDisciplined \nagile delivery\nAgility at\nscale\nAgility at scale\nDisciplined agile delivery where \nscaling factors apply:\nLarge team size\nGeographic distribution\nRegulatory compliance\nDomain complexity\nOrganization distribution\nTechnical complexity\nOrganizational complexity\nEnterprise discipline\nDisciplined agile delivery\nRisk+value driven life-cycle\nSelf-organizing with appropriate\ngovernance framework\nFull delivery life-cycle\nCore agile development\nValue-driven life-cycle\nSelf-organizing teams\nFocus on construction\nFigure 3.14 IBM\u2019s  \nAgility at Scale model  \n(\u00a9 IBM 2010)\n\n\n96  Chapter 3 \u25a0 Agile software development\n1. A completely incremental approach to requirements engineering is impossible. \nSome early work on initial software requirements is essential. You need this \nwork to identify the different parts of the system that may be developed by \n different teams and, often, to be part of the contract for the system development. \nHowever, these requirements should not normally be specified in detail; details \nare best developed incrementally.\n2. There cannot be a single product owner or customer representative. Different \npeople have to be involved for different parts of the system, and they have to \ncontinuously communicate and negotiate throughout the development process.\n3. It is not possible to focus only on the code of the system. You need to do more \nup-front design and system documentation. The software architecture has to be \ndesigned, and there has to be documentation produced to describe critical \naspects of the system, such as database schemas and the work breakdown \nacross teams.\n4. Cross-team communication mechanisms have to be designed and used. This \nshould involve regular phone and videoconferences between team members and \nfrequent, short electronic meetings where teams update each other on progress. \nA range of communication channels such as email, instant messaging, wikis, \nand social networking systems should be provided to facilitate communications.\n5. \nContinuous integration, where the whole system is built every time any devel-\noper checks in a change, is practically impossible when several separate \nprograms have to be integrated to create the system. However, it is essential \nto maintain frequent system builds and regular releases of the system. \nConfiguration management tools that support multi-team software develop-\nment are essential.\nScrum has been adapted for large-scale development. In essence, the Scrum team \nmodel described in Section 3.3 is maintained, but multiple Scrum teams are set up. \nThe key characteristics of multi-team Scrum are:\n1. Role replication Each team has a Product Owner for its work component and \nScrumMaster. There may be a chief Product Owner and ScrumMaster for the \nentire project.\n2. Product architects Each team chooses a product architect, and these architects \ncollaborate to design and evolve the overall system architecture.\n3. Release alignment The dates of product releases from each team are aligned so \nthat a demonstrable and complete system is produced.\n4. Scrum of Scrums There is a daily Scrum of Scrums where representatives from \neach team meet to discuss progress, identify problems, and plan the work to be \ndone that day. Individual team Scrums may be staggered in time so that repre-\nsentatives from other teams can attend if necessary."}
{"query": "What is the role of configuration management tools in multi-team software development?", "response": "Configuration management tools are essential in multi-team software development. These tools support the integration of several separate programs to create the system. They help in maintaining frequent system builds and regular releases of the system. Configuration management tools also facilitate version control, allowing teams to collaborate and manage changes effectively.", "context": "3.4  \u25a0 Scaling agile methods  95\nDean Leffingwell, who has a great deal of experience in scaling agile methods, \nhas developed the Scaled Agile Framework (Leffingwell 2007, 2011) to support \nlarge-scale, multi-team software development. He reports how this method has been \nused successfully in a number of large companies. IBM has also developed a frame-\nwork for the large-scale use of agile methods called the Agile Scaling Model (ASM). \nFigure 3.14, taken from Ambler\u2019s white paper that discusses ASM (Ambler 2010), \nshows an overview of this model.\nThe ASM recognizes that scaling is a staged process where development teams \nmove from the core agile practices discussed here to what is called Disciplined Agile \nDelivery. Essentially, this stage involves adapting these practices to a disciplined \norganizational setting and recognizing that teams cannot simply focus on develop-\nment but must also take into account other stages of the software engineering \n process, such as requirements and architectural design.\nThe final scaling stage in ASM is to move to Agility at Scale where the com-\nplexity that is inherent in large projects is recognized. This involves taking account \nof factors such as distributed development, complex legacy environments, and \nregulatory compliance requirements. The practices used for disciplined agile \ndelivery may have to be modified on a project-by-project basis to take these into \naccount and, sometimes, additional plan-based practices added to the process.\nNo single model is appropriate for all large-scale agile products as the type of \nproduct, the customer requirements, and the people available are all different. \nHowever, approaches to scaling agile methods have a number of things in common:\nCore agile \ndevelopment\nDisciplined \nagile delivery\nAgility at\nscale\nAgility at scale\nDisciplined agile delivery where \nscaling factors apply:\nLarge team size\nGeographic distribution\nRegulatory compliance\nDomain complexity\nOrganization distribution\nTechnical complexity\nOrganizational complexity\nEnterprise discipline\nDisciplined agile delivery\nRisk+value driven life-cycle\nSelf-organizing with appropriate\ngovernance framework\nFull delivery life-cycle\nCore agile development\nValue-driven life-cycle\nSelf-organizing teams\nFocus on construction\nFigure 3.14 IBM\u2019s  \nAgility at Scale model  \n(\u00a9 IBM 2010)\n\n\n96  Chapter 3 \u25a0 Agile software development\n1. A completely incremental approach to requirements engineering is impossible. \nSome early work on initial software requirements is essential. You need this \nwork to identify the different parts of the system that may be developed by \n different teams and, often, to be part of the contract for the system development. \nHowever, these requirements should not normally be specified in detail; details \nare best developed incrementally.\n2. There cannot be a single product owner or customer representative. Different \npeople have to be involved for different parts of the system, and they have to \ncontinuously communicate and negotiate throughout the development process.\n3. It is not possible to focus only on the code of the system. You need to do more \nup-front design and system documentation. The software architecture has to be \ndesigned, and there has to be documentation produced to describe critical \naspects of the system, such as database schemas and the work breakdown \nacross teams.\n4. Cross-team communication mechanisms have to be designed and used. This \nshould involve regular phone and videoconferences between team members and \nfrequent, short electronic meetings where teams update each other on progress. \nA range of communication channels such as email, instant messaging, wikis, \nand social networking systems should be provided to facilitate communications.\n5. \nContinuous integration, where the whole system is built every time any devel-\noper checks in a change, is practically impossible when several separate \nprograms have to be integrated to create the system. However, it is essential \nto maintain frequent system builds and regular releases of the system. \nConfiguration management tools that support multi-team software develop-\nment are essential.\nScrum has been adapted for large-scale development. In essence, the Scrum team \nmodel described in Section 3.3 is maintained, but multiple Scrum teams are set up. \nThe key characteristics of multi-team Scrum are:\n1. Role replication Each team has a Product Owner for its work component and \nScrumMaster. There may be a chief Product Owner and ScrumMaster for the \nentire project.\n2. Product architects Each team chooses a product architect, and these architects \ncollaborate to design and evolve the overall system architecture.\n3. Release alignment The dates of product releases from each team are aligned so \nthat a demonstrable and complete system is produced.\n4. Scrum of Scrums There is a daily Scrum of Scrums where representatives from \neach team meet to discuss progress, identify problems, and plan the work to be \ndone that day. Individual team Scrums may be staggered in time so that repre-\nsentatives from other teams can attend if necessary."}
{"query": "How has Scrum been adapted for large-scale development?", "response": "Scrum has been adapted for large-scale development by setting up multiple Scrum teams. Each team has its own Product Owner and ScrumMaster, and there may be a chief Product Owner and ScrumMaster for the entire project. The teams also collaborate to design and evolve the overall system architecture. The dates of product releases from each team are aligned to ensure a demonstrable and complete system is produced. Additionally, there is a daily Scrum of Scrums meeting where representatives from each team discuss progress, identify problems, and plan the work to be done.", "context": "3.4  \u25a0 Scaling agile methods  95\nDean Leffingwell, who has a great deal of experience in scaling agile methods, \nhas developed the Scaled Agile Framework (Leffingwell 2007, 2011) to support \nlarge-scale, multi-team software development. He reports how this method has been \nused successfully in a number of large companies. IBM has also developed a frame-\nwork for the large-scale use of agile methods called the Agile Scaling Model (ASM). \nFigure 3.14, taken from Ambler\u2019s white paper that discusses ASM (Ambler 2010), \nshows an overview of this model.\nThe ASM recognizes that scaling is a staged process where development teams \nmove from the core agile practices discussed here to what is called Disciplined Agile \nDelivery. Essentially, this stage involves adapting these practices to a disciplined \norganizational setting and recognizing that teams cannot simply focus on develop-\nment but must also take into account other stages of the software engineering \n process, such as requirements and architectural design.\nThe final scaling stage in ASM is to move to Agility at Scale where the com-\nplexity that is inherent in large projects is recognized. This involves taking account \nof factors such as distributed development, complex legacy environments, and \nregulatory compliance requirements. The practices used for disciplined agile \ndelivery may have to be modified on a project-by-project basis to take these into \naccount and, sometimes, additional plan-based practices added to the process.\nNo single model is appropriate for all large-scale agile products as the type of \nproduct, the customer requirements, and the people available are all different. \nHowever, approaches to scaling agile methods have a number of things in common:\nCore agile \ndevelopment\nDisciplined \nagile delivery\nAgility at\nscale\nAgility at scale\nDisciplined agile delivery where \nscaling factors apply:\nLarge team size\nGeographic distribution\nRegulatory compliance\nDomain complexity\nOrganization distribution\nTechnical complexity\nOrganizational complexity\nEnterprise discipline\nDisciplined agile delivery\nRisk+value driven life-cycle\nSelf-organizing with appropriate\ngovernance framework\nFull delivery life-cycle\nCore agile development\nValue-driven life-cycle\nSelf-organizing teams\nFocus on construction\nFigure 3.14 IBM\u2019s  \nAgility at Scale model  \n(\u00a9 IBM 2010)\n\n\n96  Chapter 3 \u25a0 Agile software development\n1. A completely incremental approach to requirements engineering is impossible. \nSome early work on initial software requirements is essential. You need this \nwork to identify the different parts of the system that may be developed by \n different teams and, often, to be part of the contract for the system development. \nHowever, these requirements should not normally be specified in detail; details \nare best developed incrementally.\n2. There cannot be a single product owner or customer representative. Different \npeople have to be involved for different parts of the system, and they have to \ncontinuously communicate and negotiate throughout the development process.\n3. It is not possible to focus only on the code of the system. You need to do more \nup-front design and system documentation. The software architecture has to be \ndesigned, and there has to be documentation produced to describe critical \naspects of the system, such as database schemas and the work breakdown \nacross teams.\n4. Cross-team communication mechanisms have to be designed and used. This \nshould involve regular phone and videoconferences between team members and \nfrequent, short electronic meetings where teams update each other on progress. \nA range of communication channels such as email, instant messaging, wikis, \nand social networking systems should be provided to facilitate communications.\n5. \nContinuous integration, where the whole system is built every time any devel-\noper checks in a change, is practically impossible when several separate \nprograms have to be integrated to create the system. However, it is essential \nto maintain frequent system builds and regular releases of the system. \nConfiguration management tools that support multi-team software develop-\nment are essential.\nScrum has been adapted for large-scale development. In essence, the Scrum team \nmodel described in Section 3.3 is maintained, but multiple Scrum teams are set up. \nThe key characteristics of multi-team Scrum are:\n1. Role replication Each team has a Product Owner for its work component and \nScrumMaster. There may be a chief Product Owner and ScrumMaster for the \nentire project.\n2. Product architects Each team chooses a product architect, and these architects \ncollaborate to design and evolve the overall system architecture.\n3. Release alignment The dates of product releases from each team are aligned so \nthat a demonstrable and complete system is produced.\n4. Scrum of Scrums There is a daily Scrum of Scrums where representatives from \neach team meet to discuss progress, identify problems, and plan the work to be \ndone that day. Individual team Scrums may be staggered in time so that repre-\nsentatives from other teams can attend if necessary."}
{"query": "What is the role of a Product Owner in a Scrum team?", "response": "The role of a Product Owner in a Scrum team is to represent the customer or stakeholder and prioritize the product backlog. They are responsible for defining and communicating the product vision, gathering requirements, and ensuring that the team is working on the most valuable features. The Product Owner also collaborates with the development team to clarify requirements, answer questions, and provide feedback on the product increments.", "context": "3.4  \u25a0 Scaling agile methods  95\nDean Leffingwell, who has a great deal of experience in scaling agile methods, \nhas developed the Scaled Agile Framework (Leffingwell 2007, 2011) to support \nlarge-scale, multi-team software development. He reports how this method has been \nused successfully in a number of large companies. IBM has also developed a frame-\nwork for the large-scale use of agile methods called the Agile Scaling Model (ASM). \nFigure 3.14, taken from Ambler\u2019s white paper that discusses ASM (Ambler 2010), \nshows an overview of this model.\nThe ASM recognizes that scaling is a staged process where development teams \nmove from the core agile practices discussed here to what is called Disciplined Agile \nDelivery. Essentially, this stage involves adapting these practices to a disciplined \norganizational setting and recognizing that teams cannot simply focus on develop-\nment but must also take into account other stages of the software engineering \n process, such as requirements and architectural design.\nThe final scaling stage in ASM is to move to Agility at Scale where the com-\nplexity that is inherent in large projects is recognized. This involves taking account \nof factors such as distributed development, complex legacy environments, and \nregulatory compliance requirements. The practices used for disciplined agile \ndelivery may have to be modified on a project-by-project basis to take these into \naccount and, sometimes, additional plan-based practices added to the process.\nNo single model is appropriate for all large-scale agile products as the type of \nproduct, the customer requirements, and the people available are all different. \nHowever, approaches to scaling agile methods have a number of things in common:\nCore agile \ndevelopment\nDisciplined \nagile delivery\nAgility at\nscale\nAgility at scale\nDisciplined agile delivery where \nscaling factors apply:\nLarge team size\nGeographic distribution\nRegulatory compliance\nDomain complexity\nOrganization distribution\nTechnical complexity\nOrganizational complexity\nEnterprise discipline\nDisciplined agile delivery\nRisk+value driven life-cycle\nSelf-organizing with appropriate\ngovernance framework\nFull delivery life-cycle\nCore agile development\nValue-driven life-cycle\nSelf-organizing teams\nFocus on construction\nFigure 3.14 IBM\u2019s  \nAgility at Scale model  \n(\u00a9 IBM 2010)\n\n\n96  Chapter 3 \u25a0 Agile software development\n1. A completely incremental approach to requirements engineering is impossible. \nSome early work on initial software requirements is essential. You need this \nwork to identify the different parts of the system that may be developed by \n different teams and, often, to be part of the contract for the system development. \nHowever, these requirements should not normally be specified in detail; details \nare best developed incrementally.\n2. There cannot be a single product owner or customer representative. Different \npeople have to be involved for different parts of the system, and they have to \ncontinuously communicate and negotiate throughout the development process.\n3. It is not possible to focus only on the code of the system. You need to do more \nup-front design and system documentation. The software architecture has to be \ndesigned, and there has to be documentation produced to describe critical \naspects of the system, such as database schemas and the work breakdown \nacross teams.\n4. Cross-team communication mechanisms have to be designed and used. This \nshould involve regular phone and videoconferences between team members and \nfrequent, short electronic meetings where teams update each other on progress. \nA range of communication channels such as email, instant messaging, wikis, \nand social networking systems should be provided to facilitate communications.\n5. \nContinuous integration, where the whole system is built every time any devel-\noper checks in a change, is practically impossible when several separate \nprograms have to be integrated to create the system. However, it is essential \nto maintain frequent system builds and regular releases of the system. \nConfiguration management tools that support multi-team software develop-\nment are essential.\nScrum has been adapted for large-scale development. In essence, the Scrum team \nmodel described in Section 3.3 is maintained, but multiple Scrum teams are set up. \nThe key characteristics of multi-team Scrum are:\n1. Role replication Each team has a Product Owner for its work component and \nScrumMaster. There may be a chief Product Owner and ScrumMaster for the \nentire project.\n2. Product architects Each team chooses a product architect, and these architects \ncollaborate to design and evolve the overall system architecture.\n3. Release alignment The dates of product releases from each team are aligned so \nthat a demonstrable and complete system is produced.\n4. Scrum of Scrums There is a daily Scrum of Scrums where representatives from \neach team meet to discuss progress, identify problems, and plan the work to be \ndone that day. Individual team Scrums may be staggered in time so that repre-\nsentatives from other teams can attend if necessary."}
{"query": "What is the role of a ScrumMaster in a Scrum team?", "response": "The role of a ScrumMaster in a Scrum team is to facilitate the Scrum process and ensure that the team adheres to the principles and practices of Scrum. They act as a servant-leader, helping the team to self-organize and make decisions, removing any obstacles or impediments that may hinder the team's progress, and protecting the team from external distractions. The ScrumMaster also facilitates the various Scrum ceremonies, such as the daily stand-up meetings, sprint planning, sprint review, and retrospective, and ensures that the team follows the agreed-upon Scrum framework.", "context": "3.4  \u25a0 Scaling agile methods  95\nDean Leffingwell, who has a great deal of experience in scaling agile methods, \nhas developed the Scaled Agile Framework (Leffingwell 2007, 2011) to support \nlarge-scale, multi-team software development. He reports how this method has been \nused successfully in a number of large companies. IBM has also developed a frame-\nwork for the large-scale use of agile methods called the Agile Scaling Model (ASM). \nFigure 3.14, taken from Ambler\u2019s white paper that discusses ASM (Ambler 2010), \nshows an overview of this model.\nThe ASM recognizes that scaling is a staged process where development teams \nmove from the core agile practices discussed here to what is called Disciplined Agile \nDelivery. Essentially, this stage involves adapting these practices to a disciplined \norganizational setting and recognizing that teams cannot simply focus on develop-\nment but must also take into account other stages of the software engineering \n process, such as requirements and architectural design.\nThe final scaling stage in ASM is to move to Agility at Scale where the com-\nplexity that is inherent in large projects is recognized. This involves taking account \nof factors such as distributed development, complex legacy environments, and \nregulatory compliance requirements. The practices used for disciplined agile \ndelivery may have to be modified on a project-by-project basis to take these into \naccount and, sometimes, additional plan-based practices added to the process.\nNo single model is appropriate for all large-scale agile products as the type of \nproduct, the customer requirements, and the people available are all different. \nHowever, approaches to scaling agile methods have a number of things in common:\nCore agile \ndevelopment\nDisciplined \nagile delivery\nAgility at\nscale\nAgility at scale\nDisciplined agile delivery where \nscaling factors apply:\nLarge team size\nGeographic distribution\nRegulatory compliance\nDomain complexity\nOrganization distribution\nTechnical complexity\nOrganizational complexity\nEnterprise discipline\nDisciplined agile delivery\nRisk+value driven life-cycle\nSelf-organizing with appropriate\ngovernance framework\nFull delivery life-cycle\nCore agile development\nValue-driven life-cycle\nSelf-organizing teams\nFocus on construction\nFigure 3.14 IBM\u2019s  \nAgility at Scale model  \n(\u00a9 IBM 2010)\n\n\n96  Chapter 3 \u25a0 Agile software development\n1. A completely incremental approach to requirements engineering is impossible. \nSome early work on initial software requirements is essential. You need this \nwork to identify the different parts of the system that may be developed by \n different teams and, often, to be part of the contract for the system development. \nHowever, these requirements should not normally be specified in detail; details \nare best developed incrementally.\n2. There cannot be a single product owner or customer representative. Different \npeople have to be involved for different parts of the system, and they have to \ncontinuously communicate and negotiate throughout the development process.\n3. It is not possible to focus only on the code of the system. You need to do more \nup-front design and system documentation. The software architecture has to be \ndesigned, and there has to be documentation produced to describe critical \naspects of the system, such as database schemas and the work breakdown \nacross teams.\n4. Cross-team communication mechanisms have to be designed and used. This \nshould involve regular phone and videoconferences between team members and \nfrequent, short electronic meetings where teams update each other on progress. \nA range of communication channels such as email, instant messaging, wikis, \nand social networking systems should be provided to facilitate communications.\n5. \nContinuous integration, where the whole system is built every time any devel-\noper checks in a change, is practically impossible when several separate \nprograms have to be integrated to create the system. However, it is essential \nto maintain frequent system builds and regular releases of the system. \nConfiguration management tools that support multi-team software develop-\nment are essential.\nScrum has been adapted for large-scale development. In essence, the Scrum team \nmodel described in Section 3.3 is maintained, but multiple Scrum teams are set up. \nThe key characteristics of multi-team Scrum are:\n1. Role replication Each team has a Product Owner for its work component and \nScrumMaster. There may be a chief Product Owner and ScrumMaster for the \nentire project.\n2. Product architects Each team chooses a product architect, and these architects \ncollaborate to design and evolve the overall system architecture.\n3. Release alignment The dates of product releases from each team are aligned so \nthat a demonstrable and complete system is produced.\n4. Scrum of Scrums There is a daily Scrum of Scrums where representatives from \neach team meet to discuss progress, identify problems, and plan the work to be \ndone that day. Individual team Scrums may be staggered in time so that repre-\nsentatives from other teams can attend if necessary."}
{"query": "What is the role of a product architect in a Scrum team?", "response": "The role of a product architect in a Scrum team is to collaborate with other architects to design and evolve the overall system architecture. They are responsible for making architectural decisions and ensuring that the system is designed in a way that meets the requirements and goals of the project. The product architect works closely with the development team to provide guidance and support in implementing the architectural design.", "context": "3.4  \u25a0 Scaling agile methods  95\nDean Leffingwell, who has a great deal of experience in scaling agile methods, \nhas developed the Scaled Agile Framework (Leffingwell 2007, 2011) to support \nlarge-scale, multi-team software development. He reports how this method has been \nused successfully in a number of large companies. IBM has also developed a frame-\nwork for the large-scale use of agile methods called the Agile Scaling Model (ASM). \nFigure 3.14, taken from Ambler\u2019s white paper that discusses ASM (Ambler 2010), \nshows an overview of this model.\nThe ASM recognizes that scaling is a staged process where development teams \nmove from the core agile practices discussed here to what is called Disciplined Agile \nDelivery. Essentially, this stage involves adapting these practices to a disciplined \norganizational setting and recognizing that teams cannot simply focus on develop-\nment but must also take into account other stages of the software engineering \n process, such as requirements and architectural design.\nThe final scaling stage in ASM is to move to Agility at Scale where the com-\nplexity that is inherent in large projects is recognized. This involves taking account \nof factors such as distributed development, complex legacy environments, and \nregulatory compliance requirements. The practices used for disciplined agile \ndelivery may have to be modified on a project-by-project basis to take these into \naccount and, sometimes, additional plan-based practices added to the process.\nNo single model is appropriate for all large-scale agile products as the type of \nproduct, the customer requirements, and the people available are all different. \nHowever, approaches to scaling agile methods have a number of things in common:\nCore agile \ndevelopment\nDisciplined \nagile delivery\nAgility at\nscale\nAgility at scale\nDisciplined agile delivery where \nscaling factors apply:\nLarge team size\nGeographic distribution\nRegulatory compliance\nDomain complexity\nOrganization distribution\nTechnical complexity\nOrganizational complexity\nEnterprise discipline\nDisciplined agile delivery\nRisk+value driven life-cycle\nSelf-organizing with appropriate\ngovernance framework\nFull delivery life-cycle\nCore agile development\nValue-driven life-cycle\nSelf-organizing teams\nFocus on construction\nFigure 3.14 IBM\u2019s  \nAgility at Scale model  \n(\u00a9 IBM 2010)\n\n\n96  Chapter 3 \u25a0 Agile software development\n1. A completely incremental approach to requirements engineering is impossible. \nSome early work on initial software requirements is essential. You need this \nwork to identify the different parts of the system that may be developed by \n different teams and, often, to be part of the contract for the system development. \nHowever, these requirements should not normally be specified in detail; details \nare best developed incrementally.\n2. There cannot be a single product owner or customer representative. Different \npeople have to be involved for different parts of the system, and they have to \ncontinuously communicate and negotiate throughout the development process.\n3. It is not possible to focus only on the code of the system. You need to do more \nup-front design and system documentation. The software architecture has to be \ndesigned, and there has to be documentation produced to describe critical \naspects of the system, such as database schemas and the work breakdown \nacross teams.\n4. Cross-team communication mechanisms have to be designed and used. This \nshould involve regular phone and videoconferences between team members and \nfrequent, short electronic meetings where teams update each other on progress. \nA range of communication channels such as email, instant messaging, wikis, \nand social networking systems should be provided to facilitate communications.\n5. \nContinuous integration, where the whole system is built every time any devel-\noper checks in a change, is practically impossible when several separate \nprograms have to be integrated to create the system. However, it is essential \nto maintain frequent system builds and regular releases of the system. \nConfiguration management tools that support multi-team software develop-\nment are essential.\nScrum has been adapted for large-scale development. In essence, the Scrum team \nmodel described in Section 3.3 is maintained, but multiple Scrum teams are set up. \nThe key characteristics of multi-team Scrum are:\n1. Role replication Each team has a Product Owner for its work component and \nScrumMaster. There may be a chief Product Owner and ScrumMaster for the \nentire project.\n2. Product architects Each team chooses a product architect, and these architects \ncollaborate to design and evolve the overall system architecture.\n3. Release alignment The dates of product releases from each team are aligned so \nthat a demonstrable and complete system is produced.\n4. Scrum of Scrums There is a daily Scrum of Scrums where representatives from \neach team meet to discuss progress, identify problems, and plan the work to be \ndone that day. Individual team Scrums may be staggered in time so that repre-\nsentatives from other teams can attend if necessary."}
{"query": "What is the purpose of release alignment in multi-team Scrum?", "response": "The purpose of release alignment in multi-team Scrum is to ensure that the dates of product releases from each team are synchronized. This allows for the creation of a demonstrable and complete system at each release, as all the teams' work components are integrated together.", "context": "3.4  \u25a0 Scaling agile methods  95\nDean Leffingwell, who has a great deal of experience in scaling agile methods, \nhas developed the Scaled Agile Framework (Leffingwell 2007, 2011) to support \nlarge-scale, multi-team software development. He reports how this method has been \nused successfully in a number of large companies. IBM has also developed a frame-\nwork for the large-scale use of agile methods called the Agile Scaling Model (ASM). \nFigure 3.14, taken from Ambler\u2019s white paper that discusses ASM (Ambler 2010), \nshows an overview of this model.\nThe ASM recognizes that scaling is a staged process where development teams \nmove from the core agile practices discussed here to what is called Disciplined Agile \nDelivery. Essentially, this stage involves adapting these practices to a disciplined \norganizational setting and recognizing that teams cannot simply focus on develop-\nment but must also take into account other stages of the software engineering \n process, such as requirements and architectural design.\nThe final scaling stage in ASM is to move to Agility at Scale where the com-\nplexity that is inherent in large projects is recognized. This involves taking account \nof factors such as distributed development, complex legacy environments, and \nregulatory compliance requirements. The practices used for disciplined agile \ndelivery may have to be modified on a project-by-project basis to take these into \naccount and, sometimes, additional plan-based practices added to the process.\nNo single model is appropriate for all large-scale agile products as the type of \nproduct, the customer requirements, and the people available are all different. \nHowever, approaches to scaling agile methods have a number of things in common:\nCore agile \ndevelopment\nDisciplined \nagile delivery\nAgility at\nscale\nAgility at scale\nDisciplined agile delivery where \nscaling factors apply:\nLarge team size\nGeographic distribution\nRegulatory compliance\nDomain complexity\nOrganization distribution\nTechnical complexity\nOrganizational complexity\nEnterprise discipline\nDisciplined agile delivery\nRisk+value driven life-cycle\nSelf-organizing with appropriate\ngovernance framework\nFull delivery life-cycle\nCore agile development\nValue-driven life-cycle\nSelf-organizing teams\nFocus on construction\nFigure 3.14 IBM\u2019s  \nAgility at Scale model  \n(\u00a9 IBM 2010)\n\n\n96  Chapter 3 \u25a0 Agile software development\n1. A completely incremental approach to requirements engineering is impossible. \nSome early work on initial software requirements is essential. You need this \nwork to identify the different parts of the system that may be developed by \n different teams and, often, to be part of the contract for the system development. \nHowever, these requirements should not normally be specified in detail; details \nare best developed incrementally.\n2. There cannot be a single product owner or customer representative. Different \npeople have to be involved for different parts of the system, and they have to \ncontinuously communicate and negotiate throughout the development process.\n3. It is not possible to focus only on the code of the system. You need to do more \nup-front design and system documentation. The software architecture has to be \ndesigned, and there has to be documentation produced to describe critical \naspects of the system, such as database schemas and the work breakdown \nacross teams.\n4. Cross-team communication mechanisms have to be designed and used. This \nshould involve regular phone and videoconferences between team members and \nfrequent, short electronic meetings where teams update each other on progress. \nA range of communication channels such as email, instant messaging, wikis, \nand social networking systems should be provided to facilitate communications.\n5. \nContinuous integration, where the whole system is built every time any devel-\noper checks in a change, is practically impossible when several separate \nprograms have to be integrated to create the system. However, it is essential \nto maintain frequent system builds and regular releases of the system. \nConfiguration management tools that support multi-team software develop-\nment are essential.\nScrum has been adapted for large-scale development. In essence, the Scrum team \nmodel described in Section 3.3 is maintained, but multiple Scrum teams are set up. \nThe key characteristics of multi-team Scrum are:\n1. Role replication Each team has a Product Owner for its work component and \nScrumMaster. There may be a chief Product Owner and ScrumMaster for the \nentire project.\n2. Product architects Each team chooses a product architect, and these architects \ncollaborate to design and evolve the overall system architecture.\n3. Release alignment The dates of product releases from each team are aligned so \nthat a demonstrable and complete system is produced.\n4. Scrum of Scrums There is a daily Scrum of Scrums where representatives from \neach team meet to discuss progress, identify problems, and plan the work to be \ndone that day. Individual team Scrums may be staggered in time so that repre-\nsentatives from other teams can attend if necessary."}
{"query": "What is a Scrum of Scrums?", "response": "A Scrum of Scrums is a daily meeting where representatives from different Scrum teams come together to discuss progress, identify problems, and plan the work to be done for the day. This meeting allows for coordination and communication between teams, ensuring that the overall project is on track and any issues are addressed in a timely manner.", "context": "3.4  \u25a0 Scaling agile methods  95\nDean Leffingwell, who has a great deal of experience in scaling agile methods, \nhas developed the Scaled Agile Framework (Leffingwell 2007, 2011) to support \nlarge-scale, multi-team software development. He reports how this method has been \nused successfully in a number of large companies. IBM has also developed a frame-\nwork for the large-scale use of agile methods called the Agile Scaling Model (ASM). \nFigure 3.14, taken from Ambler\u2019s white paper that discusses ASM (Ambler 2010), \nshows an overview of this model.\nThe ASM recognizes that scaling is a staged process where development teams \nmove from the core agile practices discussed here to what is called Disciplined Agile \nDelivery. Essentially, this stage involves adapting these practices to a disciplined \norganizational setting and recognizing that teams cannot simply focus on develop-\nment but must also take into account other stages of the software engineering \n process, such as requirements and architectural design.\nThe final scaling stage in ASM is to move to Agility at Scale where the com-\nplexity that is inherent in large projects is recognized. This involves taking account \nof factors such as distributed development, complex legacy environments, and \nregulatory compliance requirements. The practices used for disciplined agile \ndelivery may have to be modified on a project-by-project basis to take these into \naccount and, sometimes, additional plan-based practices added to the process.\nNo single model is appropriate for all large-scale agile products as the type of \nproduct, the customer requirements, and the people available are all different. \nHowever, approaches to scaling agile methods have a number of things in common:\nCore agile \ndevelopment\nDisciplined \nagile delivery\nAgility at\nscale\nAgility at scale\nDisciplined agile delivery where \nscaling factors apply:\nLarge team size\nGeographic distribution\nRegulatory compliance\nDomain complexity\nOrganization distribution\nTechnical complexity\nOrganizational complexity\nEnterprise discipline\nDisciplined agile delivery\nRisk+value driven life-cycle\nSelf-organizing with appropriate\ngovernance framework\nFull delivery life-cycle\nCore agile development\nValue-driven life-cycle\nSelf-organizing teams\nFocus on construction\nFigure 3.14 IBM\u2019s  \nAgility at Scale model  \n(\u00a9 IBM 2010)\n\n\n96  Chapter 3 \u25a0 Agile software development\n1. A completely incremental approach to requirements engineering is impossible. \nSome early work on initial software requirements is essential. You need this \nwork to identify the different parts of the system that may be developed by \n different teams and, often, to be part of the contract for the system development. \nHowever, these requirements should not normally be specified in detail; details \nare best developed incrementally.\n2. There cannot be a single product owner or customer representative. Different \npeople have to be involved for different parts of the system, and they have to \ncontinuously communicate and negotiate throughout the development process.\n3. It is not possible to focus only on the code of the system. You need to do more \nup-front design and system documentation. The software architecture has to be \ndesigned, and there has to be documentation produced to describe critical \naspects of the system, such as database schemas and the work breakdown \nacross teams.\n4. Cross-team communication mechanisms have to be designed and used. This \nshould involve regular phone and videoconferences between team members and \nfrequent, short electronic meetings where teams update each other on progress. \nA range of communication channels such as email, instant messaging, wikis, \nand social networking systems should be provided to facilitate communications.\n5. \nContinuous integration, where the whole system is built every time any devel-\noper checks in a change, is practically impossible when several separate \nprograms have to be integrated to create the system. However, it is essential \nto maintain frequent system builds and regular releases of the system. \nConfiguration management tools that support multi-team software develop-\nment are essential.\nScrum has been adapted for large-scale development. In essence, the Scrum team \nmodel described in Section 3.3 is maintained, but multiple Scrum teams are set up. \nThe key characteristics of multi-team Scrum are:\n1. Role replication Each team has a Product Owner for its work component and \nScrumMaster. There may be a chief Product Owner and ScrumMaster for the \nentire project.\n2. Product architects Each team chooses a product architect, and these architects \ncollaborate to design and evolve the overall system architecture.\n3. Release alignment The dates of product releases from each team are aligned so \nthat a demonstrable and complete system is produced.\n4. Scrum of Scrums There is a daily Scrum of Scrums where representatives from \neach team meet to discuss progress, identify problems, and plan the work to be \ndone that day. Individual team Scrums may be staggered in time so that repre-\nsentatives from other teams can attend if necessary."}
{"query": "What is discussed in a Scrum of Scrums?", "response": "In a Scrum of Scrums, representatives from each team meet to discuss progress, identify problems, and plan the work to be done that day. It is a daily meeting where representatives from different teams come together to coordinate and synchronize their efforts.", "context": "3.4  \u25a0 Scaling agile methods  95\nDean Leffingwell, who has a great deal of experience in scaling agile methods, \nhas developed the Scaled Agile Framework (Leffingwell 2007, 2011) to support \nlarge-scale, multi-team software development. He reports how this method has been \nused successfully in a number of large companies. IBM has also developed a frame-\nwork for the large-scale use of agile methods called the Agile Scaling Model (ASM). \nFigure 3.14, taken from Ambler\u2019s white paper that discusses ASM (Ambler 2010), \nshows an overview of this model.\nThe ASM recognizes that scaling is a staged process where development teams \nmove from the core agile practices discussed here to what is called Disciplined Agile \nDelivery. Essentially, this stage involves adapting these practices to a disciplined \norganizational setting and recognizing that teams cannot simply focus on develop-\nment but must also take into account other stages of the software engineering \n process, such as requirements and architectural design.\nThe final scaling stage in ASM is to move to Agility at Scale where the com-\nplexity that is inherent in large projects is recognized. This involves taking account \nof factors such as distributed development, complex legacy environments, and \nregulatory compliance requirements. The practices used for disciplined agile \ndelivery may have to be modified on a project-by-project basis to take these into \naccount and, sometimes, additional plan-based practices added to the process.\nNo single model is appropriate for all large-scale agile products as the type of \nproduct, the customer requirements, and the people available are all different. \nHowever, approaches to scaling agile methods have a number of things in common:\nCore agile \ndevelopment\nDisciplined \nagile delivery\nAgility at\nscale\nAgility at scale\nDisciplined agile delivery where \nscaling factors apply:\nLarge team size\nGeographic distribution\nRegulatory compliance\nDomain complexity\nOrganization distribution\nTechnical complexity\nOrganizational complexity\nEnterprise discipline\nDisciplined agile delivery\nRisk+value driven life-cycle\nSelf-organizing with appropriate\ngovernance framework\nFull delivery life-cycle\nCore agile development\nValue-driven life-cycle\nSelf-organizing teams\nFocus on construction\nFigure 3.14 IBM\u2019s  \nAgility at Scale model  \n(\u00a9 IBM 2010)\n\n\n96  Chapter 3 \u25a0 Agile software development\n1. A completely incremental approach to requirements engineering is impossible. \nSome early work on initial software requirements is essential. You need this \nwork to identify the different parts of the system that may be developed by \n different teams and, often, to be part of the contract for the system development. \nHowever, these requirements should not normally be specified in detail; details \nare best developed incrementally.\n2. There cannot be a single product owner or customer representative. Different \npeople have to be involved for different parts of the system, and they have to \ncontinuously communicate and negotiate throughout the development process.\n3. It is not possible to focus only on the code of the system. You need to do more \nup-front design and system documentation. The software architecture has to be \ndesigned, and there has to be documentation produced to describe critical \naspects of the system, such as database schemas and the work breakdown \nacross teams.\n4. Cross-team communication mechanisms have to be designed and used. This \nshould involve regular phone and videoconferences between team members and \nfrequent, short electronic meetings where teams update each other on progress. \nA range of communication channels such as email, instant messaging, wikis, \nand social networking systems should be provided to facilitate communications.\n5. \nContinuous integration, where the whole system is built every time any devel-\noper checks in a change, is practically impossible when several separate \nprograms have to be integrated to create the system. However, it is essential \nto maintain frequent system builds and regular releases of the system. \nConfiguration management tools that support multi-team software develop-\nment are essential.\nScrum has been adapted for large-scale development. In essence, the Scrum team \nmodel described in Section 3.3 is maintained, but multiple Scrum teams are set up. \nThe key characteristics of multi-team Scrum are:\n1. Role replication Each team has a Product Owner for its work component and \nScrumMaster. There may be a chief Product Owner and ScrumMaster for the \nentire project.\n2. Product architects Each team chooses a product architect, and these architects \ncollaborate to design and evolve the overall system architecture.\n3. Release alignment The dates of product releases from each team are aligned so \nthat a demonstrable and complete system is produced.\n4. Scrum of Scrums There is a daily Scrum of Scrums where representatives from \neach team meet to discuss progress, identify problems, and plan the work to be \ndone that day. Individual team Scrums may be staggered in time so that repre-\nsentatives from other teams can attend if necessary."}
{"query": "Why might individual team Scrums be staggered in time?", "response": "Individual team Scrums may be staggered in time so that representatives from other teams can attend if necessary. This allows for better communication and coordination between teams, as representatives can provide updates and address any issues or concerns that may arise during the Scrum meetings. Staggering the Scrums also ensures that all teams have the opportunity to participate and collaborate effectively, even if they are working on different schedules or in different time zones.", "context": "3.4  \u25a0 Scaling agile methods  95\nDean Leffingwell, who has a great deal of experience in scaling agile methods, \nhas developed the Scaled Agile Framework (Leffingwell 2007, 2011) to support \nlarge-scale, multi-team software development. He reports how this method has been \nused successfully in a number of large companies. IBM has also developed a frame-\nwork for the large-scale use of agile methods called the Agile Scaling Model (ASM). \nFigure 3.14, taken from Ambler\u2019s white paper that discusses ASM (Ambler 2010), \nshows an overview of this model.\nThe ASM recognizes that scaling is a staged process where development teams \nmove from the core agile practices discussed here to what is called Disciplined Agile \nDelivery. Essentially, this stage involves adapting these practices to a disciplined \norganizational setting and recognizing that teams cannot simply focus on develop-\nment but must also take into account other stages of the software engineering \n process, such as requirements and architectural design.\nThe final scaling stage in ASM is to move to Agility at Scale where the com-\nplexity that is inherent in large projects is recognized. This involves taking account \nof factors such as distributed development, complex legacy environments, and \nregulatory compliance requirements. The practices used for disciplined agile \ndelivery may have to be modified on a project-by-project basis to take these into \naccount and, sometimes, additional plan-based practices added to the process.\nNo single model is appropriate for all large-scale agile products as the type of \nproduct, the customer requirements, and the people available are all different. \nHowever, approaches to scaling agile methods have a number of things in common:\nCore agile \ndevelopment\nDisciplined \nagile delivery\nAgility at\nscale\nAgility at scale\nDisciplined agile delivery where \nscaling factors apply:\nLarge team size\nGeographic distribution\nRegulatory compliance\nDomain complexity\nOrganization distribution\nTechnical complexity\nOrganizational complexity\nEnterprise discipline\nDisciplined agile delivery\nRisk+value driven life-cycle\nSelf-organizing with appropriate\ngovernance framework\nFull delivery life-cycle\nCore agile development\nValue-driven life-cycle\nSelf-organizing teams\nFocus on construction\nFigure 3.14 IBM\u2019s  \nAgility at Scale model  \n(\u00a9 IBM 2010)\n\n\n96  Chapter 3 \u25a0 Agile software development\n1. A completely incremental approach to requirements engineering is impossible. \nSome early work on initial software requirements is essential. You need this \nwork to identify the different parts of the system that may be developed by \n different teams and, often, to be part of the contract for the system development. \nHowever, these requirements should not normally be specified in detail; details \nare best developed incrementally.\n2. There cannot be a single product owner or customer representative. Different \npeople have to be involved for different parts of the system, and they have to \ncontinuously communicate and negotiate throughout the development process.\n3. It is not possible to focus only on the code of the system. You need to do more \nup-front design and system documentation. The software architecture has to be \ndesigned, and there has to be documentation produced to describe critical \naspects of the system, such as database schemas and the work breakdown \nacross teams.\n4. Cross-team communication mechanisms have to be designed and used. This \nshould involve regular phone and videoconferences between team members and \nfrequent, short electronic meetings where teams update each other on progress. \nA range of communication channels such as email, instant messaging, wikis, \nand social networking systems should be provided to facilitate communications.\n5. \nContinuous integration, where the whole system is built every time any devel-\noper checks in a change, is practically impossible when several separate \nprograms have to be integrated to create the system. However, it is essential \nto maintain frequent system builds and regular releases of the system. \nConfiguration management tools that support multi-team software develop-\nment are essential.\nScrum has been adapted for large-scale development. In essence, the Scrum team \nmodel described in Section 3.3 is maintained, but multiple Scrum teams are set up. \nThe key characteristics of multi-team Scrum are:\n1. Role replication Each team has a Product Owner for its work component and \nScrumMaster. There may be a chief Product Owner and ScrumMaster for the \nentire project.\n2. Product architects Each team chooses a product architect, and these architects \ncollaborate to design and evolve the overall system architecture.\n3. Release alignment The dates of product releases from each team are aligned so \nthat a demonstrable and complete system is produced.\n4. Scrum of Scrums There is a daily Scrum of Scrums where representatives from \neach team meet to discuss progress, identify problems, and plan the work to be \ndone that day. Individual team Scrums may be staggered in time so that repre-\nsentatives from other teams can attend if necessary."}
{"query": "What are the key characteristics of multi-team Scrum?", "response": "The key characteristics of multi-team Scrum are role replication, product architects, release alignment, and Scrum of Scrums. Each team has a Product Owner and ScrumMaster for its work component, and there may be a chief Product Owner and ScrumMaster for the entire project. Each team also chooses a product architect, who collaborates with other architects to design and evolve the overall system architecture. The dates of product releases from each team are aligned to ensure a demonstrable and complete system. Finally, there is a daily Scrum of Scrums where representatives from each team meet to discuss progress, identify problems, and plan the work to be done that day.", "context": "3.4  \u25a0 Scaling agile methods  95\nDean Leffingwell, who has a great deal of experience in scaling agile methods, \nhas developed the Scaled Agile Framework (Leffingwell 2007, 2011) to support \nlarge-scale, multi-team software development. He reports how this method has been \nused successfully in a number of large companies. IBM has also developed a frame-\nwork for the large-scale use of agile methods called the Agile Scaling Model (ASM). \nFigure 3.14, taken from Ambler\u2019s white paper that discusses ASM (Ambler 2010), \nshows an overview of this model.\nThe ASM recognizes that scaling is a staged process where development teams \nmove from the core agile practices discussed here to what is called Disciplined Agile \nDelivery. Essentially, this stage involves adapting these practices to a disciplined \norganizational setting and recognizing that teams cannot simply focus on develop-\nment but must also take into account other stages of the software engineering \n process, such as requirements and architectural design.\nThe final scaling stage in ASM is to move to Agility at Scale where the com-\nplexity that is inherent in large projects is recognized. This involves taking account \nof factors such as distributed development, complex legacy environments, and \nregulatory compliance requirements. The practices used for disciplined agile \ndelivery may have to be modified on a project-by-project basis to take these into \naccount and, sometimes, additional plan-based practices added to the process.\nNo single model is appropriate for all large-scale agile products as the type of \nproduct, the customer requirements, and the people available are all different. \nHowever, approaches to scaling agile methods have a number of things in common:\nCore agile \ndevelopment\nDisciplined \nagile delivery\nAgility at\nscale\nAgility at scale\nDisciplined agile delivery where \nscaling factors apply:\nLarge team size\nGeographic distribution\nRegulatory compliance\nDomain complexity\nOrganization distribution\nTechnical complexity\nOrganizational complexity\nEnterprise discipline\nDisciplined agile delivery\nRisk+value driven life-cycle\nSelf-organizing with appropriate\ngovernance framework\nFull delivery life-cycle\nCore agile development\nValue-driven life-cycle\nSelf-organizing teams\nFocus on construction\nFigure 3.14 IBM\u2019s  \nAgility at Scale model  \n(\u00a9 IBM 2010)\n\n\n96  Chapter 3 \u25a0 Agile software development\n1. A completely incremental approach to requirements engineering is impossible. \nSome early work on initial software requirements is essential. You need this \nwork to identify the different parts of the system that may be developed by \n different teams and, often, to be part of the contract for the system development. \nHowever, these requirements should not normally be specified in detail; details \nare best developed incrementally.\n2. There cannot be a single product owner or customer representative. Different \npeople have to be involved for different parts of the system, and they have to \ncontinuously communicate and negotiate throughout the development process.\n3. It is not possible to focus only on the code of the system. You need to do more \nup-front design and system documentation. The software architecture has to be \ndesigned, and there has to be documentation produced to describe critical \naspects of the system, such as database schemas and the work breakdown \nacross teams.\n4. Cross-team communication mechanisms have to be designed and used. This \nshould involve regular phone and videoconferences between team members and \nfrequent, short electronic meetings where teams update each other on progress. \nA range of communication channels such as email, instant messaging, wikis, \nand social networking systems should be provided to facilitate communications.\n5. \nContinuous integration, where the whole system is built every time any devel-\noper checks in a change, is practically impossible when several separate \nprograms have to be integrated to create the system. However, it is essential \nto maintain frequent system builds and regular releases of the system. \nConfiguration management tools that support multi-team software develop-\nment are essential.\nScrum has been adapted for large-scale development. In essence, the Scrum team \nmodel described in Section 3.3 is maintained, but multiple Scrum teams are set up. \nThe key characteristics of multi-team Scrum are:\n1. Role replication Each team has a Product Owner for its work component and \nScrumMaster. There may be a chief Product Owner and ScrumMaster for the \nentire project.\n2. Product architects Each team chooses a product architect, and these architects \ncollaborate to design and evolve the overall system architecture.\n3. Release alignment The dates of product releases from each team are aligned so \nthat a demonstrable and complete system is produced.\n4. Scrum of Scrums There is a daily Scrum of Scrums where representatives from \neach team meet to discuss progress, identify problems, and plan the work to be \ndone that day. Individual team Scrums may be staggered in time so that repre-\nsentatives from other teams can attend if necessary."}
{"query": "How does multi-team Scrum differ from traditional Scrum?", "response": "Multi-team Scrum differs from traditional Scrum in several ways. In multi-team Scrum, there is role replication, meaning that each team has its own Product Owner and ScrumMaster. There may also be a chief Product Owner and ScrumMaster for the entire project. Additionally, each team in multi-team Scrum chooses a product architect, and these architects collaborate to design and evolve the overall system architecture. The dates of product releases from each team are aligned in multi-team Scrum to ensure that a demonstrable and complete system is produced. Finally, there is a daily Scrum of Scrums meeting in multi-team Scrum, where representatives from each team come together to discuss progress, identify problems, and plan the work to be done that day.", "context": "3.4  \u25a0 Scaling agile methods  95\nDean Leffingwell, who has a great deal of experience in scaling agile methods, \nhas developed the Scaled Agile Framework (Leffingwell 2007, 2011) to support \nlarge-scale, multi-team software development. He reports how this method has been \nused successfully in a number of large companies. IBM has also developed a frame-\nwork for the large-scale use of agile methods called the Agile Scaling Model (ASM). \nFigure 3.14, taken from Ambler\u2019s white paper that discusses ASM (Ambler 2010), \nshows an overview of this model.\nThe ASM recognizes that scaling is a staged process where development teams \nmove from the core agile practices discussed here to what is called Disciplined Agile \nDelivery. Essentially, this stage involves adapting these practices to a disciplined \norganizational setting and recognizing that teams cannot simply focus on develop-\nment but must also take into account other stages of the software engineering \n process, such as requirements and architectural design.\nThe final scaling stage in ASM is to move to Agility at Scale where the com-\nplexity that is inherent in large projects is recognized. This involves taking account \nof factors such as distributed development, complex legacy environments, and \nregulatory compliance requirements. The practices used for disciplined agile \ndelivery may have to be modified on a project-by-project basis to take these into \naccount and, sometimes, additional plan-based practices added to the process.\nNo single model is appropriate for all large-scale agile products as the type of \nproduct, the customer requirements, and the people available are all different. \nHowever, approaches to scaling agile methods have a number of things in common:\nCore agile \ndevelopment\nDisciplined \nagile delivery\nAgility at\nscale\nAgility at scale\nDisciplined agile delivery where \nscaling factors apply:\nLarge team size\nGeographic distribution\nRegulatory compliance\nDomain complexity\nOrganization distribution\nTechnical complexity\nOrganizational complexity\nEnterprise discipline\nDisciplined agile delivery\nRisk+value driven life-cycle\nSelf-organizing with appropriate\ngovernance framework\nFull delivery life-cycle\nCore agile development\nValue-driven life-cycle\nSelf-organizing teams\nFocus on construction\nFigure 3.14 IBM\u2019s  \nAgility at Scale model  \n(\u00a9 IBM 2010)\n\n\n96  Chapter 3 \u25a0 Agile software development\n1. A completely incremental approach to requirements engineering is impossible. \nSome early work on initial software requirements is essential. You need this \nwork to identify the different parts of the system that may be developed by \n different teams and, often, to be part of the contract for the system development. \nHowever, these requirements should not normally be specified in detail; details \nare best developed incrementally.\n2. There cannot be a single product owner or customer representative. Different \npeople have to be involved for different parts of the system, and they have to \ncontinuously communicate and negotiate throughout the development process.\n3. It is not possible to focus only on the code of the system. You need to do more \nup-front design and system documentation. The software architecture has to be \ndesigned, and there has to be documentation produced to describe critical \naspects of the system, such as database schemas and the work breakdown \nacross teams.\n4. Cross-team communication mechanisms have to be designed and used. This \nshould involve regular phone and videoconferences between team members and \nfrequent, short electronic meetings where teams update each other on progress. \nA range of communication channels such as email, instant messaging, wikis, \nand social networking systems should be provided to facilitate communications.\n5. \nContinuous integration, where the whole system is built every time any devel-\noper checks in a change, is practically impossible when several separate \nprograms have to be integrated to create the system. However, it is essential \nto maintain frequent system builds and regular releases of the system. \nConfiguration management tools that support multi-team software develop-\nment are essential.\nScrum has been adapted for large-scale development. In essence, the Scrum team \nmodel described in Section 3.3 is maintained, but multiple Scrum teams are set up. \nThe key characteristics of multi-team Scrum are:\n1. Role replication Each team has a Product Owner for its work component and \nScrumMaster. There may be a chief Product Owner and ScrumMaster for the \nentire project.\n2. Product architects Each team chooses a product architect, and these architects \ncollaborate to design and evolve the overall system architecture.\n3. Release alignment The dates of product releases from each team are aligned so \nthat a demonstrable and complete system is produced.\n4. Scrum of Scrums There is a daily Scrum of Scrums where representatives from \neach team meet to discuss progress, identify problems, and plan the work to be \ndone that day. Individual team Scrums may be staggered in time so that repre-\nsentatives from other teams can attend if necessary."}
{"query": "What types of companies have been the most enthusiastic adopters of agile methods?", "response": "Small software companies that develop software products have been the most enthusiastic adopters of agile methods.", "context": "3.4  \u25a0 Scaling agile methods  97\n \n3.4.4  Agile methods across organizations\nSmall software companies that develop software products have been among the \nmost enthusiastic adopters of agile methods. These companies are not constrained by \norganizational bureaucracies or process standards, and they can change quickly to \nadopt new ideas. Of course, larger companies have also experimented with agile \nmethods in specific projects, but it is much more difficult for them to \u201cscale out\u201d \nthese methods across the organization.\nIt can be difficult to introduce agile methods into large companies for a number of \nreasons:\n1. Project managers who do not have experience of agile methods may be reluctant \nto accept the risk of a new approach, as they do not know how this will affect \ntheir particular projects.\n2. Large organizations often have quality procedures and standards that all pro-\njects are expected to follow, and, because of their bureaucratic nature, these are \nlikely to be incompatible with agile methods. Sometimes, these are supported \nby software tools (e.g., requirements management tools), and the use of these \ntools is mandated for all projects.\n3. Agile methods seem to work best when team members have a relatively high \nskill level. However, within large organizations, there are likely to be a wide \nrange of skills and abilities, and people with lower skill levels may not be effec-\ntive team members in agile processes.\n4. \nThere may be cultural resistance to agile methods, especially in those organiza-\ntions that have a long history of using conventional systems engineering  processes.\nChange management and testing procedures are examples of company procedures \nthat may not be compatible with agile methods. Change management is the process of \ncontrolling changes to a system, so that the impact of changes is predictable and costs are \ncontrolled. All changes have to be approved in advance before they are made, and this \nconflicts with the notion of refactoring. When refactoring is part of an agile process, any \ndeveloper can improve any code without getting external approval. For large systems, \nthere are also testing standards where a system build is handed over to an external testing \nteam. This may conflict with test-first approaches used in agile development methods.\nIntroducing and sustaining the use of agile methods across a large organization is \na process of cultural change. Cultural change takes a long time to implement and \noften requires a change of management before it can be accomplished. Companies \nwishing to use agile methods need evangelists to promote change. Rather than try-\ning to force agile methods onto unwilling developers, companies have found that the \nbest way to introduce agile is bit by bit, starting with an enthusiastic group of devel-\nopers. A successful agile project can act as a starting point, with the project team \nspreading agile practice across the organization. Once the notion of agile is widely \nknown, explicit actions can then be taken to spread it across the organization."}
{"query": "Why might it be difficult for larger companies to scale out agile methods across the organization?", "response": "Larger companies may find it difficult to scale out agile methods across the organization for several reasons. Firstly, project managers who are not familiar with agile methods may be hesitant to adopt a new approach without knowing how it will impact their specific projects. Secondly, large organizations often have established quality procedures and standards that may not be compatible with agile methods. These procedures are typically supported by software tools that are mandated for all projects, making it challenging to integrate agile practices. Additionally, agile methods require team members with a relatively high skill level, but large organizations may have a wide range of skills and abilities, making it difficult to ensure effective team collaboration. Finally, there may be cultural resistance to agile methods, particularly in organizations that have a long history of using conventional systems engineering processes. Change management and testing procedures, which are often incompatible with agile methods, may also pose challenges. Overall, introducing and sustaining the use of agile methods across a large organization requires a process of cultural change, which can be time-consuming and may require a change in management.", "context": "3.4  \u25a0 Scaling agile methods  97\n \n3.4.4  Agile methods across organizations\nSmall software companies that develop software products have been among the \nmost enthusiastic adopters of agile methods. These companies are not constrained by \norganizational bureaucracies or process standards, and they can change quickly to \nadopt new ideas. Of course, larger companies have also experimented with agile \nmethods in specific projects, but it is much more difficult for them to \u201cscale out\u201d \nthese methods across the organization.\nIt can be difficult to introduce agile methods into large companies for a number of \nreasons:\n1. Project managers who do not have experience of agile methods may be reluctant \nto accept the risk of a new approach, as they do not know how this will affect \ntheir particular projects.\n2. Large organizations often have quality procedures and standards that all pro-\njects are expected to follow, and, because of their bureaucratic nature, these are \nlikely to be incompatible with agile methods. Sometimes, these are supported \nby software tools (e.g., requirements management tools), and the use of these \ntools is mandated for all projects.\n3. Agile methods seem to work best when team members have a relatively high \nskill level. However, within large organizations, there are likely to be a wide \nrange of skills and abilities, and people with lower skill levels may not be effec-\ntive team members in agile processes.\n4. \nThere may be cultural resistance to agile methods, especially in those organiza-\ntions that have a long history of using conventional systems engineering  processes.\nChange management and testing procedures are examples of company procedures \nthat may not be compatible with agile methods. Change management is the process of \ncontrolling changes to a system, so that the impact of changes is predictable and costs are \ncontrolled. All changes have to be approved in advance before they are made, and this \nconflicts with the notion of refactoring. When refactoring is part of an agile process, any \ndeveloper can improve any code without getting external approval. For large systems, \nthere are also testing standards where a system build is handed over to an external testing \nteam. This may conflict with test-first approaches used in agile development methods.\nIntroducing and sustaining the use of agile methods across a large organization is \na process of cultural change. Cultural change takes a long time to implement and \noften requires a change of management before it can be accomplished. Companies \nwishing to use agile methods need evangelists to promote change. Rather than try-\ning to force agile methods onto unwilling developers, companies have found that the \nbest way to introduce agile is bit by bit, starting with an enthusiastic group of devel-\nopers. A successful agile project can act as a starting point, with the project team \nspreading agile practice across the organization. Once the notion of agile is widely \nknown, explicit actions can then be taken to spread it across the organization."}
{"query": "What are some reasons that can make it difficult to introduce agile methods into large companies?", "response": "Some reasons that can make it difficult to introduce agile methods into large companies include:\n1. Project managers who are unfamiliar with agile methods may be hesitant to take on the risk of a new approach without knowing how it will impact their specific projects.\n2. Large organizations often have quality procedures and standards that all projects are expected to follow, which may be incompatible with agile methods. These procedures may also be supported by mandated software tools that may not align with agile practices.\n3. Agile methods tend to work best when team members have a relatively high skill level. However, within large organizations, there may be a wide range of skills and abilities, and individuals with lower skill levels may not be effective team members in agile processes.\n4. Cultural resistance to agile methods may exist, particularly in organizations that have a long history of using conventional systems engineering processes. Company procedures such as change management and testing standards may not be compatible with agile methods, which can create conflicts and resistance to change.", "context": "3.4  \u25a0 Scaling agile methods  97\n \n3.4.4  Agile methods across organizations\nSmall software companies that develop software products have been among the \nmost enthusiastic adopters of agile methods. These companies are not constrained by \norganizational bureaucracies or process standards, and they can change quickly to \nadopt new ideas. Of course, larger companies have also experimented with agile \nmethods in specific projects, but it is much more difficult for them to \u201cscale out\u201d \nthese methods across the organization.\nIt can be difficult to introduce agile methods into large companies for a number of \nreasons:\n1. Project managers who do not have experience of agile methods may be reluctant \nto accept the risk of a new approach, as they do not know how this will affect \ntheir particular projects.\n2. Large organizations often have quality procedures and standards that all pro-\njects are expected to follow, and, because of their bureaucratic nature, these are \nlikely to be incompatible with agile methods. Sometimes, these are supported \nby software tools (e.g., requirements management tools), and the use of these \ntools is mandated for all projects.\n3. Agile methods seem to work best when team members have a relatively high \nskill level. However, within large organizations, there are likely to be a wide \nrange of skills and abilities, and people with lower skill levels may not be effec-\ntive team members in agile processes.\n4. \nThere may be cultural resistance to agile methods, especially in those organiza-\ntions that have a long history of using conventional systems engineering  processes.\nChange management and testing procedures are examples of company procedures \nthat may not be compatible with agile methods. Change management is the process of \ncontrolling changes to a system, so that the impact of changes is predictable and costs are \ncontrolled. All changes have to be approved in advance before they are made, and this \nconflicts with the notion of refactoring. When refactoring is part of an agile process, any \ndeveloper can improve any code without getting external approval. For large systems, \nthere are also testing standards where a system build is handed over to an external testing \nteam. This may conflict with test-first approaches used in agile development methods.\nIntroducing and sustaining the use of agile methods across a large organization is \na process of cultural change. Cultural change takes a long time to implement and \noften requires a change of management before it can be accomplished. Companies \nwishing to use agile methods need evangelists to promote change. Rather than try-\ning to force agile methods onto unwilling developers, companies have found that the \nbest way to introduce agile is bit by bit, starting with an enthusiastic group of devel-\nopers. A successful agile project can act as a starting point, with the project team \nspreading agile practice across the organization. Once the notion of agile is widely \nknown, explicit actions can then be taken to spread it across the organization."}
{"query": "Why might project managers without experience of agile methods be reluctant to accept the risk of a new approach?", "response": "Project managers without experience of agile methods may be reluctant to accept the risk of a new approach because they do not know how this will affect their particular projects.", "context": "3.4  \u25a0 Scaling agile methods  97\n \n3.4.4  Agile methods across organizations\nSmall software companies that develop software products have been among the \nmost enthusiastic adopters of agile methods. These companies are not constrained by \norganizational bureaucracies or process standards, and they can change quickly to \nadopt new ideas. Of course, larger companies have also experimented with agile \nmethods in specific projects, but it is much more difficult for them to \u201cscale out\u201d \nthese methods across the organization.\nIt can be difficult to introduce agile methods into large companies for a number of \nreasons:\n1. Project managers who do not have experience of agile methods may be reluctant \nto accept the risk of a new approach, as they do not know how this will affect \ntheir particular projects.\n2. Large organizations often have quality procedures and standards that all pro-\njects are expected to follow, and, because of their bureaucratic nature, these are \nlikely to be incompatible with agile methods. Sometimes, these are supported \nby software tools (e.g., requirements management tools), and the use of these \ntools is mandated for all projects.\n3. Agile methods seem to work best when team members have a relatively high \nskill level. However, within large organizations, there are likely to be a wide \nrange of skills and abilities, and people with lower skill levels may not be effec-\ntive team members in agile processes.\n4. \nThere may be cultural resistance to agile methods, especially in those organiza-\ntions that have a long history of using conventional systems engineering  processes.\nChange management and testing procedures are examples of company procedures \nthat may not be compatible with agile methods. Change management is the process of \ncontrolling changes to a system, so that the impact of changes is predictable and costs are \ncontrolled. All changes have to be approved in advance before they are made, and this \nconflicts with the notion of refactoring. When refactoring is part of an agile process, any \ndeveloper can improve any code without getting external approval. For large systems, \nthere are also testing standards where a system build is handed over to an external testing \nteam. This may conflict with test-first approaches used in agile development methods.\nIntroducing and sustaining the use of agile methods across a large organization is \na process of cultural change. Cultural change takes a long time to implement and \noften requires a change of management before it can be accomplished. Companies \nwishing to use agile methods need evangelists to promote change. Rather than try-\ning to force agile methods onto unwilling developers, companies have found that the \nbest way to introduce agile is bit by bit, starting with an enthusiastic group of devel-\nopers. A successful agile project can act as a starting point, with the project team \nspreading agile practice across the organization. Once the notion of agile is widely \nknown, explicit actions can then be taken to spread it across the organization."}
{"query": "How might the bureaucratic nature of large organizations' quality procedures and standards conflict with agile methods?", "response": "The bureaucratic nature of large organizations' quality procedures and standards may conflict with agile methods because these procedures and standards are likely to be incompatible with the flexibility and adaptability of agile methods. Agile methods emphasize iterative and incremental development, frequent changes, and continuous improvement, while large organizations often have rigid quality procedures and standards that require extensive documentation, formal approvals, and adherence to predefined processes. These bureaucratic procedures may hinder the ability of agile teams to respond quickly to changes, collaborate effectively, and deliver value in a timely manner. Additionally, the use of mandated software tools and external testing teams may not align with the self-organizing and cross-functional nature of agile teams.", "context": "3.4  \u25a0 Scaling agile methods  97\n \n3.4.4  Agile methods across organizations\nSmall software companies that develop software products have been among the \nmost enthusiastic adopters of agile methods. These companies are not constrained by \norganizational bureaucracies or process standards, and they can change quickly to \nadopt new ideas. Of course, larger companies have also experimented with agile \nmethods in specific projects, but it is much more difficult for them to \u201cscale out\u201d \nthese methods across the organization.\nIt can be difficult to introduce agile methods into large companies for a number of \nreasons:\n1. Project managers who do not have experience of agile methods may be reluctant \nto accept the risk of a new approach, as they do not know how this will affect \ntheir particular projects.\n2. Large organizations often have quality procedures and standards that all pro-\njects are expected to follow, and, because of their bureaucratic nature, these are \nlikely to be incompatible with agile methods. Sometimes, these are supported \nby software tools (e.g., requirements management tools), and the use of these \ntools is mandated for all projects.\n3. Agile methods seem to work best when team members have a relatively high \nskill level. However, within large organizations, there are likely to be a wide \nrange of skills and abilities, and people with lower skill levels may not be effec-\ntive team members in agile processes.\n4. \nThere may be cultural resistance to agile methods, especially in those organiza-\ntions that have a long history of using conventional systems engineering  processes.\nChange management and testing procedures are examples of company procedures \nthat may not be compatible with agile methods. Change management is the process of \ncontrolling changes to a system, so that the impact of changes is predictable and costs are \ncontrolled. All changes have to be approved in advance before they are made, and this \nconflicts with the notion of refactoring. When refactoring is part of an agile process, any \ndeveloper can improve any code without getting external approval. For large systems, \nthere are also testing standards where a system build is handed over to an external testing \nteam. This may conflict with test-first approaches used in agile development methods.\nIntroducing and sustaining the use of agile methods across a large organization is \na process of cultural change. Cultural change takes a long time to implement and \noften requires a change of management before it can be accomplished. Companies \nwishing to use agile methods need evangelists to promote change. Rather than try-\ning to force agile methods onto unwilling developers, companies have found that the \nbest way to introduce agile is bit by bit, starting with an enthusiastic group of devel-\nopers. A successful agile project can act as a starting point, with the project team \nspreading agile practice across the organization. Once the notion of agile is widely \nknown, explicit actions can then be taken to spread it across the organization."}
{"query": "What is the potential issue with mandated use of software tools in large organizations when trying to implement agile methods?", "response": "The potential issue with mandated use of software tools in large organizations when trying to implement agile methods is that these tools may be incompatible with agile methods. This is because agile methods emphasize flexibility and adaptability, while mandated software tools often have rigid processes and requirements. Additionally, the use of these tools may conflict with agile practices such as refactoring and test-first approaches.", "context": "3.4  \u25a0 Scaling agile methods  97\n \n3.4.4  Agile methods across organizations\nSmall software companies that develop software products have been among the \nmost enthusiastic adopters of agile methods. These companies are not constrained by \norganizational bureaucracies or process standards, and they can change quickly to \nadopt new ideas. Of course, larger companies have also experimented with agile \nmethods in specific projects, but it is much more difficult for them to \u201cscale out\u201d \nthese methods across the organization.\nIt can be difficult to introduce agile methods into large companies for a number of \nreasons:\n1. Project managers who do not have experience of agile methods may be reluctant \nto accept the risk of a new approach, as they do not know how this will affect \ntheir particular projects.\n2. Large organizations often have quality procedures and standards that all pro-\njects are expected to follow, and, because of their bureaucratic nature, these are \nlikely to be incompatible with agile methods. Sometimes, these are supported \nby software tools (e.g., requirements management tools), and the use of these \ntools is mandated for all projects.\n3. Agile methods seem to work best when team members have a relatively high \nskill level. However, within large organizations, there are likely to be a wide \nrange of skills and abilities, and people with lower skill levels may not be effec-\ntive team members in agile processes.\n4. \nThere may be cultural resistance to agile methods, especially in those organiza-\ntions that have a long history of using conventional systems engineering  processes.\nChange management and testing procedures are examples of company procedures \nthat may not be compatible with agile methods. Change management is the process of \ncontrolling changes to a system, so that the impact of changes is predictable and costs are \ncontrolled. All changes have to be approved in advance before they are made, and this \nconflicts with the notion of refactoring. When refactoring is part of an agile process, any \ndeveloper can improve any code without getting external approval. For large systems, \nthere are also testing standards where a system build is handed over to an external testing \nteam. This may conflict with test-first approaches used in agile development methods.\nIntroducing and sustaining the use of agile methods across a large organization is \na process of cultural change. Cultural change takes a long time to implement and \noften requires a change of management before it can be accomplished. Companies \nwishing to use agile methods need evangelists to promote change. Rather than try-\ning to force agile methods onto unwilling developers, companies have found that the \nbest way to introduce agile is bit by bit, starting with an enthusiastic group of devel-\nopers. A successful agile project can act as a starting point, with the project team \nspreading agile practice across the organization. Once the notion of agile is widely \nknown, explicit actions can then be taken to spread it across the organization."}
{"query": "Why do agile methods seem to work best when team members have a relatively high skill level?", "response": "Agile methods seem to work best when team members have a relatively high skill level because these methods require a high level of collaboration, self-organization, and adaptability. Team members with a higher skill level are more likely to have the necessary expertise and experience to effectively contribute to the agile processes and make informed decisions. They are also more likely to be able to handle the fast-paced and dynamic nature of agile development, as well as possess the ability to quickly learn and apply new concepts and techniques.", "context": "3.4  \u25a0 Scaling agile methods  97\n \n3.4.4  Agile methods across organizations\nSmall software companies that develop software products have been among the \nmost enthusiastic adopters of agile methods. These companies are not constrained by \norganizational bureaucracies or process standards, and they can change quickly to \nadopt new ideas. Of course, larger companies have also experimented with agile \nmethods in specific projects, but it is much more difficult for them to \u201cscale out\u201d \nthese methods across the organization.\nIt can be difficult to introduce agile methods into large companies for a number of \nreasons:\n1. Project managers who do not have experience of agile methods may be reluctant \nto accept the risk of a new approach, as they do not know how this will affect \ntheir particular projects.\n2. Large organizations often have quality procedures and standards that all pro-\njects are expected to follow, and, because of their bureaucratic nature, these are \nlikely to be incompatible with agile methods. Sometimes, these are supported \nby software tools (e.g., requirements management tools), and the use of these \ntools is mandated for all projects.\n3. Agile methods seem to work best when team members have a relatively high \nskill level. However, within large organizations, there are likely to be a wide \nrange of skills and abilities, and people with lower skill levels may not be effec-\ntive team members in agile processes.\n4. \nThere may be cultural resistance to agile methods, especially in those organiza-\ntions that have a long history of using conventional systems engineering  processes.\nChange management and testing procedures are examples of company procedures \nthat may not be compatible with agile methods. Change management is the process of \ncontrolling changes to a system, so that the impact of changes is predictable and costs are \ncontrolled. All changes have to be approved in advance before they are made, and this \nconflicts with the notion of refactoring. When refactoring is part of an agile process, any \ndeveloper can improve any code without getting external approval. For large systems, \nthere are also testing standards where a system build is handed over to an external testing \nteam. This may conflict with test-first approaches used in agile development methods.\nIntroducing and sustaining the use of agile methods across a large organization is \na process of cultural change. Cultural change takes a long time to implement and \noften requires a change of management before it can be accomplished. Companies \nwishing to use agile methods need evangelists to promote change. Rather than try-\ning to force agile methods onto unwilling developers, companies have found that the \nbest way to introduce agile is bit by bit, starting with an enthusiastic group of devel-\nopers. A successful agile project can act as a starting point, with the project team \nspreading agile practice across the organization. Once the notion of agile is widely \nknown, explicit actions can then be taken to spread it across the organization."}
{"query": "How might the range of skills and abilities within large organizations affect the effectiveness of agile processes?", "response": "The range of skills and abilities within large organizations can affect the effectiveness of agile processes. In agile methods, team members are expected to have a relatively high skill level. However, within large organizations, there may be a wide range of skills and abilities among team members. This means that individuals with lower skill levels may not be as effective in agile processes. This can impact the overall effectiveness of agile methods within the organization, as the success of agile relies on the collaboration and contribution of all team members.", "context": "3.4  \u25a0 Scaling agile methods  97\n \n3.4.4  Agile methods across organizations\nSmall software companies that develop software products have been among the \nmost enthusiastic adopters of agile methods. These companies are not constrained by \norganizational bureaucracies or process standards, and they can change quickly to \nadopt new ideas. Of course, larger companies have also experimented with agile \nmethods in specific projects, but it is much more difficult for them to \u201cscale out\u201d \nthese methods across the organization.\nIt can be difficult to introduce agile methods into large companies for a number of \nreasons:\n1. Project managers who do not have experience of agile methods may be reluctant \nto accept the risk of a new approach, as they do not know how this will affect \ntheir particular projects.\n2. Large organizations often have quality procedures and standards that all pro-\njects are expected to follow, and, because of their bureaucratic nature, these are \nlikely to be incompatible with agile methods. Sometimes, these are supported \nby software tools (e.g., requirements management tools), and the use of these \ntools is mandated for all projects.\n3. Agile methods seem to work best when team members have a relatively high \nskill level. However, within large organizations, there are likely to be a wide \nrange of skills and abilities, and people with lower skill levels may not be effec-\ntive team members in agile processes.\n4. \nThere may be cultural resistance to agile methods, especially in those organiza-\ntions that have a long history of using conventional systems engineering  processes.\nChange management and testing procedures are examples of company procedures \nthat may not be compatible with agile methods. Change management is the process of \ncontrolling changes to a system, so that the impact of changes is predictable and costs are \ncontrolled. All changes have to be approved in advance before they are made, and this \nconflicts with the notion of refactoring. When refactoring is part of an agile process, any \ndeveloper can improve any code without getting external approval. For large systems, \nthere are also testing standards where a system build is handed over to an external testing \nteam. This may conflict with test-first approaches used in agile development methods.\nIntroducing and sustaining the use of agile methods across a large organization is \na process of cultural change. Cultural change takes a long time to implement and \noften requires a change of management before it can be accomplished. Companies \nwishing to use agile methods need evangelists to promote change. Rather than try-\ning to force agile methods onto unwilling developers, companies have found that the \nbest way to introduce agile is bit by bit, starting with an enthusiastic group of devel-\nopers. A successful agile project can act as a starting point, with the project team \nspreading agile practice across the organization. Once the notion of agile is widely \nknown, explicit actions can then be taken to spread it across the organization."}
{"query": "What kind of cultural resistance might organizations face when introducing agile methods?", "response": "Organizations may face cultural resistance when introducing agile methods, especially in those organizations that have a long history of using conventional systems engineering processes. This resistance may stem from factors such as the need for change management and testing procedures that may not be compatible with agile methods. For example, change management processes conflict with the notion of refactoring, as refactoring allows any developer to improve any code without external approval. Additionally, testing standards that involve handing over a system build to an external testing team may conflict with the test-first approaches used in agile development methods.", "context": "3.4  \u25a0 Scaling agile methods  97\n \n3.4.4  Agile methods across organizations\nSmall software companies that develop software products have been among the \nmost enthusiastic adopters of agile methods. These companies are not constrained by \norganizational bureaucracies or process standards, and they can change quickly to \nadopt new ideas. Of course, larger companies have also experimented with agile \nmethods in specific projects, but it is much more difficult for them to \u201cscale out\u201d \nthese methods across the organization.\nIt can be difficult to introduce agile methods into large companies for a number of \nreasons:\n1. Project managers who do not have experience of agile methods may be reluctant \nto accept the risk of a new approach, as they do not know how this will affect \ntheir particular projects.\n2. Large organizations often have quality procedures and standards that all pro-\njects are expected to follow, and, because of their bureaucratic nature, these are \nlikely to be incompatible with agile methods. Sometimes, these are supported \nby software tools (e.g., requirements management tools), and the use of these \ntools is mandated for all projects.\n3. Agile methods seem to work best when team members have a relatively high \nskill level. However, within large organizations, there are likely to be a wide \nrange of skills and abilities, and people with lower skill levels may not be effec-\ntive team members in agile processes.\n4. \nThere may be cultural resistance to agile methods, especially in those organiza-\ntions that have a long history of using conventional systems engineering  processes.\nChange management and testing procedures are examples of company procedures \nthat may not be compatible with agile methods. Change management is the process of \ncontrolling changes to a system, so that the impact of changes is predictable and costs are \ncontrolled. All changes have to be approved in advance before they are made, and this \nconflicts with the notion of refactoring. When refactoring is part of an agile process, any \ndeveloper can improve any code without getting external approval. For large systems, \nthere are also testing standards where a system build is handed over to an external testing \nteam. This may conflict with test-first approaches used in agile development methods.\nIntroducing and sustaining the use of agile methods across a large organization is \na process of cultural change. Cultural change takes a long time to implement and \noften requires a change of management before it can be accomplished. Companies \nwishing to use agile methods need evangelists to promote change. Rather than try-\ning to force agile methods onto unwilling developers, companies have found that the \nbest way to introduce agile is bit by bit, starting with an enthusiastic group of devel-\nopers. A successful agile project can act as a starting point, with the project team \nspreading agile practice across the organization. Once the notion of agile is widely \nknown, explicit actions can then be taken to spread it across the organization."}
{"query": "Why might change management and testing procedures not be compatible with agile methods?", "response": "Change management and testing procedures may not be compatible with agile methods because they often involve a process of controlling changes and obtaining external approval before making any changes. This conflicts with the agile principle of refactoring, where any developer can improve any code without external approval. Additionally, in large systems, there are testing standards that require handing over the system build to an external testing team, which may conflict with the test-first approaches used in agile development methods.", "context": "3.4  \u25a0 Scaling agile methods  97\n \n3.4.4  Agile methods across organizations\nSmall software companies that develop software products have been among the \nmost enthusiastic adopters of agile methods. These companies are not constrained by \norganizational bureaucracies or process standards, and they can change quickly to \nadopt new ideas. Of course, larger companies have also experimented with agile \nmethods in specific projects, but it is much more difficult for them to \u201cscale out\u201d \nthese methods across the organization.\nIt can be difficult to introduce agile methods into large companies for a number of \nreasons:\n1. Project managers who do not have experience of agile methods may be reluctant \nto accept the risk of a new approach, as they do not know how this will affect \ntheir particular projects.\n2. Large organizations often have quality procedures and standards that all pro-\njects are expected to follow, and, because of their bureaucratic nature, these are \nlikely to be incompatible with agile methods. Sometimes, these are supported \nby software tools (e.g., requirements management tools), and the use of these \ntools is mandated for all projects.\n3. Agile methods seem to work best when team members have a relatively high \nskill level. However, within large organizations, there are likely to be a wide \nrange of skills and abilities, and people with lower skill levels may not be effec-\ntive team members in agile processes.\n4. \nThere may be cultural resistance to agile methods, especially in those organiza-\ntions that have a long history of using conventional systems engineering  processes.\nChange management and testing procedures are examples of company procedures \nthat may not be compatible with agile methods. Change management is the process of \ncontrolling changes to a system, so that the impact of changes is predictable and costs are \ncontrolled. All changes have to be approved in advance before they are made, and this \nconflicts with the notion of refactoring. When refactoring is part of an agile process, any \ndeveloper can improve any code without getting external approval. For large systems, \nthere are also testing standards where a system build is handed over to an external testing \nteam. This may conflict with test-first approaches used in agile development methods.\nIntroducing and sustaining the use of agile methods across a large organization is \na process of cultural change. Cultural change takes a long time to implement and \noften requires a change of management before it can be accomplished. Companies \nwishing to use agile methods need evangelists to promote change. Rather than try-\ning to force agile methods onto unwilling developers, companies have found that the \nbest way to introduce agile is bit by bit, starting with an enthusiastic group of devel-\nopers. A successful agile project can act as a starting point, with the project team \nspreading agile practice across the organization. Once the notion of agile is widely \nknown, explicit actions can then be taken to spread it across the organization."}
{"query": "How does the process of controlling changes to a system conflict with the notion of refactoring in agile processes?", "response": "The process of controlling changes to a system conflicts with the notion of refactoring in agile processes because in the process of controlling changes, all changes have to be approved in advance before they are made. This conflicts with the idea of refactoring, which allows any developer to improve any code without external approval. Refactoring is an essential part of agile development methods, where code is continuously improved and optimized. Therefore, the strict control and approval process for changes in traditional systems engineering processes hinder the flexibility and agility of refactoring in agile methods.", "context": "3.4  \u25a0 Scaling agile methods  97\n \n3.4.4  Agile methods across organizations\nSmall software companies that develop software products have been among the \nmost enthusiastic adopters of agile methods. These companies are not constrained by \norganizational bureaucracies or process standards, and they can change quickly to \nadopt new ideas. Of course, larger companies have also experimented with agile \nmethods in specific projects, but it is much more difficult for them to \u201cscale out\u201d \nthese methods across the organization.\nIt can be difficult to introduce agile methods into large companies for a number of \nreasons:\n1. Project managers who do not have experience of agile methods may be reluctant \nto accept the risk of a new approach, as they do not know how this will affect \ntheir particular projects.\n2. Large organizations often have quality procedures and standards that all pro-\njects are expected to follow, and, because of their bureaucratic nature, these are \nlikely to be incompatible with agile methods. Sometimes, these are supported \nby software tools (e.g., requirements management tools), and the use of these \ntools is mandated for all projects.\n3. Agile methods seem to work best when team members have a relatively high \nskill level. However, within large organizations, there are likely to be a wide \nrange of skills and abilities, and people with lower skill levels may not be effec-\ntive team members in agile processes.\n4. \nThere may be cultural resistance to agile methods, especially in those organiza-\ntions that have a long history of using conventional systems engineering  processes.\nChange management and testing procedures are examples of company procedures \nthat may not be compatible with agile methods. Change management is the process of \ncontrolling changes to a system, so that the impact of changes is predictable and costs are \ncontrolled. All changes have to be approved in advance before they are made, and this \nconflicts with the notion of refactoring. When refactoring is part of an agile process, any \ndeveloper can improve any code without getting external approval. For large systems, \nthere are also testing standards where a system build is handed over to an external testing \nteam. This may conflict with test-first approaches used in agile development methods.\nIntroducing and sustaining the use of agile methods across a large organization is \na process of cultural change. Cultural change takes a long time to implement and \noften requires a change of management before it can be accomplished. Companies \nwishing to use agile methods need evangelists to promote change. Rather than try-\ning to force agile methods onto unwilling developers, companies have found that the \nbest way to introduce agile is bit by bit, starting with an enthusiastic group of devel-\nopers. A successful agile project can act as a starting point, with the project team \nspreading agile practice across the organization. Once the notion of agile is widely \nknown, explicit actions can then be taken to spread it across the organization."}
{"query": "Why might external testing standards conflict with test-first approaches used in agile development methods?", "response": "External testing standards may conflict with test-first approaches used in agile development methods because test-first approaches prioritize writing tests before writing code. This means that developers are constantly running tests and making changes to the code based on the test results. However, external testing standards often involve handing over the system build to an external testing team, which may not align with the iterative and continuous testing approach of agile methods. In external testing, the testing team typically conducts testing after the development phase is complete, which can delay the feedback loop and hinder the ability to make quick changes based on test results.", "context": "3.4  \u25a0 Scaling agile methods  97\n \n3.4.4  Agile methods across organizations\nSmall software companies that develop software products have been among the \nmost enthusiastic adopters of agile methods. These companies are not constrained by \norganizational bureaucracies or process standards, and they can change quickly to \nadopt new ideas. Of course, larger companies have also experimented with agile \nmethods in specific projects, but it is much more difficult for them to \u201cscale out\u201d \nthese methods across the organization.\nIt can be difficult to introduce agile methods into large companies for a number of \nreasons:\n1. Project managers who do not have experience of agile methods may be reluctant \nto accept the risk of a new approach, as they do not know how this will affect \ntheir particular projects.\n2. Large organizations often have quality procedures and standards that all pro-\njects are expected to follow, and, because of their bureaucratic nature, these are \nlikely to be incompatible with agile methods. Sometimes, these are supported \nby software tools (e.g., requirements management tools), and the use of these \ntools is mandated for all projects.\n3. Agile methods seem to work best when team members have a relatively high \nskill level. However, within large organizations, there are likely to be a wide \nrange of skills and abilities, and people with lower skill levels may not be effec-\ntive team members in agile processes.\n4. \nThere may be cultural resistance to agile methods, especially in those organiza-\ntions that have a long history of using conventional systems engineering  processes.\nChange management and testing procedures are examples of company procedures \nthat may not be compatible with agile methods. Change management is the process of \ncontrolling changes to a system, so that the impact of changes is predictable and costs are \ncontrolled. All changes have to be approved in advance before they are made, and this \nconflicts with the notion of refactoring. When refactoring is part of an agile process, any \ndeveloper can improve any code without getting external approval. For large systems, \nthere are also testing standards where a system build is handed over to an external testing \nteam. This may conflict with test-first approaches used in agile development methods.\nIntroducing and sustaining the use of agile methods across a large organization is \na process of cultural change. Cultural change takes a long time to implement and \noften requires a change of management before it can be accomplished. Companies \nwishing to use agile methods need evangelists to promote change. Rather than try-\ning to force agile methods onto unwilling developers, companies have found that the \nbest way to introduce agile is bit by bit, starting with an enthusiastic group of devel-\nopers. A successful agile project can act as a starting point, with the project team \nspreading agile practice across the organization. Once the notion of agile is widely \nknown, explicit actions can then be taken to spread it across the organization."}
{"query": "What is the process of introducing and sustaining the use of agile methods across a large organization like?", "response": "The process of introducing and sustaining the use of agile methods across a large organization is a process of cultural change. It takes a long time to implement and often requires a change of management before it can be accomplished. Companies wishing to use agile methods need evangelists to promote change. Rather than trying to force agile methods onto unwilling developers, companies have found that the best way to introduce agile is bit by bit, starting with an enthusiastic group of developers. A successful agile project can act as a starting point, with the project team spreading agile practice across the organization. Once the notion of agile is widely known, explicit actions can then be taken to spread it across the organization.", "context": "3.4  \u25a0 Scaling agile methods  97\n \n3.4.4  Agile methods across organizations\nSmall software companies that develop software products have been among the \nmost enthusiastic adopters of agile methods. These companies are not constrained by \norganizational bureaucracies or process standards, and they can change quickly to \nadopt new ideas. Of course, larger companies have also experimented with agile \nmethods in specific projects, but it is much more difficult for them to \u201cscale out\u201d \nthese methods across the organization.\nIt can be difficult to introduce agile methods into large companies for a number of \nreasons:\n1. Project managers who do not have experience of agile methods may be reluctant \nto accept the risk of a new approach, as they do not know how this will affect \ntheir particular projects.\n2. Large organizations often have quality procedures and standards that all pro-\njects are expected to follow, and, because of their bureaucratic nature, these are \nlikely to be incompatible with agile methods. Sometimes, these are supported \nby software tools (e.g., requirements management tools), and the use of these \ntools is mandated for all projects.\n3. Agile methods seem to work best when team members have a relatively high \nskill level. However, within large organizations, there are likely to be a wide \nrange of skills and abilities, and people with lower skill levels may not be effec-\ntive team members in agile processes.\n4. \nThere may be cultural resistance to agile methods, especially in those organiza-\ntions that have a long history of using conventional systems engineering  processes.\nChange management and testing procedures are examples of company procedures \nthat may not be compatible with agile methods. Change management is the process of \ncontrolling changes to a system, so that the impact of changes is predictable and costs are \ncontrolled. All changes have to be approved in advance before they are made, and this \nconflicts with the notion of refactoring. When refactoring is part of an agile process, any \ndeveloper can improve any code without getting external approval. For large systems, \nthere are also testing standards where a system build is handed over to an external testing \nteam. This may conflict with test-first approaches used in agile development methods.\nIntroducing and sustaining the use of agile methods across a large organization is \na process of cultural change. Cultural change takes a long time to implement and \noften requires a change of management before it can be accomplished. Companies \nwishing to use agile methods need evangelists to promote change. Rather than try-\ning to force agile methods onto unwilling developers, companies have found that the \nbest way to introduce agile is bit by bit, starting with an enthusiastic group of devel-\nopers. A successful agile project can act as a starting point, with the project team \nspreading agile practice across the organization. Once the notion of agile is widely \nknown, explicit actions can then be taken to spread it across the organization."}
{"query": "Why does cultural change often require a change of management to be accomplished?", "response": "Cultural change often requires a change of management to be accomplished because management plays a crucial role in shaping and influencing the culture of an organization. They are responsible for setting the tone, values, and priorities within the company. If management is resistant to change or does not support the adoption of agile methods, it can create barriers and resistance within the organization. In order to successfully implement cultural change, it may be necessary to have new management that is supportive and willing to champion the adoption of agile methods.", "context": "3.4  \u25a0 Scaling agile methods  97\n \n3.4.4  Agile methods across organizations\nSmall software companies that develop software products have been among the \nmost enthusiastic adopters of agile methods. These companies are not constrained by \norganizational bureaucracies or process standards, and they can change quickly to \nadopt new ideas. Of course, larger companies have also experimented with agile \nmethods in specific projects, but it is much more difficult for them to \u201cscale out\u201d \nthese methods across the organization.\nIt can be difficult to introduce agile methods into large companies for a number of \nreasons:\n1. Project managers who do not have experience of agile methods may be reluctant \nto accept the risk of a new approach, as they do not know how this will affect \ntheir particular projects.\n2. Large organizations often have quality procedures and standards that all pro-\njects are expected to follow, and, because of their bureaucratic nature, these are \nlikely to be incompatible with agile methods. Sometimes, these are supported \nby software tools (e.g., requirements management tools), and the use of these \ntools is mandated for all projects.\n3. Agile methods seem to work best when team members have a relatively high \nskill level. However, within large organizations, there are likely to be a wide \nrange of skills and abilities, and people with lower skill levels may not be effec-\ntive team members in agile processes.\n4. \nThere may be cultural resistance to agile methods, especially in those organiza-\ntions that have a long history of using conventional systems engineering  processes.\nChange management and testing procedures are examples of company procedures \nthat may not be compatible with agile methods. Change management is the process of \ncontrolling changes to a system, so that the impact of changes is predictable and costs are \ncontrolled. All changes have to be approved in advance before they are made, and this \nconflicts with the notion of refactoring. When refactoring is part of an agile process, any \ndeveloper can improve any code without getting external approval. For large systems, \nthere are also testing standards where a system build is handed over to an external testing \nteam. This may conflict with test-first approaches used in agile development methods.\nIntroducing and sustaining the use of agile methods across a large organization is \na process of cultural change. Cultural change takes a long time to implement and \noften requires a change of management before it can be accomplished. Companies \nwishing to use agile methods need evangelists to promote change. Rather than try-\ning to force agile methods onto unwilling developers, companies have found that the \nbest way to introduce agile is bit by bit, starting with an enthusiastic group of devel-\nopers. A successful agile project can act as a starting point, with the project team \nspreading agile practice across the organization. Once the notion of agile is widely \nknown, explicit actions can then be taken to spread it across the organization."}
{"query": "What role do evangelists play in companies wishing to use agile methods?", "response": "Evangelists play a role in promoting and advocating for the use of agile methods in companies. They help to introduce and sustain the use of agile methods across the organization by spreading awareness and knowledge about agile practices. Rather than forcing agile methods onto unwilling developers, evangelists start with an enthusiastic group of developers and use successful agile projects as a starting point. They act as agents of change, promoting the benefits of agile methods and encouraging others to adopt them. By doing so, they help to create a cultural shift within the organization towards agile practices.", "context": "3.4  \u25a0 Scaling agile methods  97\n \n3.4.4  Agile methods across organizations\nSmall software companies that develop software products have been among the \nmost enthusiastic adopters of agile methods. These companies are not constrained by \norganizational bureaucracies or process standards, and they can change quickly to \nadopt new ideas. Of course, larger companies have also experimented with agile \nmethods in specific projects, but it is much more difficult for them to \u201cscale out\u201d \nthese methods across the organization.\nIt can be difficult to introduce agile methods into large companies for a number of \nreasons:\n1. Project managers who do not have experience of agile methods may be reluctant \nto accept the risk of a new approach, as they do not know how this will affect \ntheir particular projects.\n2. Large organizations often have quality procedures and standards that all pro-\njects are expected to follow, and, because of their bureaucratic nature, these are \nlikely to be incompatible with agile methods. Sometimes, these are supported \nby software tools (e.g., requirements management tools), and the use of these \ntools is mandated for all projects.\n3. Agile methods seem to work best when team members have a relatively high \nskill level. However, within large organizations, there are likely to be a wide \nrange of skills and abilities, and people with lower skill levels may not be effec-\ntive team members in agile processes.\n4. \nThere may be cultural resistance to agile methods, especially in those organiza-\ntions that have a long history of using conventional systems engineering  processes.\nChange management and testing procedures are examples of company procedures \nthat may not be compatible with agile methods. Change management is the process of \ncontrolling changes to a system, so that the impact of changes is predictable and costs are \ncontrolled. All changes have to be approved in advance before they are made, and this \nconflicts with the notion of refactoring. When refactoring is part of an agile process, any \ndeveloper can improve any code without getting external approval. For large systems, \nthere are also testing standards where a system build is handed over to an external testing \nteam. This may conflict with test-first approaches used in agile development methods.\nIntroducing and sustaining the use of agile methods across a large organization is \na process of cultural change. Cultural change takes a long time to implement and \noften requires a change of management before it can be accomplished. Companies \nwishing to use agile methods need evangelists to promote change. Rather than try-\ning to force agile methods onto unwilling developers, companies have found that the \nbest way to introduce agile is bit by bit, starting with an enthusiastic group of devel-\nopers. A successful agile project can act as a starting point, with the project team \nspreading agile practice across the organization. Once the notion of agile is widely \nknown, explicit actions can then be taken to spread it across the organization."}
{"query": "What is the best way for companies to introduce agile methods according to the text?", "response": "The best way for companies to introduce agile methods, according to the text, is to start with an enthusiastic group of developers and have a successful agile project. This project team can then spread agile practices across the organization. Once the concept of agile is widely known, explicit actions can be taken to further spread it across the organization.", "context": "3.4  \u25a0 Scaling agile methods  97\n \n3.4.4  Agile methods across organizations\nSmall software companies that develop software products have been among the \nmost enthusiastic adopters of agile methods. These companies are not constrained by \norganizational bureaucracies or process standards, and they can change quickly to \nadopt new ideas. Of course, larger companies have also experimented with agile \nmethods in specific projects, but it is much more difficult for them to \u201cscale out\u201d \nthese methods across the organization.\nIt can be difficult to introduce agile methods into large companies for a number of \nreasons:\n1. Project managers who do not have experience of agile methods may be reluctant \nto accept the risk of a new approach, as they do not know how this will affect \ntheir particular projects.\n2. Large organizations often have quality procedures and standards that all pro-\njects are expected to follow, and, because of their bureaucratic nature, these are \nlikely to be incompatible with agile methods. Sometimes, these are supported \nby software tools (e.g., requirements management tools), and the use of these \ntools is mandated for all projects.\n3. Agile methods seem to work best when team members have a relatively high \nskill level. However, within large organizations, there are likely to be a wide \nrange of skills and abilities, and people with lower skill levels may not be effec-\ntive team members in agile processes.\n4. \nThere may be cultural resistance to agile methods, especially in those organiza-\ntions that have a long history of using conventional systems engineering  processes.\nChange management and testing procedures are examples of company procedures \nthat may not be compatible with agile methods. Change management is the process of \ncontrolling changes to a system, so that the impact of changes is predictable and costs are \ncontrolled. All changes have to be approved in advance before they are made, and this \nconflicts with the notion of refactoring. When refactoring is part of an agile process, any \ndeveloper can improve any code without getting external approval. For large systems, \nthere are also testing standards where a system build is handed over to an external testing \nteam. This may conflict with test-first approaches used in agile development methods.\nIntroducing and sustaining the use of agile methods across a large organization is \na process of cultural change. Cultural change takes a long time to implement and \noften requires a change of management before it can be accomplished. Companies \nwishing to use agile methods need evangelists to promote change. Rather than try-\ning to force agile methods onto unwilling developers, companies have found that the \nbest way to introduce agile is bit by bit, starting with an enthusiastic group of devel-\nopers. A successful agile project can act as a starting point, with the project team \nspreading agile practice across the organization. Once the notion of agile is widely \nknown, explicit actions can then be taken to spread it across the organization."}
{"query": "How can a successful agile project act as a starting point for spreading agile practice across the organization?", "response": "A successful agile project can act as a starting point for spreading agile practice across the organization by serving as an example and inspiration for other teams. When a project team successfully implements agile methods and achieves positive results, it can generate interest and curiosity among other teams within the organization. This can lead to a desire to learn more about agile practices and potentially adopt them in their own projects. The success of the initial agile project can serve as proof that agile methods can be effective and beneficial, which can help overcome resistance and skepticism from other team members or project managers. As the knowledge and understanding of agile practices spread, explicit actions can be taken to introduce and implement agile methods across the organization.", "context": "3.4  \u25a0 Scaling agile methods  97\n \n3.4.4  Agile methods across organizations\nSmall software companies that develop software products have been among the \nmost enthusiastic adopters of agile methods. These companies are not constrained by \norganizational bureaucracies or process standards, and they can change quickly to \nadopt new ideas. Of course, larger companies have also experimented with agile \nmethods in specific projects, but it is much more difficult for them to \u201cscale out\u201d \nthese methods across the organization.\nIt can be difficult to introduce agile methods into large companies for a number of \nreasons:\n1. Project managers who do not have experience of agile methods may be reluctant \nto accept the risk of a new approach, as they do not know how this will affect \ntheir particular projects.\n2. Large organizations often have quality procedures and standards that all pro-\njects are expected to follow, and, because of their bureaucratic nature, these are \nlikely to be incompatible with agile methods. Sometimes, these are supported \nby software tools (e.g., requirements management tools), and the use of these \ntools is mandated for all projects.\n3. Agile methods seem to work best when team members have a relatively high \nskill level. However, within large organizations, there are likely to be a wide \nrange of skills and abilities, and people with lower skill levels may not be effec-\ntive team members in agile processes.\n4. \nThere may be cultural resistance to agile methods, especially in those organiza-\ntions that have a long history of using conventional systems engineering  processes.\nChange management and testing procedures are examples of company procedures \nthat may not be compatible with agile methods. Change management is the process of \ncontrolling changes to a system, so that the impact of changes is predictable and costs are \ncontrolled. All changes have to be approved in advance before they are made, and this \nconflicts with the notion of refactoring. When refactoring is part of an agile process, any \ndeveloper can improve any code without getting external approval. For large systems, \nthere are also testing standards where a system build is handed over to an external testing \nteam. This may conflict with test-first approaches used in agile development methods.\nIntroducing and sustaining the use of agile methods across a large organization is \na process of cultural change. Cultural change takes a long time to implement and \noften requires a change of management before it can be accomplished. Companies \nwishing to use agile methods need evangelists to promote change. Rather than try-\ning to force agile methods onto unwilling developers, companies have found that the \nbest way to introduce agile is bit by bit, starting with an enthusiastic group of devel-\nopers. A successful agile project can act as a starting point, with the project team \nspreading agile practice across the organization. Once the notion of agile is widely \nknown, explicit actions can then be taken to spread it across the organization."}
{"query": "Once the notion of agile is widely known, what explicit actions can be taken to spread it across the organization?", "response": "Explicit actions that can be taken to spread the notion of agile across the organization include promoting cultural change, having evangelists to promote change, starting with an enthusiastic group of developers, and using successful agile projects as a starting point to spread agile practices.", "context": "3.4  \u25a0 Scaling agile methods  97\n \n3.4.4  Agile methods across organizations\nSmall software companies that develop software products have been among the \nmost enthusiastic adopters of agile methods. These companies are not constrained by \norganizational bureaucracies or process standards, and they can change quickly to \nadopt new ideas. Of course, larger companies have also experimented with agile \nmethods in specific projects, but it is much more difficult for them to \u201cscale out\u201d \nthese methods across the organization.\nIt can be difficult to introduce agile methods into large companies for a number of \nreasons:\n1. Project managers who do not have experience of agile methods may be reluctant \nto accept the risk of a new approach, as they do not know how this will affect \ntheir particular projects.\n2. Large organizations often have quality procedures and standards that all pro-\njects are expected to follow, and, because of their bureaucratic nature, these are \nlikely to be incompatible with agile methods. Sometimes, these are supported \nby software tools (e.g., requirements management tools), and the use of these \ntools is mandated for all projects.\n3. Agile methods seem to work best when team members have a relatively high \nskill level. However, within large organizations, there are likely to be a wide \nrange of skills and abilities, and people with lower skill levels may not be effec-\ntive team members in agile processes.\n4. \nThere may be cultural resistance to agile methods, especially in those organiza-\ntions that have a long history of using conventional systems engineering  processes.\nChange management and testing procedures are examples of company procedures \nthat may not be compatible with agile methods. Change management is the process of \ncontrolling changes to a system, so that the impact of changes is predictable and costs are \ncontrolled. All changes have to be approved in advance before they are made, and this \nconflicts with the notion of refactoring. When refactoring is part of an agile process, any \ndeveloper can improve any code without getting external approval. For large systems, \nthere are also testing standards where a system build is handed over to an external testing \nteam. This may conflict with test-first approaches used in agile development methods.\nIntroducing and sustaining the use of agile methods across a large organization is \na process of cultural change. Cultural change takes a long time to implement and \noften requires a change of management before it can be accomplished. Companies \nwishing to use agile methods need evangelists to promote change. Rather than try-\ning to force agile methods onto unwilling developers, companies have found that the \nbest way to introduce agile is bit by bit, starting with an enthusiastic group of devel-\nopers. A successful agile project can act as a starting point, with the project team \nspreading agile practice across the organization. Once the notion of agile is widely \nknown, explicit actions can then be taken to spread it across the organization."}
{"query": "How does the skill level of team members affect the implementation of agile methods?", "response": "The skill level of team members can affect the implementation of agile methods. Agile methods tend to work best when team members have a relatively high skill level. However, within large organizations, there are likely to be a wide range of skills and abilities, and people with lower skill levels may not be effective team members in agile processes. This can make it more challenging to implement agile methods in large organizations where there is a diverse skill set among team members.", "context": "3.4  \u25a0 Scaling agile methods  97\n \n3.4.4  Agile methods across organizations\nSmall software companies that develop software products have been among the \nmost enthusiastic adopters of agile methods. These companies are not constrained by \norganizational bureaucracies or process standards, and they can change quickly to \nadopt new ideas. Of course, larger companies have also experimented with agile \nmethods in specific projects, but it is much more difficult for them to \u201cscale out\u201d \nthese methods across the organization.\nIt can be difficult to introduce agile methods into large companies for a number of \nreasons:\n1. Project managers who do not have experience of agile methods may be reluctant \nto accept the risk of a new approach, as they do not know how this will affect \ntheir particular projects.\n2. Large organizations often have quality procedures and standards that all pro-\njects are expected to follow, and, because of their bureaucratic nature, these are \nlikely to be incompatible with agile methods. Sometimes, these are supported \nby software tools (e.g., requirements management tools), and the use of these \ntools is mandated for all projects.\n3. Agile methods seem to work best when team members have a relatively high \nskill level. However, within large organizations, there are likely to be a wide \nrange of skills and abilities, and people with lower skill levels may not be effec-\ntive team members in agile processes.\n4. \nThere may be cultural resistance to agile methods, especially in those organiza-\ntions that have a long history of using conventional systems engineering  processes.\nChange management and testing procedures are examples of company procedures \nthat may not be compatible with agile methods. Change management is the process of \ncontrolling changes to a system, so that the impact of changes is predictable and costs are \ncontrolled. All changes have to be approved in advance before they are made, and this \nconflicts with the notion of refactoring. When refactoring is part of an agile process, any \ndeveloper can improve any code without getting external approval. For large systems, \nthere are also testing standards where a system build is handed over to an external testing \nteam. This may conflict with test-first approaches used in agile development methods.\nIntroducing and sustaining the use of agile methods across a large organization is \na process of cultural change. Cultural change takes a long time to implement and \noften requires a change of management before it can be accomplished. Companies \nwishing to use agile methods need evangelists to promote change. Rather than try-\ning to force agile methods onto unwilling developers, companies have found that the \nbest way to introduce agile is bit by bit, starting with an enthusiastic group of devel-\nopers. A successful agile project can act as a starting point, with the project team \nspreading agile practice across the organization. Once the notion of agile is widely \nknown, explicit actions can then be taken to spread it across the organization."}
{"query": "What are some examples of company procedures that may not be compatible with agile methods?", "response": "Change management and testing procedures are examples of company procedures that may not be compatible with agile methods. Change management is the process of controlling changes to a system, so that the impact of changes is predictable and costs are controlled. All changes have to be approved in advance before they are made, and this conflicts with the notion of refactoring. When refactoring is part of an agile process, any developer can improve any code without getting external approval. For large systems, there are also testing standards where a system build is handed over to an external testing team. This may conflict with test-first approaches used in agile development methods.", "context": "3.4  \u25a0 Scaling agile methods  97\n \n3.4.4  Agile methods across organizations\nSmall software companies that develop software products have been among the \nmost enthusiastic adopters of agile methods. These companies are not constrained by \norganizational bureaucracies or process standards, and they can change quickly to \nadopt new ideas. Of course, larger companies have also experimented with agile \nmethods in specific projects, but it is much more difficult for them to \u201cscale out\u201d \nthese methods across the organization.\nIt can be difficult to introduce agile methods into large companies for a number of \nreasons:\n1. Project managers who do not have experience of agile methods may be reluctant \nto accept the risk of a new approach, as they do not know how this will affect \ntheir particular projects.\n2. Large organizations often have quality procedures and standards that all pro-\njects are expected to follow, and, because of their bureaucratic nature, these are \nlikely to be incompatible with agile methods. Sometimes, these are supported \nby software tools (e.g., requirements management tools), and the use of these \ntools is mandated for all projects.\n3. Agile methods seem to work best when team members have a relatively high \nskill level. However, within large organizations, there are likely to be a wide \nrange of skills and abilities, and people with lower skill levels may not be effec-\ntive team members in agile processes.\n4. \nThere may be cultural resistance to agile methods, especially in those organiza-\ntions that have a long history of using conventional systems engineering  processes.\nChange management and testing procedures are examples of company procedures \nthat may not be compatible with agile methods. Change management is the process of \ncontrolling changes to a system, so that the impact of changes is predictable and costs are \ncontrolled. All changes have to be approved in advance before they are made, and this \nconflicts with the notion of refactoring. When refactoring is part of an agile process, any \ndeveloper can improve any code without getting external approval. For large systems, \nthere are also testing standards where a system build is handed over to an external testing \nteam. This may conflict with test-first approaches used in agile development methods.\nIntroducing and sustaining the use of agile methods across a large organization is \na process of cultural change. Cultural change takes a long time to implement and \noften requires a change of management before it can be accomplished. Companies \nwishing to use agile methods need evangelists to promote change. Rather than try-\ning to force agile methods onto unwilling developers, companies have found that the \nbest way to introduce agile is bit by bit, starting with an enthusiastic group of devel-\nopers. A successful agile project can act as a starting point, with the project team \nspreading agile practice across the organization. Once the notion of agile is widely \nknown, explicit actions can then be taken to spread it across the organization."}
{"query": "How does refactoring conflict with change management?", "response": "Refactoring conflicts with change management because change management is a process that requires all changes to a system to be approved in advance before they are made. On the other hand, refactoring is a practice in agile methods where any developer can improve any code without getting external approval. This difference in approach conflicts with the controlled and predictable nature of change management.", "context": "3.4  \u25a0 Scaling agile methods  97\n \n3.4.4  Agile methods across organizations\nSmall software companies that develop software products have been among the \nmost enthusiastic adopters of agile methods. These companies are not constrained by \norganizational bureaucracies or process standards, and they can change quickly to \nadopt new ideas. Of course, larger companies have also experimented with agile \nmethods in specific projects, but it is much more difficult for them to \u201cscale out\u201d \nthese methods across the organization.\nIt can be difficult to introduce agile methods into large companies for a number of \nreasons:\n1. Project managers who do not have experience of agile methods may be reluctant \nto accept the risk of a new approach, as they do not know how this will affect \ntheir particular projects.\n2. Large organizations often have quality procedures and standards that all pro-\njects are expected to follow, and, because of their bureaucratic nature, these are \nlikely to be incompatible with agile methods. Sometimes, these are supported \nby software tools (e.g., requirements management tools), and the use of these \ntools is mandated for all projects.\n3. Agile methods seem to work best when team members have a relatively high \nskill level. However, within large organizations, there are likely to be a wide \nrange of skills and abilities, and people with lower skill levels may not be effec-\ntive team members in agile processes.\n4. \nThere may be cultural resistance to agile methods, especially in those organiza-\ntions that have a long history of using conventional systems engineering  processes.\nChange management and testing procedures are examples of company procedures \nthat may not be compatible with agile methods. Change management is the process of \ncontrolling changes to a system, so that the impact of changes is predictable and costs are \ncontrolled. All changes have to be approved in advance before they are made, and this \nconflicts with the notion of refactoring. When refactoring is part of an agile process, any \ndeveloper can improve any code without getting external approval. For large systems, \nthere are also testing standards where a system build is handed over to an external testing \nteam. This may conflict with test-first approaches used in agile development methods.\nIntroducing and sustaining the use of agile methods across a large organization is \na process of cultural change. Cultural change takes a long time to implement and \noften requires a change of management before it can be accomplished. Companies \nwishing to use agile methods need evangelists to promote change. Rather than try-\ning to force agile methods onto unwilling developers, companies have found that the \nbest way to introduce agile is bit by bit, starting with an enthusiastic group of devel-\nopers. A successful agile project can act as a starting point, with the project team \nspreading agile practice across the organization. Once the notion of agile is widely \nknown, explicit actions can then be taken to spread it across the organization."}
{"query": "Why might there be a cultural resistance to agile methods in organizations with a long history of using conventional systems engineering processes?", "response": "Cultural resistance to agile methods in organizations with a long history of using conventional systems engineering processes may arise due to several reasons. One possible reason is that these organizations have established quality procedures and standards that all projects are expected to follow. These procedures and standards, which are often supported by software tools, may be incompatible with agile methods. Additionally, the bureaucratic nature of these organizations may make it challenging to implement the flexible and iterative nature of agile processes. Furthermore, there may be a wide range of skills and abilities within large organizations, and individuals with lower skill levels may not be effective team members in agile processes. Finally, cultural resistance may also stem from the fact that change management and testing procedures in these organizations may conflict with the principles of agile development, such as refactoring and test-first approaches.", "context": "3.4  \u25a0 Scaling agile methods  97\n \n3.4.4  Agile methods across organizations\nSmall software companies that develop software products have been among the \nmost enthusiastic adopters of agile methods. These companies are not constrained by \norganizational bureaucracies or process standards, and they can change quickly to \nadopt new ideas. Of course, larger companies have also experimented with agile \nmethods in specific projects, but it is much more difficult for them to \u201cscale out\u201d \nthese methods across the organization.\nIt can be difficult to introduce agile methods into large companies for a number of \nreasons:\n1. Project managers who do not have experience of agile methods may be reluctant \nto accept the risk of a new approach, as they do not know how this will affect \ntheir particular projects.\n2. Large organizations often have quality procedures and standards that all pro-\njects are expected to follow, and, because of their bureaucratic nature, these are \nlikely to be incompatible with agile methods. Sometimes, these are supported \nby software tools (e.g., requirements management tools), and the use of these \ntools is mandated for all projects.\n3. Agile methods seem to work best when team members have a relatively high \nskill level. However, within large organizations, there are likely to be a wide \nrange of skills and abilities, and people with lower skill levels may not be effec-\ntive team members in agile processes.\n4. \nThere may be cultural resistance to agile methods, especially in those organiza-\ntions that have a long history of using conventional systems engineering  processes.\nChange management and testing procedures are examples of company procedures \nthat may not be compatible with agile methods. Change management is the process of \ncontrolling changes to a system, so that the impact of changes is predictable and costs are \ncontrolled. All changes have to be approved in advance before they are made, and this \nconflicts with the notion of refactoring. When refactoring is part of an agile process, any \ndeveloper can improve any code without getting external approval. For large systems, \nthere are also testing standards where a system build is handed over to an external testing \nteam. This may conflict with test-first approaches used in agile development methods.\nIntroducing and sustaining the use of agile methods across a large organization is \na process of cultural change. Cultural change takes a long time to implement and \noften requires a change of management before it can be accomplished. Companies \nwishing to use agile methods need evangelists to promote change. Rather than try-\ning to force agile methods onto unwilling developers, companies have found that the \nbest way to introduce agile is bit by bit, starting with an enthusiastic group of devel-\nopers. A successful agile project can act as a starting point, with the project team \nspreading agile practice across the organization. Once the notion of agile is widely \nknown, explicit actions can then be taken to spread it across the organization."}
{"query": "What is the impact of large organizations' quality procedures and standards on the implementation of agile methods?", "response": "Large organizations' quality procedures and standards can have a negative impact on the implementation of agile methods. These procedures and standards are often bureaucratic in nature and may be incompatible with agile methods. Additionally, these organizations may have mandated the use of software tools that do not align with agile practices. The cultural resistance to change within these organizations, especially those with a long history of using conventional systems engineering processes, can further hinder the implementation of agile methods. Overall, the presence of these quality procedures and standards can create barriers and make it more difficult to introduce and sustain the use of agile methods across a large organization.", "context": "3.4  \u25a0 Scaling agile methods  97\n \n3.4.4  Agile methods across organizations\nSmall software companies that develop software products have been among the \nmost enthusiastic adopters of agile methods. These companies are not constrained by \norganizational bureaucracies or process standards, and they can change quickly to \nadopt new ideas. Of course, larger companies have also experimented with agile \nmethods in specific projects, but it is much more difficult for them to \u201cscale out\u201d \nthese methods across the organization.\nIt can be difficult to introduce agile methods into large companies for a number of \nreasons:\n1. Project managers who do not have experience of agile methods may be reluctant \nto accept the risk of a new approach, as they do not know how this will affect \ntheir particular projects.\n2. Large organizations often have quality procedures and standards that all pro-\njects are expected to follow, and, because of their bureaucratic nature, these are \nlikely to be incompatible with agile methods. Sometimes, these are supported \nby software tools (e.g., requirements management tools), and the use of these \ntools is mandated for all projects.\n3. Agile methods seem to work best when team members have a relatively high \nskill level. However, within large organizations, there are likely to be a wide \nrange of skills and abilities, and people with lower skill levels may not be effec-\ntive team members in agile processes.\n4. \nThere may be cultural resistance to agile methods, especially in those organiza-\ntions that have a long history of using conventional systems engineering  processes.\nChange management and testing procedures are examples of company procedures \nthat may not be compatible with agile methods. Change management is the process of \ncontrolling changes to a system, so that the impact of changes is predictable and costs are \ncontrolled. All changes have to be approved in advance before they are made, and this \nconflicts with the notion of refactoring. When refactoring is part of an agile process, any \ndeveloper can improve any code without getting external approval. For large systems, \nthere are also testing standards where a system build is handed over to an external testing \nteam. This may conflict with test-first approaches used in agile development methods.\nIntroducing and sustaining the use of agile methods across a large organization is \na process of cultural change. Cultural change takes a long time to implement and \noften requires a change of management before it can be accomplished. Companies \nwishing to use agile methods need evangelists to promote change. Rather than try-\ning to force agile methods onto unwilling developers, companies have found that the \nbest way to introduce agile is bit by bit, starting with an enthusiastic group of devel-\nopers. A successful agile project can act as a starting point, with the project team \nspreading agile practice across the organization. Once the notion of agile is widely \nknown, explicit actions can then be taken to spread it across the organization."}
{"query": "What is the role of a project team in spreading agile practice across the organization?", "response": "A successful agile project team can act as a starting point for spreading agile practice across the organization. Once the notion of agile is widely known within the organization, explicit actions can then be taken to spread it further.", "context": "3.4  \u25a0 Scaling agile methods  97\n \n3.4.4  Agile methods across organizations\nSmall software companies that develop software products have been among the \nmost enthusiastic adopters of agile methods. These companies are not constrained by \norganizational bureaucracies or process standards, and they can change quickly to \nadopt new ideas. Of course, larger companies have also experimented with agile \nmethods in specific projects, but it is much more difficult for them to \u201cscale out\u201d \nthese methods across the organization.\nIt can be difficult to introduce agile methods into large companies for a number of \nreasons:\n1. Project managers who do not have experience of agile methods may be reluctant \nto accept the risk of a new approach, as they do not know how this will affect \ntheir particular projects.\n2. Large organizations often have quality procedures and standards that all pro-\njects are expected to follow, and, because of their bureaucratic nature, these are \nlikely to be incompatible with agile methods. Sometimes, these are supported \nby software tools (e.g., requirements management tools), and the use of these \ntools is mandated for all projects.\n3. Agile methods seem to work best when team members have a relatively high \nskill level. However, within large organizations, there are likely to be a wide \nrange of skills and abilities, and people with lower skill levels may not be effec-\ntive team members in agile processes.\n4. \nThere may be cultural resistance to agile methods, especially in those organiza-\ntions that have a long history of using conventional systems engineering  processes.\nChange management and testing procedures are examples of company procedures \nthat may not be compatible with agile methods. Change management is the process of \ncontrolling changes to a system, so that the impact of changes is predictable and costs are \ncontrolled. All changes have to be approved in advance before they are made, and this \nconflicts with the notion of refactoring. When refactoring is part of an agile process, any \ndeveloper can improve any code without getting external approval. For large systems, \nthere are also testing standards where a system build is handed over to an external testing \nteam. This may conflict with test-first approaches used in agile development methods.\nIntroducing and sustaining the use of agile methods across a large organization is \na process of cultural change. Cultural change takes a long time to implement and \noften requires a change of management before it can be accomplished. Companies \nwishing to use agile methods need evangelists to promote change. Rather than try-\ning to force agile methods onto unwilling developers, companies have found that the \nbest way to introduce agile is bit by bit, starting with an enthusiastic group of devel-\nopers. A successful agile project can act as a starting point, with the project team \nspreading agile practice across the organization. Once the notion of agile is widely \nknown, explicit actions can then be taken to spread it across the organization."}
{"query": "How does the use of software tools mandated for all projects affect the implementation of agile methods?", "response": "The use of software tools mandated for all projects can affect the implementation of agile methods in large organizations. This is because these tools may not be compatible with agile methods. Agile methods rely on flexibility and adaptability, allowing team members to make changes and improvements to the code without external approval. However, the use of mandated software tools may restrict this flexibility and hinder the agile development process. Additionally, these tools may not support the specific requirements of agile methods, such as requirements management tools that are designed for more traditional development approaches. Therefore, the use of mandated software tools can create challenges and conflicts when trying to implement agile methods in large organizations.", "context": "3.4  \u25a0 Scaling agile methods  97\n \n3.4.4  Agile methods across organizations\nSmall software companies that develop software products have been among the \nmost enthusiastic adopters of agile methods. These companies are not constrained by \norganizational bureaucracies or process standards, and they can change quickly to \nadopt new ideas. Of course, larger companies have also experimented with agile \nmethods in specific projects, but it is much more difficult for them to \u201cscale out\u201d \nthese methods across the organization.\nIt can be difficult to introduce agile methods into large companies for a number of \nreasons:\n1. Project managers who do not have experience of agile methods may be reluctant \nto accept the risk of a new approach, as they do not know how this will affect \ntheir particular projects.\n2. Large organizations often have quality procedures and standards that all pro-\njects are expected to follow, and, because of their bureaucratic nature, these are \nlikely to be incompatible with agile methods. Sometimes, these are supported \nby software tools (e.g., requirements management tools), and the use of these \ntools is mandated for all projects.\n3. Agile methods seem to work best when team members have a relatively high \nskill level. However, within large organizations, there are likely to be a wide \nrange of skills and abilities, and people with lower skill levels may not be effec-\ntive team members in agile processes.\n4. \nThere may be cultural resistance to agile methods, especially in those organiza-\ntions that have a long history of using conventional systems engineering  processes.\nChange management and testing procedures are examples of company procedures \nthat may not be compatible with agile methods. Change management is the process of \ncontrolling changes to a system, so that the impact of changes is predictable and costs are \ncontrolled. All changes have to be approved in advance before they are made, and this \nconflicts with the notion of refactoring. When refactoring is part of an agile process, any \ndeveloper can improve any code without getting external approval. For large systems, \nthere are also testing standards where a system build is handed over to an external testing \nteam. This may conflict with test-first approaches used in agile development methods.\nIntroducing and sustaining the use of agile methods across a large organization is \na process of cultural change. Cultural change takes a long time to implement and \noften requires a change of management before it can be accomplished. Companies \nwishing to use agile methods need evangelists to promote change. Rather than try-\ning to force agile methods onto unwilling developers, companies have found that the \nbest way to introduce agile is bit by bit, starting with an enthusiastic group of devel-\nopers. A successful agile project can act as a starting point, with the project team \nspreading agile practice across the organization. Once the notion of agile is widely \nknown, explicit actions can then be taken to spread it across the organization."}
{"query": "How does the skill level of team members in large organizations affect the effectiveness of agile processes?", "response": "The skill level of team members in large organizations can affect the effectiveness of agile processes. Agile methods tend to work best when team members have a relatively high skill level. However, within large organizations, there are likely to be a wide range of skills and abilities. This means that people with lower skill levels may not be effective team members in agile processes. Therefore, the effectiveness of agile processes in large organizations can be impacted by the skill level of team members.", "context": "3.4  \u25a0 Scaling agile methods  97\n \n3.4.4  Agile methods across organizations\nSmall software companies that develop software products have been among the \nmost enthusiastic adopters of agile methods. These companies are not constrained by \norganizational bureaucracies or process standards, and they can change quickly to \nadopt new ideas. Of course, larger companies have also experimented with agile \nmethods in specific projects, but it is much more difficult for them to \u201cscale out\u201d \nthese methods across the organization.\nIt can be difficult to introduce agile methods into large companies for a number of \nreasons:\n1. Project managers who do not have experience of agile methods may be reluctant \nto accept the risk of a new approach, as they do not know how this will affect \ntheir particular projects.\n2. Large organizations often have quality procedures and standards that all pro-\njects are expected to follow, and, because of their bureaucratic nature, these are \nlikely to be incompatible with agile methods. Sometimes, these are supported \nby software tools (e.g., requirements management tools), and the use of these \ntools is mandated for all projects.\n3. Agile methods seem to work best when team members have a relatively high \nskill level. However, within large organizations, there are likely to be a wide \nrange of skills and abilities, and people with lower skill levels may not be effec-\ntive team members in agile processes.\n4. \nThere may be cultural resistance to agile methods, especially in those organiza-\ntions that have a long history of using conventional systems engineering  processes.\nChange management and testing procedures are examples of company procedures \nthat may not be compatible with agile methods. Change management is the process of \ncontrolling changes to a system, so that the impact of changes is predictable and costs are \ncontrolled. All changes have to be approved in advance before they are made, and this \nconflicts with the notion of refactoring. When refactoring is part of an agile process, any \ndeveloper can improve any code without getting external approval. For large systems, \nthere are also testing standards where a system build is handed over to an external testing \nteam. This may conflict with test-first approaches used in agile development methods.\nIntroducing and sustaining the use of agile methods across a large organization is \na process of cultural change. Cultural change takes a long time to implement and \noften requires a change of management before it can be accomplished. Companies \nwishing to use agile methods need evangelists to promote change. Rather than try-\ning to force agile methods onto unwilling developers, companies have found that the \nbest way to introduce agile is bit by bit, starting with an enthusiastic group of devel-\nopers. A successful agile project can act as a starting point, with the project team \nspreading agile practice across the organization. Once the notion of agile is widely \nknown, explicit actions can then be taken to spread it across the organization."}
{"query": "What is the impact of testing standards on the test-first approaches used in agile development methods?", "response": "The testing standards used in large organizations may conflict with the test-first approaches used in agile development methods. In agile development, the test-first approach involves writing tests before writing the actual code. However, in large organizations, there are testing standards where a system build is handed over to an external testing team. This handover process may not align with the test-first approach, as the tests are typically written by the developers themselves in agile methods. Therefore, the testing standards can have an impact on the test-first approaches used in agile development methods.", "context": "3.4  \u25a0 Scaling agile methods  97\n \n3.4.4  Agile methods across organizations\nSmall software companies that develop software products have been among the \nmost enthusiastic adopters of agile methods. These companies are not constrained by \norganizational bureaucracies or process standards, and they can change quickly to \nadopt new ideas. Of course, larger companies have also experimented with agile \nmethods in specific projects, but it is much more difficult for them to \u201cscale out\u201d \nthese methods across the organization.\nIt can be difficult to introduce agile methods into large companies for a number of \nreasons:\n1. Project managers who do not have experience of agile methods may be reluctant \nto accept the risk of a new approach, as they do not know how this will affect \ntheir particular projects.\n2. Large organizations often have quality procedures and standards that all pro-\njects are expected to follow, and, because of their bureaucratic nature, these are \nlikely to be incompatible with agile methods. Sometimes, these are supported \nby software tools (e.g., requirements management tools), and the use of these \ntools is mandated for all projects.\n3. Agile methods seem to work best when team members have a relatively high \nskill level. However, within large organizations, there are likely to be a wide \nrange of skills and abilities, and people with lower skill levels may not be effec-\ntive team members in agile processes.\n4. \nThere may be cultural resistance to agile methods, especially in those organiza-\ntions that have a long history of using conventional systems engineering  processes.\nChange management and testing procedures are examples of company procedures \nthat may not be compatible with agile methods. Change management is the process of \ncontrolling changes to a system, so that the impact of changes is predictable and costs are \ncontrolled. All changes have to be approved in advance before they are made, and this \nconflicts with the notion of refactoring. When refactoring is part of an agile process, any \ndeveloper can improve any code without getting external approval. For large systems, \nthere are also testing standards where a system build is handed over to an external testing \nteam. This may conflict with test-first approaches used in agile development methods.\nIntroducing and sustaining the use of agile methods across a large organization is \na process of cultural change. Cultural change takes a long time to implement and \noften requires a change of management before it can be accomplished. Companies \nwishing to use agile methods need evangelists to promote change. Rather than try-\ning to force agile methods onto unwilling developers, companies have found that the \nbest way to introduce agile is bit by bit, starting with an enthusiastic group of devel-\nopers. A successful agile project can act as a starting point, with the project team \nspreading agile practice across the organization. Once the notion of agile is widely \nknown, explicit actions can then be taken to spread it across the organization."}
{"query": "How does the process of cultural change affect the implementation of agile methods across a large organization?", "response": "The process of cultural change can have a significant impact on the implementation of agile methods across a large organization. Cultural change takes time to implement and often requires a change in management before it can be accomplished. Companies that wish to use agile methods need individuals who can act as evangelists to promote change. Instead of trying to force agile methods onto unwilling developers, companies have found that it is more effective to introduce agile practices gradually, starting with a small group of enthusiastic developers. If a project using agile methods is successful, it can serve as a starting point for spreading agile practices across the organization. Once the concept of agile is widely understood, explicit actions can be taken to further promote its adoption throughout the organization.", "context": "3.4  \u25a0 Scaling agile methods  97\n \n3.4.4  Agile methods across organizations\nSmall software companies that develop software products have been among the \nmost enthusiastic adopters of agile methods. These companies are not constrained by \norganizational bureaucracies or process standards, and they can change quickly to \nadopt new ideas. Of course, larger companies have also experimented with agile \nmethods in specific projects, but it is much more difficult for them to \u201cscale out\u201d \nthese methods across the organization.\nIt can be difficult to introduce agile methods into large companies for a number of \nreasons:\n1. Project managers who do not have experience of agile methods may be reluctant \nto accept the risk of a new approach, as they do not know how this will affect \ntheir particular projects.\n2. Large organizations often have quality procedures and standards that all pro-\njects are expected to follow, and, because of their bureaucratic nature, these are \nlikely to be incompatible with agile methods. Sometimes, these are supported \nby software tools (e.g., requirements management tools), and the use of these \ntools is mandated for all projects.\n3. Agile methods seem to work best when team members have a relatively high \nskill level. However, within large organizations, there are likely to be a wide \nrange of skills and abilities, and people with lower skill levels may not be effec-\ntive team members in agile processes.\n4. \nThere may be cultural resistance to agile methods, especially in those organiza-\ntions that have a long history of using conventional systems engineering  processes.\nChange management and testing procedures are examples of company procedures \nthat may not be compatible with agile methods. Change management is the process of \ncontrolling changes to a system, so that the impact of changes is predictable and costs are \ncontrolled. All changes have to be approved in advance before they are made, and this \nconflicts with the notion of refactoring. When refactoring is part of an agile process, any \ndeveloper can improve any code without getting external approval. For large systems, \nthere are also testing standards where a system build is handed over to an external testing \nteam. This may conflict with test-first approaches used in agile development methods.\nIntroducing and sustaining the use of agile methods across a large organization is \na process of cultural change. Cultural change takes a long time to implement and \noften requires a change of management before it can be accomplished. Companies \nwishing to use agile methods need evangelists to promote change. Rather than try-\ning to force agile methods onto unwilling developers, companies have found that the \nbest way to introduce agile is bit by bit, starting with an enthusiastic group of devel-\nopers. A successful agile project can act as a starting point, with the project team \nspreading agile practice across the organization. Once the notion of agile is widely \nknown, explicit actions can then be taken to spread it across the organization."}
{"query": "What is the role of evangelists in promoting change in companies wishing to use agile methods?", "response": "Evangelists play a crucial role in promoting change in companies wishing to use agile methods. They act as advocates for agile practices and help spread awareness and understanding of agile principles and benefits within the organization. By sharing their knowledge and experiences, evangelists can inspire and motivate others to embrace agile methods. They can also provide guidance and support to teams as they transition to agile practices, helping them overcome any resistance or challenges they may face. Ultimately, evangelists help drive cultural change and facilitate the adoption and sustainability of agile methods across the entire organization.", "context": "3.4  \u25a0 Scaling agile methods  97\n \n3.4.4  Agile methods across organizations\nSmall software companies that develop software products have been among the \nmost enthusiastic adopters of agile methods. These companies are not constrained by \norganizational bureaucracies or process standards, and they can change quickly to \nadopt new ideas. Of course, larger companies have also experimented with agile \nmethods in specific projects, but it is much more difficult for them to \u201cscale out\u201d \nthese methods across the organization.\nIt can be difficult to introduce agile methods into large companies for a number of \nreasons:\n1. Project managers who do not have experience of agile methods may be reluctant \nto accept the risk of a new approach, as they do not know how this will affect \ntheir particular projects.\n2. Large organizations often have quality procedures and standards that all pro-\njects are expected to follow, and, because of their bureaucratic nature, these are \nlikely to be incompatible with agile methods. Sometimes, these are supported \nby software tools (e.g., requirements management tools), and the use of these \ntools is mandated for all projects.\n3. Agile methods seem to work best when team members have a relatively high \nskill level. However, within large organizations, there are likely to be a wide \nrange of skills and abilities, and people with lower skill levels may not be effec-\ntive team members in agile processes.\n4. \nThere may be cultural resistance to agile methods, especially in those organiza-\ntions that have a long history of using conventional systems engineering  processes.\nChange management and testing procedures are examples of company procedures \nthat may not be compatible with agile methods. Change management is the process of \ncontrolling changes to a system, so that the impact of changes is predictable and costs are \ncontrolled. All changes have to be approved in advance before they are made, and this \nconflicts with the notion of refactoring. When refactoring is part of an agile process, any \ndeveloper can improve any code without getting external approval. For large systems, \nthere are also testing standards where a system build is handed over to an external testing \nteam. This may conflict with test-first approaches used in agile development methods.\nIntroducing and sustaining the use of agile methods across a large organization is \na process of cultural change. Cultural change takes a long time to implement and \noften requires a change of management before it can be accomplished. Companies \nwishing to use agile methods need evangelists to promote change. Rather than try-\ning to force agile methods onto unwilling developers, companies have found that the \nbest way to introduce agile is bit by bit, starting with an enthusiastic group of devel-\nopers. A successful agile project can act as a starting point, with the project team \nspreading agile practice across the organization. Once the notion of agile is widely \nknown, explicit actions can then be taken to spread it across the organization."}
{"query": "How does starting with an enthusiastic group of developers help in the introduction of agile methods?", "response": "Starting with an enthusiastic group of developers helps in the introduction of agile methods because they can act as evangelists and promote change within the organization. Their enthusiasm and positive experience with agile methods can inspire and influence other team members to adopt and embrace agile practices. This gradual and organic spread of agile practices, starting from a successful agile project, can help create awareness and familiarity with agile methods, making it easier to introduce and sustain their use across the organization.", "context": "3.4  \u25a0 Scaling agile methods  97\n \n3.4.4  Agile methods across organizations\nSmall software companies that develop software products have been among the \nmost enthusiastic adopters of agile methods. These companies are not constrained by \norganizational bureaucracies or process standards, and they can change quickly to \nadopt new ideas. Of course, larger companies have also experimented with agile \nmethods in specific projects, but it is much more difficult for them to \u201cscale out\u201d \nthese methods across the organization.\nIt can be difficult to introduce agile methods into large companies for a number of \nreasons:\n1. Project managers who do not have experience of agile methods may be reluctant \nto accept the risk of a new approach, as they do not know how this will affect \ntheir particular projects.\n2. Large organizations often have quality procedures and standards that all pro-\njects are expected to follow, and, because of their bureaucratic nature, these are \nlikely to be incompatible with agile methods. Sometimes, these are supported \nby software tools (e.g., requirements management tools), and the use of these \ntools is mandated for all projects.\n3. Agile methods seem to work best when team members have a relatively high \nskill level. However, within large organizations, there are likely to be a wide \nrange of skills and abilities, and people with lower skill levels may not be effec-\ntive team members in agile processes.\n4. \nThere may be cultural resistance to agile methods, especially in those organiza-\ntions that have a long history of using conventional systems engineering  processes.\nChange management and testing procedures are examples of company procedures \nthat may not be compatible with agile methods. Change management is the process of \ncontrolling changes to a system, so that the impact of changes is predictable and costs are \ncontrolled. All changes have to be approved in advance before they are made, and this \nconflicts with the notion of refactoring. When refactoring is part of an agile process, any \ndeveloper can improve any code without getting external approval. For large systems, \nthere are also testing standards where a system build is handed over to an external testing \nteam. This may conflict with test-first approaches used in agile development methods.\nIntroducing and sustaining the use of agile methods across a large organization is \na process of cultural change. Cultural change takes a long time to implement and \noften requires a change of management before it can be accomplished. Companies \nwishing to use agile methods need evangelists to promote change. Rather than try-\ning to force agile methods onto unwilling developers, companies have found that the \nbest way to introduce agile is bit by bit, starting with an enthusiastic group of devel-\nopers. A successful agile project can act as a starting point, with the project team \nspreading agile practice across the organization. Once the notion of agile is widely \nknown, explicit actions can then be taken to spread it across the organization."}
